(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["draw2d"] = factory();
	else
		root["draw2d"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/canvg-browser/index.js":
/*!*********************************************!*\
  !*** ./node_modules/canvg-browser/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


 var RGBColor = __webpack_require__(/*! rgbcolor */ "./node_modules/rgbcolor/index.js");
 var stackblur = __webpack_require__(/*! stackblur */ "./node_modules/stackblur/index.js");
 var xmldom = __webpack_require__(/*! xmldom */ "./node_modules/xmldom/dom-parser.js");

/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */

/*
canvg(target, s)
  empty parameters: replace all 'svg' elements on page with 'canvas' elements
  target: canvas element or the id of a canvas element
  s: svg string, url to svg file, or xml document
  opts: optional hash of options
    ignoreMouse: true => ignore mouse events
    ignoreAnimation: true => ignore animations
    ignoreDimensions: true => does not try to resize canvas
    ignoreClear: true => does not clear canvas
    offsetX: int => draws at a x offset
    offsetY: int => draws at a y offset
    scaleWidth: int => scales horizontally to width
    scaleHeight: int => scales vertically to height
    renderCallback: function => will call the function after the first render is completed
    forceRedraw: function => will call the function on every frame, if it returns true, will redraw
*/
function canvg(target, s, opts) {

	// no parameters
	if (target == null && s == null && opts == null) {
		var svgTags = document.querySelectorAll('svg');
		for (var i=0; i<svgTags.length; i++) {
			var svgTag = svgTags[i];
			var c = document.createElement('canvas');
			c.width = svgTag.clientWidth;
			c.height = svgTag.clientHeight;
			svgTag.parentNode.insertBefore(c, svgTag);
			svgTag.parentNode.removeChild(svgTag);
			var div = document.createElement('div');
			div.appendChild(svgTag);
			canvg(c, div.innerHTML);
		}
		return;
	}

	if (typeof target == 'string') {
		target = document.getElementById(target);
	}

	// store class on canvas
	if (target.svg != null) target.svg.stop();
	var svg = build(opts || {});
	// on i.e. 8 for flash canvas, we can't assign the property so check for it
	if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;

	var ctx = target.getContext('2d');
	if (typeof s.documentElement != 'undefined') {
		// load from xml doc
		svg.loadXmlDoc(ctx, s);
	}
	else if (s.substr(0,1) == '<') {
		// load from xml string
		svg.loadXml(ctx, s);
	}
	else {
		// load from url
		svg.load(ctx, s);
	}
}

function getMatchesSelector() {
  // see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
  var matchesSelector;
  if (typeof Element.prototype.matches != 'undefined') {
  	matchesSelector = function(node, selector) {
  		return node.matches(selector);
  	};
  } else if (typeof Element.prototype.webkitMatchesSelector != 'undefined') {
  	matchesSelector = function(node, selector) {
  		return node.webkitMatchesSelector(selector);
  	};
  } else if (typeof Element.prototype.mozMatchesSelector != 'undefined') {
  	matchesSelector = function(node, selector) {
  		return node.mozMatchesSelector(selector);
  	};
  } else if (typeof Element.prototype.msMatchesSelector != 'undefined') {
  	matchesSelector = function(node, selector) {
  		return node.msMatchesSelector(selector);
  	};
  } else if (typeof Element.prototype.oMatchesSelector != 'undefined') {
  	matchesSelector = function(node, selector) {
  		return node.oMatchesSelector(selector);
  	};
  } else {
  	// requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation
  	// or jQuery: http://jquery.com/download/
  	// or Zepto: http://zeptojs.com/#
  	// without it, this is a ReferenceError

  	if (typeof jQuery == 'function' || typeof Zepto == 'function') {
  		matchesSelector = function (node, selector) {
  			return $(node).is(selector);
  		};
  	}

  	if (typeof matchesSelector == 'undefined') {
  		matchesSelector = Sizzle.matchesSelector;
  	}
  }

  return matchesSelector;
}

function getSelectorSpecificity(selector) {
	var typeCount = [0, 0, 0];

  // slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
  var attributeRegex = /(\[[^\]]+\])/g;
  var idRegex = /(#[^\s\+>~\.\[:]+)/g;
  var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
  var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi;
  var pseudoClassWithBracketsRegex = /(:[\w-]+\([^\)]*\))/gi;
  var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
  var elementRegex = /([^\s\+>~\.\[:]+)/g;

	var findMatch = function(regex, type) {
		var matches = selector.match(regex);
		if (matches == null) {
			return;
		}
		typeCount[type] += matches.length;
		selector = selector.replace(regex, ' ');
	};

	selector = selector.replace(/:not\(([^\)]*)\)/g, '     $1 ');
	selector = selector.replace(/{[^]*/gm, ' ');
	findMatch(attributeRegex, 1);
	findMatch(idRegex, 0);
	findMatch(classRegex, 1);
	findMatch(pseudoElementRegex, 2);
	findMatch(pseudoClassWithBracketsRegex, 1);
	findMatch(pseudoClassRegex, 1);
	selector = selector.replace(/[\*\s\+>~]/g, ' ');
	selector = selector.replace(/[#\.]/g, ' ');
	findMatch(elementRegex, 2);
	return typeCount.join('');
}

function build(opts) {
	var svg = { opts: opts };

  var matchesSelector = getMatchesSelector();

  if (typeof CanvasRenderingContext2D  != 'undefined') {
    CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh, opts) {
      var cOpts = {
        ignoreMouse: true,
        ignoreAnimation: true,
        ignoreDimensions: true,
        ignoreClear: true,
        offsetX: dx,
        offsetY: dy,
        scaleWidth: dw,
        scaleHeight: dh
      };

      for(var prop in opts) {
        if(opts.hasOwnProperty(prop)){
          cOpts[prop] = opts[prop];
        }
      }
      canvg(this.canvas, s, cOpts);
    };
  }

	svg.FRAMERATE = 30;
	svg.MAX_VIRTUAL_PIXELS = 30000;

	svg.log = function(msg) {};
	if (svg.opts.log == true && typeof console != 'undefined') {
		svg.log = function(msg) { console.log(msg); };
	}

	// globals
	svg.init = function(ctx) {
		var uniqueId = 0;
		svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
		svg.Definitions = {};
		svg.Styles = {};
		svg.StylesSpecificity = {};
		svg.Animations = [];
		svg.Images = [];
		svg.ctx = ctx;
		svg.ViewPort = new (function () {
			this.viewPorts = [];
			this.Clear = function() { this.viewPorts = []; };
			this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); };
			this.RemoveCurrent = function() { this.viewPorts.pop(); };
			this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; };
			this.width = function() { return this.Current().width; };
			this.height = function() { return this.Current().height; };
			this.ComputeSize = function(d) {
				if (d != null && typeof d == 'number') return d;
				if (d == 'x') return this.width();
				if (d == 'y') return this.height();
				return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
			};
		});
	}
	svg.init();

	// images loaded
	svg.ImagesLoaded = function() {
		for (var i=0; i<svg.Images.length; i++) {
			if (!svg.Images[i].loaded) return false;
		}
		return true;
	}

	// trim
	svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }

	// compress spaces
	svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }

	// ajax
	svg.ajax = function(url) {
		var AJAX;
		if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
		else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
		if(AJAX){
		   AJAX.open('GET',url,false);
		   AJAX.send(null);
		   return AJAX.responseText;
		}
		return null;
	}

	// parse xml
	svg.parseXml = function(xml) {
		if (typeof Windows != 'undefined' && typeof Windows.Data != 'undefined' && typeof Windows.Data.Xml != 'undefined') {
			var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
			var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
			settings.prohibitDtd = false;
			xmlDoc.loadXml(xml, settings);
			return xmlDoc;
		}
		else if (window.DOMParser)
		{
			var parser = new DOMParser();
			return parser.parseFromString(xml, 'text/xml');
		}
		else
		{
			xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
			var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
			xmlDoc.async = 'false';
			xmlDoc.loadXML(xml);
			return xmlDoc;
		}
	}

	svg.Property = function(name, value) {
		this.name = name;
		this.value = value;
	}
		svg.Property.prototype.getValue = function() {
			return this.value;
		}

		svg.Property.prototype.hasValue = function() {
			return (this.value != null && this.value != '');
		}

		// return the numerical value of the property
		svg.Property.prototype.numValue = function() {
			if (!this.hasValue()) return 0;

			var n = parseFloat(this.value);
			if ((this.value + '').match(/%$/)) {
				n = n / 100.0;
			}
			return n;
		}

		svg.Property.prototype.valueOrDefault = function(def) {
			if (this.hasValue()) return this.value;
			return def;
		}

		svg.Property.prototype.numValueOrDefault = function(def) {
			if (this.hasValue()) return this.numValue();
			return def;
		}

		// color extensions
			// augment the current color value with the opacity
			svg.Property.prototype.addOpacity = function(opacityProp) {
				var newValue = this.value;
				if (opacityProp.value != null && opacityProp.value != '' && typeof this.value == 'string') { // can only add opacity to colors, not patterns
					var color = new RGBColor(this.value);
					if (color.ok) {
						newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
					}
				}
				return new svg.Property(this.name, newValue);
			}

		// definition extensions
			// get the definition from the definitions table
			svg.Property.prototype.getDefinition = function() {
				var name = this.value.match(/#([^\)'"]+)/);
				if (name) { name = name[1]; }
				if (!name) { name = this.value; }
				return svg.Definitions[name];
			}

			svg.Property.prototype.isUrlDefinition = function() {
				return this.value.indexOf('url(') == 0
			}

			svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
				var def = this.getDefinition();

				// gradient
				if (def != null && def.createGradient) {
					return def.createGradient(svg.ctx, e, opacityProp);
				}

				// pattern
				if (def != null && def.createPattern) {
					if (def.getHrefAttribute().hasValue()) {
						var pt = def.attribute('patternTransform');
						def = def.getHrefAttribute().getDefinition();
						if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
					}
					return def.createPattern(svg.ctx, e);
				}

				return null;
			}

		// length extensions
			svg.Property.prototype.getDPI = function(viewPort) {
				return 96.0; // TODO: compute?
			}

			svg.Property.prototype.getEM = function(viewPort) {
				var em = 12;

				var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
				if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);

				return em;
			}

			svg.Property.prototype.getUnits = function() {
				var s = this.value+'';
				return s.replace(/[0-9\.\-]/g,'');
			}

			// get the length as pixels
			svg.Property.prototype.toPixels = function(viewPort, processPercent) {
				if (!this.hasValue()) return 0;
				var s = this.value+'';
				if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
				if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
				if (s.match(/px$/)) return this.numValue();
				if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
				if (s.match(/pc$/)) return this.numValue() * 15;
				if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
				if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
				if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
				if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
				var n = this.numValue();
				if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
				return n;
			}

		// time extensions
			// get the time as milliseconds
			svg.Property.prototype.toMilliseconds = function() {
				if (!this.hasValue()) return 0;
				var s = this.value+'';
				if (s.match(/s$/)) return this.numValue() * 1000;
				if (s.match(/ms$/)) return this.numValue();
				return this.numValue();
			}

		// angle extensions
			// get the angle as radians
			svg.Property.prototype.toRadians = function() {
				if (!this.hasValue()) return 0;
				var s = this.value+'';
				if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
				if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
				if (s.match(/rad$/)) return this.numValue();
				return this.numValue() * (Math.PI / 180.0);
			}

		// text extensions
			// get the text baseline
			var textBaselineMapping = {
				'baseline': 'alphabetic',
				'before-edge': 'top',
				'text-before-edge': 'top',
				'middle': 'middle',
				'central': 'middle',
				'after-edge': 'bottom',
				'text-after-edge': 'bottom',
				'ideographic': 'ideographic',
				'alphabetic': 'alphabetic',
				'hanging': 'hanging',
				'mathematical': 'alphabetic'
			};
			svg.Property.prototype.toTextBaseline = function () {
				if (!this.hasValue()) return null;
				return textBaselineMapping[this.value];
			}

	// fonts
	svg.Font = new (function() {
		this.Styles = 'normal|italic|oblique|inherit';
		this.Variants = 'normal|small-caps|inherit';
		this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

		this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
			var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
			return {
				fontFamily: fontFamily || f.fontFamily,
				fontSize: fontSize || f.fontSize,
				fontStyle: fontStyle || f.fontStyle,
				fontWeight: fontWeight || f.fontWeight,
				fontVariant: fontVariant || f.fontVariant,
				toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }
			}
		}

		var that = this;
		this.Parse = function(s) {
			var f = {};
			var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
			var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
			var ff = '';
			for (var i=0; i<d.length; i++) {
				if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
				else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
				else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
				else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
				else { if (d[i] != 'inherit') ff += d[i]; }
			} if (ff != '') f.fontFamily = ff;
			return f;
		}
	});

	// points and paths
	svg.ToNumberArray = function(s) {
		var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
		for (var i=0; i<a.length; i++) {
			a[i] = parseFloat(a[i]);
		}
		return a;
	}
	svg.Point = function(x, y) {
		this.x = x;
		this.y = y;
	}
		svg.Point.prototype.angleTo = function(p) {
			return Math.atan2(p.y - this.y, p.x - this.x);
		}

		svg.Point.prototype.applyTransform = function(v) {
			var xp = this.x * v[0] + this.y * v[2] + v[4];
			var yp = this.x * v[1] + this.y * v[3] + v[5];
			this.x = xp;
			this.y = yp;
		}

	svg.CreatePoint = function(s) {
		var a = svg.ToNumberArray(s);
		return new svg.Point(a[0], a[1]);
	}
	svg.CreatePath = function(s) {
		var a = svg.ToNumberArray(s);
		var path = [];
		for (var i=0; i<a.length; i+=2) {
			path.push(new svg.Point(a[i], a[i+1]));
		}
		return path;
	}

	// bounding box
	svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
		this.x1 = Number.NaN;
		this.y1 = Number.NaN;
		this.x2 = Number.NaN;
		this.y2 = Number.NaN;

		this.x = function() { return this.x1; }
		this.y = function() { return this.y1; }
		this.width = function() { return this.x2 - this.x1; }
		this.height = function() { return this.y2 - this.y1; }

		this.addPoint = function(x, y) {
			if (x != null) {
				if (isNaN(this.x1) || isNaN(this.x2)) {
					this.x1 = x;
					this.x2 = x;
				}
				if (x < this.x1) this.x1 = x;
				if (x > this.x2) this.x2 = x;
			}

			if (y != null) {
				if (isNaN(this.y1) || isNaN(this.y2)) {
					this.y1 = y;
					this.y2 = y;
				}
				if (y < this.y1) this.y1 = y;
				if (y > this.y2) this.y2 = y;
			}
		}
		this.addX = function(x) { this.addPoint(x, null); }
		this.addY = function(y) { this.addPoint(null, y); }

		this.addBoundingBox = function(bb) {
			this.addPoint(bb.x1, bb.y1);
			this.addPoint(bb.x2, bb.y2);
		}

		this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
			var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
			var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
			var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
			var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
			this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
		}

		this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
			// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
			var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
			this.addPoint(p0[0], p0[1]);
			this.addPoint(p3[0], p3[1]);

			for (var i=0; i<=1; i++) {
				var f = function(t) {
					return Math.pow(1-t, 3) * p0[i]
					+ 3 * Math.pow(1-t, 2) * t * p1[i]
					+ 3 * (1-t) * Math.pow(t, 2) * p2[i]
					+ Math.pow(t, 3) * p3[i];
				}

				var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
				var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
				var c = 3 * p1[i] - 3 * p0[i];

				if (a == 0) {
					if (b == 0) continue;
					var t = -c / b;
					if (0 < t && t < 1) {
						if (i == 0) this.addX(f(t));
						if (i == 1) this.addY(f(t));
					}
					continue;
				}

				var b2ac = Math.pow(b, 2) - 4 * c * a;
				if (b2ac < 0) continue;
				var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
				if (0 < t1 && t1 < 1) {
					if (i == 0) this.addX(f(t1));
					if (i == 1) this.addY(f(t1));
				}
				var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
				if (0 < t2 && t2 < 1) {
					if (i == 0) this.addX(f(t2));
					if (i == 1) this.addY(f(t2));
				}
			}
		}

		this.isPointInBox = function(x, y) {
			return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
		}

		this.addPoint(x1, y1);
		this.addPoint(x2, y2);
	}

	// transforms
	svg.Transform = function(v) {
		var that = this;
		this.Type = {}

		// translate
		this.Type.translate = function(s) {
			this.p = svg.CreatePoint(s);
			this.apply = function(ctx) {
				ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
			}
			this.unapply = function(ctx) {
				ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
			}
			this.applyToPoint = function(p) {
				p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
			}
		}

		// rotate
		this.Type.rotate = function(s) {
			var a = svg.ToNumberArray(s);
			this.angle = new svg.Property('angle', a[0]);
			this.cx = a[1] || 0;
			this.cy = a[2] || 0;
			this.apply = function(ctx) {
				ctx.translate(this.cx, this.cy);
				ctx.rotate(this.angle.toRadians());
				ctx.translate(-this.cx, -this.cy);
			}
			this.unapply = function(ctx) {
				ctx.translate(this.cx, this.cy);
				ctx.rotate(-1.0 * this.angle.toRadians());
				ctx.translate(-this.cx, -this.cy);
			}
			this.applyToPoint = function(p) {
				var a = this.angle.toRadians();
				p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
				p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
				p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
			}
		}

		this.Type.scale = function(s) {
			this.p = svg.CreatePoint(s);
			this.apply = function(ctx) {
				ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
			}
			this.unapply = function(ctx) {
				ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
			}
			this.applyToPoint = function(p) {
				p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
			}
		}

		this.Type.matrix = function(s) {
			this.m = svg.ToNumberArray(s);
			this.apply = function(ctx) {
				ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
			}
			this.unapply = function(ctx) {
				var a = this.m[0];
				var b = this.m[2];
				var c = this.m[4];
				var d = this.m[1];
				var e = this.m[3];
				var f = this.m[5];
				var g = 0.0;
				var h = 0.0;
				var i = 1.0;
				var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
				ctx.transform(
					det*(e*i-f*h),
					det*(f*g-d*i),
					det*(c*h-b*i),
					det*(a*i-c*g),
					det*(b*f-c*e),
					det*(c*d-a*f)
				);
			}
			this.applyToPoint = function(p) {
				p.applyTransform(this.m);
			}
		}

		this.Type.SkewBase = function(s) {
			this.base = that.Type.matrix;
			this.base(s);
			this.angle = new svg.Property('angle', s);
		}
		this.Type.SkewBase.prototype = new this.Type.matrix;

		this.Type.skewX = function(s) {
			this.base = that.Type.SkewBase;
			this.base(s);
			this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
		}
		this.Type.skewX.prototype = new this.Type.SkewBase;

		this.Type.skewY = function(s) {
			this.base = that.Type.SkewBase;
			this.base(s);
			this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
		}
		this.Type.skewY.prototype = new this.Type.SkewBase;

		this.transforms = [];

		this.apply = function(ctx) {
			for (var i=0; i<this.transforms.length; i++) {
				this.transforms[i].apply(ctx);
			}
		}

		this.unapply = function(ctx) {
			for (var i=this.transforms.length-1; i>=0; i--) {
				this.transforms[i].unapply(ctx);
			}
		}

		this.applyToPoint = function(p) {
			for (var i=0; i<this.transforms.length; i++) {
				this.transforms[i].applyToPoint(p);
			}
		}

		var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
		for (var i=0; i<data.length; i++) {
			var type = svg.trim(data[i].split('(')[0]);
			var s = data[i].split('(')[1].replace(')','');
			var transformType = this.Type[type];
			if (typeof transformType != 'undefined') {
				var transform = new transformType(s);
				transform.type = type;
				this.transforms.push(transform);
			}
		}
	}

	// aspect ratio
	svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
		// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
		aspectRatio = svg.compressSpaces(aspectRatio);
		aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
		var align = aspectRatio.split(' ')[0] || 'xMidYMid';
		var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';

		// calculate scale
		var scaleX = width / desiredWidth;
		var scaleY = height / desiredHeight;
		var scaleMin = Math.min(scaleX, scaleY);
		var scaleMax = Math.max(scaleX, scaleY);
		if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
		if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }

		refX = new svg.Property('refX', refX);
		refY = new svg.Property('refY', refY);
		if (refX.hasValue() && refY.hasValue()) {
			ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
		}
		else {
			// align
			if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
			if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
			if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);
			if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);
		}

		// scale
		if (align == 'none') ctx.scale(scaleX, scaleY);
		else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);
		else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);

		// translate
		ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
	}

	// elements
	svg.Element = {}

	svg.EmptyProperty = new svg.Property('EMPTY', '');

	svg.Element.ElementBase = function(node) {
		this.attributes = {};
		this.styles = {};
		this.stylesSpecificity = {};
		this.children = [];

		// get or create attribute
		this.attribute = function(name, createIfNotExists) {
			var a = this.attributes[name];
			if (a != null) return a;

			if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
			return a || svg.EmptyProperty;
		}

		this.getHrefAttribute = function() {
			for (var a in this.attributes) {
				if (a == 'href' || a.match(/:href$/)) {
					return this.attributes[a];
				}
			}
			return svg.EmptyProperty;
		}

		// get or create style, crawls up node tree
		this.style = function(name, createIfNotExists, skipAncestors) {
			var s = this.styles[name];
			if (s != null) return s;

			var a = this.attribute(name);
			if (a != null && a.hasValue()) {
				this.styles[name] = a; // move up to me to cache
				return a;
			}

			if (skipAncestors != true) {
				var p = this.parent;
				if (p != null) {
					var ps = p.style(name);
					if (ps != null && ps.hasValue()) {
						return ps;
					}
				}
			}

			if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
			return s || svg.EmptyProperty;
		}

		// base render
		this.render = function(ctx) {
			// don't render display=none
			if (this.style('display').value == 'none') return;

			// don't render visibility=hidden
			if (this.style('visibility').value == 'hidden') return;

			ctx.save();
			if (this.style('mask').hasValue()) { // mask
				var mask = this.style('mask').getDefinition();
				if (mask != null) mask.apply(ctx, this);
			}
			else if (this.style('filter').hasValue()) { // filter
				var filter = this.style('filter').getDefinition();
				if (filter != null) filter.apply(ctx, this);
			}
			else {
				this.setContext(ctx);
				this.renderChildren(ctx);
				this.clearContext(ctx);
			}
			ctx.restore();
		}

		// base set context
		this.setContext = function(ctx) {
			// OVERRIDE ME!
		}

		// base clear context
		this.clearContext = function(ctx) {
			// OVERRIDE ME!
		}

		// base render children
		this.renderChildren = function(ctx) {
			for (var i=0; i<this.children.length; i++) {
				this.children[i].render(ctx);
			}
		}

		this.addChild = function(childNode, create) {
			var child = childNode;
			if (create) child = svg.CreateElement(childNode);
			child.parent = this;
			if (child.type != 'title') { this.children.push(child);	}
		}

		this.addStylesFromStyleDefinition = function () {
			// add styles
			for (var selector in svg.Styles) {
				if (selector[0] != '@' && matchesSelector(node, selector)) {
					var styles = svg.Styles[selector];
					var specificity = svg.StylesSpecificity[selector];
					if (styles != null) {
						for (var name in styles) {
							var existingSpecificity = this.stylesSpecificity[name];
							if (typeof existingSpecificity == 'undefined') {
								existingSpecificity = '000';
							}
							if (specificity > existingSpecificity) {
								this.styles[name] = styles[name];
								this.stylesSpecificity[name] = specificity;
							}
						}
					}
				}
			}
		};

		if (node != null && node.nodeType == 1) { //ELEMENT_NODE
			// add attributes
			for (var i=0; i<node.attributes.length; i++) {
				var attribute = node.attributes[i];
				this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.value);
			}

			this.addStylesFromStyleDefinition();

			// add inline styles
			if (this.attribute('style').hasValue()) {
				var styles = this.attribute('style').value.split(';');
				for (var i=0; i<styles.length; i++) {
					if (svg.trim(styles[i]) != '') {
						var style = styles[i].split(':');
						var name = svg.trim(style[0]);
						var value = svg.trim(style[1]);
						this.styles[name] = new svg.Property(name, value);
					}
				}
			}

			// add id
			if (this.attribute('id').hasValue()) {
				if (svg.Definitions[this.attribute('id').value] == null) {
					svg.Definitions[this.attribute('id').value] = this;
				}
			}

			// add children
			for (var i=0; i<node.childNodes.length; i++) {
				var childNode = node.childNodes[i];
				if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
				if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
					var text = childNode.value || childNode.text || childNode.textContent || '';
					if (svg.compressSpaces(text) != '') {
						this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
					}
				}
			}
		}
	}

	svg.Element.RenderedElementBase = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.setContext = function(ctx) {
			// fill
			if (this.style('fill').isUrlDefinition()) {
				var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
				if (fs != null) ctx.fillStyle = fs;
			}
			else if (this.style('fill').hasValue()) {
				var fillStyle = this.style('fill');
				if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
				if (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
			}
			if (this.style('fill-opacity').hasValue()) {
				var fillStyle = new svg.Property('fill', ctx.fillStyle);
				fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
				ctx.fillStyle = fillStyle.value;
			}

			// stroke
			if (this.style('stroke').isUrlDefinition()) {
				var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
				if (fs != null) ctx.strokeStyle = fs;
			}
			else if (this.style('stroke').hasValue()) {
				var strokeStyle = this.style('stroke');
				if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
				if (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
			}
			if (this.style('stroke-opacity').hasValue()) {
				var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
				strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
				ctx.strokeStyle = strokeStyle.value;
			}
			if (this.style('stroke-width').hasValue()) {
				var newLineWidth = this.style('stroke-width').toPixels();
				ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
		    }
			if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
			if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
			if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
			if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
				var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
				if (typeof ctx.setLineDash != 'undefined') { ctx.setLineDash(gaps); }
				else if (typeof ctx.webkitLineDash != 'undefined') { ctx.webkitLineDash = gaps; }
				else if (typeof ctx.mozDash != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }

				var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
				if (typeof ctx.lineDashOffset != 'undefined') { ctx.lineDashOffset = offset; }
				else if (typeof ctx.webkitLineDashOffset != 'undefined') { ctx.webkitLineDashOffset = offset; }
				else if (typeof ctx.mozDashOffset != 'undefined') { ctx.mozDashOffset = offset; }
			}

			// font
			if (typeof ctx.font != 'undefined') {
				ctx.font = svg.Font.CreateFont(
					this.style('font-style').value,
					this.style('font-variant').value,
					this.style('font-weight').value,
					this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',
					this.style('font-family').value).toString();
			}

			// transform
			if (this.style('transform', false, true).hasValue()) {
				var transform = new svg.Transform(this.style('transform', false, true).value);
				transform.apply(ctx);
			}

			// clip
			if (this.style('clip-path', false, true).hasValue()) {
				var clip = this.style('clip-path', false, true).getDefinition();
				if (clip != null) clip.apply(ctx);
			}

			// opacity
			if (this.style('opacity').hasValue()) {
				ctx.globalAlpha = this.style('opacity').numValue();
			}
		}
	}
	svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;

	svg.Element.PathElementBase = function(node) {
		this.base = svg.Element.RenderedElementBase;
		this.base(node);

		this.path = function(ctx) {
			if (ctx != null) ctx.beginPath();
			return new svg.BoundingBox();
		}

		this.renderChildren = function(ctx) {
			this.path(ctx);
			svg.Mouse.checkPath(this, ctx);
			if (ctx.fillStyle != '') {
				if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
				else { ctx.fill(); }
			}
			if (ctx.strokeStyle != '') ctx.stroke();

			var markers = this.getMarkers();
			if (markers != null) {
				if (this.style('marker-start').isUrlDefinition()) {
					var marker = this.style('marker-start').getDefinition();
					marker.render(ctx, markers[0][0], markers[0][1]);
				}
				if (this.style('marker-mid').isUrlDefinition()) {
					var marker = this.style('marker-mid').getDefinition();
					for (var i=1;i<markers.length-1;i++) {
						marker.render(ctx, markers[i][0], markers[i][1]);
					}
				}
				if (this.style('marker-end').isUrlDefinition()) {
					var marker = this.style('marker-end').getDefinition();
					marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
				}
			}
		}

		this.getBoundingBox = function() {
			return this.path();
		}

		this.getMarkers = function() {
			return null;
		}
	}
	svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;

	// svg element
	svg.Element.svg = function(node) {
		this.base = svg.Element.RenderedElementBase;
		this.base(node);

		this.baseClearContext = this.clearContext;
		this.clearContext = function(ctx) {
			this.baseClearContext(ctx);
			svg.ViewPort.RemoveCurrent();
		}

		this.baseSetContext = this.setContext;
		this.setContext = function(ctx) {
			// initial values and defaults
			ctx.strokeStyle = 'rgba(0,0,0,0)';
			ctx.lineCap = 'butt';
			ctx.lineJoin = 'miter';
			ctx.miterLimit = 4;
			if (typeof ctx.font != 'undefined' && typeof window.getComputedStyle != 'undefined') {
				ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
			}

			this.baseSetContext(ctx);

			// create new view port
			if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
			if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
			ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));

			var width = svg.ViewPort.width();
			var height = svg.ViewPort.height();

			if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
			if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
			if (typeof this.root == 'undefined') {
				width = this.attribute('width').toPixels('x');
				height = this.attribute('height').toPixels('y');

				var x = 0;
				var y = 0;
				if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
					x = -this.attribute('refX').toPixels('x');
					y = -this.attribute('refY').toPixels('y');
				}

				if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
					ctx.beginPath();
					ctx.moveTo(x, y);
					ctx.lineTo(width, y);
					ctx.lineTo(width, height);
					ctx.lineTo(x, height);
					ctx.closePath();
					ctx.clip();
				}
			}
			svg.ViewPort.SetCurrent(width, height);

			// viewbox
			if (this.attribute('viewBox').hasValue()) {
				var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
				var minX = viewBox[0];
				var minY = viewBox[1];
				width = viewBox[2];
				height = viewBox[3];

				svg.AspectRatio(ctx,
								this.attribute('preserveAspectRatio').value,
								svg.ViewPort.width(),
								width,
								svg.ViewPort.height(),
								height,
								minX,
								minY,
								this.attribute('refX').value,
								this.attribute('refY').value);

				svg.ViewPort.RemoveCurrent();
				svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
			}
		}
	}
	svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

	// rect element
	svg.Element.rect = function(node) {
		this.base = svg.Element.PathElementBase;
		this.base(node);

		this.path = function(ctx) {
			var x = this.attribute('x').toPixels('x');
			var y = this.attribute('y').toPixels('y');
			var width = this.attribute('width').toPixels('x');
			var height = this.attribute('height').toPixels('y');
			var rx = this.attribute('rx').toPixels('x');
			var ry = this.attribute('ry').toPixels('y');
			if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
			if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
			rx = Math.min(rx, width / 2.0);
			ry = Math.min(ry, height / 2.0);
			if (ctx != null) {
				ctx.beginPath();
				ctx.moveTo(x + rx, y);
				ctx.lineTo(x + width - rx, y);
				ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
				ctx.lineTo(x + width, y + height - ry);
				ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
				ctx.lineTo(x + rx, y + height);
				ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
				ctx.lineTo(x, y + ry);
				ctx.quadraticCurveTo(x, y, x + rx, y)
				ctx.closePath();
			}

			return new svg.BoundingBox(x, y, x + width, y + height);
		}
	}
	svg.Element.rect.prototype = new svg.Element.PathElementBase;

	// circle element
	svg.Element.circle = function(node) {
		this.base = svg.Element.PathElementBase;
		this.base(node);

		this.path = function(ctx) {
			var cx = this.attribute('cx').toPixels('x');
			var cy = this.attribute('cy').toPixels('y');
			var r = this.attribute('r').toPixels();

			if (ctx != null) {
				ctx.beginPath();
				ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
				ctx.closePath();
			}

			return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
		}
	}
	svg.Element.circle.prototype = new svg.Element.PathElementBase;

	// ellipse element
	svg.Element.ellipse = function(node) {
		this.base = svg.Element.PathElementBase;
		this.base(node);

		this.path = function(ctx) {
			var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
			var rx = this.attribute('rx').toPixels('x');
			var ry = this.attribute('ry').toPixels('y');
			var cx = this.attribute('cx').toPixels('x');
			var cy = this.attribute('cy').toPixels('y');

			if (ctx != null) {
				ctx.beginPath();
				ctx.moveTo(cx, cy - ry);
				ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
				ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
				ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
				ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
				ctx.closePath();
			}

			return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
		}
	}
	svg.Element.ellipse.prototype = new svg.Element.PathElementBase;

	// line element
	svg.Element.line = function(node) {
		this.base = svg.Element.PathElementBase;
		this.base(node);

		this.getPoints = function() {
			return [
				new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
				new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
		}

		this.path = function(ctx) {
			var points = this.getPoints();

			if (ctx != null) {
				ctx.beginPath();
				ctx.moveTo(points[0].x, points[0].y);
				ctx.lineTo(points[1].x, points[1].y);
			}

			return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
		}

		this.getMarkers = function() {
			var points = this.getPoints();
			var a = points[0].angleTo(points[1]);
			return [[points[0], a], [points[1], a]];
		}
	}
	svg.Element.line.prototype = new svg.Element.PathElementBase;

	// polyline element
	svg.Element.polyline = function(node) {
		this.base = svg.Element.PathElementBase;
		this.base(node);

		this.points = svg.CreatePath(this.attribute('points').value);
		this.path = function(ctx) {
			var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
			if (ctx != null) {
				ctx.beginPath();
				ctx.moveTo(this.points[0].x, this.points[0].y);
			}
			for (var i=1; i<this.points.length; i++) {
				bb.addPoint(this.points[i].x, this.points[i].y);
				if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
			}
			return bb;
		}

		this.getMarkers = function() {
			var markers = [];
			for (var i=0; i<this.points.length - 1; i++) {
				markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
			}
			if (markers.length > 0) {
				markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
			}
			return markers;
		}
	}
	svg.Element.polyline.prototype = new svg.Element.PathElementBase;

	// polygon element
	svg.Element.polygon = function(node) {
		this.base = svg.Element.polyline;
		this.base(node);

		this.basePath = this.path;
		this.path = function(ctx) {
			var bb = this.basePath(ctx);
			if (ctx != null) {
				ctx.lineTo(this.points[0].x, this.points[0].y);
				ctx.closePath();
			}
			return bb;
		}
	}
	svg.Element.polygon.prototype = new svg.Element.polyline;

	// path element
	svg.Element.path = function(node) {
		this.base = svg.Element.PathElementBase;
		this.base(node);

		var d = this.attribute('d').value;
		// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
		d = d.replace(/,/gm,' '); // get rid of all commas
		// As the end of a match can also be the start of the next match, we need to run this replace twice.
		for(var i=0; i<2; i++)
			d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // suffix commands with spaces
		d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // prefix commands with spaces
		d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits on +- signs
		// Again, we need to run this twice to find all occurances
		for(var i=0; i<2; i++)
			d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when they start with a comma
		d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
		d = svg.compressSpaces(d); // compress multiple spaces
		d = svg.trim(d);
		this.PathParser = new (function(d) {
			this.tokens = d.split(' ');

			this.reset = function() {
				this.i = -1;
				this.command = '';
				this.previousCommand = '';
				this.start = new svg.Point(0, 0);
				this.control = new svg.Point(0, 0);
				this.current = new svg.Point(0, 0);
				this.points = [];
				this.angles = [];
			}

			this.isEnd = function() {
				return this.i >= this.tokens.length - 1;
			}

			this.isCommandOrEnd = function() {
				if (this.isEnd()) return true;
				return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
			}

			this.isRelativeCommand = function() {
				switch(this.command)
				{
					case 'm':
					case 'l':
					case 'h':
					case 'v':
					case 'c':
					case 's':
					case 'q':
					case 't':
					case 'a':
					case 'z':
						return true;
						break;
				}
				return false;
			}

			this.getToken = function() {
				this.i++;
				return this.tokens[this.i];
			}

			this.getScalar = function() {
				return parseFloat(this.getToken());
			}

			this.nextCommand = function() {
				this.previousCommand = this.command;
				this.command = this.getToken();
			}

			this.getPoint = function() {
				var p = new svg.Point(this.getScalar(), this.getScalar());
				return this.makeAbsolute(p);
			}

			this.getAsControlPoint = function() {
				var p = this.getPoint();
				this.control = p;
				return p;
			}

			this.getAsCurrentPoint = function() {
				var p = this.getPoint();
				this.current = p;
				return p;
			}

			this.getReflectedControlPoint = function() {
				if (this.previousCommand.toLowerCase() != 'c' &&
				    this.previousCommand.toLowerCase() != 's' &&
					this.previousCommand.toLowerCase() != 'q' &&
					this.previousCommand.toLowerCase() != 't' ){
					return this.current;
				}

				// reflect point
				var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
				return p;
			}

			this.makeAbsolute = function(p) {
				if (this.isRelativeCommand()) {
					p.x += this.current.x;
					p.y += this.current.y;
				}
				return p;
			}

			this.addMarker = function(p, from, priorTo) {
				// if the last angle isn't filled in because we didn't have this point yet ...
				if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
					this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
				}
				this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
			}

			this.addMarkerAngle = function(p, a) {
				this.points.push(p);
				this.angles.push(a);
			}

			this.getMarkerPoints = function() { return this.points; }
			this.getMarkerAngles = function() {
				for (var i=0; i<this.angles.length; i++) {
					if (this.angles[i] == null) {
						for (var j=i+1; j<this.angles.length; j++) {
							if (this.angles[j] != null) {
								this.angles[i] = this.angles[j];
								break;
							}
						}
					}
				}
				return this.angles;
			}
		})(d);

		this.path = function(ctx) {
			var pp = this.PathParser;
			pp.reset();

			var bb = new svg.BoundingBox();
			if (ctx != null) ctx.beginPath();
			while (!pp.isEnd()) {
				pp.nextCommand();
				switch (pp.command) {
				case 'M':
				case 'm':
					var p = pp.getAsCurrentPoint();
					pp.addMarker(p);
					bb.addPoint(p.x, p.y);
					if (ctx != null) ctx.moveTo(p.x, p.y);
					pp.start = pp.current;
					while (!pp.isCommandOrEnd()) {
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p, pp.start);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.lineTo(p.x, p.y);
					}
					break;
				case 'L':
				case 'l':
					while (!pp.isCommandOrEnd()) {
						var c = pp.current;
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p, c);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.lineTo(p.x, p.y);
					}
					break;
				case 'H':
				case 'h':
					while (!pp.isCommandOrEnd()) {
						var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
						pp.addMarker(newP, pp.current);
						pp.current = newP;
						bb.addPoint(pp.current.x, pp.current.y);
						if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
					}
					break;
				case 'V':
				case 'v':
					while (!pp.isCommandOrEnd()) {
						var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
						pp.addMarker(newP, pp.current);
						pp.current = newP;
						bb.addPoint(pp.current.x, pp.current.y);
						if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
					}
					break;
				case 'C':
				case 'c':
					while (!pp.isCommandOrEnd()) {
						var curr = pp.current;
						var p1 = pp.getPoint();
						var cntrl = pp.getAsControlPoint();
						var cp = pp.getAsCurrentPoint();
						pp.addMarker(cp, cntrl, p1);
						bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
					}
					break;
				case 'S':
				case 's':
					while (!pp.isCommandOrEnd()) {
						var curr = pp.current;
						var p1 = pp.getReflectedControlPoint();
						var cntrl = pp.getAsControlPoint();
						var cp = pp.getAsCurrentPoint();
						pp.addMarker(cp, cntrl, p1);
						bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
					}
					break;
				case 'Q':
				case 'q':
					while (!pp.isCommandOrEnd()) {
						var curr = pp.current;
						var cntrl = pp.getAsControlPoint();
						var cp = pp.getAsCurrentPoint();
						pp.addMarker(cp, cntrl, cntrl);
						bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
						if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
					}
					break;
				case 'T':
				case 't':
					while (!pp.isCommandOrEnd()) {
						var curr = pp.current;
						var cntrl = pp.getReflectedControlPoint();
						pp.control = cntrl;
						var cp = pp.getAsCurrentPoint();
						pp.addMarker(cp, cntrl, cntrl);
						bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
						if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
					}
					break;
				case 'A':
				case 'a':
					while (!pp.isCommandOrEnd()) {
					    var curr = pp.current;
						var rx = pp.getScalar();
						var ry = pp.getScalar();
						var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
						var largeArcFlag = pp.getScalar();
						var sweepFlag = pp.getScalar();
						var cp = pp.getAsCurrentPoint();

						// Conversion from endpoint to center parameterization
						// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
						// x1', y1'
						var currp = new svg.Point(
							Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
							-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
						);
						// adjust radii
						var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
						if (l > 1) {
							rx *= Math.sqrt(l);
							ry *= Math.sqrt(l);
						}
						// cx', cy'
						var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
							((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
							(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
						);
						if (isNaN(s)) s = 0;
						var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
						// cx, cy
						var centp = new svg.Point(
							(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
							(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
						);
						// vector magnitude
						var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
						// ratio between two vectors
						var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
						// angle between two vectors
						var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
						// initial angle
						var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
						// angle delta
						var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
						var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
						var ad = a(u, v);
						if (r(u,v) <= -1) ad = Math.PI;
						if (r(u,v) >= 1) ad = 0;

						// for markers
						var dir = 1 - sweepFlag ? 1.0 : -1.0;
						var ah = a1 + dir * (ad / 2.0);
						var halfWay = new svg.Point(
							centp.x + rx * Math.cos(ah),
							centp.y + ry * Math.sin(ah)
						);
						pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
						pp.addMarkerAngle(cp, ah - dir * Math.PI);

						bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
						if (ctx != null) {
							var r = rx > ry ? rx : ry;
							var sx = rx > ry ? 1 : rx / ry;
							var sy = rx > ry ? ry / rx : 1;

							ctx.translate(centp.x, centp.y);
							ctx.rotate(xAxisRotation);
							ctx.scale(sx, sy);
							ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
							ctx.scale(1/sx, 1/sy);
							ctx.rotate(-xAxisRotation);
							ctx.translate(-centp.x, -centp.y);
						}
					}
					break;
				case 'Z':
				case 'z':
					if (ctx != null) ctx.closePath();
					pp.current = pp.start;
				}
			}

			return bb;
		}

		this.getMarkers = function() {
			var points = this.PathParser.getMarkerPoints();
			var angles = this.PathParser.getMarkerAngles();

			var markers = [];
			for (var i=0; i<points.length; i++) {
				markers.push([points[i], angles[i]]);
			}
			return markers;
		}
	}
	svg.Element.path.prototype = new svg.Element.PathElementBase;

	// pattern element
	svg.Element.pattern = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.createPattern = function(ctx, element) {
			var width = this.attribute('width').toPixels('x', true);
			var height = this.attribute('height').toPixels('y', true);

			// render me using a temporary svg element
			var tempSvg = new svg.Element.svg();
			tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
			tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
			tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
			tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
			tempSvg.children = this.children;

			var c = document.createElement('canvas');
			c.width = width;
			c.height = height;
			var cctx = c.getContext('2d');
			if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
				cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
			}
			// render 3x3 grid so when we transform there's no white space on edges
			for (var x=-1; x<=1; x++) {
				for (var y=-1; y<=1; y++) {
					cctx.save();
					tempSvg.attributes['x'] = new svg.Property('x', x * c.width);
					tempSvg.attributes['y'] = new svg.Property('y', y * c.height);
					tempSvg.render(cctx);
					cctx.restore();
				}
			}
			var pattern = ctx.createPattern(c, 'repeat');
			return pattern;
		}
	}
	svg.Element.pattern.prototype = new svg.Element.ElementBase;

	// marker element
	svg.Element.marker = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.baseRender = this.render;
		this.render = function(ctx, point, angle) {
			ctx.translate(point.x, point.y);
			if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
			if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
			ctx.save();

			// render me using a temporary svg element
			var tempSvg = new svg.Element.svg();
			tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
			tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
			tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
			tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
			tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
			tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
			tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
			tempSvg.children = this.children;
			tempSvg.render(ctx);

			ctx.restore();
			if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
			if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
			ctx.translate(-point.x, -point.y);
		}
	}
	svg.Element.marker.prototype = new svg.Element.ElementBase;

	// definitions element
	svg.Element.defs = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.render = function(ctx) {
			// NOOP
		}
	}
	svg.Element.defs.prototype = new svg.Element.ElementBase;

	// base for gradients
	svg.Element.GradientBase = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.stops = [];
		for (var i=0; i<this.children.length; i++) {
			var child = this.children[i];
			if (child.type == 'stop') this.stops.push(child);
		}

		this.getGradient = function() {
			// OVERRIDE ME!
		}

		this.gradientUnits = function () {
			return this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
		}

		this.attributesToInherit = ['gradientUnits'];

		this.inheritStopContainer = function (stopsContainer) {
			for (var i=0; i<this.attributesToInherit.length; i++) {
				var attributeToInherit = this.attributesToInherit[i];
				if (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {
					this.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;
				}
			}
		}

		this.createGradient = function(ctx, element, parentOpacityProp) {
			var stopsContainer = this;
			if (this.getHrefAttribute().hasValue()) {
				stopsContainer = this.getHrefAttribute().getDefinition();
				this.inheritStopContainer(stopsContainer);
			}

			var addParentOpacity = function (color) {
				if (parentOpacityProp.hasValue()) {
					var p = new svg.Property('color', color);
					return p.addOpacity(parentOpacityProp).value;
				}
				return color;
			};

			var g = this.getGradient(ctx, element);
			if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
			for (var i=0; i<stopsContainer.stops.length; i++) {
				g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
			}

			if (this.attribute('gradientTransform').hasValue()) {
				// render as transformed pattern on temporary canvas
				var rootView = svg.ViewPort.viewPorts[0];

				var rect = new svg.Element.rect();
				rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
				rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
				rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
				rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);

				var group = new svg.Element.g();
				group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
				group.children = [ rect ];

				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['x'] = new svg.Property('x', 0);
				tempSvg.attributes['y'] = new svg.Property('y', 0);
				tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
				tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
				tempSvg.children = [ group ];

				var c = document.createElement('canvas');
				c.width = rootView.width;
				c.height = rootView.height;
				var tempCtx = c.getContext('2d');
				tempCtx.fillStyle = g;
				tempSvg.render(tempCtx);
				return tempCtx.createPattern(c, 'no-repeat');
			}

			return g;
		}
	}
	svg.Element.GradientBase.prototype = new svg.Element.ElementBase;

	// linear gradient element
	svg.Element.linearGradient = function(node) {
		this.base = svg.Element.GradientBase;
		this.base(node);

		this.attributesToInherit.push('x1');
		this.attributesToInherit.push('y1');
		this.attributesToInherit.push('x2');
		this.attributesToInherit.push('y2');

		this.getGradient = function(ctx, element) {
			var bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;

			if (!this.attribute('x1').hasValue()
			 && !this.attribute('y1').hasValue()
			 && !this.attribute('x2').hasValue()
			 && !this.attribute('y2').hasValue()) {
				this.attribute('x1', true).value = 0;
				this.attribute('y1', true).value = 0;
				this.attribute('x2', true).value = 1;
				this.attribute('y2', true).value = 0;
			 }

			var x1 = (this.gradientUnits() == 'objectBoundingBox'
				? bb.x() + bb.width() * this.attribute('x1').numValue()
				: this.attribute('x1').toPixels('x'));
			var y1 = (this.gradientUnits() == 'objectBoundingBox'
				? bb.y() + bb.height() * this.attribute('y1').numValue()
				: this.attribute('y1').toPixels('y'));
			var x2 = (this.gradientUnits() == 'objectBoundingBox'
				? bb.x() + bb.width() * this.attribute('x2').numValue()
				: this.attribute('x2').toPixels('x'));
			var y2 = (this.gradientUnits() == 'objectBoundingBox'
				? bb.y() + bb.height() * this.attribute('y2').numValue()
				: this.attribute('y2').toPixels('y'));

			if (x1 == x2 && y1 == y2) return null;
			return ctx.createLinearGradient(x1, y1, x2, y2);
		}
	}
	svg.Element.linearGradient.prototype = new svg.Element.GradientBase;

	// radial gradient element
	svg.Element.radialGradient = function(node) {
		this.base = svg.Element.GradientBase;
		this.base(node);

		this.attributesToInherit.push('cx');
		this.attributesToInherit.push('cy');
		this.attributesToInherit.push('r');
		this.attributesToInherit.push('fx');
		this.attributesToInherit.push('fy');

		this.getGradient = function(ctx, element) {
			var bb = element.getBoundingBox();

			if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
			if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
			if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';

			var cx = (this.gradientUnits() == 'objectBoundingBox'
				? bb.x() + bb.width() * this.attribute('cx').numValue()
				: this.attribute('cx').toPixels('x'));
			var cy = (this.gradientUnits() == 'objectBoundingBox'
				? bb.y() + bb.height() * this.attribute('cy').numValue()
				: this.attribute('cy').toPixels('y'));

			var fx = cx;
			var fy = cy;
			if (this.attribute('fx').hasValue()) {
				fx = (this.gradientUnits() == 'objectBoundingBox'
				? bb.x() + bb.width() * this.attribute('fx').numValue()
				: this.attribute('fx').toPixels('x'));
			}
			if (this.attribute('fy').hasValue()) {
				fy = (this.gradientUnits() == 'objectBoundingBox'
				? bb.y() + bb.height() * this.attribute('fy').numValue()
				: this.attribute('fy').toPixels('y'));
			}

			var r = (this.gradientUnits() == 'objectBoundingBox'
				? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
				: this.attribute('r').toPixels());

			return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
		}
	}
	svg.Element.radialGradient.prototype = new svg.Element.GradientBase;

	// gradient stop element
	svg.Element.stop = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.offset = this.attribute('offset').numValue();
		if (this.offset < 0) this.offset = 0;
		if (this.offset > 1) this.offset = 1;

		var stopColor = this.style('stop-color', true);
		if (stopColor.value == '') stopColor.value = '#000';
		if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
		this.color = stopColor.value;
	}
	svg.Element.stop.prototype = new svg.Element.ElementBase;

	// animation base element
	svg.Element.AnimateBase = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		svg.Animations.push(this);

		this.duration = 0.0;
		this.begin = this.attribute('begin').toMilliseconds();
		this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();

		this.getProperty = function() {
			var attributeType = this.attribute('attributeType').value;
			var attributeName = this.attribute('attributeName').value;

			if (attributeType == 'CSS') {
				return this.parent.style(attributeName, true);
			}
			return this.parent.attribute(attributeName, true);
		};

		this.initialValue = null;
		this.initialUnits = '';
		this.removed = false;

		this.calcValue = function() {
			// OVERRIDE ME!
			return '';
		}

		this.update = function(delta) {
			// set initial value
			if (this.initialValue == null) {
				this.initialValue = this.getProperty().value;
				this.initialUnits = this.getProperty().getUnits();
			}

			// if we're past the end time
			if (this.duration > this.maxDuration) {
				// loop for indefinitely repeating animations
				if (this.attribute('repeatCount').value == 'indefinite'
				 || this.attribute('repeatDur').value == 'indefinite') {
					this.duration = 0.0
				}
				else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
					this.frozen = true;
					this.parent.animationFrozen = true;
					this.parent.animationFrozenValue = this.getProperty().value;
				}
				else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
					this.removed = true;
					this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
					return true;
				}
				return false;
			}
			this.duration = this.duration + delta;

			// if we're past the begin time
			var updated = false;
			if (this.begin < this.duration) {
				var newValue = this.calcValue(); // tween

				if (this.attribute('type').hasValue()) {
					// for transform, etc.
					var type = this.attribute('type').value;
					newValue = type + '(' + newValue + ')';
				}

				this.getProperty().value = newValue;
				updated = true;
			}

			return updated;
		}

		this.from = this.attribute('from');
		this.to = this.attribute('to');
		this.values = this.attribute('values');
		if (this.values.hasValue()) this.values.value = this.values.value.split(';');

		// fraction of duration we've covered
		this.progress = function() {
			var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
			if (this.values.hasValue()) {
				var p = ret.progress * (this.values.value.length - 1);
				var lb = Math.floor(p), ub = Math.ceil(p);
				ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
				ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
				ret.progress = (p - lb) / (ub - lb);
			}
			else {
				ret.from = this.from;
				ret.to = this.to;
			}
			return ret;
		}
	}
	svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;

	// animate element
	svg.Element.animate = function(node) {
		this.base = svg.Element.AnimateBase;
		this.base(node);

		this.calcValue = function() {
			var p = this.progress();

			// tween value linearly
			var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
			return newValue + this.initialUnits;
		};
	}
	svg.Element.animate.prototype = new svg.Element.AnimateBase;

	// animate color element
	svg.Element.animateColor = function(node) {
		this.base = svg.Element.AnimateBase;
		this.base(node);

		this.calcValue = function() {
			var p = this.progress();
			var from = new RGBColor(p.from.value);
			var to = new RGBColor(p.to.value);

			if (from.ok && to.ok) {
				// tween color linearly
				var r = from.r + (to.r - from.r) * p.progress;
				var g = from.g + (to.g - from.g) * p.progress;
				var b = from.b + (to.b - from.b) * p.progress;
				return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
			}
			return this.attribute('from').value;
		};
	}
	svg.Element.animateColor.prototype = new svg.Element.AnimateBase;

	// animate transform element
	svg.Element.animateTransform = function(node) {
		this.base = svg.Element.AnimateBase;
		this.base(node);

		this.calcValue = function() {
			var p = this.progress();

			// tween value linearly
			var from = svg.ToNumberArray(p.from.value);
			var to = svg.ToNumberArray(p.to.value);
			var newValue = '';
			for (var i=0; i<from.length; i++) {
				newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
			}
			return newValue;
		};
	}
	svg.Element.animateTransform.prototype = new svg.Element.animate;

	// font element
	svg.Element.font = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.horizAdvX = this.attribute('horiz-adv-x').numValue();

		this.isRTL = false;
		this.isArabic = false;
		this.fontFace = null;
		this.missingGlyph = null;
		this.glyphs = [];
		for (var i=0; i<this.children.length; i++) {
			var child = this.children[i];
			if (child.type == 'font-face') {
				this.fontFace = child;
				if (child.style('font-family').hasValue()) {
					svg.Definitions[child.style('font-family').value] = this;
				}
			}
			else if (child.type == 'missing-glyph') this.missingGlyph = child;
			else if (child.type == 'glyph') {
				if (child.arabicForm != '') {
					this.isRTL = true;
					this.isArabic = true;
					if (typeof this.glyphs[child.unicode] == 'undefined') this.glyphs[child.unicode] = [];
					this.glyphs[child.unicode][child.arabicForm] = child;
				}
				else {
					this.glyphs[child.unicode] = child;
				}
			}
		}
	}
	svg.Element.font.prototype = new svg.Element.ElementBase;

	// font-face element
	svg.Element.fontface = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.ascent = this.attribute('ascent').value;
		this.descent = this.attribute('descent').value;
		this.unitsPerEm = this.attribute('units-per-em').numValue();
	}
	svg.Element.fontface.prototype = new svg.Element.ElementBase;

	// missing-glyph element
	svg.Element.missingglyph = function(node) {
		this.base = svg.Element.path;
		this.base(node);

		this.horizAdvX = 0;
	}
	svg.Element.missingglyph.prototype = new svg.Element.path;

	// glyph element
	svg.Element.glyph = function(node) {
		this.base = svg.Element.path;
		this.base(node);

		this.horizAdvX = this.attribute('horiz-adv-x').numValue();
		this.unicode = this.attribute('unicode').value;
		this.arabicForm = this.attribute('arabic-form').value;
	}
	svg.Element.glyph.prototype = new svg.Element.path;

	// text element
	svg.Element.text = function(node) {
		this.captureTextNodes = true;
		this.base = svg.Element.RenderedElementBase;
		this.base(node);

		this.baseSetContext = this.setContext;
		this.setContext = function(ctx) {
			this.baseSetContext(ctx);

			var textBaseline = this.style('dominant-baseline').toTextBaseline();
			if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
			if (textBaseline != null) ctx.textBaseline = textBaseline;
		}

		this.getBoundingBox = function () {
			var x = this.attribute('x').toPixels('x');
			var y = this.attribute('y').toPixels('y');
			var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
			return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
		}

		this.renderChildren = function(ctx) {
			this.x = this.attribute('x').toPixels('x');
			this.y = this.attribute('y').toPixels('y');
			if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
			if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
			this.x += this.getAnchorDelta(ctx, this, 0);
			for (var i=0; i<this.children.length; i++) {
				this.renderChild(ctx, this, this, i);
			}
		}

		this.getAnchorDelta = function (ctx, parent, startI) {
			var textAnchor = this.style('text-anchor').valueOrDefault('start');
			if (textAnchor != 'start') {
				var width = 0;
				for (var i=startI; i<parent.children.length; i++) {
					var child = parent.children[i];
					if (i > startI && child.attribute('x').hasValue()) break; // new group
					width += child.measureTextRecursive(ctx);
				}
				return -1 * (textAnchor == 'end' ? width : width / 2.0);
			}
			return 0;
		}

		this.renderChild = function(ctx, textParent, parent, i) {
			var child = parent.children[i];
			if (child.attribute('x').hasValue()) {
				child.x = child.attribute('x').toPixels('x') + textParent.getAnchorDelta(ctx, parent, i);
				if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
			}
			else {
				if (child.attribute('dx').hasValue()) textParent.x += child.attribute('dx').toPixels('x');
				child.x = textParent.x;
			}
			textParent.x = child.x + child.measureText(ctx);

			if (child.attribute('y').hasValue()) {
				child.y = child.attribute('y').toPixels('y');
				if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
			}
			else {
				if (child.attribute('dy').hasValue()) textParent.y += child.attribute('dy').toPixels('y');
				child.y = textParent.y;
			}
			textParent.y = child.y;

			child.render(ctx);

			for (var i=0; i<child.children.length; i++) {
				textParent.renderChild(ctx, textParent, child, i);
			}
		}
	}
	svg.Element.text.prototype = new svg.Element.RenderedElementBase;

	// text base
	svg.Element.TextElementBase = function(node) {
		this.base = svg.Element.RenderedElementBase;
		this.base(node);

		this.getGlyph = function(font, text, i) {
			var c = text[i];
			var glyph = null;
			if (font.isArabic) {
				var arabicForm = 'isolated';
				if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';
				if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
				if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
				if (typeof font.glyphs[c] != 'undefined') {
					glyph = font.glyphs[c][arabicForm];
					if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
				}
			}
			else {
				glyph = font.glyphs[c];
			}
			if (glyph == null) glyph = font.missingGlyph;
			return glyph;
		}

		this.renderChildren = function(ctx) {
			var customFont = this.parent.style('font-family').getDefinition();
			if (customFont != null) {
				var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
				var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
				var text = this.getText();
				if (customFont.isRTL) text = text.split("").reverse().join("");

				var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
				for (var i=0; i<text.length; i++) {
					var glyph = this.getGlyph(customFont, text, i);
					var scale = fontSize / customFont.fontFace.unitsPerEm;
					ctx.translate(this.x, this.y);
					ctx.scale(scale, -scale);
					var lw = ctx.lineWidth;
					ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
					if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
					glyph.render(ctx);
					if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
					ctx.lineWidth = lw;
					ctx.scale(1/scale, -1/scale);
					ctx.translate(-this.x, -this.y);

					this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
					if (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {
						this.x += dx[i];
					}
				}
				return;
			}

			if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
			if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
		}

		this.getText = function() {
			// OVERRIDE ME
		}

		this.measureTextRecursive = function(ctx) {
			var width = this.measureText(ctx);
			for (var i=0; i<this.children.length; i++) {
				width += this.children[i].measureTextRecursive(ctx);
			}
			return width;
		}

		this.measureText = function(ctx) {
			var customFont = this.parent.style('font-family').getDefinition();
			if (customFont != null) {
				var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
				var measure = 0;
				var text = this.getText();
				if (customFont.isRTL) text = text.split("").reverse().join("");
				var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
				for (var i=0; i<text.length; i++) {
					var glyph = this.getGlyph(customFont, text, i);
					measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
					if (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {
						measure += dx[i];
					}
				}
				return measure;
			}

			var textToMeasure = svg.compressSpaces(this.getText());
			if (!ctx.measureText) return textToMeasure.length * 10;

			ctx.save();
			this.setContext(ctx);
			var width = ctx.measureText(textToMeasure).width;
			ctx.restore();
			return width;
		}
	}
	svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

	// tspan
	svg.Element.tspan = function(node) {
		this.captureTextNodes = true;
		this.base = svg.Element.TextElementBase;
		this.base(node);

		this.text = svg.compressSpaces(node.value || node.text || node.textContent || '');
		this.getText = function() {
			// if this node has children, then they own the text
			if (this.children.length > 0) { return ''; }
			return this.text;
		}
	}
	svg.Element.tspan.prototype = new svg.Element.TextElementBase;

	// tref
	svg.Element.tref = function(node) {
		this.base = svg.Element.TextElementBase;
		this.base(node);

		this.getText = function() {
			var element = this.getHrefAttribute().getDefinition();
			if (element != null) return element.children[0].getText();
		}
	}
	svg.Element.tref.prototype = new svg.Element.TextElementBase;

	// a element
	svg.Element.a = function(node) {
		this.base = svg.Element.TextElementBase;
		this.base(node);

		this.hasText = node.childNodes.length > 0;
		for (var i=0; i<node.childNodes.length; i++) {
			if (node.childNodes[i].nodeType != 3) this.hasText = false;
		}

		// this might contain text
		this.text = this.hasText ? node.childNodes[0].value : '';
		this.getText = function() {
			return this.text;
		}

		this.baseRenderChildren = this.renderChildren;
		this.renderChildren = function(ctx) {
			if (this.hasText) {
				// render as text element
				this.baseRenderChildren(ctx);
				var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
				svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
			}
			else if (this.children.length > 0) {
				// render as temporary group
				var g = new svg.Element.g();
				g.children = this.children;
				g.parent = this;
				g.render(ctx);
			}
		}

		this.onclick = function() {
			window.open(this.getHrefAttribute().value);
		}

		this.onmousemove = function() {
			svg.ctx.canvas.style.cursor = 'pointer';
		}
	}
	svg.Element.a.prototype = new svg.Element.TextElementBase;

	// image element
	svg.Element.image = function(node) {
		this.base = svg.Element.RenderedElementBase;
		this.base(node);

		var href = this.getHrefAttribute().value;
		if (href == '') { return; }
		var isSvg = href.match(/\.svg$/)

		svg.Images.push(this);
		this.loaded = false;
		if (!isSvg) {
			this.img = document.createElement('img');
			if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
			var self = this;
			this.img.onload = function() { self.loaded = true; }
			this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
			this.img.src = href;
		}
		else {
			this.img = svg.ajax(href);
			this.loaded = true;
		}

		this.renderChildren = function(ctx) {
			var x = this.attribute('x').toPixels('x');
			var y = this.attribute('y').toPixels('y');

			var width = this.attribute('width').toPixels('x');
			var height = this.attribute('height').toPixels('y');
			if (width == 0 || height == 0) return;

			ctx.save();
			if (isSvg) {
				ctx.drawSvg(this.img, x, y, width, height);
			}
			else {
				ctx.translate(x, y);
				svg.AspectRatio(ctx,
								this.attribute('preserveAspectRatio').value,
								width,
								this.img.width,
								height,
								this.img.height,
								0,
								0);
				ctx.drawImage(this.img, 0, 0);
			}
			ctx.restore();
		}

		this.getBoundingBox = function() {
			var x = this.attribute('x').toPixels('x');
			var y = this.attribute('y').toPixels('y');
			var width = this.attribute('width').toPixels('x');
			var height = this.attribute('height').toPixels('y');
			return new svg.BoundingBox(x, y, x + width, y + height);
		}
	}
	svg.Element.image.prototype = new svg.Element.RenderedElementBase;

	// group element
	svg.Element.g = function(node) {
		this.base = svg.Element.RenderedElementBase;
		this.base(node);

		this.getBoundingBox = function() {
			var bb = new svg.BoundingBox();
			for (var i=0; i<this.children.length; i++) {
				bb.addBoundingBox(this.children[i].getBoundingBox());
			}
			return bb;
		};
	}
	svg.Element.g.prototype = new svg.Element.RenderedElementBase;

	// symbol element
	svg.Element.symbol = function(node) {
		this.base = svg.Element.RenderedElementBase;
		this.base(node);

		this.render = function(ctx) {
			// NO RENDER
		};
	}
	svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;

	// style element
	svg.Element.style = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		// text, or spaces then CDATA
		var css = ''
		for (var i=0; i<node.childNodes.length; i++) {
		  css += node.childNodes[i].data;
		}
		css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
		css = svg.compressSpaces(css); // replace whitespace
		var cssDefs = css.split('}');
		for (var i=0; i<cssDefs.length; i++) {
			if (svg.trim(cssDefs[i]) != '') {
				var cssDef = cssDefs[i].split('{');
				var cssClasses = cssDef[0].split(',');
				var cssProps = cssDef[1].split(';');
				for (var j=0; j<cssClasses.length; j++) {
					var cssClass = svg.trim(cssClasses[j]);
					if (cssClass != '') {
						var props = svg.Styles[cssClass] || {};
						for (var k=0; k<cssProps.length; k++) {
							var prop = cssProps[k].indexOf(':');
							var name = cssProps[k].substr(0, prop);
							var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
							if (name != null && value != null) {
								props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
							}
						}
						svg.Styles[cssClass] = props;
						svg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
						if (cssClass == '@font-face') {
							var fontFamily = props['font-family'].value.replace(/"/g,'');
							var srcs = props['src'].value.split(',');
							for (var s=0; s<srcs.length; s++) {
								if (srcs[s].indexOf('format("svg")') > 0) {
									var urlStart = srcs[s].indexOf('url');
									var urlEnd = srcs[s].indexOf(')', urlStart);
									var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
									var doc = svg.parseXml(svg.ajax(url));
									var fonts = doc.getElementsByTagName('font');
									for (var f=0; f<fonts.length; f++) {
										var font = svg.CreateElement(fonts[f]);
										svg.Definitions[fontFamily] = font;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	svg.Element.style.prototype = new svg.Element.ElementBase;

	// use element
	svg.Element.use = function(node) {
		this.base = svg.Element.RenderedElementBase;
		this.base(node);

		this.baseSetContext = this.setContext;
		this.setContext = function(ctx) {
			this.baseSetContext(ctx);
			if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
			if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
		}

		var element = this.getHrefAttribute().getDefinition();

		this.path = function(ctx) {
			if (element != null) element.path(ctx);
		}

		this.getBoundingBox = function() {
			if (element != null) return element.getBoundingBox();
		}

		this.renderChildren = function(ctx) {
			if (element != null) {
				var tempSvg = element;
				if (element.type == 'symbol') {
					// render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
					tempSvg = new svg.Element.svg();
					tempSvg.type = 'svg';
					tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
					tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
					tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
					tempSvg.children = element.children;
				}
				if (tempSvg.type == 'svg') {
					// if symbol or svg, inherit width/height from me
					if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
					if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
				}
				var oldParent = tempSvg.parent;
				tempSvg.parent = null;
				tempSvg.render(ctx);
				tempSvg.parent = oldParent;
			}
		}
	}
	svg.Element.use.prototype = new svg.Element.RenderedElementBase;

	// mask element
	svg.Element.mask = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.apply = function(ctx, element) {
			// render as temp svg
			var x = this.attribute('x').toPixels('x');
			var y = this.attribute('y').toPixels('y');
			var width = this.attribute('width').toPixels('x');
			var height = this.attribute('height').toPixels('y');

			if (width == 0 && height == 0) {
				var bb = new svg.BoundingBox();
				for (var i=0; i<this.children.length; i++) {
					bb.addBoundingBox(this.children[i].getBoundingBox());
				}
				var x = Math.floor(bb.x1);
				var y = Math.floor(bb.y1);
				var width = Math.floor(bb.width());
				var	height = Math.floor(bb.height());
			}

			// temporarily remove mask to avoid recursion
			var mask = element.attribute('mask').value;
			element.attribute('mask').value = '';

				var cMask = document.createElement('canvas');
				cMask.width = x + width;
				cMask.height = y + height;
				var maskCtx = cMask.getContext('2d');
				this.renderChildren(maskCtx);

				var c = document.createElement('canvas');
				c.width = x + width;
				c.height = y + height;
				var tempCtx = c.getContext('2d');
				element.render(tempCtx);
				tempCtx.globalCompositeOperation = 'destination-in';
				tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
				tempCtx.fillRect(0, 0, x + width, y + height);

				ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
				ctx.fillRect(0, 0, x + width, y + height);

			// reassign mask
			element.attribute('mask').value = mask;
		}

		this.render = function(ctx) {
			// NO RENDER
		}
	}
	svg.Element.mask.prototype = new svg.Element.ElementBase;

	// clip element
	svg.Element.clipPath = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.apply = function(ctx) {
			var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
			CanvasRenderingContext2D.prototype.beginPath = function () { };

			var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
			CanvasRenderingContext2D.prototype.closePath = function () { };

			oldBeginPath.call(ctx);
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (typeof child.path != 'undefined') {
					var transform = null;
					if (child.style('transform', false, true).hasValue()) {
						transform = new svg.Transform(child.style('transform', false, true).value);
						transform.apply(ctx);
					}
					child.path(ctx);
					CanvasRenderingContext2D.prototype.closePath = oldClosePath;
					if (transform) { transform.unapply(ctx); }
				}
			}
			oldClosePath.call(ctx);
			ctx.clip();

			CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
			CanvasRenderingContext2D.prototype.closePath = oldClosePath;
		}

		this.render = function(ctx) {
			// NO RENDER
		}
	}
	svg.Element.clipPath.prototype = new svg.Element.ElementBase;

	// filters
	svg.Element.filter = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.apply = function(ctx, element) {
			// render as temp svg
			var bb = element.getBoundingBox();
			var x = Math.floor(bb.x1);
			var y = Math.floor(bb.y1);
			var width = Math.floor(bb.width());
			var	height = Math.floor(bb.height());

			// temporarily remove filter to avoid recursion
			var filter = element.style('filter').value;
			element.style('filter').value = '';

			var px = 0, py = 0;
			for (var i=0; i<this.children.length; i++) {
				var efd = this.children[i].extraFilterDistance || 0;
				px = Math.max(px, efd);
				py = Math.max(py, efd);
			}

			var c = document.createElement('canvas');
			c.width = width + 2*px;
			c.height = height + 2*py;
			var tempCtx = c.getContext('2d');
			tempCtx.translate(-x + px, -y + py);
			element.render(tempCtx);

			// apply filters
			for (var i=0; i<this.children.length; i++) {
				if (typeof this.children[i].apply == 'function') {
					this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
				}
			}

			// render on me
			ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);

			// reassign filter
			element.style('filter', true).value = filter;
		}

		this.render = function(ctx) {
			// NO RENDER
		}
	}
	svg.Element.filter.prototype = new svg.Element.ElementBase;

	svg.Element.feMorphology = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.apply = function(ctx, x, y, width, height) {
			// TODO: implement
		}
	}
	svg.Element.feMorphology.prototype = new svg.Element.ElementBase;

	svg.Element.feComposite = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.apply = function(ctx, x, y, width, height) {
			// TODO: implement
		}
	}
	svg.Element.feComposite.prototype = new svg.Element.ElementBase;

	svg.Element.feColorMatrix = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		var matrix = svg.ToNumberArray(this.attribute('values').value);
		switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
			case 'saturate':
				var s = matrix[0];
				matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
						  0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
						  0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
						  0,0,0,1,0,
						  0,0,0,0,1];
				break;
			case 'hueRotate':
				var a = matrix[0] * Math.PI / 180.0;
				var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
				matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
						  c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
						  c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
						  0,0,0,1,0,
						  0,0,0,0,1];
				break;
			case 'luminanceToAlpha':
				matrix = [0,0,0,0,0,
						  0,0,0,0,0,
						  0,0,0,0,0,
						  0.2125,0.7154,0.0721,0,0,
						  0,0,0,0,1];
				break;
		}

		function imGet(img, x, y, width, height, rgba) {
			return img[y*width*4 + x*4 + rgba];
		}

		function imSet(img, x, y, width, height, rgba, val) {
			img[y*width*4 + x*4 + rgba] = val;
		}

		function m(i, v) {
			var mi = matrix[i];
			return mi * (mi < 0 ? v - 255 : v);
		}

		this.apply = function(ctx, x, y, width, height) {
			// assuming x==0 && y==0 for now
			var srcData = ctx.getImageData(0, 0, width, height);
			for (var y = 0; y < height; y++) {
				for (var x = 0; x < width; x++) {
					var r = imGet(srcData.data, x, y, width, height, 0);
					var g = imGet(srcData.data, x, y, width, height, 1);
					var b = imGet(srcData.data, x, y, width, height, 2);
					var a = imGet(srcData.data, x, y, width, height, 3);
					imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
					imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
					imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
					imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
				}
			}
			ctx.clearRect(0, 0, width, height);
			ctx.putImageData(srcData, 0, 0);
		}
	}
	svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;

	svg.Element.feGaussianBlur = function(node) {
		this.base = svg.Element.ElementBase;
		this.base(node);

		this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
		this.extraFilterDistance = this.blurRadius;

		this.apply = function(ctx, x, y, width, height) {
			if (typeof stackblur.canvasRGBA == 'undefined') {
				svg.log('ERROR: StackBlur.js must be included for blur to work');
				return;
			}

			// StackBlur requires canvas be on document
			ctx.canvas.id = svg.UniqueId();
			ctx.canvas.style.display = 'none';
			document.body.appendChild(ctx.canvas);
			stackblur.canvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
			document.body.removeChild(ctx.canvas);
		}
	}
	svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;

	// title element, do nothing
	svg.Element.title = function(node) {
	}
	svg.Element.title.prototype = new svg.Element.ElementBase;

	// desc element, do nothing
	svg.Element.desc = function(node) {
	}
	svg.Element.desc.prototype = new svg.Element.ElementBase;

	svg.Element.MISSING = function(node) {
		svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
	}
	svg.Element.MISSING.prototype = new svg.Element.ElementBase;

	// element factory
	svg.CreateElement = function(node) {
		var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
		className = className.replace(/\-/g,''); // remove dashes
		var e = null;
		if (typeof svg.Element[className] != 'undefined') {
			e = new svg.Element[className](node);
		}
		else {
			e = new svg.Element.MISSING(node);
		}

		e.type = node.nodeName;
		return e;
	}

	// load from url
	svg.load = function(ctx, url) {
		svg.loadXml(ctx, svg.ajax(url));
	}

	// load from xml
	svg.loadXml = function(ctx, xml) {
		svg.loadXmlDoc(ctx, svg.parseXml(xml));
	}

	svg.loadXmlDoc = function(ctx, dom) {
		svg.init(ctx);

		var mapXY = function(p) {
			var e = ctx.canvas;
			while (e) {
				p.x -= e.offsetLeft;
				p.y -= e.offsetTop;
				e = e.offsetParent;
			}
			if (window.scrollX) p.x += window.scrollX;
			if (window.scrollY) p.y += window.scrollY;
			return p;
		}

		// bind mouse
		if (svg.opts['ignoreMouse'] != true) {
			ctx.canvas.onclick = function(e) {
				var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
				svg.Mouse.onclick(p.x, p.y);
			};
			ctx.canvas.onmousemove = function(e) {
				var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
				svg.Mouse.onmousemove(p.x, p.y);
			};
		}

		var e = svg.CreateElement(dom.documentElement);
		e.root = true;
		e.addStylesFromStyleDefinition();

		// render loop
		var isFirstRender = true;
		var draw = function() {
			svg.ViewPort.Clear();
			if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);

			if (svg.opts['ignoreDimensions'] != true) {
				// set canvas size
				if (e.style('width').hasValue()) {
					ctx.canvas.width = e.style('width').toPixels('x');
					ctx.canvas.style.width = ctx.canvas.width + 'px';
				}
				if (e.style('height').hasValue()) {
					ctx.canvas.height = e.style('height').toPixels('y');
					ctx.canvas.style.height = ctx.canvas.height + 'px';
				}
			}
			var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
			var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
			if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
				cWidth = e.style('width').toPixels('x');
				cHeight = e.style('height').toPixels('y');
			}
			svg.ViewPort.SetCurrent(cWidth, cHeight);

			if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
			if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
			if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
				var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);

				if (svg.opts['scaleWidth'] != null) {
					if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
					else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
				}

				if (svg.opts['scaleHeight'] != null) {
					if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
					else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
				}

				if (xRatio == null) { xRatio = yRatio; }
				if (yRatio == null) { yRatio = xRatio; }

				e.attribute('width', true).value = svg.opts['scaleWidth'];
				e.attribute('height', true).value = svg.opts['scaleHeight'];
				e.style('transform', true, true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
			}

			// clear and render
			if (svg.opts['ignoreClear'] != true) {
				ctx.clearRect(0, 0, cWidth, cHeight);
			}
			e.render(ctx);
			if (isFirstRender) {
				isFirstRender = false;
				if (typeof svg.opts['renderCallback'] == 'function') svg.opts['renderCallback'](dom);
			}
		}

		var waitingForImages = true;
		if (svg.ImagesLoaded()) {
			waitingForImages = false;
			draw();
		}
		svg.intervalID = setInterval(function() {
			var needUpdate = false;

			if (waitingForImages && svg.ImagesLoaded()) {
				waitingForImages = false;
				needUpdate = true;
			}

			// need update from mouse events?
			if (svg.opts['ignoreMouse'] != true) {
				needUpdate = needUpdate | svg.Mouse.hasEvents();
			}

			// need update from animations?
			if (svg.opts['ignoreAnimation'] != true) {
				for (var i=0; i<svg.Animations.length; i++) {
					needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
				}
			}

			// need update from redraw?
			if (typeof svg.opts['forceRedraw'] == 'function') {
				if (svg.opts['forceRedraw']() == true) needUpdate = true;
			}

			// render if needed
			if (needUpdate) {
				draw();
				svg.Mouse.runEvents(); // run and clear our events
			}
		}, 1000 / svg.FRAMERATE);
	}

	svg.stop = function() {
		if (svg.intervalID) {
			clearInterval(svg.intervalID);
		}
	}

	svg.Mouse = new (function() {
		this.events = [];
		this.hasEvents = function() { return this.events.length != 0; }

		this.onclick = function(x, y) {
			this.events.push({ type: 'onclick', x: x, y: y,
				run: function(e) { if (e.onclick) e.onclick(); }
			});
		}

		this.onmousemove = function(x, y) {
			this.events.push({ type: 'onmousemove', x: x, y: y,
				run: function(e) { if (e.onmousemove) e.onmousemove(); }
			});
		}

		this.eventElements = [];

		this.checkPath = function(element, ctx) {
			for (var i=0; i<this.events.length; i++) {
				var e = this.events[i];
				if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
			}
		}

		this.checkBoundingBox = function(element, bb) {
			for (var i=0; i<this.events.length; i++) {
				var e = this.events[i];
				if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
			}
		}

		this.runEvents = function() {
			svg.ctx.canvas.style.cursor = '';

			for (var i=0; i<this.events.length; i++) {
				var e = this.events[i];
				var element = this.eventElements[i];
				while (element) {
					e.run(element);
					element = element.parent;
				}
			}

			// done running, clear
			this.events = [];
			this.eventElements = [];
		}
	});

	return svg;
};

module.exports = canvg;


/***/ }),

/***/ "./node_modules/css-loader/index.js!./src/css/contextmenu.css":
/*!***********************************************************!*\
  !*** ./node_modules/css-loader!./src/css/contextmenu.css ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n\n/*!\n * jQuery contextMenu - Plugin for simple contextMenu handling\n *\n * Version: 1.5.24\n *\n * Authors: Rodney Rehm, Addy Osmani (patches for FF)\n * Web: http://medialize.github.com/jQuery-contextMenu/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *   GPL v3 http://opensource.org/licenses/GPL-3.0\n *\n */\n.context-menu-list {\n    margin:0;\n    padding:0;\n\n    min-width: 120px;\n    max-width: 250px;\n    display: inline-block;\n    position: absolute;\n    list-style-type: none;\n\n    border: 1px solid #DDD;\n    background: #EEE;\n\n    -webkit-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n       -moz-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n        -ms-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n         -o-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);\n\n    font-family: Verdana, Arial, Helvetica, sans-serif;\n    font-size: 11px;\n}\n\n.context-menu-item {\n    padding: 2px 2px 2px 24px;\n    background-color: #EEE;\n    position: relative;\n    -webkit-user-select: none;\n       -moz-user-select: -moz-none;\n        -ms-user-select: none;\n            user-select: none;\n}\n\n.context-menu-separator {\n    padding-bottom:0;\n    border-bottom: 1px solid #DDD;\n}\n\n.context-menu-item > label > input,\n.context-menu-item > label > textarea {\n    -webkit-user-select: text;\n       -moz-user-select: text;\n        -ms-user-select: text;\n            user-select: text;\n}\n\n.context-menu-item.hover {\n    cursor: pointer;\n    background-color: #39F;\n}\n\n.context-menu-item.disabled {\n    color: #666;\n}\n\n.context-menu-input.hover,\n.context-menu-item.disabled.hover {\n    cursor: default;\n    background-color: #EEE;\n}\n\n.context-menu-submenu:after {\n    content: \">\";\n    color: #666;\n    position: absolute;\n    top: 0;\n    right: 3px;\n    z-index: 1;\n}\n\n/* icons\n    #protip:\n    In case you want to use sprites for icons (which I would suggest you do) have a look at\n    http://css-tricks.com/13224-pseudo-spriting/ to get an idea of how to implement\n    .context-menu-item.icon:before {}\n */\n.context-menu-item.icon { min-height: 18px; background-repeat: no-repeat; background-position: 4px 2px; }\n\n/* vertically align inside labels */\n.context-menu-input > label > * { vertical-align: top; }\n\n/* position checkboxes and radios as icons */\n.context-menu-input > label > input[type=\"checkbox\"],\n.context-menu-input > label > input[type=\"radio\"] {\n    margin-left: -17px;\n}\n.context-menu-input > label > span {\n    margin-left: 5px;\n}\n\n.context-menu-input > label,\n.context-menu-input > label > input[type=\"text\"],\n.context-menu-input > label > textarea,\n.context-menu-input > label > select {\n    display: block;\n    width: 100%;\n\n    -webkit-box-sizing: border-box;\n       -moz-box-sizing: border-box;\n        -ms-box-sizing: border-box;\n         -o-box-sizing: border-box;\n            box-sizing: border-box;\n}\n\n.context-menu-input > label > textarea {\n    height: 100px;\n}\n.context-menu-item > .context-menu-list {\n    display: none;\n    /* re-positioned by js */\n    right: -5px;\n    top: 5px;\n}\n\n.context-menu-item.hover > .context-menu-list {\n    display: block;\n}\n\n.context-menu-accesskey {\n    text-decoration: underline;\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/lib/Class.exec.js":
/*!*********************************************************!*\
  !*** ./node_modules/raw-loader!./src/lib/Class.exec.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/* \n * Simple JavaScript Inheritance \n * By John Resig http://ejohn.org/ \n * MIT Licensed. \n * \n ****************************************************** \n * Example Usage \n ****************************************************** \n var Person = Class.extend({ \n  init: function(isDancing){ \n    this.dancing = isDancing; \n  }, \n  dance: function(){ \n    return this.dancing; \n  } \n}); \n\nvar Ninja = Person.extend({ \n  init: function(){ \n    this._super( false ); \n  }, \n  dance: function(){ \n    // Call the inherited version of dance() \n    return this._super(); \n  }, \n  swingSword: function(){ \n    return true; \n  } \n}); \n\nvar p = new Person(true); \np.dance(); // => true \n\nvar n = new Ninja(); \nn.dance(); // => false \nn.swingSword(); // => true \n\n// Should all be true \np instanceof Person && p instanceof Class && \nn instanceof Ninja && n instanceof Person && n instanceof Class \n\n ****************************************************** \n */ \n  \n// Inspired by base2 and Prototype \n(function(){ \n  var fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/; \n\n  // The base Class implementation (does nothing) \n  this.Class = function(){}; \n  \n\n  // Create a new Class that inherits from this class \n  Class.extend = function(prop) { \n    var _super = this.prototype; \n    \n    // Instantiate a base class (but only create the instance, \n    // don't run the init constructor) \n    initializing = true; \n    var prototype = new this(); \n    initializing = false; \n    \n     \n    // Copy the properties over onto the new prototype \n    for (var name in prop) { \n      // Check if we're overwriting an existing function \n      prototype[name] = typeof prop[name] == \"function\" && \n        typeof _super[name] == \"function\" && fnTest.test(prop[name]) ? \n        (function(name, fn){ \n          return function() { \n            var tmp = this._super; \n            \n            // Add a new ._super() method that is the same method \n            // but on the super-class \n            this._super = _super[name]; \n            \n            // The method only need to be bound temporarily, so we \n            // remove it when we're done executing \n            var ret = fn.apply(this, arguments);        \n            this._super = tmp; \n            \n            return ret; \n          }; \n        })(name, prop[name]) : \n        prop[name]; \n    } \n    \n    // The dummy class constructor \n    function Class() { \n      // All construction is actually done in the init method \n      if ( !initializing && this.init ) \n        this.init.apply(this, arguments); \n    } \n    \n    // Populate our constructed prototype object \n    Class.prototype = prototype; \n    \n    // Enforce the constructor to be what we expect \n    Class.prototype.constructor = Class; \n\n    // And make this class extendable \n    Class.extend = arguments.callee; \n    \n    // EXTENSION BY Draw2D.org to inject methods into an existing class to provide plugins or \n    // bugfixes for further releases \n    // \n    Class.inject = function (prop) { \n        var proto = this.prototype; \n        var parent = {}; \n        for (var name in prop) { \n            if (typeof (prop[name]) == \"function\" && typeof (proto[name]) == \"function\" && fnTest.test(prop[name])) { \n                parent[name] = proto[name]; \n                proto[name] = (function (name, fn) { \n                    return function () { \n                        var tmp = this.parent; \n                        this.parent = parent[name]; \n                        var ret = fn.apply(this, arguments); \n                        this.parent = tmp; \n                        return ret; \n                    }; \n                })(name, prop[name]); \n            } else { \n                proto[name] = prop[name]; \n            } \n        } \n    }; \n     \n    return Class; \n  }; \n})();\n \n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/lib/pathfinding.exec.js":
/*!***************************************************************!*\
  !*** ./node_modules/raw-loader!./src/lib/pathfinding.exec.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "var PF=function(){var e=function(t,n){var r=e.resolve(t,n||\"/\"),i=e.modules[r];if(!i)throw new Error(\"Failed to resolve module \"+t+\", tried \"+r);var s=i._cached?i._cached:i();return s};return e.paths=[],e.modules={},e.extensions=[\".js\",\".coffee\"],e._core={assert:!0,events:!0,fs:!0,path:!0,vm:!0},e.resolve=function(){return function(t,n){function u(t){if(e.modules[t])return t;for(var n=0;n<e.extensions.length;n++){var r=e.extensions[n];if(e.modules[t+r])return t+r}}function a(t){t=t.replace(/\\/+$/,\"\");var n=t+\"/package.json\";if(e.modules[n]){var i=e.modules[n](),s=i.browserify;if(typeof s==\"object\"&&s.main){var o=u(r.resolve(t,s.main));if(o)return o}else if(typeof s==\"string\"){var o=u(r.resolve(t,s));if(o)return o}else if(i.main){var o=u(r.resolve(t,i.main));if(o)return o}}return u(t+\"/index\")}function f(e,t){var n=l(t);for(var r=0;r<n.length;r++){var i=n[r],s=u(i+\"/\"+e);if(s)return s;var o=a(i+\"/\"+e);if(o)return o}var s=u(e);if(s)return s}function l(e){var t;e===\"/\"?t=[\"\"]:t=r.normalize(e).split(\"/\");var n=[];for(var i=t.length-1;i>=0;i--){if(t[i]===\"node_modules\")continue;var s=t.slice(0,i+1).join(\"/\")+\"/node_modules\";n.push(s)}return n}n||(n=\"/\");if(e._core[t])return t;var r=e.modules.path();n=r.resolve(\"/\",n);var i=n||\"/\";if(t.match(/^(?:\\.\\.?\\/|\\/)/)){var s=u(r.resolve(i,t))||a(r.resolve(i,t));if(s)return s}var o=f(t,i);if(o)return o;throw new Error(\"Cannot find module '\"+t+\"'\")}}(),e.alias=function(t,n){var r=e.modules.path(),i=null;try{i=e.resolve(t+\"/package.json\",\"/\")}catch(s){i=e.resolve(t,\"/\")}var o=r.dirname(i),u=(Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t})(e.modules);for(var a=0;a<u.length;a++){var f=u[a];if(f.slice(0,o.length+1)===o+\"/\"){var l=f.slice(o.length);e.modules[n+l]=e.modules[o+l]}else f===o&&(e.modules[n]=e.modules[o])}},e.define=function(t,n){var r=e._core[t]?\"\":e.modules.path().dirname(t),i=function(t){return e(t,r)};i.resolve=function(t){return e.resolve(t,r)},i.modules=e.modules,i.define=e.define;var s={exports:{}};e.modules[t]=function(){return e.modules[t]._cached=s.exports,n.call(s.exports,i,s,s.exports,r,t),e.modules[t]._cached=s.exports,s.exports}},typeof process==\"undefined\"&&(process={}),process.nextTick||(process.nextTick=function(){var e=[],t=typeof window!=\"undefined\"&&window.postMessage&&window.addEventListener;return t&&window.addEventListener(\"message\",function(t){if(t.source===window&&t.data===\"browserify-tick\"){t.stopPropagation();if(e.length>0){var n=e.shift();n()}}},!0),function(n){t?(e.push(n),window.postMessage(\"browserify-tick\",\"*\")):setTimeout(n,0)}}()),process.title||(process.title=\"browser\"),process.binding||(process.binding=function(t){if(t===\"evals\")return e(\"vm\");throw new Error(\"No such module\")}),process.cwd||(process.cwd=function(){return\".\"}),process.env||(process.env={}),process.argv||(process.argv=[]),e.define(\"path\",function(e,t,n,r,i){function s(e,t){var n=[];for(var r=0;r<e.length;r++)t(e[r],r,e)&&n.push(e[r]);return n}function o(e,t){var n=0;for(var r=e.length;r>=0;r--){var i=e[r];i==\".\"?e.splice(r,1):i===\"..\"?(e.splice(r,1),n++):n&&(e.splice(r,1),n--)}if(t)for(;n--;n)e.unshift(\"..\");return e}var u=/^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;n.resolve=function(){var e=\"\",t=!1;for(var n=arguments.length;n>=-1&&!t;n--){var r=n>=0?arguments[n]:process.cwd();if(typeof r!=\"string\"||!r)continue;e=r+\"/\"+e,t=r.charAt(0)===\"/\"}return e=o(s(e.split(\"/\"),function(e){return!!e}),!t).join(\"/\"),(t?\"/\":\"\")+e||\".\"},n.normalize=function(e){var t=e.charAt(0)===\"/\",n=e.slice(-1)===\"/\";return e=o(s(e.split(\"/\"),function(e){return!!e}),!t).join(\"/\"),!e&&!t&&(e=\".\"),e&&n&&(e+=\"/\"),(t?\"/\":\"\")+e},n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(s(e,function(e,t){return e&&typeof e==\"string\"}).join(\"/\"))},n.dirname=function(e){var t=u.exec(e)[1]||\"\",n=!1;return t?t.length===1||n&&t.length<=3&&t.charAt(1)===\":\"?t:t.substring(0,t.length-1):\".\"},n.basename=function(e,t){var n=u.exec(e)[2]||\"\";return t&&n.substr(-1*t.length)===t&&(n=n.substr(0,n.length-t.length)),n},n.extname=function(e){return u.exec(e)[3]||\"\"}}),e.define(\"/core/Node.js\",function(e,t,n,r,i){function s(e,t,n){this.x=e,this.y=t,this.walkable=n===undefined?!0:n}t.exports=s}),e.define(\"/core/Grid.js\",function(e,t,n,r,i){function o(e,t,n){this.width=e,this.height=t,this.nodes=this._buildNodes(e,t,n)}var s=e(\"./Node\");o.prototype._buildNodes=function(e,t,n){var r,i,o=new Array(t),u;for(r=0;r<t;++r){o[r]=new Array(e);for(i=0;i<e;++i)o[r][i]=new s(i,r)}if(n===undefined)return o;if(n.length!==t||n[0].length!==e)throw new Error(\"Matrix size does not fit\");for(r=0;r<t;++r)for(i=0;i<e;++i)n[r][i]&&(o[r][i].walkable=!1);return o},o.prototype.getNodeAt=function(e,t){return this.nodes[t][e]},o.prototype.isWalkableAt=function(e,t){return this.isInside(e,t)&&this.nodes[t][e].walkable},o.prototype.isInside=function(e,t){return e>=0&&e<this.width&&t>=0&&t<this.height},o.prototype.setWalkableAt=function(e,t,n){this.nodes[t][e].walkable=n},o.prototype.getNeighbors=function(e,t,n){var r=e.x,i=e.y,s=[],o=!1,u=!1,a=!1,f=!1,l=!1,c=!1,h=!1,p=!1,d=this.nodes;return this.isWalkableAt(r,i-1)&&(s.push(d[i-1][r]),o=!0),this.isWalkableAt(r+1,i)&&(s.push(d[i][r+1]),a=!0),this.isWalkableAt(r,i+1)&&(s.push(d[i+1][r]),l=!0),this.isWalkableAt(r-1,i)&&(s.push(d[i][r-1]),h=!0),t?(n?(u=h&&o,f=o&&a,c=a&&l,p=l&&h):(u=h||o,f=o||a,c=a||l,p=l||h),u&&this.isWalkableAt(r-1,i-1)&&s.push(d[i-1][r-1]),f&&this.isWalkableAt(r+1,i-1)&&s.push(d[i-1][r+1]),c&&this.isWalkableAt(r+1,i+1)&&s.push(d[i+1][r+1]),p&&this.isWalkableAt(r-1,i+1)&&s.push(d[i+1][r-1]),s):s},o.prototype.clone=function(){var e,t,n=this.width,r=this.height,i=this.nodes,u=new o(n,r),a=new Array(r),f;for(e=0;e<r;++e){a[e]=new Array(n);for(t=0;t<n;++t)a[e][t]=new s(t,e,i[e][t].walkable)}return u.nodes=a,u},t.exports=o}),e.define(\"/core/Heap.js\",function(e,t,n,r,i){(function(){var e,n,r,i,s,o,u,a,f,l,c,h,p,d,v;r=Math.floor,l=Math.min,n=function(e,t){return e<t?-1:e>t?1:0},f=function(e,t,i,s,o){var u;i==null&&(i=0),o==null&&(o=n);if(i<0)throw new Error(\"lo must be non-negative\");s==null&&(s=e.length);while(o(i,s)<0)u=r((i+s)/2),o(t,e[u])<0?s=u:i=u+1;return[].splice.apply(e,[i,i-i].concat(t)),t},o=function(e,t,r){return r==null&&(r=n),e.push(t),d(e,0,e.length-1,r)},s=function(e,t){var r,i;return t==null&&(t=n),r=e.pop(),e.length?(i=e[0],e[0]=r,v(e,0,t)):i=r,i},a=function(e,t,r){var i;return r==null&&(r=n),i=e[0],e[0]=t,v(e,0,r),i},u=function(e,t,r){var i;return r==null&&(r=n),e.length&&r(e[0],t)<0&&(i=[e[0],t],t=i[0],e[0]=i[1],v(e,0,r)),t},i=function(e,t){var i,s,o,u,a,f,l,c;t==null&&(t=n),f=function(){c=[];for(var t=0,n=r(e.length/2);0<=n?t<n:t>n;0<=n?t++:t--)c.push(t);return c}.apply(this).reverse(),l=[];for(s=0,u=f.length;s<u;s++)i=f[s],l.push(v(e,i,t));return l},p=function(e,t,r){var i;return r==null&&(r=n),i=e.indexOf(t),d(e,0,i,r),v(e,i,r)},c=function(e,t,r){var s,o,a,f,l;r==null&&(r=n),o=e.slice(0,t);if(!o.length)return o;i(o,r),l=e.slice(t);for(a=0,f=l.length;a<f;a++)s=l[a],u(o,s,r);return o.sort(r).reverse()},h=function(e,t,r){var o,u,a,c,h,p,d,v,m,g;r==null&&(r=n);if(t*10<=e.length){c=e.slice(0,t).sort(r);if(!c.length)return c;a=c[c.length-1],v=e.slice(t);for(h=0,d=v.length;h<d;h++)o=v[h],r(o,a)<0&&(f(c,o,0,null,r),c.pop(),a=c[c.length-1]);return c}i(e,r),g=[];for(u=p=0,m=l(t,e.length);0<=m?p<m:p>m;u=0<=m?++p:--p)g.push(s(e,r));return g},d=function(e,t,r,i){var s,o,u;i==null&&(i=n),s=e[r];while(r>t){u=r-1>>1,o=e[u];if(i(s,o)<0){e[r]=o,r=u;continue}break}return e[r]=s},v=function(e,t,r){var i,s,o,u,a;r==null&&(r=n),s=e.length,a=t,o=e[t],i=2*t+1;while(i<s)u=i+1,u<s&&!(r(e[i],e[u])<0)&&(i=u),e[t]=e[i],t=i,i=2*t+1;return e[t]=o,d(e,a,t,r)},e=function(){function e(e){this.cmp=e!=null?e:n,this.nodes=[]}return e.name=\"Heap\",e.push=o,e.pop=s,e.replace=a,e.pushpop=u,e.heapify=i,e.nlargest=c,e.nsmallest=h,e.prototype.push=function(e){return o(this.nodes,e,this.cmp)},e.prototype.pop=function(){return s(this.nodes,this.cmp)},e.prototype.peek=function(){return this.nodes[0]},e.prototype.contains=function(e){return this.nodes.indexOf(e)!==-1},e.prototype.replace=function(e){return a(this.nodes,e,this.cmp)},e.prototype.pushpop=function(e){return u(this.nodes,e,this.cmp)},e.prototype.heapify=function(){return i(this.nodes,this.cmp)},e.prototype.updateItem=function(e){return p(this.nodes,e,this.cmp)},e.prototype.clear=function(){return this.nodes=[]},e.prototype.empty=function(){return this.nodes.length===0},e.prototype.size=function(){return this.nodes.length},e.prototype.clone=function(){var t;return t=new e,t.nodes=this.nodes.slice(0),t},e.prototype.toArray=function(){return this.nodes.slice(0)},e.prototype.insert=e.prototype.push,e.prototype.remove=e.prototype.pop,e.prototype.top=e.prototype.peek,e.prototype.front=e.prototype.peek,e.prototype.has=e.prototype.contains,e.prototype.copy=e.prototype.clone,e}(),(typeof t!=\"undefined\"&&t!==null?t.exports:void 0)?t.exports=e:window.Heap=e}).call(this)}),e.define(\"/core/Util.js\",function(e,t,n,r,i){function s(e){var t=[[e.x,e.y]];while(e.parent)e=e.parent,t.push([e.x,e.y]);return t.reverse()}function o(e,t){var n=s(e),r=s(t);return n.concat(r.reverse())}function u(e){var t,n=0,r,i,s,o;for(t=1;t<e.length;++t)r=e[t-1],i=e[t],s=r[0]-i[0],o=r[1]-i[1],n+=Math.sqrt(s*s+o*o);return n}function a(e,t,n,r){var i=Math.abs,s=[],o,u,a,f,l,c;a=i(n-e),f=i(r-t),o=e<n?1:-1,u=t<r?1:-1,l=a-f;for(;;){s.push([e,t]);if(e===n&&t===r)break;c=2*l,c>-f&&(l-=f,e+=o),c<a&&(l+=a,t+=u)}return s}function f(e,t){var n=t.length,r=t[0][0],i=t[0][1],s=t[n-1][0],o=t[n-1][1],u,f,l,c,h,p,d,v,m,g,y,b,w;u=r,f=i,h=t[1][0],p=t[1][1],d=[[u,f]];for(v=2;v<n;++v){g=t[v],l=g[0],c=g[1],y=a(u,f,l,c),w=!1;for(m=1;m<y.length;++m){b=y[m];if(!e.isWalkableAt(b[0],b[1])){w=!0,d.push([h,p]),u=h,f=p;break}}w||(h=l,p=c)}return d.push([s,o]),d}n.backtrace=s,n.biBacktrace=o,n.pathLength=u,n.getLine=a,n.smoothenPath=f}),e.define(\"/core/Heuristic.js\",function(e,t,n,r,i){t.exports={manhattan:function(e,t){return e+t},euclidean:function(e,t){return Math.sqrt(e*e+t*t)},chebyshev:function(e,t){return Math.max(e,t)}}}),e.define(\"/finders/AStarFinder.js\",function(e,t,n,r,i){function a(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners,this.heuristic=e.heuristic||u.manhattan}var s=e(\"../core/Heap\"),o=e(\"../core/Util\"),u=e(\"../core/Heuristic\");a.prototype.findPath=function(e,t,n,r,i){var u=new s(function(e,t){return e.f-t.f}),a=i.getNodeAt(e,t),f=i.getNodeAt(n,r),l=this.heuristic,c=this.allowDiagonal,h=this.dontCrossCorners,p=Math.abs,d=Math.SQRT2,v,m,g,y,b,w,E,S;a.g=0,a.f=0,u.push(a),a.opened=!0;while(!u.empty()){v=u.pop(),v.closed=!0;if(v===f)return o.backtrace(f);m=i.getNeighbors(v,c,h);for(y=0,b=m.length;y<b;++y){g=m[y];if(g.closed)continue;w=g.x,E=g.y,S=v.g+(w-v.x===0||E-v.y===0?1:d);if(!g.opened||S<g.g)g.g=S,g.h=g.h||l(p(w-n),p(E-r)),g.f=g.g+g.h,g.parent=v,g.opened?u.updateItem(g):(u.push(g),g.opened=!0)}}return[]},t.exports=a}),e.define(\"/finders/BestFirstFinder.js\",function(e,t,n,r,i){function o(e){s.call(this,e);var t=this.heuristic;this.heuristic=function(e,n){return t(e,n)*1e6}}var s=e(\"./AStarFinder\");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define(\"/finders/BreadthFirstFinder.js\",function(e,t,n,r,i){function o(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners}var s=e(\"../core/Util\");o.prototype.findPath=function(e,t,n,r,i){var o=[],u=this.allowDiagonal,a=this.dontCrossCorners,f=i.getNodeAt(e,t),l=i.getNodeAt(n,r),c,h,p,d,v;o.push(f),f.opened=!0;while(o.length){p=o.shift(),p.closed=!0;if(p===l)return s.backtrace(l);c=i.getNeighbors(p,u,a);for(d=0,v=c.length;d<v;++d){h=c[d];if(h.closed||h.opened)continue;o.push(h),h.opened=!0,h.parent=p}}return[]},t.exports=o}),e.define(\"/finders/DijkstraFinder.js\",function(e,t,n,r,i){function o(e){s.call(this,e),this.heuristic=function(e,t){return 0}}var s=e(\"./AStarFinder\");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define(\"/finders/BiAStarFinder.js\",function(e,t,n,r,i){function a(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners,this.heuristic=e.heuristic||u.manhattan}var s=e(\"../core/Heap\"),o=e(\"../core/Util\"),u=e(\"../core/Heuristic\");a.prototype.findPath=function(e,t,n,r,i){var u=function(e,t){return e.f-t.f},a=new s(u),f=new s(u),l=i.getNodeAt(e,t),c=i.getNodeAt(n,r),h=this.heuristic,p=this.allowDiagonal,d=this.dontCrossCorners,v=Math.abs,m=Math.SQRT2,g,y,b,w,E,S,x,T,N=1,C=2;l.g=0,l.f=0,a.push(l),l.opened=N,c.g=0,c.f=0,f.push(c),c.opened=C;while(!a.empty()&&!f.empty()){g=a.pop(),g.closed=!0,y=i.getNeighbors(g,p,d);for(w=0,E=y.length;w<E;++w){b=y[w];if(b.closed)continue;if(b.opened===C)return o.biBacktrace(g,b);S=b.x,x=b.y,T=g.g+(S-g.x===0||x-g.y===0?1:m);if(!b.opened||T<b.g)b.g=T,b.h=b.h||h(v(S-n),v(x-r)),b.f=b.g+b.h,b.parent=g,b.opened?a.updateItem(b):(a.push(b),b.opened=N)}g=f.pop(),g.closed=!0,y=i.getNeighbors(g,p,d);for(w=0,E=y.length;w<E;++w){b=y[w];if(b.closed)continue;if(b.opened===N)return o.biBacktrace(b,g);S=b.x,x=b.y,T=g.g+(S-g.x===0||x-g.y===0?1:m);if(!b.opened||T<b.g)b.g=T,b.h=b.h||h(v(S-e),v(x-t)),b.f=b.g+b.h,b.parent=g,b.opened?f.updateItem(b):(f.push(b),b.opened=C)}}return[]},t.exports=a}),e.define(\"/finders/BiBestFirstFinder.js\",function(e,t,n,r,i){function o(e){s.call(this,e);var t=this.heuristic;this.heuristic=function(e,n){return t(e,n)*1e6}}var s=e(\"./BiAStarFinder\");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define(\"/finders/BiBreadthFirstFinder.js\",function(e,t,n,r,i){function o(e){e=e||{},this.allowDiagonal=e.allowDiagonal,this.dontCrossCorners=e.dontCrossCorners}var s=e(\"../core/Util\");o.prototype.findPath=function(e,t,n,r,i){var o=i.getNodeAt(e,t),u=i.getNodeAt(n,r),a=[],f=[],l,c,h,p=this.allowDiagonal,d=this.dontCrossCorners,v=0,m=1,g,y;a.push(o),o.opened=!0,o.by=v,f.push(u),u.opened=!0,u.by=m;while(a.length&&f.length){h=a.shift(),h.closed=!0,l=i.getNeighbors(h,p,d);for(g=0,y=l.length;g<y;++g){c=l[g];if(c.closed)continue;if(c.opened){if(c.by===m)return s.biBacktrace(h,c);continue}a.push(c),c.parent=h,c.opened=!0,c.by=v}h=f.shift(),h.closed=!0,l=i.getNeighbors(h,p,d);for(g=0,y=l.length;g<y;++g){c=l[g];if(c.closed)continue;if(c.opened){if(c.by===v)return s.biBacktrace(c,h);continue}f.push(c),c.parent=h,c.opened=!0,c.by=m}}return[]},t.exports=o}),e.define(\"/finders/BiDijkstraFinder.js\",function(e,t,n,r,i){function o(e){s.call(this,e),this.heuristic=function(e,t){return 0}}var s=e(\"./BiAStarFinder\");o.prototype=new s,o.prototype.constructor=o,t.exports=o}),e.define(\"/finders/JumpPointFinder.js\",function(e,t,n,r,i){function a(e){e=e||{},this.heuristic=e.heuristic||u.manhattan}var s=e(\"../core/Heap\"),o=e(\"../core/Util\"),u=e(\"../core/Heuristic\");a.prototype.findPath=function(e,t,n,r,i){var u=this.openList=new s(function(e,t){return e.f-t.f}),a=this.startNode=i.getNodeAt(e,t),f=this.endNode=i.getNodeAt(n,r),l;this.grid=i,a.g=0,a.f=0,u.push(a),a.opened=!0;while(!u.empty()){l=u.pop(),l.closed=!0;if(l===f)return o.backtrace(f);this._identifySuccessors(l)}return[]},a.prototype._identifySuccessors=function(e){var t=this.grid,n=this.heuristic,r=this.openList,i=this.endNode.x,s=this.endNode.y,o,a,f,l,c,h=e.x,p=e.y,d,v,m,g,y,b,w,E=Math.abs,S=Math.max;o=this._findNeighbors(e);for(l=0,c=o.length;l<c;++l){a=o[l],f=this._jump(a[0],a[1],h,p);if(f){d=f[0],v=f[1],w=t.getNodeAt(d,v);if(w.closed)continue;y=u.euclidean(E(d-h),E(v-p)),b=e.g+y;if(!w.opened||b<w.g)w.g=b,w.h=w.h||n(E(d-i),E(v-s)),w.f=w.g+w.h,w.parent=e,w.opened?r.updateItem(w):(r.push(w),w.opened=!0)}}},a.prototype._jump=function(e,t,n,r){var i=this.grid,s=e-n,o=t-r,u,a;if(!i.isWalkableAt(e,t))return null;if(i.getNodeAt(e,t)===this.endNode)return[e,t];if(s!==0&&o!==0){if(i.isWalkableAt(e-s,t+o)&&!i.isWalkableAt(e-s,t)||i.isWalkableAt(e+s,t-o)&&!i.isWalkableAt(e,t-o))return[e,t]}else if(s!==0){if(i.isWalkableAt(e+s,t+1)&&!i.isWalkableAt(e,t+1)||i.isWalkableAt(e+s,t-1)&&!i.isWalkableAt(e,t-1))return[e,t]}else if(i.isWalkableAt(e+1,t+o)&&!i.isWalkableAt(e+1,t)||i.isWalkableAt(e-1,t+o)&&!i.isWalkableAt(e-1,t))return[e,t];if(s!==0&&o!==0){u=this._jump(e+s,t,e,t),a=this._jump(e,t+o,e,t);if(u||a)return[e,t]}return i.isWalkableAt(e+s,t)||i.isWalkableAt(e,t+o)?this._jump(e+s,t+o,e,t):null},a.prototype._findNeighbors=function(e){var t=e.parent,n=e.x,r=e.y,i=this.grid,s,o,u,a,f,l,c=[],h,p,d,v;if(t)s=t.x,o=t.y,f=(n-s)/Math.max(Math.abs(n-s),1),l=(r-o)/Math.max(Math.abs(r-o),1),f!==0&&l!==0?(i.isWalkableAt(n,r+l)&&c.push([n,r+l]),i.isWalkableAt(n+f,r)&&c.push([n+f,r]),(i.isWalkableAt(n,r+l)||i.isWalkableAt(n+f,r))&&c.push([n+f,r+l]),!i.isWalkableAt(n-f,r)&&i.isWalkableAt(n,r+l)&&c.push([n-f,r+l]),!i.isWalkableAt(n,r-l)&&i.isWalkableAt(n+f,r)&&c.push([n+f,r-l])):f===0?i.isWalkableAt(n,r+l)&&(i.isWalkableAt(n,r+l)&&c.push([n,r+l]),i.isWalkableAt(n+1,r)||c.push([n+1,r+l]),i.isWalkableAt(n-1,r)||c.push([n-1,r+l])):i.isWalkableAt(n+f,r)&&(i.isWalkableAt(n+f,r)&&c.push([n+f,r]),i.isWalkableAt(n,r+1)||c.push([n+f,r+1]),i.isWalkableAt(n,r-1)||c.push([n+f,r-1]));else{h=i.getNeighbors(e,!0);for(d=0,v=h.length;d<v;++d)p=h[d],c.push([p.x,p.y])}return c},t.exports=a}),e.define(\"/PathFinding.js\",function(e,t,n,r,i){t.exports={Node:e(\"./core/Node\"),Grid:e(\"./core/Grid\"),Heap:e(\"./core/Heap\"),Util:e(\"./core/Util\"),Heuristic:e(\"./core/Heuristic\"),AStarFinder:e(\"./finders/AStarFinder\"),BestFirstFinder:e(\"./finders/BestFirstFinder\"),BreadthFirstFinder:e(\"./finders/BreadthFirstFinder\"),DijkstraFinder:e(\"./finders/DijkstraFinder\"),BiAStarFinder:e(\"./finders/BiAStarFinder\"),BiBestFirstFinder:e(\"./finders/BiBestFirstFinder\"),BiBreadthFirstFinder:e(\"./finders/BiBreadthFirstFinder\"),BiDijkstraFinder:e(\"./finders/BiDijkstraFinder\"),JumpPointFinder:e(\"./finders/JumpPointFinder\")}}),e(\"/PathFinding.js\"),e(\"/PathFinding\")}()"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./src/lib/raphael.exec.js":
/*!***********************************************************!*\
  !*** ./node_modules/raw-loader!./src/lib/raphael.exec.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\n\n//  \\\\//  Raphal 2.1.0 - JavaScript Vector Library                           \\\\\n//  \\\\\n//  Copyright  2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)     \\\\\n//  Copyright  2008-2012 Sencha Labs (http://sencha.com)               \\\\\n//  \\\\\n//  Licensed under the MIT (http://raphaeljs.com/license.html) license. \\\\\n//  \\\\\n\n//  \\\\\n//  Eve 0.3.4 - JavaScript Events Library                                                 \\\\\n//  \\\\\n//  Copyright (c) 2008-2011 Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)           \\\\\n//  Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.  \\\\\n//  \\\\\n\n// THIS FILES IS PATCHED BY FREEGROUP\n// you can't replace this file with a new version without migrate all changes\n// tagged with \"FREEGROUP\"\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//  \\\\\n//  Eve 0.4.2 - JavaScript Events Library                       \\\\\n//  \\\\\n//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\\\\n//  \\\\\n(function (glob, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(\"eve\", function() {\n            return factory();\n        });\n    } else if (typeof exports === \"object\") {\n        module.exports = factory();\n    } else {\n        glob.eve = factory();\n    }\n}(this, function(){\n    var version = \"0.4.2\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        wildcard = \"*\",\n        fun = function () {},\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     > Arguments\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners\n     \\*/\n        eve = function (name, scope) {\n            name = String(name);\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out.length ? out : null;\n        };\n    // Undocumented. Debug only.\n    eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     > Arguments\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n     \\*/\n    eve.listeners = function (name) {\n        var names = name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n\n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards `*` for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt()` function will be called before `eatIt()`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.\n     \\*/\n    eve.on = function (name, f) {\n        name = String(name);\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = name.split(separator),\n            e = events;\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            e = e.n;\n            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n        }\n        e.f = e.f || [];\n        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n            return fun;\n        }\n        e.f.push(f);\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     > Arguments\n     - event (string) event name\n     - varargs () and any other arguments\n     = (function) possible event handler function\n     \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n     \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     > Arguments\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current events name contains `subname`\n     \\*/\n    eve.nt = function (subname) {\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\n        }\n        return current_event;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n     \\*/\n    eve.nts = function () {\n        return current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n     \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = name.split(separator),\n            e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n     \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.unbind(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n     \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n\n    return eve;\n}));\n\n//  \\\\\n//  Raphal 2.1.4 - JavaScript Vector Library                       \\\\\n//  \\\\\n//  Core Module                                                         \\\\\n//  \\\\\n//  Licensed under the MIT (http://raphaeljs.com/license.html) license. \\\\\n//  \\\\\n\n(function (glob, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(\"raphael.core\", [\"eve\"], function(eve) {\n            return factory(eve);\n        });\n    } else if (typeof exports === \"object\") {\n        module.exports = factory(require(\"eve\"));\n    } else {\n        glob.Raphael = factory(glob.eve);\n    }\n}(this, function (eve) {\n    /*\\\n     * Raphael\n     [ method ]\n     **\n     * Creates a canvas object on which to draw.\n     * You must do this first, as all future calls to drawing methods\n     * from this instance will be bound to this canvas.\n     > Parameters\n     **\n     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\n     - width (number)\n     - height (number)\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n     * or\n     - x (number)\n     - y (number)\n     - width (number)\n     - height (number)\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n     * or\n     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n     * or\n     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eves DOMLoad event. In this case method returns `undefined`.\n     = (object) @Paper\n     > Usage\n     | // Each of the following examples create a canvas\n     | // that is 320px wide by 200px high.\n     | // Canvas is created at the viewports 10,50 coordinate.\n     | var paper = Raphael(10, 50, 320, 200);\n     | // Canvas is created at the top left corner of the #notepad element\n     | // (or its top right corner in dir=\"rtl\" elements)\n     | var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\n     | // Same as above\n     | var paper = Raphael(\"notepad\", 320, 200);\n     | // Image dump\n     | var set = Raphael([\"notepad\", 320, 200, {\n     |     type: \"rect\",\n     |     x: 10,\n     |     y: 10,\n     |     width: 25,\n     |     height: 25,\n     |     stroke: \"#f00\"\n     | }, {\n     |     type: \"text\",\n     |     x: 30,\n     |     y: 40,\n     |     text: \"Dump\"\n     | }]);\n     \\*/\n    function R(first) {\n        if (R.is(first, \"function\")) {\n            return loaded ? first() : eve.on(\"raphael.DOMload\", first);\n        } else if (R.is(first, array)) {\n            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);\n        } else {\n            var args = Array.prototype.slice.call(arguments, 0);\n            if (R.is(args[args.length - 1], \"function\")) {\n                var f = args.pop();\n                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(\"raphael.DOMload\", function () {\n                    f.call(R._engine.create[apply](R, args));\n                });\n            } else {\n                return R._engine.create[apply](R, arguments);\n            }\n        }\n    }\n    R.version = \"2.1.4\";\n    R.eve = eve;\n    var loaded,\n        separator = /[, ]+/,\n        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},\n        formatrg = /\\{(\\d+)\\}/g,\n        proto = \"prototype\",\n        has = \"hasOwnProperty\",\n        g = {\n            doc: document,\n            win: window\n        },\n        oldRaphael = {\n            was: Object.prototype[has].call(g.win, \"Raphael\"),\n            is: g.win.Raphael\n        },\n        Paper = function () {\n            /*\\\n             * Paper.ca\n             [ property (object) ]\n             **\n             * Shortcut for @Paper.customAttributes\n             \\*/\n            /*\\\n             * Paper.customAttributes\n             [ property (object) ]\n             **\n             * If you have a set of attributes that you would like to represent\n             * as a function of some number you can do it easily with custom attributes:\n             > Usage\n             | paper.customAttributes.hue = function (num) {\n             |     num = num % 1;\n             |     return {fill: \"hsb(\" + num + \", 0.75, 1)\"};\n             | };\n             | // Custom attribute hue will change fill\n             | // to be given hue with fixed saturation and brightness.\n             | // Now you can use it like this:\n             | var c = paper.circle(10, 10, 10).attr({hue: .45});\n             | // or even like this:\n             | c.animate({hue: 1}, 1e3);\n             |\n             | // You could also create custom attribute\n             | // with multiple parameters:\n             | paper.customAttributes.hsb = function (h, s, b) {\n             |     return {fill: \"hsb(\" + [h, s, b].join(\",\") + \")\"};\n             | };\n             | c.attr({hsb: \"0.5 .8 1\"});\n             | c.animate({hsb: [1, 0, 0.5]}, 1e3);\n             \\*/\n            this.ca = this.customAttributes = {};\n        },\n        paperproto,\n        appendChild = \"appendChild\",\n        apply = \"apply\",\n        concat = \"concat\",\n        supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test\n        E = \"\",\n        S = \" \",\n        Str = String,\n        split = \"split\",\n        events = \"click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel\"[split](S),\n        touchMap = {\n            mousedown: \"touchstart\",\n            mousemove: \"touchmove\",\n            mouseup: \"touchend\"\n        },\n        lowerCase = Str.prototype.toLowerCase,\n        math = Math,\n        mmax = math.max,\n        mmin = math.min,\n        abs = math.abs,\n        pow = math.pow,\n        PI = math.PI,\n        nu = \"number\",\n        string = \"string\",\n        array = \"array\",\n        toString = \"toString\",\n        fillString = \"fill\",\n        objectToString = Object.prototype.toString,\n        paper = {},\n        push = \"push\",\n        ISURL = R._ISURL = /^url\\(['\"]?(.+?)['\"]?\\)$/i,\n        colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i,\n        isnan = {\"NaN\": 1, \"Infinity\": 1, \"-Infinity\": 1},\n        bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n        round = math.round,\n        setAttribute = \"setAttribute\",\n        toFloat = parseFloat,\n        toInt = parseInt,\n        upperCase = Str.prototype.toUpperCase,\n        availableAttrs = R._availableAttrs = {\n            \"arrow-end\": \"none\",\n            \"arrow-start\": \"none\",\n            blur: 0,\n            \"clip-rect\": \"0 0 1e9 1e9\",\n            cursor: \"default\",\n            cx: 0,\n            cy: 0,\n            fill: \"#fff\",\n            \"fill-opacity\": 1,\n            font: '10px \"Arial\"',\n            \"font-family\": '\"Arial\"',\n            \"font-size\": \"10\",\n            \"font-style\": \"normal\",\n            \"font-weight\": 400,\n            gradient: 0,\n            height: 0,\n            href: \"http://raphaeljs.com/\",\n            \"letter-spacing\": 0,\n            opacity: 1,\n            path: \"M0,0\",\n            r: 0,\n            rx: 0,\n            ry: 0,\n            src: \"\",\n            stroke: \"#000\",\n            \"stroke-dasharray\": \"\",\n            \"stroke-linecap\": \"butt\",\n            \"stroke-linejoin\": \"butt\",\n            \"stroke-miterlimit\": 0,\n            \"stroke-opacity\": 1,\n            \"stroke-width\": 1,\n            \"stroke-scale\": false, // FreeGroup: draw2d enhancement\n            target: \"_blank\",\n            \"text-anchor\": \"middle\",\n            title: \"Raphael\",\n            transform: \"\",\n            width: 0,\n            x: 0,\n            y: 0\n        },\n        availableAnimAttrs = R._availableAnimAttrs = {\n            blur: nu,\n            \"clip-rect\": \"csv\",\n            cx: nu,\n            cy: nu,\n            fill: \"colour\",\n            \"fill-opacity\": nu,\n            \"font-size\": nu,\n            height: nu,\n            opacity: nu,\n            path: \"path\",\n            r: nu,\n            rx: nu,\n            ry: nu,\n            stroke: \"colour\",\n            \"stroke-opacity\": nu,\n            \"stroke-width\": nu,\n            transform: \"transform\",\n            width: nu,\n            x: nu,\n            y: nu\n        },\n        whitespace = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]/g,\n        commaSpaces = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/,\n        hsrg = {hs: 1, rg: 1},\n        p2s = /,?([achlmqrstvxz]),?/gi,\n        pathCommand = /([achlmrqstvz])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n        tCommand = /([rstm])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n        pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/ig,\n        radial_gradient = R._radial_gradient = /^r(?:\\(([^,]+?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*([^\\)]+?)\\))?/,\n        eldata = {},\n        sortByKey = function (a, b) {\n            return a.key - b.key;\n        },\n        sortByNumber = function (a, b) {\n            return toFloat(a) - toFloat(b);\n        },\n        fun = function () {},\n        pipe = function (x) {\n            return x;\n        },\n        rectPath = R._rectPath = function (x, y, w, h, r) {\n            if (r) {\n                return [[\"M\", x + r, y], [\"l\", w - r * 2, 0], [\"a\", r, r, 0, 0, 1, r, r], [\"l\", 0, h - r * 2], [\"a\", r, r, 0, 0, 1, -r, r], [\"l\", r * 2 - w, 0], [\"a\", r, r, 0, 0, 1, -r, -r], [\"l\", 0, r * 2 - h], [\"a\", r, r, 0, 0, 1, r, -r], [\"z\"]];\n            }\n            return [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n        },\n        ellipsePath = function (x, y, rx, ry) {\n            if (ry == null) {\n                ry = rx;\n            }\n            return [[\"M\", x, y], [\"m\", 0, -ry], [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry], [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry], [\"z\"]];\n        },\n        getPath = R._getPath = {\n            path: function (el) {\n                return el.attr(\"path\");\n            },\n            circle: function (el) {\n                var a = el.attrs;\n                return ellipsePath(a.cx, a.cy, a.r);\n            },\n            ellipse: function (el) {\n                var a = el.attrs;\n                return ellipsePath(a.cx, a.cy, a.rx, a.ry);\n            },\n            rect: function (el) {\n                var a = el.attrs;\n                return rectPath(a.x, a.y, a.width, a.height, a.r);\n            },\n            image: function (el) {\n                var a = el.attrs;\n                return rectPath(a.x, a.y, a.width, a.height);\n            },\n            text: function (el) {\n                var bbox = el._getBBox();\n                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n            },\n            set : function(el) {\n                var bbox = el._getBBox();\n                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n            }\n        },\n    /*\\\n     * Raphael.mapPath\n     [ method ]\n     **\n     * Transform the path string with given matrix.\n     > Parameters\n     - path (string) path string\n     - matrix (object) see @Matrix\n     = (string) transformed path string\n     \\*/\n        mapPath = R.mapPath = function (path, matrix) {\n            if (!matrix) {\n                return path;\n            }\n            var x, y, i, j, ii, jj, pathi;\n            path = path2curve(path);\n            for (i = 0, ii = path.length; i < ii; i++) {\n                pathi = path[i];\n                for (j = 1, jj = pathi.length; j < jj; j += 2) {\n                    x = matrix.x(pathi[j], pathi[j + 1]);\n                    y = matrix.y(pathi[j], pathi[j + 1]);\n                    pathi[j] = x;\n                    pathi[j + 1] = y;\n                }\n            }\n            return path;\n        };\n\n    R._g = g;\n    /*\\\n     * Raphael.type\n     [ property (string) ]\n     **\n     * Can be SVG, VML or empty, depending on browser support.\n     \\*/\n    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\") ? \"SVG\" : \"VML\");\n    if (R.type == \"VML\") {\n        var d = g.doc.createElement(\"div\"),\n            b;\n        d.innerHTML = '<v:shape adj=\"1\"/>';\n        b = d.firstChild;\n        b.style.behavior = \"url(#default#VML)\";\n        if (!(b && typeof b.adj == \"object\")) {\n            return (R.type = E);\n        }\n        d = null;\n    }\n    /*\\\n     * Raphael.svg\n     [ property (boolean) ]\n     **\n     * `true` if browser supports SVG.\n     \\*/\n    /*\\\n     * Raphael.vml\n     [ property (boolean) ]\n     **\n     * `true` if browser supports VML.\n     \\*/\n    R.svg = !(R.vml = R.type == \"VML\");\n    R._Paper = Paper;\n    /*\\\n     * Raphael.fn\n     [ property (object) ]\n     **\n     * You can add your own method to the canvas. For example if you want to draw a pie chart,\n     * you can create your own pie chart function and ship it as a Raphal plugin. To do this\n     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a\n     * Raphal instance is created, otherwise it will take no effect. Please note that the\n     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to\n     * ensure any namespacing ensures proper context.\n     > Usage\n     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {\n     |     return this.path( ... );\n     | };\n     | // or create namespace\n     | Raphael.fn.mystuff = {\n     |     arrow: function () {},\n     |     star: function () {},\n     |     // etc\n     | };\n     | var paper = Raphael(10, 10, 630, 480);\n     | // then use it\n     | paper.arrow(10, 10, 30, 30, 5).attr({fill: \"#f00\"});\n     | paper.mystuff.arrow();\n     | paper.mystuff.star();\n     \\*/\n    R.fn = paperproto = Paper.prototype = R.prototype;\n    R._id = 0;\n    R._oid = 0;\n    /*\\\n     * Raphael.is\n     [ method ]\n     **\n     * Handful of replacements for `typeof` operator.\n     > Parameters\n     - o () any object or primitive\n     - type (string) name of the type, i.e. string, function, number, etc.\n     = (boolean) is given value is of given type\n     \\*/\n    R.is = function (o, type) {\n        type = lowerCase.call(type);\n        if (type == \"finite\") {\n            return !isnan[has](+o);\n        }\n        if (type == \"array\") {\n            return o instanceof Array;\n        }\n        return  (type == \"null\" && o === null) ||\n            (type == typeof o && o !== null) ||\n            (type == \"object\" && o === Object(o)) ||\n            (type == \"array\" && Array.isArray && Array.isArray(o)) ||\n            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n    };\n\n    function clone(obj) {\n        if (typeof obj == \"function\" || Object(obj) !== obj) {\n            return obj;\n        }\n        var res = new obj.constructor;\n        for (var key in obj) if (obj[has](key)) {\n            res[key] = clone(obj[key]);\n        }\n        return res;\n    }\n\n    /*\\\n     * Raphael.angle\n     [ method ]\n     **\n     * Returns angle between two or three points\n     > Parameters\n     - x1 (number) x coord of first point\n     - y1 (number) y coord of first point\n     - x2 (number) x coord of second point\n     - y2 (number) y coord of second point\n     - x3 (number) #optional x coord of third point\n     - y3 (number) #optional y coord of third point\n     = (number) angle in degrees.\n     \\*/\n    R.angle = function (x1, y1, x2, y2, x3, y3) {\n        if (x3 == null) {\n            var x = x1 - x2,\n                y = y1 - y2;\n            if (!x && !y) {\n                return 0;\n            }\n            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n        } else {\n            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);\n        }\n    };\n    /*\\\n     * Raphael.rad\n     [ method ]\n     **\n     * Transform angle to radians\n     > Parameters\n     - deg (number) angle in degrees\n     = (number) angle in radians.\n     \\*/\n    R.rad = function (deg) {\n        return deg % 360 * PI / 180;\n    };\n    /*\\\n     * Raphael.deg\n     [ method ]\n     **\n     * Transform angle to degrees\n     > Parameters\n     - rad (number) angle in radians\n     = (number) angle in degrees.\n     \\*/\n    R.deg = function (rad) {\n        return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;\n    };\n    /*\\\n     * Raphael.snapTo\n     [ method ]\n     **\n     * Snaps given value to given grid.\n     > Parameters\n     - values (array|number) given array of values or step of the grid\n     - value (number) value to adjust\n     - tolerance (number) #optional tolerance for snapping. Default is `10`.\n     = (number) adjusted value.\n     \\*/\n    R.snapTo = function (values, value, tolerance) {\n        tolerance = R.is(tolerance, \"finite\") ? tolerance : 10;\n        if (R.is(values, array)) {\n            var i = values.length;\n            while (i--) if (abs(values[i] - value) <= tolerance) {\n                return values[i];\n            }\n        } else {\n            values = +values;\n            var rem = value % values;\n            if (rem < tolerance) {\n                return value - rem;\n            }\n            if (rem > values - tolerance) {\n                return value - rem + values;\n            }\n        }\n        return value;\n    };\n\n    /*\\\n     * Raphael.createUUID\n     [ method ]\n     **\n     * Returns RFC4122, version 4 ID\n     \\*/\n    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {\n        return function () {\n            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(uuidRegEx, uuidReplacer).toUpperCase();\n        };\n    })(/[xy]/g, function (c) {\n        var r = math.random() * 16 | 0,\n            v = c == \"x\" ? r : (r & 3 | 8);\n        return v.toString(16);\n    });\n\n    /*\\\n     * Raphael.setWindow\n     [ method ]\n     **\n     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.\n     > Parameters\n     - newwin (window) new window object\n     \\*/\n    R.setWindow = function (newwin) {\n        eve(\"raphael.setWindow\", R, g.win, newwin);\n        g.win = newwin;\n        g.doc = g.win.document;\n        if (R._engine.initWin) {\n            R._engine.initWin(g.win);\n        }\n    };\n    var toHex = function (color) {\n            if (R.vml) {\n                // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/\n                var trim = /^\\s+|\\s+$/g;\n                var bod;\n                try {\n                    var docum = new ActiveXObject(\"htmlfile\");\n                    docum.write(\"<body>\");\n                    docum.close();\n                    bod = docum.body;\n                } catch(e) {\n                    bod = createPopup().document.body;\n                }\n                var range = bod.createTextRange();\n                toHex = cacher(function (color) {\n                    try {\n                        bod.style.color = Str(color).replace(trim, E);\n                        var value = range.queryCommandValue(\"ForeColor\");\n                        value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\n                        return \"#\" + (\"000000\" + value.toString(16)).slice(-6);\n                    } catch(e) {\n                        return \"none\";\n                    }\n                });\n            } else {\n                var i = g.doc.createElement(\"i\");\n                i.title = \"Rapha\\xebl Colour Picker\";\n                i.style.display = \"none\";\n                g.doc.body.appendChild(i);\n                toHex = cacher(function (color) {\n                    i.style.color = color;\n                    return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n                });\n            }\n            return toHex(color);\n        },\n        hsbtoString = function () {\n            return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n        },\n        hsltoString = function () {\n            return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n        },\n        rgbtoString = function () {\n            return this.hex;\n        },\n        prepareRGB = function (r, g, b) {\n            if (g == null && R.is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n                b = r.b;\n                g = r.g;\n                r = r.r;\n            }\n            if (g == null && R.is(r, string)) {\n                var clr = R.getRGB(r);\n                r = clr.r;\n                g = clr.g;\n                b = clr.b;\n            }\n            if (r > 1 || g > 1 || b > 1) {\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n\n            return [r, g, b];\n        },\n        packageRGB = function (r, g, b, o) {\n            r *= 255;\n            g *= 255;\n            b *= 255;\n            var rgb = {\n                r: r,\n                g: g,\n                b: b,\n                hex: R.rgb(r, g, b),\n                toString: rgbtoString\n            };\n            R.is(o, \"finite\") && (rgb.opacity = o);\n            return rgb;\n        };\n\n    /*\\\n     * Raphael.color\n     [ method ]\n     **\n     * Parses the color string and returns object with all values for the given color.\n     > Parameters\n     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)\n     = (object) Combined RGB & HSB object in format:\n     o {\n     o     r (number) red,\n     o     g (number) green,\n     o     b (number) blue,\n     o     hex (string) color in HTML/CSS format: #,\n     o     error (boolean) `true` if string cant be parsed,\n     o     h (number) hue,\n     o     s (number) saturation,\n     o     v (number) value (brightness),\n     o     l (number) lightness\n     o }\n     \\*/\n    R.color = function (clr) {\n        var rgb;\n        if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n            rgb = R.hsb2rgb(clr);\n            clr.r = rgb.r;\n            clr.g = rgb.g;\n            clr.b = rgb.b;\n            clr.hex = rgb.hex;\n        } else if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n            rgb = R.hsl2rgb(clr);\n            clr.r = rgb.r;\n            clr.g = rgb.g;\n            clr.b = rgb.b;\n            clr.hex = rgb.hex;\n        } else {\n            if (R.is(clr, \"string\")) {\n                clr = R.getRGB(clr);\n            }\n            if (R.is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr) {\n                rgb = R.rgb2hsl(clr);\n                clr.h = rgb.h;\n                clr.s = rgb.s;\n                clr.l = rgb.l;\n                rgb = R.rgb2hsb(clr);\n                clr.v = rgb.b;\n            } else {\n                clr = {hex: \"none\"};\n                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n            }\n        }\n        clr.toString = rgbtoString;\n        return clr;\n    };\n    /*\\\n     * Raphael.hsb2rgb\n     [ method ]\n     **\n     * Converts HSB values to RGB object.\n     > Parameters\n     - h (number) hue\n     - s (number) saturation\n     - v (number) value or brightness\n     = (object) RGB object in format:\n     o {\n     o     r (number) red,\n     o     g (number) green,\n     o     b (number) blue,\n     o     hex (string) color in HTML/CSS format: #\n     o }\n     \\*/\n    R.hsb2rgb = function (h, s, v, o) {\n        if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n            v = h.b;\n            s = h.s;\n            o = h.o;\n            h = h.h;\n        }\n        h *= 360;\n        var R, G, B, X, C;\n        h = (h % 360) / 60;\n        C = v * s;\n        X = C * (1 - abs(h % 2 - 1));\n        R = G = B = v - C;\n\n        h = ~~h;\n        R += [C, X, 0, 0, X, C][h];\n        G += [X, C, C, X, 0, 0][h];\n        B += [0, 0, X, C, C, X][h];\n        return packageRGB(R, G, B, o);\n    };\n    /*\\\n     * Raphael.hsl2rgb\n     [ method ]\n     **\n     * Converts HSL values to RGB object.\n     > Parameters\n     - h (number) hue\n     - s (number) saturation\n     - l (number) luminosity\n     = (object) RGB object in format:\n     o {\n     o     r (number) red,\n     o     g (number) green,\n     o     b (number) blue,\n     o     hex (string) color in HTML/CSS format: #\n     o }\n     \\*/\n    R.hsl2rgb = function (h, s, l, o) {\n        if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n            l = h.l;\n            s = h.s;\n            h = h.h;\n        }\n        if (h > 1 || s > 1 || l > 1) {\n            h /= 360;\n            s /= 100;\n            l /= 100;\n        }\n        h *= 360;\n        var R, G, B, X, C;\n        h = (h % 360) / 60;\n        C = 2 * s * (l < .5 ? l : 1 - l);\n        X = C * (1 - abs(h % 2 - 1));\n        R = G = B = l - C / 2;\n\n        h = ~~h;\n        R += [C, X, 0, 0, X, C][h];\n        G += [X, C, C, X, 0, 0][h];\n        B += [0, 0, X, C, C, X][h];\n        return packageRGB(R, G, B, o);\n    };\n    /*\\\n     * Raphael.rgb2hsb\n     [ method ]\n     **\n     * Converts RGB values to HSB object.\n     > Parameters\n     - r (number) red\n     - g (number) green\n     - b (number) blue\n     = (object) HSB object in format:\n     o {\n     o     h (number) hue\n     o     s (number) saturation\n     o     b (number) brightness\n     o }\n     \\*/\n    R.rgb2hsb = function (r, g, b) {\n        b = prepareRGB(r, g, b);\n        r = b[0];\n        g = b[1];\n        b = b[2];\n\n        var H, S, V, C;\n        V = mmax(r, g, b);\n        C = V - mmin(r, g, b);\n        H = (C == 0 ? null :\n                V == r ? (g - b) / C :\n                    V == g ? (b - r) / C + 2 :\n                    (r - g) / C + 4\n        );\n        H = ((H + 360) % 6) * 60 / 360;\n        S = C == 0 ? 0 : C / V;\n        return {h: H, s: S, b: V, toString: hsbtoString};\n    };\n    /*\\\n     * Raphael.rgb2hsl\n     [ method ]\n     **\n     * Converts RGB values to HSL object.\n     > Parameters\n     - r (number) red\n     - g (number) green\n     - b (number) blue\n     = (object) HSL object in format:\n     o {\n     o     h (number) hue\n     o     s (number) saturation\n     o     l (number) luminosity\n     o }\n     \\*/\n    R.rgb2hsl = function (r, g, b) {\n        b = prepareRGB(r, g, b);\n        r = b[0];\n        g = b[1];\n        b = b[2];\n\n        var H, S, L, M, m, C;\n        M = mmax(r, g, b);\n        m = mmin(r, g, b);\n        C = M - m;\n        H = (C == 0 ? null :\n            M == r ? (g - b) / C :\n                M == g ? (b - r) / C + 2 :\n                (r - g) / C + 4);\n        H = ((H + 360) % 6) * 60 / 360;\n        L = (M + m) / 2;\n        S = (C == 0 ? 0 :\n            L < .5 ? C / (2 * L) :\n            C / (2 - 2 * L));\n        return {h: H, s: S, l: L, toString: hsltoString};\n    };\n    R._path2string = function () {\n        return this.join(\",\").replace(p2s, \"$1\");\n    };\n    function repush(array, item) {\n        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n            return array.push(array.splice(i, 1)[0]);\n        }\n    }\n    function cacher(f, scope, postprocessor) {\n        function newf() {\n            var arg = Array.prototype.slice.call(arguments, 0),\n                args = arg.join(\"\\u2400\"),\n                cache = newf.cache = newf.cache || {},\n                count = newf.count = newf.count || [];\n            if (cache[has](args)) {\n                repush(count, args);\n                return postprocessor ? postprocessor(cache[args]) : cache[args];\n            }\n            count.length >= 1e3 && delete cache[count.shift()];\n            count.push(args);\n            cache[args] = f[apply](scope, arg);\n            return postprocessor ? postprocessor(cache[args]) : cache[args];\n        }\n        return newf;\n    }\n\n    var preload = R._preload = function (src, f) {\n        var img = g.doc.createElement(\"img\");\n        img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n        img.onload = function () {\n            f.call(this);\n            this.onload = null;\n            g.doc.body.removeChild(this);\n        };\n        img.onerror = function () {\n            g.doc.body.removeChild(this);\n        };\n        g.doc.body.appendChild(img);\n        img.src = src;\n    };\n\n    function clrToString() {\n        return this.hex;\n    }\n\n    /*\\\n     * Raphael.getRGB\n     [ method ]\n     **\n     * Parses colour string as RGB object\n     > Parameters\n     - colour (string) colour string in one of formats:\n     # <ul>\n     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>\n     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>\n     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n     #     <li>hsb(%, %, %)  same as above, but in %</li>\n     #     <li>hsl(, , )  same as hsb</li>\n     #     <li>hsl(%, %, %)  same as hsb</li>\n     # </ul>\n     = (object) RGB object in format:\n     o {\n     o     r (number) red,\n     o     g (number) green,\n     o     b (number) blue\n     o     hex (string) color in HTML/CSS format: #,\n     o     error (boolean) true if string cant be parsed\n     o }\n     \\*/\n    R.getRGB = cacher(function (colour) {\n        if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n            return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: clrToString};\n        }\n        if (colour == \"none\") {\n            return {r: -1, g: -1, b: -1, hex: \"none\", toString: clrToString};\n        }\n        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n        var res,\n            red,\n            green,\n            blue,\n            opacity,\n            t,\n            values,\n            rgb = colour.match(colourRegExp);\n        if (rgb) {\n            if (rgb[2]) {\n                blue = toInt(rgb[2].substring(5), 16);\n                green = toInt(rgb[2].substring(3, 5), 16);\n                red = toInt(rgb[2].substring(1, 3), 16);\n            }\n            if (rgb[3]) {\n                blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n                green = toInt((t = rgb[3].charAt(2)) + t, 16);\n                red = toInt((t = rgb[3].charAt(1)) + t, 16);\n            }\n            if (rgb[4]) {\n                values = rgb[4][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            }\n            if (rgb[5]) {\n                values = rgb[5][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n                rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n                return R.hsb2rgb(red, green, blue, opacity);\n            }\n            if (rgb[6]) {\n                values = rgb[6][split](commaSpaces);\n                red = toFloat(values[0]);\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\n                green = toFloat(values[1]);\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\n                blue = toFloat(values[2]);\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n                rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n                return R.hsl2rgb(red, green, blue, opacity);\n            }\n            rgb = {r: red, g: green, b: blue, toString: clrToString};\n            rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n            R.is(opacity, \"finite\") && (rgb.opacity = opacity);\n            return rgb;\n        }\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: clrToString};\n    }, R);\n    /*\\\n     * Raphael.hsb\n     [ method ]\n     **\n     * Converts HSB values to hex representation of the colour.\n     > Parameters\n     - h (number) hue\n     - s (number) saturation\n     - b (number) value or brightness\n     = (string) hex representation of the colour.\n     \\*/\n    R.hsb = cacher(function (h, s, b) {\n        return R.hsb2rgb(h, s, b).hex;\n    });\n    /*\\\n     * Raphael.hsl\n     [ method ]\n     **\n     * Converts HSL values to hex representation of the colour.\n     > Parameters\n     - h (number) hue\n     - s (number) saturation\n     - l (number) luminosity\n     = (string) hex representation of the colour.\n     \\*/\n    R.hsl = cacher(function (h, s, l) {\n        return R.hsl2rgb(h, s, l).hex;\n    });\n    /*\\\n     * Raphael.rgb\n     [ method ]\n     **\n     * Converts RGB values to hex representation of the colour.\n     > Parameters\n     - r (number) red\n     - g (number) green\n     - b (number) blue\n     = (string) hex representation of the colour.\n     \\*/\n    R.rgb = cacher(function (r, g, b) {\n        function round(x) { return (x + 0.5) | 0; }\n        return \"#\" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);\n    });\n    /*\\\n     * Raphael.getColor\n     [ method ]\n     **\n     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset\n     > Parameters\n     - value (number) #optional brightness, default is `0.75`\n     = (string) hex representation of the colour.\n     \\*/\n    R.getColor = function (value) {\n        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},\n            rgb = this.hsb2rgb(start.h, start.s, start.b);\n        start.h += .075;\n        if (start.h > 1) {\n            start.h = 0;\n            start.s -= .2;\n            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});\n        }\n        return rgb.hex;\n    };\n    /*\\\n     * Raphael.getColor.reset\n     [ method ]\n     **\n     * Resets spectrum position for @Raphael.getColor back to red.\n     \\*/\n    R.getColor.reset = function () {\n        delete this.start;\n    };\n\n    // http://schepers.cc/getting-to-the-point\n    function catmullRom2bezier(crp, z) {\n        var d = [];\n        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n            var p = [\n                {x: +crp[i - 2], y: +crp[i - 1]},\n                {x: +crp[i],     y: +crp[i + 1]},\n                {x: +crp[i + 2], y: +crp[i + 3]},\n                {x: +crp[i + 4], y: +crp[i + 5]}\n            ];\n            if (z) {\n                if (!i) {\n                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n                } else if (iLen - 4 == i) {\n                    p[3] = {x: +crp[0], y: +crp[1]};\n                } else if (iLen - 2 == i) {\n                    p[2] = {x: +crp[0], y: +crp[1]};\n                    p[3] = {x: +crp[2], y: +crp[3]};\n                }\n            } else {\n                if (iLen - 4 == i) {\n                    p[3] = p[2];\n                } else if (!i) {\n                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n                }\n            }\n            d.push([\"C\",\n                (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n                (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n                (p[1].x + 6 * p[2].x - p[3].x) / 6,\n                (p[1].y + 6*p[2].y - p[3].y) / 6,\n                p[2].x,\n                p[2].y\n            ]);\n        }\n\n        return d;\n    }\n    /*\\\n     * Raphael.parsePathString\n     [ method ]\n     **\n     * Utility method\n     **\n     * Parses given path string into an array of arrays of path segments.\n     > Parameters\n     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)\n     = (array) array of segments.\n     \\*/\n    R.parsePathString = function (pathString) {\n        if (!pathString) {\n            return null;\n        }\n        var pth = paths(pathString);\n        if (pth.arr) {\n            return pathClone(pth.arr);\n        }\n\n        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},\n            data = [];\n        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption\n            data = pathClone(pathString);\n        }\n        if (!data.length) {\n            Str(pathString).replace(pathCommand, function (a, b, c) {\n                var params = [],\n                    name = b.toLowerCase();\n                c.replace(pathValues, function (a, b) {\n                    b && params.push(+b);\n                });\n                if (name == \"m\" && params.length > 2) {\n                    data.push([b][concat](params.splice(0, 2)));\n                    name = \"l\";\n                    b = b == \"m\" ? \"l\" : \"L\";\n                }\n                if (name == \"r\") {\n                    data.push([b][concat](params));\n                } else while (params.length >= paramCounts[name]) {\n                    data.push([b][concat](params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) {\n                        break;\n                    }\n                }\n            });\n        }\n        data.toString = R._path2string;\n        pth.arr = pathClone(data);\n        return data;\n    };\n    /*\\\n     * Raphael.parseTransformString\n     [ method ]\n     **\n     * Utility method\n     **\n     * Parses given path string into an array of transformations.\n     > Parameters\n     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)\n     = (array) array of transformations.\n     \\*/\n    R.parseTransformString = cacher(function (TString) {\n        if (!TString) {\n            return null;\n        }\n        var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n            data = [];\n        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption\n            data = pathClone(TString);\n        }\n        if (!data.length) {\n            Str(TString).replace(tCommand, function (a, b, c) {\n                var params = [],\n                    name = lowerCase.call(b);\n                c.replace(pathValues, function (a, b) {\n                    b && params.push(+b);\n                });\n                data.push([b][concat](params));\n            });\n        }\n        data.toString = R._path2string;\n        return data;\n    });\n    // PATHS\n    var paths = function (ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p) if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    };\n    /*\\\n     * Raphael.findDotsAtSegment\n     [ method ]\n     **\n     * Utility method\n     **\n     * Find dot coordinates on the given cubic bezier curve at the given t.\n     > Parameters\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     - t (number) position on the curve (0..1)\n     = (object) point information in format:\n     o {\n     o     x: (number) x coordinate of the point\n     o     y: (number) y coordinate of the point\n     o     m: {\n     o         x: (number) x coordinate of the left anchor\n     o         y: (number) y coordinate of the left anchor\n     o     }\n     o     n: {\n     o         x: (number) x coordinate of the right anchor\n     o         y: (number) y coordinate of the right anchor\n     o     }\n     o     start: {\n     o         x: (number) x coordinate of the start of the curve\n     o         y: (number) y coordinate of the start of the curve\n     o     }\n     o     end: {\n     o         x: (number) x coordinate of the end of the curve\n     o         y: (number) y coordinate of the end of the curve\n     o     }\n     o     alpha: (number) angle of the curve derivative at the point\n     o }\n     \\*/\n    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t,\n            t13 = pow(t1, 3),\n            t12 = pow(t1, 2),\n            t2 = t * t,\n            t3 = t2 * t,\n            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n            ax = t1 * p1x + t * c1x,\n            ay = t1 * p1y + t * c1y,\n            cx = t1 * c2x + t * p2x,\n            cy = t1 * c2y + t * p2y,\n            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n        (mx > nx || my < ny) && (alpha += 180);\n        return {\n            x: x,\n            y: y,\n            m: {x: mx, y: my},\n            n: {x: nx, y: ny},\n            start: {x: ax, y: ay},\n            end: {x: cx, y: cy},\n            alpha: alpha\n        };\n    };\n    /*\\\n     * Raphael.bezierBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Return bounding box of a given cubic bezier curve\n     > Parameters\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     * or\n     - bez (array) array of six points for bezier curve\n     = (object) point information in format:\n     o {\n     o     min: {\n     o         x: (number) x coordinate of the left point\n     o         y: (number) y coordinate of the top point\n     o     }\n     o     max: {\n     o         x: (number) x coordinate of the right point\n     o         y: (number) y coordinate of the bottom point\n     o     }\n     o }\n     \\*/\n    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n        if (!R.is(p1x, \"array\")) {\n            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n        }\n        var bbox = curveDim.apply(null, p1x);\n        return {\n            x: bbox.min.x,\n            y: bbox.min.y,\n            x2: bbox.max.x,\n            y2: bbox.max.y,\n            width: bbox.max.x - bbox.min.x,\n            height: bbox.max.y - bbox.min.y\n        };\n    };\n    /*\\\n     * Raphael.isPointInsideBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside bounding boxes.\n     > Parameters\n     - bbox (string) bounding box\n     - x (string) x coordinate of the point\n     - y (string) y coordinate of the point\n     = (boolean) `true` if point inside\n     \\*/\n    R.isPointInsideBBox = function (bbox, x, y) {\n        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;\n    };\n    /*\\\n     * Raphael.isBBoxIntersect\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if two bounding boxes intersect\n     > Parameters\n     - bbox1 (string) first bounding box\n     - bbox2 (string) second bounding box\n     = (boolean) `true` if they intersect\n     \\*/\n    R.isBBoxIntersect = function (bbox1, bbox2) {\n        var i = R.isPointInsideBBox;\n        return i(bbox2, bbox1.x, bbox1.y)\n            || i(bbox2, bbox1.x2, bbox1.y)\n            || i(bbox2, bbox1.x, bbox1.y2)\n            || i(bbox2, bbox1.x2, bbox1.y2)\n            || i(bbox1, bbox2.x, bbox2.y)\n            || i(bbox1, bbox2.x2, bbox2.y)\n            || i(bbox1, bbox2.x, bbox2.y2)\n            || i(bbox1, bbox2.x2, bbox2.y2)\n            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n    };\n    function base3(t, p1, p2, p3, p4) {\n        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n        return t * t2 - 3 * p1 + 3 * p2;\n    }\n    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n        if (z == null) {\n            z = 1;\n        }\n        z = z > 1 ? 1 : z < 0 ? 0 : z;\n        var z2 = z / 2,\n            n = 12,\n            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],\n            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n            sum = 0;\n        for (var i = 0; i < n; i++) {\n            var ct = z2 * Tvalues[i] + z2,\n                xbase = base3(ct, x1, x2, x3, x4),\n                ybase = base3(ct, y1, y2, y3, y4),\n                comb = xbase * xbase + ybase * ybase;\n            sum += Cvalues[i] * math.sqrt(comb);\n        }\n        return z2 * sum;\n    }\n    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n            return;\n        }\n        var t = 1,\n            step = t / 2,\n            t2 = t - step,\n            l,\n            e = .01;\n        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        while (abs(l - ll) > e) {\n            step /= 2;\n            t2 += (l < ll ? 1 : -1) * step;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        }\n        return t2;\n    }\n    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        if (\n            mmax(x1, x2) < mmin(x3, x4) ||\n            mmin(x1, x2) > mmax(x3, x4) ||\n            mmax(y1, y2) < mmin(y3, y4) ||\n            mmin(y1, y2) > mmax(y3, y4)\n        ) {\n            return;\n        }\n        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n        if (!denominator) {\n            return;\n        }\n        var px = nx / denominator,\n            py = ny / denominator,\n            px2 = +px.toFixed(2),\n            py2 = +py.toFixed(2);\n        if (\n            px2 < +mmin(x1, x2).toFixed(2) ||\n            px2 > +mmax(x1, x2).toFixed(2) ||\n            px2 < +mmin(x3, x4).toFixed(2) ||\n            px2 > +mmax(x3, x4).toFixed(2) ||\n            py2 < +mmin(y1, y2).toFixed(2) ||\n            py2 > +mmax(y1, y2).toFixed(2) ||\n            py2 < +mmin(y3, y4).toFixed(2) ||\n            py2 > +mmax(y3, y4).toFixed(2)\n        ) {\n            return;\n        }\n        return {x: px, y: py};\n    }\n    function inter(bez1, bez2) {\n        return interHelper(bez1, bez2);\n    }\n    function interCount(bez1, bez2) {\n        return interHelper(bez1, bez2, 1);\n    }\n    function interHelper(bez1, bez2, justCount) {\n        var bbox1 = R.bezierBBox(bez1),\n            bbox2 = R.bezierBBox(bez2);\n        if (!R.isBBoxIntersect(bbox1, bbox2)) {\n            return justCount ? 0 : [];\n        }\n        var l1 = bezlen.apply(0, bez1),\n            l2 = bezlen.apply(0, bez2),\n            n1 = mmax(~~(l1 / 5), 1),\n            n2 = mmax(~~(l2 / 5), 1),\n            dots1 = [],\n            dots2 = [],\n            xy = {},\n            res = justCount ? 0 : [];\n        for (var i = 0; i < n1 + 1; i++) {\n            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));\n            dots1.push({x: p.x, y: p.y, t: i / n1});\n        }\n        for (i = 0; i < n2 + 1; i++) {\n            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));\n            dots2.push({x: p.x, y: p.y, t: i / n2});\n        }\n        for (i = 0; i < n1; i++) {\n            for (var j = 0; j < n2; j++) {\n                var di = dots1[i],\n                    di1 = dots1[i + 1],\n                    dj = dots2[j],\n                    dj1 = dots2[j + 1],\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n                if (is) {\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                        continue;\n                    }\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {\n                        if (justCount) {\n                            res++;\n                        } else {\n                            res.push({\n                                x: is.x,\n                                y: is.y,\n                                t1: mmin(t1, 1),\n                                t2: mmin(t2, 1)\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    /*\\\n     * Raphael.pathIntersection\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds intersections of two paths\n     > Parameters\n     - path1 (string) path string\n     - path2 (string) path string\n     = (array) dots of intersection\n     o [\n     o     {\n     o         x: (number) x coordinate of the point\n     o         y: (number) y coordinate of the point\n     o         t1: (number) t value for segment of path1\n     o         t2: (number) t value for segment of path2\n     o         segment1: (number) order number for segment of path1\n     o         segment2: (number) order number for segment of path2\n     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1\n     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2\n     o     }\n     o ]\n     \\*/\n    R.pathIntersection = function (path1, path2) {\n        return interPathHelper(path1, path2);\n    };\n    R.pathIntersectionNumber = function (path1, path2) {\n        return interPathHelper(path1, path2, 1);\n    };\n    function interPathHelper(path1, path2, justCount) {\n        path1 = R._path2curve(path1);\n        path2 = R._path2curve(path2);\n        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n            res = justCount ? 0 : [];\n        for (var i = 0, ii = path1.length; i < ii; i++) {\n            var pi = path1[i];\n            if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n            } else {\n                if (pi[0] == \"C\") {\n                    bez1 = [x1, y1].concat(pi.slice(1));\n                    x1 = bez1[6];\n                    y1 = bez1[7];\n                } else {\n                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n                    x1 = x1m;\n                    y1 = y1m;\n                }\n                for (var j = 0, jj = path2.length; j < jj; j++) {\n                    var pj = path2[j];\n                    if (pj[0] == \"M\") {\n                        x2 = x2m = pj[1];\n                        y2 = y2m = pj[2];\n                    } else {\n                        if (pj[0] == \"C\") {\n                            bez2 = [x2, y2].concat(pj.slice(1));\n                            x2 = bez2[6];\n                            y2 = bez2[7];\n                        } else {\n                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n                            x2 = x2m;\n                            y2 = y2m;\n                        }\n                        var intr = interHelper(bez1, bez2, justCount);\n                        if (justCount) {\n                            res += intr;\n                        } else {\n                            for (var k = 0, kk = intr.length; k < kk; k++) {\n                                intr[k].segment1 = i;\n                                intr[k].segment2 = j;\n                                intr[k].bez1 = bez1;\n                                intr[k].bez2 = bez2;\n                            }\n                            res = res.concat(intr);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    /*\\\n     * Raphael.isPointInsidePath\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside a given closed path.\n     > Parameters\n     - path (string) path string\n     - x (number) x of the point\n     - y (number) y of the point\n     = (boolean) true, if point is inside the path\n     \\*/\n    R.isPointInsidePath = function (path, x, y) {\n        var bbox = R.pathBBox(path);\n        return R.isPointInsideBBox(bbox, x, y) &&\n            interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n    };\n    R._removedFactory = function (methodname) {\n        return function () {\n            eve(\"raphael.log\", null, \"Rapha\\xebl: you are calling to method \\u201c\" + methodname + \"\\u201d of removed object\", methodname);\n        };\n    };\n    /*\\\n     * Raphael.pathBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Return bounding box of a given path\n     > Parameters\n     - path (string) path string\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box\n     o     y: (number) y coordinate of the left top point of the box\n     o     x2: (number) x coordinate of the right bottom point of the box\n     o     y2: (number) y coordinate of the right bottom point of the box\n     o     width: (number) width of the box\n     o     height: (number) height of the box\n     o     cx: (number) x coordinate of the center of the box\n     o     cy: (number) y coordinate of the center of the box\n     o }\n     \\*/\n    var pathDimensions = R.pathBBox = function (path) {\n            var pth = paths(path);\n            if (pth.bbox) {\n                var b= pth.bbox;\n                return {x: b.x, y: b.y, width: b.width, height: b.height, x2: b.x2, y2: b.y2} ; // FREEGROUP FIX!!!!!!\n                // raphael reuse the returned bbox. You must clone it here if the caller need the bbxo for\n                //further calculation\n            }\n            if (!path) {\n                return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};\n            }\n            path = path2curve(path);\n            var x = 0,\n                y = 0,\n                X = [],\n                Y = [],\n                p;\n            for (var i = 0, ii = path.length; i < ii; i++) {\n                p = path[i];\n                if (p[0] == \"M\") {\n                    x = p[1];\n                    y = p[2];\n                    X.push(x);\n                    Y.push(y);\n                } else {\n                    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                    X = X[concat](dim.min.x, dim.max.x);\n                    Y = Y[concat](dim.min.y, dim.max.y);\n                    x = p[5];\n                    y = p[6];\n                }\n            }\n            var xmin = mmin[apply](0, X),\n                ymin = mmin[apply](0, Y),\n                xmax = mmax[apply](0, X),\n                ymax = mmax[apply](0, Y),\n                width = xmax - xmin,\n                height = ymax - ymin,\n                bb = {\n                    x: xmin,\n                    y: ymin,\n                    x2: xmax,\n                    y2: ymax,\n                    width: width,\n                    height: height,\n                    cx: xmin + width / 2,\n                    cy: ymin + height / 2\n                };\n            pth.bbox = clone(bb);\n            return bb;\n        },\n        pathClone = function (pathArray) {\n            var res = clone(pathArray);\n            res.toString = R._path2string;\n            return res;\n        },\n        pathToRelative = R._pathToRelative = function (pathArray) {\n            var pth = paths(pathArray);\n            if (pth.rel) {\n                return pathClone(pth.rel);\n            }\n            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption\n                pathArray = R.parsePathString(pathArray);\n            }\n            var res = [],\n                x = 0,\n                y = 0,\n                mx = 0,\n                my = 0,\n                start = 0;\n            if (pathArray[0][0] == \"M\") {\n                x = pathArray[0][1];\n                y = pathArray[0][2];\n                mx = x;\n                my = y;\n                start++;\n                res.push([\"M\", x, y]);\n            }\n            for (var i = start, ii = pathArray.length; i < ii; i++) {\n                var r = res[i] = [],\n                    pa = pathArray[i];\n                if (pa[0] != lowerCase.call(pa[0])) {\n                    r[0] = lowerCase.call(pa[0]);\n                    switch (r[0]) {\n                        case \"a\":\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +(pa[6] - x).toFixed(3);\n                            r[7] = +(pa[7] - y).toFixed(3);\n                            break;\n                        case \"v\":\n                            r[1] = +(pa[1] - y).toFixed(3);\n                            break;\n                        case \"m\":\n                            mx = pa[1];\n                            my = pa[2];\n                        default:\n                            for (var j = 1, jj = pa.length; j < jj; j++) {\n                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n                            }\n                    }\n                } else {\n                    r = res[i] = [];\n                    if (pa[0] == \"m\") {\n                        mx = pa[1] + x;\n                        my = pa[2] + y;\n                    }\n                    for (var k = 0, kk = pa.length; k < kk; k++) {\n                        res[i][k] = pa[k];\n                    }\n                }\n                var len = res[i].length;\n                switch (res[i][0]) {\n                    case \"z\":\n                        x = mx;\n                        y = my;\n                        break;\n                    case \"h\":\n                        x += +res[i][len - 1];\n                        break;\n                    case \"v\":\n                        y += +res[i][len - 1];\n                        break;\n                    default:\n                        x += +res[i][len - 2];\n                        y += +res[i][len - 1];\n                }\n            }\n            res.toString = R._path2string;\n            pth.rel = pathClone(res);\n            return res;\n        },\n        pathToAbsolute = R._pathToAbsolute = function (pathArray) {\n            var pth = paths(pathArray);\n            if (pth.abs) {\n                return pathClone(pth.abs);\n            }\n            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption\n                pathArray = R.parsePathString(pathArray);\n            }\n            if (!pathArray || !pathArray.length) {\n                return [[\"M\", 0, 0]];\n            }\n            var res = [],\n                x = 0,\n                y = 0,\n                mx = 0,\n                my = 0,\n                start = 0;\n            if (pathArray[0][0] == \"M\") {\n                x = +pathArray[0][1];\n                y = +pathArray[0][2];\n                mx = x;\n                my = y;\n                start++;\n                res[0] = [\"M\", x, y];\n            }\n            var crz = pathArray.length == 3 && pathArray[0][0] == \"M\" && pathArray[1][0].toUpperCase() == \"R\" && pathArray[2][0].toUpperCase() == \"Z\";\n            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n                res.push(r = []);\n                pa = pathArray[i];\n                if (pa[0] != upperCase.call(pa[0])) {\n                    r[0] = upperCase.call(pa[0]);\n                    switch (r[0]) {\n                        case \"A\":\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +(pa[6] + x);\n                            r[7] = +(pa[7] + y);\n                            break;\n                        case \"V\":\n                            r[1] = +pa[1] + y;\n                            break;\n                        case \"H\":\n                            r[1] = +pa[1] + x;\n                            break;\n                        case \"R\":\n                            var dots = [x, y][concat](pa.slice(1));\n                            for (var j = 2, jj = dots.length; j < jj; j++) {\n                                dots[j] = +dots[j] + x;\n                                dots[++j] = +dots[j] + y;\n                            }\n                            res.pop();\n                            res = res[concat](catmullRom2bezier(dots, crz));\n                            break;\n                        case \"M\":\n                            mx = +pa[1] + x;\n                            my = +pa[2] + y;\n                        default:\n                            for (j = 1, jj = pa.length; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                    }\n                } else if (pa[0] == \"R\") {\n                    dots = [x, y][concat](pa.slice(1));\n                    res.pop();\n                    res = res[concat](catmullRom2bezier(dots, crz));\n                    r = [\"R\"][concat](pa.slice(-2));\n                } else {\n                    for (var k = 0, kk = pa.length; k < kk; k++) {\n                        r[k] = pa[k];\n                    }\n                }\n                switch (r[0]) {\n                    case \"Z\":\n                        x = mx;\n                        y = my;\n                        break;\n                    case \"H\":\n                        x = r[1];\n                        break;\n                    case \"V\":\n                        y = r[1];\n                        break;\n                    case \"M\":\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                }\n            }\n            res.toString = R._path2string;\n            pth.abs = pathClone(res);\n            return res;\n        },\n        l2c = function (x1, y1, x2, y2) {\n            return [x1, y1, x2, y2, x2, y2];\n        },\n        q2c = function (x1, y1, ax, ay, x2, y2) {\n            var _13 = 1 / 3,\n                _23 = 2 / 3;\n            return [\n                _13 * x1 + _23 * ax,\n                _13 * y1 + _23 * ay,\n                _13 * x2 + _23 * ax,\n                _13 * y2 + _23 * ay,\n                x2,\n                y2\n            ];\n        },\n        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = PI * 120 / 180,\n                rad = PI / 180 * (+angle || 0),\n                res = [],\n                xy,\n                rotate = cacher(function (x, y, rad) {\n                    var X = x * math.cos(rad) - y * math.sin(rad),\n                        Y = x * math.sin(rad) + y * math.cos(rad);\n                    return {x: X, y: Y};\n                });\n            if (!recursive) {\n                xy = rotate(x1, y1, -rad);\n                x1 = xy.x;\n                y1 = xy.y;\n                xy = rotate(x2, y2, -rad);\n                x2 = xy.x;\n                y2 = xy.y;\n                var cos = math.cos(PI / 180 * angle),\n                    sin = math.sin(PI / 180 * angle),\n                    x = (x1 - x2) / 2,\n                    y = (y1 - y2) / 2;\n                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n                if (h > 1) {\n                    h = math.sqrt(h);\n                    rx = h * rx;\n                    ry = h * ry;\n                }\n                var rx2 = rx * rx,\n                    ry2 = ry * ry,\n                    k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n                    cx = k * rx * y / ry + (x1 + x2) / 2,\n                    cy = k * -ry * x / rx + (y1 + y2) / 2,\n                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\n                f1 = x1 < cx ? PI - f1 : f1;\n                f2 = x2 < cx ? PI - f2 : f2;\n                f1 < 0 && (f1 = PI * 2 + f1);\n                f2 < 0 && (f2 = PI * 2 + f2);\n                if (sweep_flag && f1 > f2) {\n                    f1 = f1 - PI * 2;\n                }\n                if (!sweep_flag && f2 > f1) {\n                    f2 = f2 - PI * 2;\n                }\n            } else {\n                f1 = recursive[0];\n                f2 = recursive[1];\n                cx = recursive[2];\n                cy = recursive[3];\n            }\n            var df = f2 - f1;\n            if (abs(df) > _120) {\n                var f2old = f2,\n                    x2old = x2,\n                    y2old = y2;\n                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n                x2 = cx + rx * math.cos(f2);\n                y2 = cy + ry * math.sin(f2);\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n            df = f2 - f1;\n            var c1 = math.cos(f1),\n                s1 = math.sin(f1),\n                c2 = math.cos(f2),\n                s2 = math.sin(f2),\n                t = math.tan(df / 4),\n                hx = 4 / 3 * rx * t,\n                hy = 4 / 3 * ry * t,\n                m1 = [x1, y1],\n                m2 = [x1 + hx * s1, y1 - hy * c1],\n                m3 = [x2 + hx * s2, y2 - hy * c2],\n                m4 = [x2, y2];\n            m2[0] = 2 * m1[0] - m2[0];\n            m2[1] = 2 * m1[1] - m2[1];\n            if (recursive) {\n                return [m2, m3, m4][concat](res);\n            } else {\n                res = [m2, m3, m4][concat](res).join()[split](\",\");\n                var newres = [];\n                for (var i = 0, ii = res.length; i < ii; i++) {\n                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                }\n                return newres;\n            }\n        },\n        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n            var t1 = 1 - t;\n            return {\n                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n            };\n        },\n        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),\n                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),\n                c = p1x - c1x,\n                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,\n                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,\n                y = [p1y, p2y],\n                x = [p1x, p2x],\n                dot;\n            abs(t1) > \"1e12\" && (t1 = .5);\n            abs(t2) > \"1e12\" && (t2 = .5);\n            if (t1 > 0 && t1 < 1) {\n                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n                x.push(dot.x);\n                y.push(dot.y);\n            }\n            if (t2 > 0 && t2 < 1) {\n                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n                x.push(dot.x);\n                y.push(dot.y);\n            }\n            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);\n            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);\n            c = p1y - c1y;\n            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;\n            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;\n            abs(t1) > \"1e12\" && (t1 = .5);\n            abs(t2) > \"1e12\" && (t2 = .5);\n            if (t1 > 0 && t1 < 1) {\n                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n                x.push(dot.x);\n                y.push(dot.y);\n            }\n            if (t2 > 0 && t2 < 1) {\n                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n                x.push(dot.x);\n                y.push(dot.y);\n            }\n            return {\n                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},\n                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}\n            };\n        }),\n        path2curve = R._path2curve = cacher(function (path, path2) {\n            var pth = !path2 && paths(path);\n            if (!path2 && pth.curve) {\n                return pathClone(pth.curve);\n            }\n            var p = pathToAbsolute(path),\n                p2 = path2 && pathToAbsolute(path2),\n                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n                processPath = function (path, d, pcom) {\n                    var nx, ny, tq = {T:1, Q:1};\n                    if (!path) {\n                        return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n                    }\n                    !(path[0] in tq) && (d.qx = d.qy = null);\n                    switch (path[0]) {\n                        case \"M\":\n                            d.X = path[1];\n                            d.Y = path[2];\n                            break;\n                        case \"A\":\n                            path = [\"C\"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));\n                            break;\n                        case \"S\":\n                            if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n                                nx = d.x * 2 - d.bx;          // And reflect the previous\n                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n                            }\n                            else {                            // or some else or nothing\n                                nx = d.x;\n                                ny = d.y;\n                            }\n                            path = [\"C\", nx, ny][concat](path.slice(1));\n                            break;\n                        case \"T\":\n                            if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n                                d.qy = d.y * 2 - d.qy;        // to case \"S\".\n                            }\n                            else {                            // or something else or nothing\n                                d.qx = d.x;\n                                d.qy = d.y;\n                            }\n                            path = [\"C\"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                            break;\n                        case \"Q\":\n                            d.qx = path[1];\n                            d.qy = path[2];\n                            path = [\"C\"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                            break;\n                        case \"L\":\n                            path = [\"C\"][concat](l2c(d.x, d.y, path[1], path[2]));\n                            break;\n                        case \"H\":\n                            path = [\"C\"][concat](l2c(d.x, d.y, path[1], d.y));\n                            break;\n                        case \"V\":\n                            path = [\"C\"][concat](l2c(d.x, d.y, d.x, path[1]));\n                            break;\n                        case \"Z\":\n                            path = [\"C\"][concat](l2c(d.x, d.y, d.X, d.Y));\n                            break;\n                    }\n                    return path;\n                },\n                fixArc = function (pp, i) {\n                    if (pp[i].length > 7) {\n                        pp[i].shift();\n                        var pi = pp[i];\n                        while (pi.length) {\n                            pcoms1[i]=\"A\"; // if created multiple C:s, their original seg is saved\n                            p2 && (pcoms2[i]=\"A\"); // the same as above\n                            pp.splice(i++, 0, [\"C\"][concat](pi.splice(0, 6)));\n                        }\n                        pp.splice(i, 1);\n                        ii = mmax(p.length, p2 && p2.length || 0);\n                    }\n                },\n                fixM = function (path1, path2, a1, a2, i) {\n                    if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                        path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n                        a1.bx = 0;\n                        a1.by = 0;\n                        a1.x = path1[i][1];\n                        a1.y = path1[i][2];\n                        ii = mmax(p.length, p2 && p2.length || 0);\n                    }\n                },\n                pcoms1 = [], // path commands of original path p\n                pcoms2 = [], // path commands of original path p2\n                pfirst = \"\", // temporary holder for original path command\n                pcom = \"\"; // holder for previous path command of original path\n            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n                p[i] && (pfirst = p[i][0]); // save current path command\n\n                if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n                {\n                    pcoms1[i] = pfirst; // Save current path command\n                    i && ( pcom = pcoms1[i-1]); // Get previous path command pcom\n                }\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n                if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n                // which may produce multiple C:s\n                // so we have to make sure that C is also C in original path\n\n                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n                if (p2) { // the same procedures is done to p2\n                    p2[i] && (pfirst = p2[i][0]);\n                    if (pfirst != \"C\")\n                    {\n                        pcoms2[i] = pfirst;\n                        i && (pcom = pcoms2[i-1]);\n                    }\n                    p2[i] = processPath(p2[i], attrs2, pcom);\n\n                    if (pcoms2[i]!=\"A\" && pfirst==\"C\") pcoms2[i]=\"C\";\n\n                    fixArc(p2, i);\n                }\n                fixM(p, p2, attrs, attrs2, i);\n                fixM(p2, p, attrs2, attrs, i);\n                var seg = p[i],\n                    seg2 = p2 && p2[i],\n                    seglen = seg.length,\n                    seg2len = p2 && seg2.length;\n                attrs.x = seg[seglen - 2];\n                attrs.y = seg[seglen - 1];\n                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n                attrs2.x = p2 && seg2[seg2len - 2];\n                attrs2.y = p2 && seg2[seg2len - 1];\n            }\n            if (!p2) {\n                pth.curve = pathClone(p);\n            }\n            return p2 ? [p, p2] : p;\n        }, null, pathClone),\n        parseDots = R._parseDots = cacher(function (gradient) {\n            var dots = [];\n            for (var i = 0, ii = gradient.length; i < ii; i++) {\n                var dot = {},\n                    par = gradient[i].match(/^([^:]*):?([\\d\\.]*)/);\n                dot.color = R.getRGB(par[1]);\n                if (dot.color.error) {\n                    return null;\n                }\n                dot.opacity = dot.color.opacity;\n                dot.color = dot.color.hex;\n                par[2] && (dot.offset = par[2] + \"%\");\n                dots.push(dot);\n            }\n            for (i = 1, ii = dots.length - 1; i < ii; i++) {\n                if (!dots[i].offset) {\n                    var start = toFloat(dots[i - 1].offset || 0),\n                        end = 0;\n                    for (var j = i + 1; j < ii; j++) {\n                        if (dots[j].offset) {\n                            end = dots[j].offset;\n                            break;\n                        }\n                    }\n                    if (!end) {\n                        end = 100;\n                        j = ii;\n                    }\n                    end = toFloat(end);\n                    var d = (end - start) / (j - i + 1);\n                    for (; i < j; i++) {\n                        start += d;\n                        dots[i].offset = start + \"%\";\n                    }\n                }\n            }\n            return dots;\n        }),\n        tear = R._tear = function (el, paper) {\n            el == paper.top && (paper.top = el.prev);\n            el == paper.bottom && (paper.bottom = el.next);\n            el.next && (el.next.prev = el.prev);\n            el.prev && (el.prev.next = el.next);\n        },\n        tofront = R._tofront = function (el, paper) {\n            if (paper.top === el) {\n                return;\n            }\n            tear(el, paper);\n            el.next = null;\n            el.prev = paper.top;\n            paper.top.next = el;\n            paper.top = el;\n        },\n        toback = R._toback = function (el, paper) {\n            if (paper.bottom === el) {\n                return;\n            }\n            tear(el, paper);\n            el.next = paper.bottom;\n            el.prev = null;\n            paper.bottom.prev = el;\n            paper.bottom = el;\n        },\n        insertafter = R._insertafter = function (el, el2, paper) {\n            tear(el, paper);\n            el2 == paper.top && (paper.top = el);\n            el2.next && (el2.next.prev = el);\n            el.next = el2.next;\n            el.prev = el2;\n            el2.next = el;\n        },\n        insertbefore = R._insertbefore = function (el, el2, paper) {\n            tear(el, paper);\n            el2 == paper.bottom && (paper.bottom = el);\n            el2.prev && (el2.prev.next = el);\n            el.prev = el2.prev;\n            el2.prev = el;\n            el.next = el2;\n        },\n    /*\\\n     * Raphael.toMatrix\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns matrix of transformations applied to a given path\n     > Parameters\n     - path (string) path string\n     - transform (string|array) transformation string\n     = (object) @Matrix\n     \\*/\n        toMatrix = R.toMatrix = function (path, transform) {\n            var bb = pathDimensions(path),\n                el = {\n                    _: {\n                        transform: E\n                    },\n                    getBBox: function () {\n                        return bb;\n                    }\n                };\n            extractTransform(el, transform);\n            return el.matrix;\n        },\n    /*\\\n     * Raphael.transformPath\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns path transformed by a given transformation\n     > Parameters\n     - path (string) path string\n     - transform (string|array) transformation string\n     = (string) path\n     \\*/\n        transformPath = R.transformPath = function (path, transform) {\n            return mapPath(path, toMatrix(path, transform));\n        },\n        extractTransform = R._extractTransform = function (el, tstr) {\n            if (tstr == null) {\n                return el._.transform;\n            }\n            tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n            var tdata = R.parseTransformString(tstr),\n                deg = 0,\n                dx = 0,\n                dy = 0,\n                sx = 1,\n                sy = 1,\n                _ = el._,\n                m = new Matrix;\n            _.transform = tdata || [];\n            if (tdata) {\n                for (var i = 0, ii = tdata.length; i < ii; i++) {\n                    var t = tdata[i],\n                        tlen = t.length,\n                        command = Str(t[0]).toLowerCase(),\n                        absolute = t[0] != command,\n                        inver = absolute ? m.invert() : 0,\n                        x1,\n                        y1,\n                        x2,\n                        y2,\n                        bb;\n                    if (command == \"t\" && tlen == 3) {\n                        if (absolute) {\n                            x1 = inver.x(0, 0);\n                            y1 = inver.y(0, 0);\n                            x2 = inver.x(t[1], t[2]);\n                            y2 = inver.y(t[1], t[2]);\n                            m.translate(x2 - x1, y2 - y1);\n                        } else {\n                            m.translate(t[1], t[2]);\n                        }\n                    } else if (command == \"r\") {\n                        if (tlen == 2) {\n                            bb = bb || el.getBBox(1);\n                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                            deg += t[1];\n                        } else if (tlen == 4) {\n                            if (absolute) {\n                                x2 = inver.x(t[2], t[3]);\n                                y2 = inver.y(t[2], t[3]);\n                                m.rotate(t[1], x2, y2);\n                            } else {\n                                m.rotate(t[1], t[2], t[3]);\n                            }\n                            deg += t[1];\n                        }\n                    } else if (command == \"s\") {\n                        if (tlen == 2 || tlen == 3) {\n                            bb = bb || el.getBBox(1);\n                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                            sx *= t[1];\n                            sy *= t[tlen - 1];\n                        } else if (tlen == 5) {\n                            if (absolute) {\n                                x2 = inver.x(t[3], t[4]);\n                                y2 = inver.y(t[3], t[4]);\n                                m.scale(t[1], t[2], x2, y2);\n                            } else {\n                                m.scale(t[1], t[2], t[3], t[4]);\n                            }\n                            sx *= t[1];\n                            sy *= t[2];\n                        }\n                    } else if (command == \"m\" && tlen == 7) {\n                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n                    }\n                    _.dirtyT = 1;\n                    el.matrix = m;\n                }\n            }\n\n            /*\\\n             * Element.matrix\n             [ property (object) ]\n             **\n             * Keeps @Matrix object, which represents element transformation\n             \\*/\n            el.matrix = m;\n\n            _.sx = sx;\n            _.sy = sy;\n            _.deg = deg;\n            _.dx = dx = m.e;\n            _.dy = dy = m.f;\n\n            if (sx == 1 && sy == 1 && !deg && _.bbox) {\n                _.bbox.x += +dx;\n                _.bbox.y += +dy;\n            } else {\n                _.dirtyT = 1;\n            }\n        },\n        getEmpty = function (item) {\n            var l = item[0];\n            switch (l.toLowerCase()) {\n                case \"t\": return [l, 0, 0];\n                case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n                case \"r\": if (item.length == 4) {\n                    return [l, 0, item[2], item[3]];\n                } else {\n                    return [l, 0];\n                }\n                case \"s\": if (item.length == 5) {\n                    return [l, 1, 1, item[3], item[4]];\n                } else if (item.length == 3) {\n                    return [l, 1, 1];\n                } else {\n                    return [l, 1];\n                }\n            }\n        },\n        equaliseTransform = R._equaliseTransform = function (t1, t2) {\n            t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n            t1 = R.parseTransformString(t1) || [];\n            t2 = R.parseTransformString(t2) || [];\n            var maxlength = mmax(t1.length, t2.length),\n                from = [],\n                to = [],\n                i = 0, j, jj,\n                tt1, tt2;\n            for (; i < maxlength; i++) {\n                tt1 = t1[i] || getEmpty(t2[i]);\n                tt2 = t2[i] || getEmpty(tt1);\n                if ((tt1[0] != tt2[0]) ||\n                    (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n                    (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n                ) {\n                    return;\n                }\n                from[i] = [];\n                to[i] = [];\n                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {\n                    j in tt1 && (from[i][j] = tt1[j]);\n                    j in tt2 && (to[i][j] = tt2[j]);\n                }\n            }\n            return {\n                from: from,\n                to: to\n            };\n        };\n    R._getContainer = function (x, y, w, h) {\n        var container;\n        container = h == null && !R.is(x, \"object\") ? g.doc.getElementById(x) : x;\n        if (container == null) {\n            return;\n        }\n        if (container.tagName) {\n            if (y == null) {\n                return {\n                    container: container,\n                    width: container.style.pixelWidth || container.offsetWidth,\n                    height: container.style.pixelHeight || container.offsetHeight\n                };\n            } else {\n                return {\n                    container: container,\n                    width: y,\n                    height: w\n                };\n            }\n        }\n        return {\n            container: 1,\n            x: x,\n            y: y,\n            width: w,\n            height: h\n        };\n    };\n    /*\\\n     * Raphael.pathToRelative\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path to relative form\n     > Parameters\n     - pathString (string|array) path string or array of segments\n     = (array) array of segments.\n     \\*/\n    R.pathToRelative = pathToRelative;\n    R._engine = {};\n    /*\\\n     * Raphael.path2curve\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path to a new path where all segments are cubic bezier curves.\n     > Parameters\n     - pathString (string|array) path string or array of segments\n     = (array) array of segments.\n     \\*/\n    R.path2curve = path2curve;\n    /*\\\n     * Raphael.matrix\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns matrix based on given parameters.\n     > Parameters\n     - a (number)\n     - b (number)\n     - c (number)\n     - d (number)\n     - e (number)\n     - f (number)\n     = (object) @Matrix\n     \\*/\n    R.matrix = function (a, b, c, d, e, f) {\n        return new Matrix(a, b, c, d, e, f);\n    };\n    function Matrix(a, b, c, d, e, f) {\n        if (a != null) {\n            this.a = +a;\n            this.b = +b;\n            this.c = +c;\n            this.d = +d;\n            this.e = +e;\n            this.f = +f;\n        } else {\n            this.a = 1;\n            this.b = 0;\n            this.c = 0;\n            this.d = 1;\n            this.e = 0;\n            this.f = 0;\n        }\n    }\n    (function (matrixproto) {\n        /*\\\n         * Matrix.add\n         [ method ]\n         **\n         * Adds given matrix to existing one.\n         > Parameters\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         or\n         - matrix (object) @Matrix\n         \\*/\n        matrixproto.add = function (a, b, c, d, e, f) {\n            var out = [[], [], []],\n                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n                x, y, z, res;\n\n            if (a && a instanceof Matrix) {\n                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n            }\n\n            for (x = 0; x < 3; x++) {\n                for (y = 0; y < 3; y++) {\n                    res = 0;\n                    for (z = 0; z < 3; z++) {\n                        res += m[x][z] * matrix[z][y];\n                    }\n                    out[x][y] = res;\n                }\n            }\n            this.a = out[0][0];\n            this.b = out[1][0];\n            this.c = out[0][1];\n            this.d = out[1][1];\n            this.e = out[0][2];\n            this.f = out[1][2];\n        };\n        /*\\\n         * Matrix.invert\n         [ method ]\n         **\n         * Returns inverted version of the matrix\n         = (object) @Matrix\n         \\*/\n        matrixproto.invert = function () {\n            var me = this,\n                x = me.a * me.d - me.b * me.c;\n            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n        };\n        /*\\\n         * Matrix.clone\n         [ method ]\n         **\n         * Returns copy of the matrix\n         = (object) @Matrix\n         \\*/\n        matrixproto.clone = function () {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n        };\n        /*\\\n         * Matrix.translate\n         [ method ]\n         **\n         * Translate the matrix\n         > Parameters\n         - x (number)\n         - y (number)\n         \\*/\n        matrixproto.translate = function (x, y) {\n            this.add(1, 0, 0, 1, x, y);\n        };\n        /*\\\n         * Matrix.scale\n         [ method ]\n         **\n         * Scales the matrix\n         > Parameters\n         - x (number)\n         - y (number) #optional\n         - cx (number) #optional\n         - cy (number) #optional\n         \\*/\n        matrixproto.scale = function (x, y, cx, cy) {\n            y == null && (y = x);\n            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n            this.add(x, 0, 0, y, 0, 0);\n            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n        };\n        /*\\\n         * Matrix.rotate\n         [ method ]\n         **\n         * Rotates the matrix\n         > Parameters\n         - a (number)\n         - x (number)\n         - y (number)\n         \\*/\n        matrixproto.rotate = function (a, x, y) {\n            a = R.rad(a);\n            x = x || 0;\n            y = y || 0;\n            var cos = +math.cos(a).toFixed(9),\n                sin = +math.sin(a).toFixed(9);\n            this.add(cos, sin, -sin, cos, x, y);\n            this.add(1, 0, 0, 1, -x, -y);\n        };\n        /*\\\n         * Matrix.x\n         [ method ]\n         **\n         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n         > Parameters\n         - x (number)\n         - y (number)\n         = (number) x\n         \\*/\n        matrixproto.x = function (x, y) {\n            return x * this.a + y * this.c + this.e;\n        };\n        /*\\\n         * Matrix.y\n         [ method ]\n         **\n         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n         > Parameters\n         - x (number)\n         - y (number)\n         = (number) y\n         \\*/\n        matrixproto.y = function (x, y) {\n            return x * this.b + y * this.d + this.f;\n        };\n        matrixproto.get = function (i) {\n            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n        };\n        matrixproto.toString = function () {\n            return R.svg ?\n            \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\" :\n                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();\n        };\n        matrixproto.toFilter = function () {\n            return \"progid:DXImageTransform.Microsoft.Matrix(M11=\" + this.get(0) +\n                \", M12=\" + this.get(2) + \", M21=\" + this.get(1) + \", M22=\" + this.get(3) +\n                \", Dx=\" + this.get(4) + \", Dy=\" + this.get(5) + \", sizingmethod='auto expand')\";\n        };\n        matrixproto.offset = function () {\n            return [this.e.toFixed(4), this.f.toFixed(4)];\n        };\n        function norm(a) {\n            return a[0] * a[0] + a[1] * a[1];\n        }\n        function normalize(a) {\n            var mag = math.sqrt(norm(a));\n            a[0] && (a[0] /= mag);\n            a[1] && (a[1] /= mag);\n        }\n        /*\\\n         * Matrix.split\n         [ method ]\n         **\n         * Splits matrix into primitive transformations\n         = (object) in format:\n         o dx (number) translation by x\n         o dy (number) translation by y\n         o scalex (number) scale by x\n         o scaley (number) scale by y\n         o shear (number) shear\n         o rotate (number) rotation in deg\n         o isSimple (boolean) could it be represented via simple transformations\n         \\*/\n        matrixproto.split = function () {\n            var out = {};\n            // translation\n            out.dx = this.e;\n            out.dy = this.f;\n\n            // scale and shear\n            var row = [[this.a, this.c], [this.b, this.d]];\n            out.scalex = math.sqrt(norm(row[0]));\n            normalize(row[0]);\n\n            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\n            out.scaley = math.sqrt(norm(row[1]));\n            normalize(row[1]);\n            out.shear /= out.scaley;\n\n            // rotation\n            var sin = -row[0][1],\n                cos = row[1][1];\n            if (cos < 0) {\n                out.rotate = R.deg(math.acos(cos));\n                if (sin < 0) {\n                    out.rotate = 360 - out.rotate;\n                }\n            } else {\n                out.rotate = R.deg(math.asin(sin));\n            }\n\n            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n            return out;\n        };\n        /*\\\n         * Matrix.toTransformString\n         [ method ]\n         **\n         * Return transform string that represents given matrix\n         = (string) transform string\n         \\*/\n        matrixproto.toTransformString = function (shorter) {\n            var s = shorter || this[split]();\n            if (s.isSimple) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return  (s.dx || s.dy ? \"t\" + [s.dx, s.dy] : E) +\n                    (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n                    (s.rotate ? \"r\" + [s.rotate, 0, 0] : E);\n            } else {\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n            }\n        };\n    })(Matrix.prototype);\n\n    var preventDefault = function () {\n            this.returnValue = false;\n        },\n        preventTouch = function () {\n            return this.originalEvent.preventDefault();\n        },\n        stopPropagation = function () {\n            this.cancelBubble = true;\n        },\n        stopTouch = function () {\n            return this.originalEvent.stopPropagation();\n        },\n        getEventPosition = function (e) {\n            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n\n            return {\n                x: e.clientX + scrollX,\n                y: e.clientY + scrollY\n            };\n        },\n        addEvent = (function () {\n            if (g.doc.addEventListener) {\n                return function (obj, type, fn, element) {\n                    var f = function (e) {\n                        var pos = getEventPosition(e);\n                        return fn.call(element, e, pos.x, pos.y);\n                    };\n                    obj.addEventListener(type, f, false);\n\n                    if (supportsTouch && touchMap[type]) {\n                        var _f = function (e) {\n                            var pos = getEventPosition(e),\n                                olde = e;\n\n                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n                                if (e.targetTouches[i].target == obj) {\n                                    e = e.targetTouches[i];\n                                    e.originalEvent = olde;\n                                    e.preventDefault = preventTouch;\n                                    e.stopPropagation = stopTouch;\n                                    break;\n                                }\n                            }\n\n                            return fn.call(element, e, pos.x, pos.y);\n                        };\n                        obj.addEventListener(touchMap[type], _f, false);\n                    }\n\n                    return function () {\n                        obj.removeEventListener(type, f, false);\n\n                        if (supportsTouch && touchMap[type])\n                            obj.removeEventListener(touchMap[type], _f, false);\n\n                        return true;\n                    };\n                };\n            } else if (g.doc.attachEvent) {\n                return function (obj, type, fn, element) {\n                    var f = function (e) {\n                        e = e || g.win.event;\n                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n                            x = e.clientX + scrollX,\n                            y = e.clientY + scrollY;\n                        e.preventDefault = e.preventDefault || preventDefault;\n                        e.stopPropagation = e.stopPropagation || stopPropagation;\n                        return fn.call(element, e, x, y);\n                    };\n                    obj.attachEvent(\"on\" + type, f);\n                    var detacher = function () {\n                        obj.detachEvent(\"on\" + type, f);\n                        return true;\n                    };\n                    return detacher;\n                };\n            }\n        })(),\n        drag = [],\n        dragMove = function (e) {\n            var x = e.clientX,\n                y = e.clientY,\n                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n                dragi,\n                j = drag.length;\n            while (j--) {\n                dragi = drag[j];\n                if (supportsTouch && e.touches) {\n                    var i = e.touches.length,\n                        touch;\n                    while (i--) {\n                        touch = e.touches[i];\n                        if (touch.identifier == dragi.el._drag.id) {\n                            x = touch.clientX;\n                            y = touch.clientY;\n                            (e.originalEvent ? e.originalEvent : e).preventDefault();\n                            break;\n                        }\n                    }\n                } else {\n                    e.preventDefault();\n                }\n                var node = dragi.el.node,\n                    o,\n                    next = node.nextSibling,\n                    parent = node.parentNode,\n                    display = node.style.display;\n                g.win.opera && parent.removeChild(node);\n                node.style.display = \"none\";\n                o = dragi.el.paper.getElementByPoint(x, y);\n                node.style.display = display;\n                g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n                o && eve(\"raphael.drag.over.\" + dragi.el.id, dragi.el, o);\n                x += scrollX;\n                y += scrollY;\n                eve(\"raphael.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n            }\n        },\n        dragUp = function (e) {\n            R.unmousemove(dragMove).unmouseup(dragUp);\n            var i = drag.length,\n                dragi;\n            while (i--) {\n                dragi = drag[i];\n                dragi.el._drag = {};\n                eve(\"raphael.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n            }\n            drag = [];\n        },\n    /*\\\n     * Raphael.el\n     [ property (object) ]\n     **\n     * You can add your own method to elements. This is usefull when you want to hack default functionality or\n     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,\n     * you can redefine element method at any time. Expending element methods wouldnt affect set.\n     > Usage\n     | Raphael.el.red = function () {\n     |     this.attr({fill: \"#f00\"});\n     | };\n     | // then use it\n     | paper.circle(100, 100, 20).red();\n     \\*/\n        elproto = R.el = {};\n    /*\\\n     * Element.click\n     [ method ]\n     **\n     * Adds event handler for click for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.unclick\n     [ method ]\n     **\n     * Removes event handler for click for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.dblclick\n     [ method ]\n     **\n     * Adds event handler for double click for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.undblclick\n     [ method ]\n     **\n     * Removes event handler for double click for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.mousedown\n     [ method ]\n     **\n     * Adds event handler for mousedown for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.unmousedown\n     [ method ]\n     **\n     * Removes event handler for mousedown for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.mousemove\n     [ method ]\n     **\n     * Adds event handler for mousemove for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.unmousemove\n     [ method ]\n     **\n     * Removes event handler for mousemove for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.mouseout\n     [ method ]\n     **\n     * Adds event handler for mouseout for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.unmouseout\n     [ method ]\n     **\n     * Removes event handler for mouseout for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.mouseover\n     [ method ]\n     **\n     * Adds event handler for mouseover for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.unmouseover\n     [ method ]\n     **\n     * Removes event handler for mouseover for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.mouseup\n     [ method ]\n     **\n     * Adds event handler for mouseup for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.unmouseup\n     [ method ]\n     **\n     * Removes event handler for mouseup for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.touchstart\n     [ method ]\n     **\n     * Adds event handler for touchstart for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.untouchstart\n     [ method ]\n     **\n     * Removes event handler for touchstart for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.touchmove\n     [ method ]\n     **\n     * Adds event handler for touchmove for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.untouchmove\n     [ method ]\n     **\n     * Removes event handler for touchmove for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.touchend\n     [ method ]\n     **\n     * Adds event handler for touchend for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.untouchend\n     [ method ]\n     **\n     * Removes event handler for touchend for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n\n    /*\\\n     * Element.touchcancel\n     [ method ]\n     **\n     * Adds event handler for touchcancel for the element.\n     > Parameters\n     - handler (function) handler for the event\n     = (object) @Element\n     \\*/\n    /*\\\n     * Element.untouchcancel\n     [ method ]\n     **\n     * Removes event handler for touchcancel for the element.\n     > Parameters\n     - handler (function) #optional handler for the event\n     = (object) @Element\n     \\*/\n    for (var i = events.length; i--;) {\n        (function (eventName) {\n            R[eventName] = elproto[eventName] = function (fn, scope) {\n                if (R.is(fn, \"function\")) {\n                    this.events = this.events || [];\n                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});\n                }\n                return this;\n            };\n            R[\"un\" + eventName] = elproto[\"un\" + eventName] = function (fn) {\n                var events = this.events || [],\n                    l = events.length;\n                while (l--){\n                    if (events[l].name == eventName && (R.is(fn, \"undefined\") || events[l].f == fn)) {\n                        events[l].unbind();\n                        events.splice(l, 1);\n                        !events.length && delete this.events;\n                    }\n                }\n                return this;\n            };\n        })(events[i]);\n    }\n\n    /*\\\n     * Element.data\n     [ method ]\n     **\n     * Adds or retrieves given value asociated with given key.\n     **\n     * See also @Element.removeData\n     > Parameters\n     - key (string) key to store data\n     - value (any) #optional value to store\n     = (object) @Element\n     * or, if value is not specified:\n     = (any) value\n     * or, if key and value are not specified:\n     = (object) Key/value pairs for all the data associated with the element.\n     > Usage\n     | for (var i = 0, i < 5, i++) {\n     |     paper.circle(10 + 15 * i, 10, 10)\n     |          .attr({fill: \"#000\"})\n     |          .data(\"i\", i)\n     |          .click(function () {\n     |             alert(this.data(\"i\"));\n     |          });\n     | }\n     \\*/\n    elproto.data = function (key, value) {\n        var data = eldata[this.id] = eldata[this.id] || {};\n        if (arguments.length == 0) {\n            return data;\n        }\n        if (arguments.length == 1) {\n            if (R.is(key, \"object\")) {\n                for (var i in key) if (key[has](i)) {\n                    this.data(i, key[i]);\n                }\n                return this;\n            }\n            eve(\"raphael.data.get.\" + this.id, this, data[key], key);\n            return data[key];\n        }\n        data[key] = value;\n        eve(\"raphael.data.set.\" + this.id, this, value, key);\n        return this;\n    };\n    /*\\\n     * Element.removeData\n     [ method ]\n     **\n     * Removes value associated with an element by given key.\n     * If key is not provided, removes all the data of the element.\n     > Parameters\n     - key (string) #optional key\n     = (object) @Element\n     \\*/\n    elproto.removeData = function (key) {\n        if (key == null) {\n            eldata[this.id] = {};\n        } else {\n            eldata[this.id] && delete eldata[this.id][key];\n        }\n        return this;\n    };\n    /*\\\n     * Element.getData\n     [ method ]\n     **\n     * Retrieves the element data\n     = (object) data\n     \\*/\n    elproto.getData = function () {\n        return clone(eldata[this.id] || {});\n    };\n    /*\\\n     * Element.hover\n     [ method ]\n     **\n     * Adds event handlers for hover for the element.\n     > Parameters\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     - icontext (object) #optional context for hover in handler\n     - ocontext (object) #optional context for hover out handler\n     = (object) @Element\n     \\*/\n    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n    };\n    /*\\\n     * Element.unhover\n     [ method ]\n     **\n     * Removes event handlers for hover for the element.\n     > Parameters\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     = (object) @Element\n     \\*/\n    elproto.unhover = function (f_in, f_out) {\n        return this.unmouseover(f_in).unmouseout(f_out);\n    };\n    var draggable = [];\n    /*\\\n     * Element.drag\n     [ method ]\n     **\n     * Adds event handlers for drag of the element.\n     > Parameters\n     - onmove (function) handler for moving\n     - onstart (function) handler for drag start\n     - onend (function) handler for drag end\n     - mcontext (object) #optional context for moving handler\n     - scontext (object) #optional context for drag start handler\n     - econtext (object) #optional context for drag end handler\n     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,\n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element\n     * `drag.over.<id>` will be fired as well.\n     *\n     * Start event and start handler will be called in specified context or in context of the element with following parameters:\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * Move event and move handler will be called in specified context or in context of the element with following parameters:\n     o dx (number) shift by x from the start point\n     o dy (number) shift by y from the start point\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * End event and end handler will be called in specified context or in context of the element with following parameters:\n     o event (object) DOM event object\n     = (object) @Element\n     \\*/\n    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n        function start(e) {\n            (e.originalEvent || e).preventDefault();\n            var x = e.clientX,\n                y = e.clientY,\n                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n            this._drag.id = e.identifier;\n            if (supportsTouch && e.touches) {\n                var i = e.touches.length, touch;\n                while (i--) {\n                    touch = e.touches[i];\n                    this._drag.id = touch.identifier;\n                    if (touch.identifier == this._drag.id) {\n                        x = touch.clientX;\n                        y = touch.clientY;\n                        break;\n                    }\n                }\n            }\n            this._drag.x = x + scrollX;\n            this._drag.y = y + scrollY;\n            !drag.length && R.mousemove(dragMove).mouseup(dragUp);\n            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n            onstart && eve.on(\"raphael.drag.start.\" + this.id, onstart);\n            onmove && eve.on(\"raphael.drag.move.\" + this.id, onmove);\n            onend && eve.on(\"raphael.drag.end.\" + this.id, onend);\n            eve(\"raphael.drag.start.\" + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);\n        }\n        this._drag = {};\n        draggable.push({el: this, start: start});\n        this.mousedown(start);\n        return this;\n    };\n    /*\\\n     * Element.onDragOver\n     [ method ]\n     **\n     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).\n     > Parameters\n     - f (function) handler for event, first argument would be the element you are dragging over\n     \\*/\n    elproto.onDragOver = function (f) {\n        f ? eve.on(\"raphael.drag.over.\" + this.id, f) : eve.unbind(\"raphael.drag.over.\" + this.id);\n    };\n    /*\\\n     * Element.undrag\n     [ method ]\n     **\n     * Removes all drag event handlers from given element.\n     \\*/\n    elproto.undrag = function () {\n        var i = draggable.length;\n        while (i--) if (draggable[i].el == this) {\n            this.unmousedown(draggable[i].start);\n            draggable.splice(i, 1);\n            eve.unbind(\"raphael.drag.*.\" + this.id);\n        }\n        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);\n        drag = [];\n    };\n    /*\\\n     * Paper.circle\n     [ method ]\n     **\n     * Draws a circle.\n     **\n     > Parameters\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - r (number) radius\n     = (object) Raphal element object with type circle\n     **\n     > Usage\n     | var c = paper.circle(50, 50, 40);\n     \\*/\n    paperproto.circle = function (x, y, r) {\n        var out = R._engine.circle(this, x || 0, y || 0, r || 0);\n        this.__set__ && this.__set__.push(out);\n        return out;\n    };\n    /*\\\n     * Paper.rect\n     [ method ]\n     *\n     * Draws a rectangle.\n     **\n     > Parameters\n     **\n     - x (number) x coordinate of the top left corner\n     - y (number) y coordinate of the top left corner\n     - width (number) width\n     - height (number) height\n     - r (number) #optional radius for rounded corners, default is 0\n     = (object) Raphal element object with type rect\n     **\n     > Usage\n     | // regular rectangle\n     | var c = paper.rect(10, 10, 50, 50);\n     | // rectangle with rounded corners\n     | var c = paper.rect(40, 40, 50, 50, 10);\n     \\*/\n    paperproto.rect = function (x, y, w, h, r) {\n        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);\n        this.__set__ && this.__set__.push(out);\n        return out;\n    };\n    /*\\\n     * Paper.ellipse\n     [ method ]\n     **\n     * Draws an ellipse.\n     **\n     > Parameters\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - rx (number) horizontal radius\n     - ry (number) vertical radius\n     = (object) Raphal element object with type ellipse\n     **\n     > Usage\n     | var c = paper.ellipse(50, 50, 40, 20);\n     \\*/\n    paperproto.ellipse = function (x, y, rx, ry) {\n        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);\n        this.__set__ && this.__set__.push(out);\n        return out;\n    };\n    /*\\\n     * Paper.path\n     [ method ]\n     **\n     * Creates a path element by given path data string.\n     > Parameters\n     - pathString (string) #optional path string in SVG format.\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:\n     | \"M10,20L30,40\"\n     * Here we can see two commands: M, with arguments `(10, 20)` and L with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caserelative.\n     *\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a>.</p>\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>\n     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n     * * Catmull-Rom curveto is a not standard SVG command and added in 2.0 to make life easier.\n     * Note: there is a special case when path consist of just three commands: M10,10Rz. In this case path will smoothly connects to its beginning.\n     > Usage\n     | var c = paper.path(\"M10 10L90 90\");\n     | // draw a diagonal line:\n     | // move to 10,10, line to 90,90\n     * For example of path strings, check out these icons: http://raphaeljs.com/icons/\n     \\*/\n    paperproto.path = function (pathString) {\n        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);\n        var out = R._engine.path(R.format[apply](R, arguments), this);\n        this.__set__ && this.__set__.push(out);\n        return out;\n    };\n    /*\\\n     * Paper.image\n     [ method ]\n     **\n     * Embeds an image into the surface.\n     **\n     > Parameters\n     **\n     - src (string) URI of the source image\n     - x (number) x coordinate position\n     - y (number) y coordinate position\n     - width (number) width of the image\n     - height (number) height of the image\n     = (object) Raphal element object with type image\n     **\n     > Usage\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n     \\*/\n    paperproto.image = function (src, x, y, w, h) {\n        var out = R._engine.image(this, src || \"about:blank\", x || 0, y || 0, w || 0, h || 0);\n        this.__set__ && this.__set__.push(out);\n        return out;\n    };\n    /*\\\n     * Paper.text\n     [ method ]\n     **\n     * Draws a text string. If you need line breaks, put \\n in the string.\n     **\n     > Parameters\n     **\n     - x (number) x coordinate position\n     - y (number) y coordinate position\n     - text (string) The text string to draw\n     = (object) Raphal element object with type text\n     **\n     > Usage\n     | var t = paper.text(50, 50, \"Raphal\\nkicks\\nbutt!\");\n     \\*/\n    paperproto.text = function (x, y, text) {\n        var out = R._engine.text(this, x || 0, y || 0, Str(text));\n        this.__set__ && this.__set__.push(out);\n        return out;\n    };\n    /*\\\n     * Paper.set\n     [ method ]\n     **\n     * Creates array-like object to keep and operate several elements at once.\n     * Warning: it doesnt create any elements for itself in the page, it just groups existing elements.\n     * Sets act as pseudo elements  all methods available to an element can be used on a set.\n     = (object) array-like object that represents set of elements\n     **\n     > Usage\n     | var st = paper.set();\n     | st.push(\n     |     paper.circle(10, 10, 5),\n     |     paper.circle(30, 10, 5)\n     | );\n     | st.attr({fill: \"red\"}); // changes the fill of both circles\n     \\*/\n    paperproto.set = function (itemsArray) {\n        !R.is(itemsArray, \"array\") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));\n        var out = new Set(itemsArray);\n        this.__set__ && this.__set__.push(out);\n        out[\"paper\"] = this;\n        out[\"type\"] = \"set\";\n        return out;\n    };\n    /*\\\n     * Paper.setStart\n     [ method ]\n     **\n     * Creates @Paper.set. All elements that will be created after calling this method and before calling\n     * @Paper.setFinish will be added to the set.\n     **\n     > Usage\n     | paper.setStart();\n     | paper.circle(10, 10, 5),\n     | paper.circle(30, 10, 5)\n     | var st = paper.setFinish();\n     | st.attr({fill: \"red\"}); // changes the fill of both circles\n     \\*/\n    paperproto.setStart = function (set) {\n        this.__set__ = set || this.set();\n    };\n    /*\\\n     * Paper.setFinish\n     [ method ]\n     **\n     * See @Paper.setStart. This method finishes catching and returns resulting set.\n     **\n     = (object) set\n     \\*/\n    paperproto.setFinish = function (set) {\n        var out = this.__set__;\n        delete this.__set__;\n        return out;\n    };\n    /*\\\n     * Paper.getSize\n     [ method ]\n     **\n     * Obtains current paper actual size.\n     **\n     = (object)\n     \\*/\n    paperproto.getSize = function () {\n        var container = this.canvas.parentNode;\n        return {\n            width: container.offsetWidth,\n            height: container.offsetHeight\n        };\n    };\n    /*\\\n     * Paper.setSize\n     [ method ]\n     **\n     * If you need to change dimensions of the canvas call this method\n     **\n     > Parameters\n     **\n     - width (number) new width of the canvas\n     - height (number) new height of the canvas\n     \\*/\n    paperproto.setSize = function (width, height) {\n        return R._engine.setSize.call(this, width, height);\n    };\n    /*\\\n     * Paper.setViewBox\n     [ method ]\n     **\n     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by\n     * specifying new boundaries.\n     **\n     > Parameters\n     **\n     - x (number) new x position, default is `0`\n     - y (number) new y position, default is `0`\n     - w (number) new width of the canvas\n     - h (number) new height of the canvas\n     - fit (boolean) `true` if you want graphics to fit into new boundary box\n     \\*/\n    paperproto.setViewBox = function (x, y, w, h, fit) {\n        return R._engine.setViewBox.call(this, x, y, w, h, fit);\n    };\n    /*\\\n     * Paper.top\n     [ property ]\n     **\n     * Points to the topmost element on the paper\n     \\*/\n    /*\\\n     * Paper.bottom\n     [ property ]\n     **\n     * Points to the bottom element on the paper\n     \\*/\n    paperproto.top = paperproto.bottom = null;\n    /*\\\n     * Paper.raphael\n     [ property ]\n     **\n     * Points to the @Raphael object/function\n     \\*/\n    paperproto.raphael = R;\n    var getOffset = function (elem) {\n        var box = elem.getBoundingClientRect(),\n            doc = elem.ownerDocument,\n            body = doc.body,\n            docElem = doc.documentElement,\n            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n        return {\n            y: top,\n            x: left\n        };\n    };\n    /*\\\n     * Paper.getElementByPoint\n     [ method ]\n     **\n     * Returns you topmost element under given point.\n     **\n     = (object) Raphal element object\n     > Parameters\n     **\n     - x (number) x coordinate from the top left corner of the window\n     - y (number) y coordinate from the top left corner of the window\n     > Usage\n     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n     \\*/\n    paperproto.getElementByPoint = function (x, y) {\n        var paper = this,\n            svg = paper.canvas,\n            target = g.doc.elementFromPoint(x, y);\n        if (g.win.opera && target.tagName == \"svg\") {\n            var so = getOffset(svg),\n                sr = svg.createSVGRect();\n            sr.x = x - so.x;\n            sr.y = y - so.y;\n            sr.width = sr.height = 1;\n            var hits = svg.getIntersectionList(sr, null);\n            if (hits.length) {\n                target = hits[hits.length - 1];\n            }\n        }\n        if (!target) {\n            return null;\n        }\n        while (target.parentNode && target != svg.parentNode && !target.raphael) {\n            target = target.parentNode;\n        }\n        target == paper.canvas.parentNode && (target = svg);\n        target = target && target.raphael ? paper.getById(target.raphaelid) : null;\n        return target;\n    };\n\n    /*\\\n     * Paper.getElementsByBBox\n     [ method ]\n     **\n     * Returns set of elements that have an intersecting bounding box\n     **\n     > Parameters\n     **\n     - bbox (object) bbox to check with\n     = (object) @Set\n     \\*/\n    paperproto.getElementsByBBox = function (bbox) {\n        var set = this.set();\n        this.forEach(function (el) {\n            if (R.isBBoxIntersect(el.getBBox(), bbox)) {\n                set.push(el);\n            }\n        });\n        return set;\n    };\n\n    /*\\\n     * Paper.getById\n     [ method ]\n     **\n     * Returns you element by its internal ID.\n     **\n     > Parameters\n     **\n     - id (number) id\n     = (object) Raphal element object\n     \\*/\n    paperproto.getById = function (id) {\n        var bot = this.bottom;\n        while (bot) {\n            if (bot.id == id) {\n                return bot;\n            }\n            bot = bot.next;\n        }\n        return null;\n    };\n    /*\\\n     * Paper.forEach\n     [ method ]\n     **\n     * Executes given function for each element on the paper\n     *\n     * If callback function returns `false` it will stop loop running.\n     **\n     > Parameters\n     **\n     - callback (function) function to run\n     - thisArg (object) context object for the callback\n     = (object) Paper object\n     > Usage\n     | paper.forEach(function (el) {\n     |     el.attr({ stroke: \"blue\" });\n     | });\n     \\*/\n    paperproto.forEach = function (callback, thisArg) {\n        var bot = this.bottom;\n        while (bot) {\n            if (callback.call(thisArg, bot) === false) {\n                return this;\n            }\n            bot = bot.next;\n        }\n        return this;\n    };\n    /*\\\n     * Paper.getElementsByPoint\n     [ method ]\n     **\n     * Returns set of elements that have common point inside\n     **\n     > Parameters\n     **\n     - x (number) x coordinate of the point\n     - y (number) y coordinate of the point\n     = (object) @Set\n     \\*/\n    paperproto.getElementsByPoint = function (x, y) {\n        var set = this.set();\n        this.forEach(function (el) {\n            if (el.isPointInside(x, y)) {\n                set.push(el);\n            }\n        });\n        return set;\n    };\n    function x_y() {\n        return this.x + S + this.y;\n    }\n    function x_y_w_h() {\n        return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n    }\n    /*\\\n     * Element.isPointInside\n     [ method ]\n     **\n     * Determine if given point is inside this elements shape\n     **\n     > Parameters\n     **\n     - x (number) x coordinate of the point\n     - y (number) y coordinate of the point\n     = (boolean) `true` if point inside the shape\n     \\*/\n    elproto.isPointInside = function (x, y) {\n        var rp = this.realPath = getPath[this.type](this);\n        if (this.attr('transform') && this.attr('transform').length) {\n            rp = R.transformPath(rp, this.attr('transform'));\n        }\n        return R.isPointInsidePath(rp, x, y);\n    };\n    /*\\\n     * Element.getBBox\n     [ method ]\n     **\n     * Return bounding box for a given element\n     **\n     > Parameters\n     **\n     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.\n     = (object) Bounding box object:\n     o {\n     o     x: (number) top left corner x\n     o     y: (number) top left corner y\n     o     x2: (number) bottom right corner x\n     o     y2: (number) bottom right corner y\n     o     width: (number) width\n     o     height: (number) height\n     o }\n     \\*/\n    elproto.getBBox = function (isWithoutTransform) {\n        if (this.removed) {\n            return {};\n        }\n        var _ = this._;\n        if (isWithoutTransform) {\n            if (_.dirty || !_.bboxwt) {\n                this.realPath = getPath[this.type](this);\n                _.bboxwt = pathDimensions(this.realPath);\n                _.bboxwt.toString = x_y_w_h;\n                _.dirty = 0;\n            }\n            return _.bboxwt;\n        }\n        if (_.dirty || _.dirtyT || !_.bbox) {\n            if (_.dirty || !this.realPath) {\n                _.bboxwt = 0;\n                this.realPath = getPath[this.type](this);\n            }\n            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));\n            _.bbox.toString = x_y_w_h;\n            _.dirty = _.dirtyT = 0;\n        }\n        return _.bbox;\n    };\n    /*\\\n     * Element.clone\n     [ method ]\n     **\n     = (object) clone of a given element\n     **\n     \\*/\n    elproto.clone = function () {\n        if (this.removed) {\n            return null;\n        }\n        var out = this.paper[this.type]().attr(this.attr());\n        this.__set__ && this.__set__.push(out);\n        return out;\n    };\n    /*\\\n     * Element.glow\n     [ method ]\n     **\n     * Return set of elements that create glow-like effect around given element. See @Paper.set.\n     *\n     * Note: Glow is not connected to the element. If you change element attributes it wont adjust itself.\n     **\n     > Parameters\n     **\n     - glow (object) #optional parameters object with all properties optional:\n     o {\n     o     width (number) size of the glow, default is `10`\n     o     fill (boolean) will it be filled, default is `false`\n     o     opacity (number) opacity, default is `0.5`\n     o     offsetx (number) horizontal offset, default is `0`\n     o     offsety (number) vertical offset, default is `0`\n     o     color (string) glow colour, default is `black`\n     o }\n     = (object) @Paper.set of elements that represents glow\n     \\*/\n    elproto.glow = function (glow) {\n        if (this.type == \"text\") {\n            return null;\n        }\n        glow = glow || {};\n        var s = {\n                width: (glow.width || 10) + (+this.attr(\"stroke-width\") || 1),\n                fill: glow.fill || false,\n                opacity: glow.opacity == null ? .5 : glow.opacity,\n                offsetx: glow.offsetx || 0,\n                offsety: glow.offsety || 0,\n                color: glow.color || \"#000\"\n            },\n            c = s.width / 2,\n            r = this.paper,\n            out = r.set(),\n            path = this.realPath || getPath[this.type](this);\n        path = this.matrix ? mapPath(path, this.matrix) : path;\n        for (var i = 1; i < c + 1; i++) {\n            out.push(r.path(path).attr({\n                stroke: s.color,\n                fill: s.fill ? s.color : \"none\",\n                \"stroke-linejoin\": \"round\",\n                \"stroke-linecap\": \"round\",\n                \"stroke-width\": +(s.width / c * i).toFixed(3),\n                opacity: +(s.opacity / c).toFixed(3)\n            }));\n        }\n        return out.insertBefore(this).translate(s.offsetx, s.offsety);\n    };\n    var curveslengths = {},\n        getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n            if (length == null) {\n                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n            } else {\n                return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n            }\n        },\n        getLengthFactory = function (istotal, subpath) {\n            return function (path, length, onlystart) {\n                path = path2curve(path);\n                var x, y, p, l, sp = \"\", subpaths = {}, point,\n                    len = 0;\n                for (var i = 0, ii = path.length; i < ii; i++) {\n                    p = path[i];\n                    if (p[0] == \"M\") {\n                        x = +p[1];\n                        y = +p[2];\n                    } else {\n                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                        if (len + l > length) {\n                            if (subpath && !subpaths.start) {\n                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                                sp += [\"C\" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];\n                                if (onlystart) {return sp;}\n                                subpaths.start = sp;\n                                sp = [\"M\" + point.x, point.y + \"C\" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();\n                                len += l;\n                                x = +p[5];\n                                y = +p[6];\n                                continue;\n                            }\n                            if (!istotal && !subpath) {\n                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                                return {x: point.x, y: point.y, alpha: point.alpha};\n                            }\n                        }\n                        len += l;\n                        x = +p[5];\n                        y = +p[6];\n                    }\n                    sp += p.shift() + p;\n                }\n                subpaths.end = sp;\n                point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n                point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});\n                return point;\n            };\n        };\n    var getTotalLength = getLengthFactory(1),\n        getPointAtLength = getLengthFactory(),\n        getSubpathsAtLength = getLengthFactory(0, 1);\n    /*\\\n     * Raphael.getTotalLength\n     [ method ]\n     **\n     * Returns length of the given path in pixels.\n     **\n     > Parameters\n     **\n     - path (string) SVG path string.\n     **\n     = (number) length.\n     \\*/\n    R.getTotalLength = getTotalLength;\n    /*\\\n     * Raphael.getPointAtLength\n     [ method ]\n     **\n     * Return coordinates of the point located at the given length on the given path.\n     **\n     > Parameters\n     **\n     - path (string) SVG path string\n     - length (number)\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate\n     o     y: (number) y coordinate\n     o     alpha: (number) angle of derivative\n     o }\n     \\*/\n    R.getPointAtLength = getPointAtLength;\n    /*\\\n     * Raphael.getSubpath\n     [ method ]\n     **\n     * Return subpath of a given path from given length to given length.\n     **\n     > Parameters\n     **\n     - path (string) SVG path string\n     - from (number) position of the start of the segment\n     - to (number) position of the end of the segment\n     **\n     = (string) pathstring for the segment\n     \\*/\n    R.getSubpath = function (path, from, to) {\n        if (this.getTotalLength(path) - to < 1e-6) {\n            return getSubpathsAtLength(path, from).end;\n        }\n        var a = getSubpathsAtLength(path, to, 1);\n        return from ? getSubpathsAtLength(a, from).end : a;\n    };\n    /*\\\n     * Element.getTotalLength\n     [ method ]\n     **\n     * Returns length of the path in pixels. Only works for element of path type.\n     = (number) length.\n     \\*/\n    elproto.getTotalLength = function () {\n        var path = this.getPath();\n        if (!path) {\n            return;\n        }\n\n        if (this.node.getTotalLength) {\n            return this.node.getTotalLength();\n        }\n\n        return getTotalLength(path);\n    };\n    /*\\\n     * Element.getPointAtLength\n     [ method ]\n     **\n     * Return coordinates of the point located at the given length on the given path. Only works for element of path type.\n     **\n     > Parameters\n     **\n     - length (number)\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate\n     o     y: (number) y coordinate\n     o     alpha: (number) angle of derivative\n     o }\n     \\*/\n    elproto.getPointAtLength = function (length) {\n        var path = this.getPath();\n        if (!path) {\n            return;\n        }\n\n        return getPointAtLength(path, length);\n    };\n    /*\\\n     * Element.getPath\n     [ method ]\n     **\n     * Returns path of the element. Only works for elements of path type and simple elements like circle.\n     = (object) path\n     **\n     \\*/\n    elproto.getPath = function () {\n        var path,\n            getPath = R._getPath[this.type];\n\n        if (this.type == \"text\" || this.type == \"set\") {\n            return;\n        }\n\n        if (getPath) {\n            path = getPath(this);\n        }\n\n        return path;\n    };\n    /*\\\n     * Element.getSubpath\n     [ method ]\n     **\n     * Return subpath of a given element from given length to given length. Only works for element of path type.\n     **\n     > Parameters\n     **\n     - from (number) position of the start of the segment\n     - to (number) position of the end of the segment\n     **\n     = (string) pathstring for the segment\n     \\*/\n    elproto.getSubpath = function (from, to) {\n        var path = this.getPath();\n        if (!path) {\n            return;\n        }\n\n        return R.getSubpath(path, from, to);\n    };\n    /*\\\n     * Raphael.easing_formulas\n     [ property ]\n     **\n     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:\n     # <ul>\n     #     <li>linear</li>\n     #     <li>&lt; or easeIn or ease-in</li>\n     #     <li>> or easeOut or ease-out</li>\n     #     <li>&lt;> or easeInOut or ease-in-out</li>\n     #     <li>backIn or back-in</li>\n     #     <li>backOut or back-out</li>\n     #     <li>elastic</li>\n     #     <li>bounce</li>\n     # </ul>\n     # <p>See also <a href=\"http://raphaeljs.com/easing.html\">Easing demo</a>.</p>\n     \\*/\n    var ef = R.easing_formulas = {\n        linear: function (n) {\n            return n;\n        },\n        \"<\": function (n) {\n            return pow(n, 1.7);\n        },\n        \">\": function (n) {\n            return pow(n, .48);\n        },\n        \"<>\": function (n) {\n            var q = .48 - n / 1.04,\n                Q = math.sqrt(.1734 + q * q),\n                x = Q - q,\n                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n                y = -Q - q,\n                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n                t = X + Y + .5;\n            return (1 - t) * 3 * t * t + t * t * t;\n        },\n        backIn: function (n) {\n            var s = 1.70158;\n            return n * n * ((s + 1) * n - s);\n        },\n        backOut: function (n) {\n            n = n - 1;\n            var s = 1.70158;\n            return n * n * ((s + 1) * n + s) + 1;\n        },\n        elastic: function (n) {\n            if (n == !!n) {\n                return n;\n            }\n            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;\n        },\n        bounce: function (n) {\n            var s = 7.5625,\n                p = 2.75,\n                l;\n            if (n < (1 / p)) {\n                l = s * n * n;\n            } else {\n                if (n < (2 / p)) {\n                    n -= (1.5 / p);\n                    l = s * n * n + .75;\n                } else {\n                    if (n < (2.5 / p)) {\n                        n -= (2.25 / p);\n                        l = s * n * n + .9375;\n                    } else {\n                        n -= (2.625 / p);\n                        l = s * n * n + .984375;\n                    }\n                }\n            }\n            return l;\n        }\n    };\n    ef.easeIn = ef[\"ease-in\"] = ef[\"<\"];\n    ef.easeOut = ef[\"ease-out\"] = ef[\">\"];\n    ef.easeInOut = ef[\"ease-in-out\"] = ef[\"<>\"];\n    ef[\"back-in\"] = ef.backIn;\n    ef[\"back-out\"] = ef.backOut;\n\n    var animationElements = [],\n        requestAnimFrame = window.requestAnimationFrame       ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame    ||\n            window.oRequestAnimationFrame      ||\n            window.msRequestAnimationFrame     ||\n            function (callback) {\n                setTimeout(callback, 16);\n            },\n        animation = function () {\n            var Now = +new Date,\n                l = 0;\n            for (; l < animationElements.length; l++) {\n                var e = animationElements[l];\n                if (e.el.removed || e.paused) {\n                    continue;\n                }\n                var time = Now - e.start,\n                    ms = e.ms,\n                    easing = e.easing,\n                    from = e.from,\n                    diff = e.diff,\n                    to = e.to,\n                    t = e.t,\n                    that = e.el,\n                    set = {},\n                    now,\n                    init = {},\n                    key;\n                if (e.initstatus) {\n                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;\n                    e.status = e.initstatus;\n                    delete e.initstatus;\n                    e.stop && animationElements.splice(l--, 1);\n                } else {\n                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;\n                }\n                if (time < 0) {\n                    continue;\n                }\n                if (time < ms) {\n                    var pos = easing(time / ms);\n                    for (var attr in from) if (from[has](attr)) {\n                        switch (availableAnimAttrs[attr]) {\n                            case nu:\n                                now = +from[attr] + pos * ms * diff[attr];\n                                break;\n                            case \"colour\":\n                                now = \"rgb(\" + [\n                                        upto255(round(from[attr].r + pos * ms * diff[attr].r)),\n                                        upto255(round(from[attr].g + pos * ms * diff[attr].g)),\n                                        upto255(round(from[attr].b + pos * ms * diff[attr].b))\n                                    ].join(\",\") + \")\";\n                                break;\n                            case \"path\":\n                                now = [];\n                                for (var i = 0, ii = from[attr].length; i < ii; i++) {\n                                    now[i] = [from[attr][i][0]];\n                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];\n                                    }\n                                    now[i] = now[i].join(S);\n                                }\n                                now = now.join(S);\n                                break;\n                            case \"transform\":\n                                if (diff[attr].real) {\n                                    now = [];\n                                    for (i = 0, ii = from[attr].length; i < ii; i++) {\n                                        now[i] = [from[attr][i][0]];\n                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];\n                                        }\n                                    }\n                                } else {\n                                    var get = function (i) {\n                                        return +from[attr][i] + pos * ms * diff[attr][i];\n                                    };\n                                    // now = [[\"r\", get(2), 0, 0], [\"t\", get(3), get(4)], [\"s\", get(0), get(1), 0, 0]];\n                                    now = [[\"m\", get(0), get(1), get(2), get(3), get(4), get(5)]];\n                                }\n                                break;\n                            case \"csv\":\n                                if (attr == \"clip-rect\") {\n                                    now = [];\n                                    i = 4;\n                                    while (i--) {\n                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];\n                                    }\n                                }\n                                break;\n                            default:\n                                var from2 = [][concat](from[attr]);\n                                now = [];\n                                i = that.paper.customAttributes[attr].length;\n                                while (i--) {\n                                    now[i] = +from2[i] + pos * ms * diff[attr][i];\n                                }\n                                break;\n                        }\n                        set[attr] = now;\n                    }\n                    that.attr(set);\n                    (function (id, that, anim) {\n                        setTimeout(function () {\n                            eve(\"raphael.anim.frame.\" + id, that, anim);\n                        });\n                    })(that.id, that, e.anim);\n                } else {\n                    (function(f, el, a) {\n                        setTimeout(function() {\n                            eve(\"raphael.anim.frame.\" + el.id, el, a);\n                            eve(\"raphael.anim.finish.\" + el.id, el, a);\n                            R.is(f, \"function\") && f.call(el);\n                        });\n                    })(e.callback, that, e.anim);\n                    that.attr(to);\n                    animationElements.splice(l--, 1);\n                    if (e.repeat > 1 && !e.next) {\n                        for (key in to) if (to[has](key)) {\n                            init[key] = e.totalOrigin[key];\n                        }\n                        e.el.attr(init);\n                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);\n                    }\n                    if (e.next && !e.stop) {\n                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);\n                    }\n                }\n            }\n            animationElements.length && requestAnimFrame(animation);\n        },\n        upto255 = function (color) {\n            return color > 255 ? 255 : color < 0 ? 0 : color;\n        };\n    /*\\\n     * Element.animateWith\n     [ method ]\n     **\n     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.\n     **\n     > Parameters\n     **\n     - el (object) element to sync with\n     - anim (object) animation to sync with\n     - params (object) #optional final attributes for the element, see also @Element.attr\n     - ms (number) #optional number of milliseconds for animation to run\n     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n     - callback (function) #optional callback function. Will be called at the end of animation.\n     * or\n     - element (object) element to sync with\n     - anim (object) animation to sync with\n     - animation (object) #optional animation object, see @Raphael.animation\n     **\n     = (object) original element\n     \\*/\n    elproto.animateWith = function (el, anim, params, ms, easing, callback) {\n        var element = this;\n        if (element.removed) {\n            callback && callback.call(element);\n            return element;\n        }\n        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),\n            x, y;\n        runAnimation(a, element, a.percents[0], null, element.attr());\n        for (var i = 0, ii = animationElements.length; i < ii; i++) {\n            if (animationElements[i].anim == anim && animationElements[i].el == el) {\n                animationElements[ii - 1].start = animationElements[i].start;\n                break;\n            }\n        }\n        return element;\n        //\n        //\n        // var a = params ? R.animation(params, ms, easing, callback) : anim,\n        //     status = element.status(anim);\n        // return this.animate(a).status(a, status * anim.ms / a.ms);\n    };\n    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {\n        var cx = 3 * p1x,\n            bx = 3 * (p2x - p1x) - cx,\n            ax = 1 - cx - bx,\n            cy = 3 * p1y,\n            by = 3 * (p2y - p1y) - cy,\n            ay = 1 - cy - by;\n        function sampleCurveX(t) {\n            return ((ax * t + bx) * t + cx) * t;\n        }\n        function solve(x, epsilon) {\n            var t = solveCurveX(x, epsilon);\n            return ((ay * t + by) * t + cy) * t;\n        }\n        function solveCurveX(x, epsilon) {\n            var t0, t1, t2, x2, d2, i;\n            for(t2 = x, i = 0; i < 8; i++) {\n                x2 = sampleCurveX(t2) - x;\n                if (abs(x2) < epsilon) {\n                    return t2;\n                }\n                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;\n                if (abs(d2) < 1e-6) {\n                    break;\n                }\n                t2 = t2 - x2 / d2;\n            }\n            t0 = 0;\n            t1 = 1;\n            t2 = x;\n            if (t2 < t0) {\n                return t0;\n            }\n            if (t2 > t1) {\n                return t1;\n            }\n            while (t0 < t1) {\n                x2 = sampleCurveX(t2);\n                if (abs(x2 - x) < epsilon) {\n                    return t2;\n                }\n                if (x > x2) {\n                    t0 = t2;\n                } else {\n                    t1 = t2;\n                }\n                t2 = (t1 - t0) / 2 + t0;\n            }\n            return t2;\n        }\n        return solve(t, 1 / (200 * duration));\n    }\n    elproto.onAnimation = function (f) {\n        f ? eve.on(\"raphael.anim.frame.\" + this.id, f) : eve.unbind(\"raphael.anim.frame.\" + this.id);\n        return this;\n    };\n    function Animation(anim, ms) {\n        var percents = [],\n            newAnim = {};\n        this.ms = ms;\n        this.times = 1;\n        if (anim) {\n            for (var attr in anim) if (anim[has](attr)) {\n                newAnim[toFloat(attr)] = anim[attr];\n                percents.push(toFloat(attr));\n            }\n            percents.sort(sortByNumber);\n        }\n        this.anim = newAnim;\n        this.top = percents[percents.length - 1];\n        this.percents = percents;\n    }\n    /*\\\n     * Animation.delay\n     [ method ]\n     **\n     * Creates a copy of existing animation object with given delay.\n     **\n     > Parameters\n     **\n     - delay (number) number of ms to pass between animation start and actual animation\n     **\n     = (object) new altered Animation object\n     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);\n     | circle1.animate(anim); // run the given animation immediately\n     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms\n     \\*/\n    Animation.prototype.delay = function (delay) {\n        var a = new Animation(this.anim, this.ms);\n        a.times = this.times;\n        a.del = +delay || 0;\n        return a;\n    };\n    /*\\\n     * Animation.repeat\n     [ method ]\n     **\n     * Creates a copy of existing animation object with given repetition.\n     **\n     > Parameters\n     **\n     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`\n     **\n     = (object) new altered Animation object\n     \\*/\n    Animation.prototype.repeat = function (times) {\n        var a = new Animation(this.anim, this.ms);\n        a.del = this.del;\n        a.times = math.floor(mmax(times, 0)) || 1;\n        return a;\n    };\n    function runAnimation(anim, element, percent, status, totalOrigin, times) {\n        percent = toFloat(percent);\n        var params,\n            isInAnim,\n            isInAnimSet,\n            percents = [],\n            next,\n            prev,\n            timestamp,\n            ms = anim.ms,\n            from = {},\n            to = {},\n            diff = {};\n        if (status) {\n            for (i = 0, ii = animationElements.length; i < ii; i++) {\n                var e = animationElements[i];\n                if (e.el.id == element.id && e.anim == anim) {\n                    if (e.percent != percent) {\n                        animationElements.splice(i, 1);\n                        isInAnimSet = 1;\n                    } else {\n                        isInAnim = e;\n                    }\n                    element.attr(e.totalOrigin);\n                    break;\n                }\n            }\n        } else {\n            status = +to; // NaN\n        }\n        for (var i = 0, ii = anim.percents.length; i < ii; i++) {\n            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {\n                percent = anim.percents[i];\n                prev = anim.percents[i - 1] || 0;\n                ms = ms / anim.top * (percent - prev);\n                next = anim.percents[i + 1];\n                params = anim.anim[percent];\n                break;\n            } else if (status) {\n                element.attr(anim.anim[anim.percents[i]]);\n            }\n        }\n        if (!params) {\n            return;\n        }\n        if (!isInAnim) {\n            for (var attr in params) if (params[has](attr)) {\n                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {\n                    from[attr] = element.attr(attr);\n                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);\n                    to[attr] = params[attr];\n                    switch (availableAnimAttrs[attr]) {\n                        case nu:\n                            diff[attr] = (to[attr] - from[attr]) / ms;\n                            break;\n                        case \"colour\":\n                            from[attr] = R.getRGB(from[attr]);\n                            var toColour = R.getRGB(to[attr]);\n                            diff[attr] = {\n                                r: (toColour.r - from[attr].r) / ms,\n                                g: (toColour.g - from[attr].g) / ms,\n                                b: (toColour.b - from[attr].b) / ms\n                            };\n                            break;\n                        case \"path\":\n                            var pathes = path2curve(from[attr], to[attr]),\n                                toPath = pathes[1];\n                            from[attr] = pathes[0];\n                            diff[attr] = [];\n                            for (i = 0, ii = from[attr].length; i < ii; i++) {\n                                diff[attr][i] = [0];\n                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;\n                                }\n                            }\n                            break;\n                        case \"transform\":\n                            var _ = element._,\n                                eq = equaliseTransform(_[attr], to[attr]);\n                            if (eq) {\n                                from[attr] = eq.from;\n                                to[attr] = eq.to;\n                                diff[attr] = [];\n                                diff[attr].real = true;\n                                for (i = 0, ii = from[attr].length; i < ii; i++) {\n                                    diff[attr][i] = [from[attr][i][0]];\n                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;\n                                    }\n                                }\n                            } else {\n                                var m = (element.matrix || new Matrix),\n                                    to2 = {\n                                        _: {transform: _.transform},\n                                        getBBox: function () {\n                                            return element.getBBox(1);\n                                        }\n                                    };\n                                from[attr] = [\n                                    m.a,\n                                    m.b,\n                                    m.c,\n                                    m.d,\n                                    m.e,\n                                    m.f\n                                ];\n                                extractTransform(to2, to[attr]);\n                                to[attr] = to2._.transform;\n                                diff[attr] = [\n                                    (to2.matrix.a - m.a) / ms,\n                                    (to2.matrix.b - m.b) / ms,\n                                    (to2.matrix.c - m.c) / ms,\n                                    (to2.matrix.d - m.d) / ms,\n                                    (to2.matrix.e - m.e) / ms,\n                                    (to2.matrix.f - m.f) / ms\n                                ];\n                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];\n                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};\n                                // extractTransform(to2, to[attr]);\n                                // diff[attr] = [\n                                //     (to2._.sx - _.sx) / ms,\n                                //     (to2._.sy - _.sy) / ms,\n                                //     (to2._.deg - _.deg) / ms,\n                                //     (to2._.dx - _.dx) / ms,\n                                //     (to2._.dy - _.dy) / ms\n                                // ];\n                            }\n                            break;\n                        case \"csv\":\n                            var values = Str(params[attr])[split](separator),\n                                from2 = Str(from[attr])[split](separator);\n                            if (attr == \"clip-rect\") {\n                                from[attr] = from2;\n                                diff[attr] = [];\n                                i = from2.length;\n                                while (i--) {\n                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;\n                                }\n                            }\n                            to[attr] = values;\n                            break;\n                        default:\n                            values = [][concat](params[attr]);\n                            from2 = [][concat](from[attr]);\n                            diff[attr] = [];\n                            i = element.paper.customAttributes[attr].length;\n                            while (i--) {\n                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;\n                            }\n                            break;\n                    }\n                }\n            }\n            var easing = params.easing,\n                easyeasy = R.easing_formulas[easing];\n            if (!easyeasy) {\n                easyeasy = Str(easing).match(bezierrg);\n                if (easyeasy && easyeasy.length == 5) {\n                    var curve = easyeasy;\n                    easyeasy = function (t) {\n                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);\n                    };\n                } else {\n                    easyeasy = pipe;\n                }\n            }\n            timestamp = params.start || anim.start || +new Date;\n            e = {\n                anim: anim,\n                percent: percent,\n                timestamp: timestamp,\n                start: timestamp + (anim.del || 0),\n                status: 0,\n                initstatus: status || 0,\n                stop: false,\n                ms: ms,\n                easing: easyeasy,\n                from: from,\n                diff: diff,\n                to: to,\n                el: element,\n                callback: params.callback,\n                prev: prev,\n                next: next,\n                repeat: times || anim.times,\n                origin: element.attr(),\n                totalOrigin: totalOrigin\n            };\n            animationElements.push(e);\n            if (status && !isInAnim && !isInAnimSet) {\n                e.stop = true;\n                e.start = new Date - ms * status;\n                if (animationElements.length == 1) {\n                    return animation();\n                }\n            }\n            if (isInAnimSet) {\n                e.start = new Date - e.ms * status;\n            }\n            animationElements.length == 1 && requestAnimFrame(animation);\n        } else {\n            isInAnim.initstatus = status;\n            isInAnim.start = new Date - isInAnim.ms * status;\n        }\n        eve(\"raphael.anim.start.\" + element.id, element, anim);\n    }\n    /*\\\n     * Raphael.animation\n     [ method ]\n     **\n     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.\n     * See also @Animation.delay and @Animation.repeat methods.\n     **\n     > Parameters\n     **\n     - params (object) final attributes for the element, see also @Element.attr\n     - ms (number) number of milliseconds for animation to run\n     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n     - callback (function) #optional callback function. Will be called at the end of animation.\n     **\n     = (object) @Animation\n     \\*/\n    R.animation = function (params, ms, easing, callback) {\n        if (params instanceof Animation) {\n            return params;\n        }\n        if (R.is(easing, \"function\") || !easing) {\n            callback = callback || easing || null;\n            easing = null;\n        }\n        params = Object(params);\n        ms = +ms || 0;\n        var p = {},\n            json,\n            attr;\n        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + \"%\" != attr) {\n            json = true;\n            p[attr] = params[attr];\n        }\n        if (!json) {\n            // if percent-like syntax is used and end-of-all animation callback used\n            if(callback){\n                // find the last one\n                var lastKey = 0;\n                for(var i in params){\n                    var percent = toInt(i);\n                    if(params[has](i) && percent > lastKey){\n                        lastKey = percent;\n                    }\n                }\n                lastKey += '%';\n                // if already defined callback in the last keyframe, skip\n                !params[lastKey].callback && (params[lastKey].callback = callback);\n            }\n            return new Animation(params, ms);\n        } else {\n            easing && (p.easing = easing);\n            callback && (p.callback = callback);\n            return new Animation({100: p}, ms);\n        }\n    };\n    /*\\\n     * Element.animate\n     [ method ]\n     **\n     * Creates and starts animation for given element.\n     **\n     > Parameters\n     **\n     - params (object) final attributes for the element, see also @Element.attr\n     - ms (number) number of milliseconds for animation to run\n     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n     - callback (function) #optional callback function. Will be called at the end of animation.\n     * or\n     - animation (object) animation object, see @Raphael.animation\n     **\n     = (object) original element\n     \\*/\n    elproto.animate = function (params, ms, easing, callback) {\n        var element = this;\n        if (element.removed) {\n            callback && callback.call(element);\n            return element;\n        }\n        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);\n        runAnimation(anim, element, anim.percents[0], null, element.attr());\n        return element;\n    };\n    /*\\\n     * Element.setTime\n     [ method ]\n     **\n     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.\n     **\n     > Parameters\n     **\n     - anim (object) animation object\n     - value (number) number of milliseconds from the beginning of the animation\n     **\n     = (object) original element if `value` is specified\n     * Note, that during animation following events are triggered:\n     *\n     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.\n     \\*/\n    elproto.setTime = function (anim, value) {\n        if (anim && value != null) {\n            this.status(anim, mmin(value, anim.ms) / anim.ms);\n        }\n        return this;\n    };\n    /*\\\n     * Element.status\n     [ method ]\n     **\n     * Gets or sets the status of animation of the element.\n     **\n     > Parameters\n     **\n     - anim (object) #optional animation object\n     - value (number) #optional 0  1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.\n     **\n     = (number) status\n     * or\n     = (array) status if `anim` is not specified. Array of objects in format:\n     o {\n     o     anim: (object) animation object\n     o     status: (number) status\n     o }\n     * or\n     = (object) original element if `value` is specified\n     \\*/\n    elproto.status = function (anim, value) {\n        var out = [],\n            i = 0,\n            len,\n            e;\n        if (value != null) {\n            runAnimation(anim, this, -1, mmin(value, 1));\n            return this;\n        } else {\n            len = animationElements.length;\n            for (; i < len; i++) {\n                e = animationElements[i];\n                if (e.el.id == this.id && (!anim || e.anim == anim)) {\n                    if (anim) {\n                        return e.status;\n                    }\n                    out.push({\n                        anim: e.anim,\n                        status: e.status\n                    });\n                }\n            }\n            if (anim) {\n                return 0;\n            }\n            return out;\n        }\n    };\n    /*\\\n     * Element.pause\n     [ method ]\n     **\n     * Stops animation of the element with ability to resume it later on.\n     **\n     > Parameters\n     **\n     - anim (object) #optional animation object\n     **\n     = (object) original element\n     \\*/\n    elproto.pause = function (anim) {\n        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n            if (eve(\"raphael.anim.pause.\" + this.id, this, animationElements[i].anim) !== false) {\n                animationElements[i].paused = true;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.resume\n     [ method ]\n     **\n     * Resumes animation if it was paused with @Element.pause method.\n     **\n     > Parameters\n     **\n     - anim (object) #optional animation object\n     **\n     = (object) original element\n     \\*/\n    elproto.resume = function (anim) {\n        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n            var e = animationElements[i];\n            if (eve(\"raphael.anim.resume.\" + this.id, this, e.anim) !== false) {\n                delete e.paused;\n                this.status(e.anim, e.status);\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.stop\n     [ method ]\n     **\n     * Stops animation of the element.\n     **\n     > Parameters\n     **\n     - anim (object) #optional animation object\n     **\n     = (object) original element\n     \\*/\n    elproto.stop = function (anim) {\n        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n            if (eve(\"raphael.anim.stop.\" + this.id, this, animationElements[i].anim) !== false) {\n                animationElements.splice(i--, 1);\n            }\n        }\n        return this;\n    };\n    function stopAnimation(paper) {\n        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {\n            animationElements.splice(i--, 1);\n        }\n    }\n    eve.on(\"raphael.remove\", stopAnimation);\n    eve.on(\"raphael.clear\", stopAnimation);\n    elproto.toString = function () {\n        return \"Rapha\\xebl\\u2019s object\";\n    };\n\n    // Set\n    var Set = function (items) {\n            this.items = [];\n            this.length = 0;\n            this.type = \"set\";\n            if (items) {\n                for (var i = 0, ii = items.length; i < ii; i++) {\n                    if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {\n                        this[this.items.length] = this.items[this.items.length] = items[i];\n                        this.length++;\n                    }\n                }\n            }\n        },\n        setproto = Set.prototype;\n    /*\\\n     * Set.push\n     [ method ]\n     **\n     * Adds each argument to the current set.\n     = (object) original element\n     \\*/\n    setproto.push = function () {\n        var item,\n            len;\n        for (var i = 0, ii = arguments.length; i < ii; i++) {\n            item = arguments[i];\n            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {\n                len = this.items.length;\n                this[len] = this.items[len] = item;\n                this.length++;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.pop\n     [ method ]\n     **\n     * Removes last element and returns it.\n     = (object) element\n     \\*/\n    setproto.pop = function () {\n        this.length && delete this[this.length--];\n        return this.items.pop();\n    };\n    /*\\\n     * Set.forEach\n     [ method ]\n     **\n     * Executes given function for each element in the set.\n     *\n     * If function returns `false` it will stop loop running.\n     **\n     > Parameters\n     **\n     - callback (function) function to run\n     - thisArg (object) context object for the callback\n     = (object) Set object\n     \\*/\n    setproto.forEach = function (callback, thisArg) {\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            if (callback.call(thisArg, this.items[i], i) === false) {\n                return this;\n            }\n        }\n        return this;\n    };\n    for (var method in elproto) if (elproto[has](method)) {\n        setproto[method] = (function (methodname) {\n            return function () {\n                var arg = arguments;\n                return this.forEach(function (el) {\n                    el[methodname][apply](el, arg);\n                });\n            };\n        })(method);\n    }\n    setproto.attr = function (name, value) {\n        if (name && R.is(name, array) && R.is(name[0], \"object\")) {\n            for (var j = 0, jj = name.length; j < jj; j++) {\n                this.items[j].attr(name[j]);\n            }\n        } else {\n            for (var i = 0, ii = this.items.length; i < ii; i++) {\n                this.items[i].attr(name, value);\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.clear\n     [ method ]\n     **\n     * Removes all elements from the set\n     \\*/\n    setproto.clear = function () {\n        while (this.length) {\n            this.pop();\n        }\n    };\n    /*\\\n     * Set.splice\n     [ method ]\n     **\n     * Removes given element from the set\n     **\n     > Parameters\n     **\n     - index (number) position of the deletion\n     - count (number) number of element to remove\n     - insertion (object) #optional elements to insert\n     = (object) set elements that were deleted\n     \\*/\n    setproto.splice = function (index, count, insertion) {\n        index = index < 0 ? mmax(this.length + index, 0) : index;\n        count = mmax(0, mmin(this.length - index, count));\n        var tail = [],\n            todel = [],\n            args = [],\n            i;\n        for (i = 2; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        for (i = 0; i < count; i++) {\n            todel.push(this[index + i]);\n        }\n        for (; i < this.length - index; i++) {\n            tail.push(this[index + i]);\n        }\n        var arglen = args.length;\n        for (i = 0; i < arglen + tail.length; i++) {\n            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n        }\n        i = this.items.length = this.length -= count - arglen;\n        while (this[i]) {\n            delete this[i++];\n        }\n        return new Set(todel);\n    };\n    /*\\\n     * Set.exclude\n     [ method ]\n     **\n     * Removes given element from the set\n     **\n     > Parameters\n     **\n     - element (object) element to remove\n     = (boolean) `true` if object was found & removed from the set\n     \\*/\n    setproto.exclude = function (el) {\n        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n            this.splice(i, 1);\n            return true;\n        }\n    };\n    setproto.animate = function (params, ms, easing, callback) {\n        (R.is(easing, \"function\") || !easing) && (callback = easing || null);\n        var len = this.items.length,\n            i = len,\n            item,\n            set = this,\n            collector;\n        if (!len) {\n            return this;\n        }\n        callback && (collector = function () {\n            !--len && callback.call(set);\n        });\n        easing = R.is(easing, string) ? easing : collector;\n        var anim = R.animation(params, ms, easing, collector);\n        item = this.items[--i].animate(anim);\n        while (i--) {\n            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);\n            (this.items[i] && !this.items[i].removed) || len--;\n        }\n        return this;\n    };\n    setproto.insertAfter = function (el) {\n        var i = this.items.length;\n        while (i--) {\n            this.items[i].insertAfter(el);\n        }\n        return this;\n    };\n\n    // FREEGROUP Fix: RaphaelJS changes the order of the elements of the 'set' by calling the toBack method.\n    //                \"toBack\" must be called reverse to care about the rendering order. In this case we override\n    //                the buggy default implementation here.\n    //\n    setproto.toBack = function () {\n        var i = this.items.length;\n        while (i--) {\n            this.items[i].toBack();\n        }\n        return this;\n    };\n\n    // FREEGROUP Fix: Unfortunately raphael didn'T expose the \"set.prototype\". In this case\n    //                I must add all extension to the raphael implementation itself.\n    //                Provide support method for easy check if the elements are visible.\n    setproto.isVisible = function () {\n        var i = this.items.length;\n        var visible = false;\n        while (i--) {\n            visible = visible ||this.items[i].isVisible();\n        }\n        return visible;\n    };\n\n\n    // FREEGROUP FIX: Adding \"isWithoutTransform\" to the function and redirect them to the elements\n    setproto.getBBox = function (isWithoutTransform) {\n        var x = [],\n            y = [],\n            x2 = [],\n            y2 = [];\n        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n            var box = this.items[i].getBBox(isWithoutTransform);\n            x.push(box.x);\n            y.push(box.y);\n            x2.push(box.x + box.width);\n            y2.push(box.y + box.height);\n        }\n        x = mmin[apply](0, x);\n        y = mmin[apply](0, y);\n        x2 = mmax[apply](0, x2);\n        y2 = mmax[apply](0, y2);\n        return {\n            x: x,\n            y: y,\n            x2: x2,\n            y2: y2,\n            width: x2 - x,\n            height: y2 - y\n        };\n    };\n    setproto.clone = function (s) {\n        s = this.paper.set();\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            s.push(this.items[i].clone());\n        }\n        return s;\n    };\n    setproto.toString = function () {\n        return \"Rapha\\xebl\\u2018s set\";\n    };\n\n    setproto.glow = function(glowConfig) {\n        var ret = this.paper.set();\n        this.forEach(function(shape, index){\n            var g = shape.glow(glowConfig);\n            if(g != null){\n                g.forEach(function(shape2, index2){\n                    ret.push(shape2);\n                });\n            }\n        });\n        return ret;\n    };\n\n\n    /*\\\n     * Set.isPointInside\n     [ method ]\n     **\n     * Determine if given point is inside this sets elements\n     **\n     > Parameters\n     **\n     - x (number) x coordinate of the point\n     - y (number) y coordinate of the point\n     = (boolean) `true` if point is inside any of the set's elements\n     \\*/\n    setproto.isPointInside = function (x, y) {\n        var isPointInside = false;\n        this.forEach(function (el) {\n            if (el.isPointInside(x, y)) {\n                isPointInside = true;\n                return false; // stop loop\n            }\n        });\n        return isPointInside;\n    };\n\n    /*\\\n     * Raphael.registerFont\n     [ method ]\n     **\n     * Adds given font to the registered set of fonts for Raphal. Should be used as an internal call from within Cufns font file.\n     * Returns original parameter, so it could be used with chaining.\n     # <a href=\"http://wiki.github.com/sorccu/cufon/about\">More about Cufn and how to convert your font form TTF, OTF, etc to JavaScript file.</a>\n     **\n     > Parameters\n     **\n     - font (object) the font to register\n     = (object) the font you passed in\n     > Usage\n     | Cufon.registerFont(Raphael.registerFont({}));\n     \\*/\n    R.registerFont = function (font) {\n        if (!font.face) {\n            return font;\n        }\n        this.fonts = this.fonts || {};\n        var fontcopy = {\n                w: font.w,\n                face: {},\n                glyphs: {}\n            },\n            family = font.face[\"font-family\"];\n        for (var prop in font.face) if (font.face[has](prop)) {\n            fontcopy.face[prop] = font.face[prop];\n        }\n        if (this.fonts[family]) {\n            this.fonts[family].push(fontcopy);\n        } else {\n            this.fonts[family] = [fontcopy];\n        }\n        if (!font.svg) {\n            fontcopy.face[\"units-per-em\"] = toInt(font.face[\"units-per-em\"], 10);\n            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {\n                var path = font.glyphs[glyph];\n                fontcopy.glyphs[glyph] = {\n                    w: path.w,\n                    k: {},\n                    d: path.d && \"M\" + path.d.replace(/[mlcxtrv]/g, function (command) {\n                        return {l: \"L\", c: \"C\", x: \"z\", t: \"m\", r: \"l\", v: \"c\"}[command] || \"M\";\n                    }) + \"z\"\n                };\n                if (path.k) {\n                    for (var k in path.k) if (path[has](k)) {\n                        fontcopy.glyphs[glyph].k[k] = path.k[k];\n                    }\n                }\n            }\n        }\n        return font;\n    };\n    /*\\\n     * Paper.getFont\n     [ method ]\n     **\n     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like Myriad for Myriad Pro.\n     **\n     > Parameters\n     **\n     - family (string) font family name or any word from it\n     - weight (string) #optional font weight\n     - style (string) #optional font style\n     - stretch (string) #optional font stretch\n     = (object) the font object\n     > Usage\n     | paper.print(100, 100, \"Test string\", paper.getFont(\"Times\", 800), 30);\n     \\*/\n    paperproto.getFont = function (family, weight, style, stretch) {\n        stretch = stretch || \"normal\";\n        style = style || \"normal\";\n        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;\n        if (!R.fonts) {\n            return;\n        }\n        var font = R.fonts[family];\n        if (!font) {\n            var name = new RegExp(\"(^|\\\\s)\" + family.replace(/[^\\w\\d\\s+!~.:_-]/g, E) + \"(\\\\s|$)\", \"i\");\n            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {\n                if (name.test(fontName)) {\n                    font = R.fonts[fontName];\n                    break;\n                }\n            }\n        }\n        var thefont;\n        if (font) {\n            for (var i = 0, ii = font.length; i < ii; i++) {\n                thefont = font[i];\n                if (thefont.face[\"font-weight\"] == weight && (thefont.face[\"font-style\"] == style || !thefont.face[\"font-style\"]) && thefont.face[\"font-stretch\"] == stretch) {\n                    break;\n                }\n            }\n        }\n        return thefont;\n    };\n    /*\\\n     * Paper.print\n     [ method ]\n     **\n     * Creates path that represent given text written using given font at given position with given size.\n     * Result of the method is path element that contains whole text as a separate path.\n     **\n     > Parameters\n     **\n     - x (number) x position of the text\n     - y (number) y position of the text\n     - string (string) text to print\n     - font (object) font object, see @Paper.getFont\n     - size (number) #optional size of the font, default is `16`\n     - origin (string) #optional could be `\"baseline\"` or `\"middle\"`, default is `\"middle\"`\n     - letter_spacing (number) #optional number in range `-1..1`, default is `0`\n     - line_spacing (number) #optional number in range `1..3`, default is `1`\n     = (object) resulting path element, which consist of all letters\n     > Usage\n     | var txt = r.print(10, 50, \"print\", r.getFont(\"Museo\"), 30).attr({fill: \"#fff\"});\n     \\*/\n    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {\n        origin = origin || \"middle\"; // baseline|middle\n        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);\n        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);\n        var letters = Str(string)[split](E),\n            shift = 0,\n            notfirst = 0,\n            path = E,\n            scale;\n        R.is(font, \"string\") && (font = this.getFont(font));\n        if (font) {\n            scale = (size || 16) / font.face[\"units-per-em\"];\n            var bb = font.face.bbox[split](separator),\n                top = +bb[0],\n                lineHeight = bb[3] - bb[1],\n                shifty = 0,\n                height = +bb[1] + (origin == \"baseline\" ? lineHeight + (+font.face.descent) : lineHeight / 2);\n            for (var i = 0, ii = letters.length; i < ii; i++) {\n                if (letters[i] == \"\\n\") {\n                    shift = 0;\n                    curr = 0;\n                    notfirst = 0;\n                    shifty += lineHeight * line_spacing;\n                } else {\n                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},\n                        curr = font.glyphs[letters[i]];\n                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;\n                    notfirst = 1;\n                }\n                if (curr && curr.d) {\n                    path += R.transformPath(curr.d, [\"t\", shift * scale, shifty * scale, \"s\", scale, scale, top, height, \"t\", (x - top) / scale, (y - height) / scale]);\n                }\n            }\n        }\n        return this.path(path).attr({\n            fill: \"#000\",\n            stroke: \"none\"\n        });\n    };\n\n    /*\\\n     * Paper.add\n     [ method ]\n     **\n     * Imports elements in JSON array in format `{type: type, <attributes>}`\n     **\n     > Parameters\n     **\n     - json (array)\n     = (object) resulting set of imported elements\n     > Usage\n     | paper.add([\n     |     {\n     |         type: \"circle\",\n     |         cx: 10,\n     |         cy: 10,\n     |         r: 5\n     |     },\n     |     {\n     |         type: \"rect\",\n     |         x: 10,\n     |         y: 10,\n     |         width: 10,\n     |         height: 10,\n     |         fill: \"#fc0\"\n     |     }\n     | ]);\n     \\*/\n    paperproto.add = function (json) {\n        if (R.is(json, \"array\")) {\n            var res = this.set(),\n                i = 0,\n                ii = json.length,\n                j;\n            for (; i < ii; i++) {\n                j = json[i] || {};\n                elements[has](j.type) && res.push(this[j.type]().attr(j));\n            }\n        }\n        return res;\n    };\n\n    /*\\\n     * Raphael.format\n     [ method ]\n     **\n     * Simple format function. Replaces construction of type `{<number>}` to the corresponding argument.\n     **\n     > Parameters\n     **\n     - token (string) string to format\n     -  (string) rest of arguments will be treated as parameters for replacement\n     = (string) formated string\n     > Usage\n     | var x = 10,\n     |     y = 20,\n     |     width = 40,\n     |     height = 50;\n     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n     | paper.path(Raphael.format(\"M{0},{1}h{2}v{3}h{4}z\", x, y, width, height, -width));\n     \\*/\n    R.format = function (token, params) {\n        var args = R.is(params, array) ? [0][concat](params) : arguments;\n        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {\n            return args[++i] == null ? E : args[i];\n        }));\n        return token || E;\n    };\n    /*\\\n     * Raphael.fullfill\n     [ method ]\n     **\n     * A little bit more advanced format function than @Raphael.format. Replaces construction of type `{<name>}` to the corresponding argument.\n     **\n     > Parameters\n     **\n     - token (string) string to format\n     - json (object) object which properties will be used as a replacement\n     = (string) formated string\n     > Usage\n     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n     | paper.path(Raphael.fullfill(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n     |     x: 10,\n     |     y: 20,\n     |     dim: {\n     |         width: 40,\n     |         height: 50,\n     |         \"negative width\": -40\n     |     }\n     | }));\n     \\*/\n    R.fullfill = (function () {\n        var tokenRegex = /\\{([^\\}]+)\\}/g,\n            objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n            replacer = function (all, key, obj) {\n                var res = obj;\n                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n                    name = name || quotedName;\n                    if (res) {\n                        if (name in res) {\n                            res = res[name];\n                        }\n                        typeof res == \"function\" && isFunc && (res = res());\n                    }\n                });\n                res = (res == null || res == obj ? all : res) + \"\";\n                return res;\n            };\n        return function (str, obj) {\n            return String(str).replace(tokenRegex, function (all, key) {\n                return replacer(all, key, obj);\n            });\n        };\n    })();\n    /*\\\n     * Raphael.ninja\n     [ method ]\n     **\n     * If you want to leave no trace of Raphal (Well, Raphal creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.\n     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.\n     **\n     = (object) Raphael object\n     > Usage\n     | (function (local_raphael) {\n     |     var paper = local_raphael(10, 10, 320, 200);\n     |     \n     | })(Raphael.ninja());\n     \\*/\n    R.ninja = function () {\n        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;\n        return R;\n    };\n    /*\\\n     * Raphael.st\n     [ property (object) ]\n     **\n     * You can add your own method to elements and sets. It is wise to add a set method for each element method\n     * you added, so you will be able to call the same method on sets too.\n     **\n     * See also @Raphael.el.\n     > Usage\n     | Raphael.el.red = function () {\n     |     this.attr({fill: \"#f00\"});\n     | };\n     | Raphael.st.red = function () {\n     |     this.forEach(function (el) {\n     |         el.red();\n     |     });\n     | };\n     | // then use it\n     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();\n     \\*/\n    R.st = setproto;\n\n    eve.on(\"raphael.DOMload\", function () {\n        loaded = true;\n    });\n\n    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n    (function (doc, loaded, f) {\n        if (doc.readyState == null && doc.addEventListener){\n            doc.addEventListener(loaded, f = function () {\n                doc.removeEventListener(loaded, f, false);\n                doc.readyState = \"complete\";\n            }, false);\n            doc.readyState = \"loading\";\n        }\n        function isLoaded() {\n            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve(\"raphael.DOMload\");\n        }\n        isLoaded();\n    })(document, \"DOMContentLoaded\");\n\n    return R;\n}));\n\n//  \\\\\n//  Raphal 2.1.4 - JavaScript Vector Library                        \\\\\n//  \\\\\n//  SVG Module                                                           \\\\\n//  \\\\\n//  Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)    \\\\\n//  Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)              \\\\\n//  Licensed under the MIT (http://raphaeljs.com/license.html) license.  \\\\\n//  \\\\\n\n(function (glob, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(\"raphael.svg\", [\"raphael.core\"], function(raphael) {\n            return factory(raphael);\n        });\n    } else if (typeof exports === \"object\") {\n        factory(require(\"./raphael.core\"));\n    } else {\n        factory(glob.Raphael);\n    }\n}(this, function(R) {\n    if (R && !R.svg) {\n        return;\n    }\n\n    var has = \"hasOwnProperty\",\n        Str = String,\n        toFloat = parseFloat,\n        toInt = parseInt,\n        math = Math,\n        mmax = math.max,\n        abs = math.abs,\n        pow = math.pow,\n        separator = /[, ]+/,\n        eve = R.eve,\n        E = \"\",\n        S = \" \";\n    var xlink = \"http://www.w3.org/1999/xlink\",\n        markers = {\n            block: \"M5,0 0,2.5 5,5z\",\n            classic: \"M5,0 0,2.5 5,5 3.5,3 3.5,2z\",\n            diamond: \"M2.5,0 5,2.5 2.5,5 0,2.5z\",\n            open: \"M6,1 1,3.5 6,6\",\n            oval: \"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z\"\n        },\n        markerCounter = {};\n    R.toString = function () {\n        return  \"Your browser supports SVG.\\nYou are running Rapha\\xebl \" + this.version;\n    };\n    var $ = function (el, attr) {\n            if (attr) {\n                if (typeof el == \"string\") {\n                    el = $(el);\n                }\n                for (var key in attr) if (attr[has](key)) {\n                    if (key.substring(0, 6) == \"xlink:\") {\n                        el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));\n                    } else {\n                        el.setAttribute(key, Str(attr[key]));\n                    }\n                }\n            } else {\n                el = R._g.doc.createElementNS(\"http://www.w3.org/2000/svg\", el);\n                el.style && (el.style.webkitTapHighlightColor = \"rgba(0,0,0,0)\");\n            }\n            return el;\n        },\n        addGradientFill = function (element, gradient) {\n            var type = \"linear\",\n                id = element.id + gradient,\n                fx = .5, fy = .5,\n                o = element.node,\n                SVG = element.paper,\n                s = o.style,\n                el = R._g.doc.getElementById(id);\n            if (!el) {\n                gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {\n                    type = \"radial\";\n                    if (_fx && _fy) {\n                        fx = toFloat(_fx);\n                        fy = toFloat(_fy);\n                        var dir = ((fy > .5) * 2 - 1);\n                        pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&\n                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&\n                        fy != .5 &&\n                        (fy = fy.toFixed(5) - 1e-5 * dir);\n                    }\n                    return E;\n                });\n                gradient = gradient.split(/\\s*\\-\\s*/);\n                if (type == \"linear\") {\n                    var angle = gradient.shift();\n                    angle = -toFloat(angle);\n                    if (isNaN(angle)) {\n                        return null;\n                    }\n                    var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],\n                        max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);\n                    vector[2] *= max;\n                    vector[3] *= max;\n                    if (vector[2] < 0) {\n                        vector[0] = -vector[2];\n                        vector[2] = 0;\n                    }\n                    if (vector[3] < 0) {\n                        vector[1] = -vector[3];\n                        vector[3] = 0;\n                    }\n                }\n                var dots = R._parseDots(gradient);\n                if (!dots) {\n                    return null;\n                }\n                id = id.replace(/[\\(\\)\\s,\\xb0#]/g, \"_\");\n\n                if (element.gradient && id != element.gradient.id) {\n                    SVG.defs.removeChild(element.gradient);\n                    delete element.gradient;\n                }\n\n                if (!element.gradient) {\n                    el = $(type + \"Gradient\", {id: id});\n                    element.gradient = el;\n                    $(el, type == \"radial\" ? {\n                        fx: fx,\n                        fy: fy\n                    } : {\n                        x1: vector[0],\n                        y1: vector[1],\n                        x2: vector[2],\n                        y2: vector[3],\n                        gradientTransform: element.matrix.invert()\n                    });\n                    SVG.defs.appendChild(el);\n                    for (var i = 0, ii = dots.length; i < ii; i++) {\n                        el.appendChild($(\"stop\", {\n                            offset: dots[i].offset ? dots[i].offset : i ? \"100%\" : \"0%\",\n                            \"stop-color\": dots[i].color || \"#fff\",\n                            \"stop-opacity\": isFinite(dots[i].opacity) ? dots[i].opacity : 1\n                        }));\n                    }\n                }\n            }\n            /* FREEGROUP: don't push URL parameter into the drawing. This will break Apps with \"?\" in the URL\n             * see: https://github.com/DmitryBaranovskiy/raphael/issues/693\n             **/\n            var url =\"\";//document.location.protocol + \"//\" + document.location.host  + document.location.pathname;\n            $(o, {\n                fill: \"url('\" + url + \"#\" + id + \"')\",\n                opacity: 1,\n                \"fill-opacity\": 1\n            });\n\n            s.fill = E;\n            s.opacity = 1;\n            s.fillOpacity = 1;\n            return 1;\n        },\n        updatePosition = function (o) {\n            var bbox = o.getBBox(1);\n            $(o.pattern, {patternTransform: o.matrix.invert() + \" translate(\" + bbox.x + \",\" + bbox.y + \")\"});\n        },\n        addArrow = function (o, value, isEnd) {\n            if (o.type == \"path\") {\n                var values = Str(value).toLowerCase().split(\"-\"),\n                    p = o.paper,\n                    se = isEnd ? \"end\" : \"start\",\n                    node = o.node,\n                    attrs = o.attrs,\n                    stroke = attrs[\"stroke-width\"],\n                    i = values.length,\n                    type = \"classic\",\n                    from,\n                    to,\n                    dx,\n                    refX,\n                    attr,\n                    w = 3,\n                    h = 3,\n                    t = 5;\n                while (i--) {\n                    switch (values[i]) {\n                        case \"block\":\n                        case \"classic\":\n                        case \"oval\":\n                        case \"diamond\":\n                        case \"open\":\n                        case \"none\":\n                            type = values[i];\n                            break;\n                        case \"wide\": h = 5; break;\n                        case \"narrow\": h = 2; break;\n                        case \"long\": w = 5; break;\n                        case \"short\": w = 2; break;\n                    }\n                }\n                if (type == \"open\") {\n                    w += 2;\n                    h += 2;\n                    t += 2;\n                    dx = 1;\n                    refX = isEnd ? 4 : 1;\n                    attr = {\n                        fill: \"none\",\n                        stroke: attrs.stroke\n                    };\n                } else {\n                    refX = dx = w / 2;\n                    attr = {\n                        fill: attrs.stroke,\n                        stroke: \"none\"\n                    };\n                }\n                if (o._.arrows) {\n                    if (isEnd) {\n                        o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;\n                        o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;\n                    } else {\n                        o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;\n                        o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;\n                    }\n                } else {\n                    o._.arrows = {};\n                }\n                if (type != \"none\") {\n                    var pathId = \"raphael-marker-\" + type,\n                        markerId = \"raphael-marker-\" + se + type + w + h + \"-obj\" + o.id;\n                    if (!R._g.doc.getElementById(pathId)) {\n                        p.defs.appendChild($($(\"path\"), {\n                            \"stroke-linecap\": \"round\",\n                            d: markers[type],\n                            id: pathId\n                        }));\n                        markerCounter[pathId] = 1;\n                    } else {\n                        markerCounter[pathId]++;\n                    }\n                    var marker = R._g.doc.getElementById(markerId),\n                        use;\n                    if (!marker) {\n                        marker = $($(\"marker\"), {\n                            id: markerId,\n                            markerHeight: h,\n                            markerWidth: w,\n                            orient: \"auto\",\n                            refX: refX,\n                            refY: h / 2\n                        });\n                        use = $($(\"use\"), {\n                            \"xlink:href\": \"#\" + pathId,\n                            transform: (isEnd ? \"rotate(180 \" + w / 2 + \" \" + h / 2 + \") \" : E) + \"scale(\" + w / t + \",\" + h / t + \")\",\n                            \"stroke-width\": (1 / ((w / t + h / t) / 2)).toFixed(4)\n                        });\n                        marker.appendChild(use);\n                        p.defs.appendChild(marker);\n                        markerCounter[markerId] = 1;\n                    } else {\n                        markerCounter[markerId]++;\n                        use = marker.getElementsByTagName(\"use\")[0];\n                    }\n                    $(use, attr);\n                    var delta = dx * (type != \"diamond\" && type != \"oval\");\n                    if (isEnd) {\n                        from = o._.arrows.startdx * stroke || 0;\n                        to = R.getTotalLength(attrs.path) - delta * stroke;\n                    } else {\n                        from = delta * stroke;\n                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n                    }\n                    attr = {};\n                    attr[\"marker-\" + se] = \"url(#\" + markerId + \")\";\n                    if (to || from) {\n                        attr.d = R.getSubpath(attrs.path, from, to);\n                    }\n                    $(node, attr);\n                    o._.arrows[se + \"Path\"] = pathId;\n                    o._.arrows[se + \"Marker\"] = markerId;\n                    o._.arrows[se + \"dx\"] = delta;\n                    o._.arrows[se + \"Type\"] = type;\n                    o._.arrows[se + \"String\"] = value;\n                } else {\n                    if (isEnd) {\n                        from = o._.arrows.startdx * stroke || 0;\n                        to = R.getTotalLength(attrs.path) - from;\n                    } else {\n                        from = 0;\n                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n                    }\n                    o._.arrows[se + \"Path\"] && $(node, {d: R.getSubpath(attrs.path, from, to)});\n                    delete o._.arrows[se + \"Path\"];\n                    delete o._.arrows[se + \"Marker\"];\n                    delete o._.arrows[se + \"dx\"];\n                    delete o._.arrows[se + \"Type\"];\n                    delete o._.arrows[se + \"String\"];\n                }\n                for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {\n                    var item = R._g.doc.getElementById(attr);\n                    item && item.parentNode.removeChild(item);\n                }\n            }\n        },\n        dasharray = {\n            \"-\": [3, 1],\n            \".\": [1, 1],\n            \"-.\": [3, 1, 1, 1],\n            \"-..\": [3, 1, 1, 1, 1, 1],\n            \". \": [1, 3],\n            \"- \": [4, 3],\n            \"--\": [8, 3],\n            \"- .\": [4, 3, 1, 3],\n            \"--.\": [8, 3, 1, 3],\n            \"--..\": [8, 3, 1, 3, 1, 3]\n        },\n        addDashes = function (o, value, params) {\n            value = dasharray[Str(value).toLowerCase()];\n            if (value) {\n                var width = o.attrs[\"stroke-width\"] || \"1\",\n                    butt = {round: width, square: width, butt: 0}[o.attrs[\"stroke-linecap\"] || params[\"stroke-linecap\"]] || 0,\n                    dashes = [],\n                    i = value.length;\n                while (i--) {\n                    dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;\n                }\n                $(o.node, {\"stroke-dasharray\": dashes.join(\",\")});\n            }\n            else {\n                $(o.node, {\"stroke-dasharray\": \"none\"});\n            }\n        },\n        setFillAndStroke = function (o, params) {\n            var node = o.node,\n                attrs = o.attrs,\n                vis = node.style.visibility;\n            node.style.visibility = \"hidden\";\n            for (var att in params) {\n                if (params[has](att)) {\n                    if (!R._availableAttrs[has](att)) {\n                        continue;\n                    }\n                    var value = params[att];\n                    attrs[att] = value;\n                    switch (att) {\n                        case \"blur\":\n                            o.blur(value);\n                            break;\n                        case \"title\":\n                            var title = node.getElementsByTagName(\"title\");\n\n                            // Use the existing <title>.\n                            if (title.length && (title = title[0])) {\n                                title.firstChild.nodeValue = value;\n                            } else {\n                                title = $(\"title\");\n                                var val = R._g.doc.createTextNode(value);\n                                title.appendChild(val);\n                                node.appendChild(title);\n                            }\n                            break;\n                        case \"href\":\n                        case \"target\":\n                            var pn = node.parentNode;\n                            if (pn.tagName.toLowerCase() != \"a\") {\n                                var hl = $(\"a\");\n                                pn.insertBefore(hl, node);\n                                hl.appendChild(node);\n                                pn = hl;\n                            }\n                            if (att == \"target\") {\n                                pn.setAttributeNS(xlink, \"show\", value == \"blank\" ? \"new\" : value);\n                            } else {\n                                pn.setAttributeNS(xlink, att, value);\n                            }\n                            break;\n                        case \"cursor\":\n                            node.style.cursor = value;\n                            break;\n                        case \"transform\":\n                            o.transform(value);\n                            break;\n                        case \"arrow-start\":\n                            addArrow(o, value);\n                            break;\n                        case \"arrow-end\":\n                            addArrow(o, value, 1);\n                            break;\n                        case \"clip-rect\":\n                            var rect = Str(value).split(separator);\n                            if (rect.length == 4) {\n                                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);\n                                var el = $(\"clipPath\"),\n                                    rc = $(\"rect\");\n                                el.id = R.createUUID();\n                                $(rc, {\n                                    x: rect[0],\n                                    y: rect[1],\n                                    width: rect[2],\n                                    height: rect[3]\n                                });\n                                el.appendChild(rc);\n                                o.paper.defs.appendChild(el);\n                                $(node, {\"clip-path\": \"url(#\" + el.id + \")\"});\n                                o.clip = rc;\n                            }\n                            if (!value) {\n                                var path = node.getAttribute(\"clip-path\");\n                                if (path) {\n                                    var clip = R._g.doc.getElementById(path.replace(/(^url\\(#|\\)$)/g, E));\n                                    clip && clip.parentNode.removeChild(clip);\n                                    $(node, {\"clip-path\": E});\n                                    delete o.clip;\n                                }\n                            }\n                            break;\n                        case \"path\":\n                            if (o.type == \"path\") {\n                                $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : \"M0,0\"});\n                                o._.dirty = 1;\n                                if (o._.arrows) {\n                                    \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                                    \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                                }\n                            }\n                            break;\n                        case \"width\":\n                            node.setAttribute(att, value);\n                            o._.dirty = 1;\n                            if (attrs.fx) {\n                                att = \"x\";\n                                value = attrs.x;\n                            } else {\n                                break;\n                            }\n                        case \"x\":\n                            if (attrs.fx) {\n                                value = -attrs.x - (attrs.width || 0);\n                            }\n                        case \"rx\":\n                            if (att == \"rx\" && o.type == \"rect\") {\n                                break;\n                            }\n                        case \"cx\":\n                            node.setAttribute(att, value);\n                            o.pattern && updatePosition(o);\n                            o._.dirty = 1;\n                            break;\n                        case \"height\":\n                            node.setAttribute(att, value);\n                            o._.dirty = 1;\n                            if (attrs.fy) {\n                                att = \"y\";\n                                value = attrs.y;\n                            } else {\n                                break;\n                            }\n                        case \"y\":\n                            if (attrs.fy) {\n                                value = -attrs.y - (attrs.height || 0);\n                            }\n                        case \"ry\":\n                            if (att == \"ry\" && o.type == \"rect\") {\n                                break;\n                            }\n                        case \"cy\":\n                            node.setAttribute(att, value);\n                            o.pattern && updatePosition(o);\n                            o._.dirty = 1;\n                            break;\n                        case \"r\":\n                            if (o.type == \"rect\") {\n                                $(node, {rx: value, ry: value});\n                            } else {\n                                node.setAttribute(att, value);\n                            }\n                            o._.dirty = 1;\n                            break;\n                        case \"src\":\n                            if (o.type == \"image\") {\n                                node.setAttributeNS(xlink, \"href\", value);\n                            }\n                            break;\n                        case \"stroke-width\":\n                            /* FREEGROUP fix\n                             * draw2d version 3.0.3\n                             *\n                             * don't scale the line width if the user resize an shape/element.\n                             * Obscure stroke-width in case of \"Draw2D touch\" usage\n                             */\n                            if(!attrs[\"stroke-scale\"]){\n                                if (o._.sx != 1 || o._.sy != 1) {\n                                    value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;\n                                }\n                                if (o.paper._vbSize) {\n                                //    value *= o.paper._vbSize;\n                                }\n                            }\n\n\n                            node.setAttribute(att, value);\n                            if (attrs[\"stroke-dasharray\"]) {\n                                addDashes(o, attrs[\"stroke-dasharray\"], params);\n                            }\n                            if (o._.arrows) {\n                                \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                                \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                            }\n                            break;\n                        case \"stroke-dasharray\":\n                            addDashes(o, value, params);\n                            break;\n                        case \"fill\":\n                            var isURL = Str(value).match(R._ISURL);\n                            if (isURL) {\n                                el = $(\"pattern\");\n                                var ig = $(\"image\");\n                                el.id = R.createUUID();\n                                $(el, {x: 0, y: 0, patternUnits: \"userSpaceOnUse\", height: 1, width: 1});\n                                $(ig, {x: 0, y: 0, \"xlink:href\": isURL[1]});\n                                el.appendChild(ig);\n\n                                (function (el) {\n                                    R._preload(isURL[1], function () {\n                                        var w = this.offsetWidth,\n                                            h = this.offsetHeight;\n                                        $(el, {width: w, height: h});\n                                        $(ig, {width: w, height: h});\n                                    });\n                                })(el);\n                                o.paper.defs.appendChild(el);\n                                $(node, {fill: \"url(#\" + el.id + \")\"});\n                                o.pattern = el;\n                                o.pattern && updatePosition(o);\n                                break;\n                            }\n                            var clr = R.getRGB(value);\n                            if (!clr.error) {\n                                delete params.gradient;\n                                delete attrs.gradient;\n                                !R.is(attrs.opacity, \"undefined\") &&\n                                R.is(params.opacity, \"undefined\") &&\n                                $(node, {opacity: attrs.opacity});\n                                !R.is(attrs[\"fill-opacity\"], \"undefined\") &&\n                                R.is(params[\"fill-opacity\"], \"undefined\") &&\n                                $(node, {\"fill-opacity\": attrs[\"fill-opacity\"]});\n                            } else if ((o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value)) {\n                                if (\"opacity\" in attrs || \"fill-opacity\" in attrs) {\n                                    var gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n                                    if (gradient) {\n                                        var stops = gradient.getElementsByTagName(\"stop\");\n                                        $(stops[stops.length - 1], {\"stop-opacity\": (\"opacity\" in attrs ? attrs.opacity : 1) * (\"fill-opacity\" in attrs ? attrs[\"fill-opacity\"] : 1)});\n                                    }\n                                }\n                                attrs.gradient = value;\n                                attrs.fill = \"none\";\n                                break;\n                            }\n                            clr[has](\"opacity\") && $(node, {\"fill-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});\n                        case \"stroke\":\n                            clr = R.getRGB(value);\n                            node.setAttribute(att, clr.hex);\n                            att == \"stroke\" && clr[has](\"opacity\") && $(node, {\"stroke-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});\n                            if (att == \"stroke\" && o._.arrows) {\n                                \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n                                \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n                            }\n                            break;\n                        case \"gradient\":\n                            (o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value);\n                            break;\n                        case \"opacity\":\n                            if (attrs.gradient && !attrs[has](\"stroke-opacity\")) {\n                                $(node, {\"stroke-opacity\": value > 1 ? value / 100 : value});\n                            }\n                        // fall\n                        case \"fill-opacity\":\n                            if (attrs.gradient) {\n                                gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n                                if (gradient) {\n                                    stops = gradient.getElementsByTagName(\"stop\");\n                                    // FREEGROUP FIX\n                                    for (gri = 0, grii = stops.length; gri < grii; gri++) {\n                                        $(stops[gri], {\"stop-opacity\": value});\n                                    }\n                                    // END FIX\n                                }\n                                break;\n                            }\n                        default:\n                            att == \"font-size\" && (value = toInt(value, 10) + \"px\");\n                            var cssrule = att.replace(/(\\-.)/g, function (w) {\n                                return w.substring(1).toUpperCase();\n                            });\n                            node.style[cssrule] = value;\n                            o._.dirty = 1;\n                            node.setAttribute(att, value);\n                            break;\n                    }\n                }\n            }\n\n            tuneText(o, params);\n            node.style.visibility = vis;\n        },\n        leading = 1.2,\n        tuneText = function (el, params) {\n            if (el.type != \"text\" || !(params[has](\"text\") || params[has](\"font\") || params[has](\"font-size\") || params[has](\"x\") || params[has](\"y\"))) {\n                return;\n            }\n            var a = el.attrs,\n                node = el.node,\n                fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue(\"font-size\"), 10) : 10;\n\n            if (params[has](\"text\")) {\n                a.text = params.text;\n                while (node.firstChild) {\n                    node.removeChild(node.firstChild);\n                }\n                var texts = Str(params.text).split(\"\\n\"),\n                    tspans = [],\n                    tspan;\n                for (var i = 0, ii = texts.length; i < ii; i++) {\n                    tspan = $(\"tspan\");\n                    i && $(tspan, {dy: fontSize * leading, x: a.x});\n                    tspan.appendChild(R._g.doc.createTextNode(texts[i]));\n                    node.appendChild(tspan);\n                    tspans[i] = tspan;\n                }\n            } else {\n                tspans = node.getElementsByTagName(\"tspan\");\n                for (i = 0, ii = tspans.length; i < ii; i++) if (i) {\n                    $(tspans[i], {dy: fontSize * leading, x: a.x});\n                } else {\n                    $(tspans[0], {dy: 0});\n                }\n            }\n            $(node, {x: a.x, y: a.y});\n            el._.dirty = 1;\n            var bb = el._getBBox(),\n                dif = a.y - (bb.y + bb.height / 2);\n            dif && R.is(dif, \"finite\") && $(tspans[0], {dy: dif});\n        },\n        getRealNode = function (node) {\n            if (node.parentNode && node.parentNode.tagName.toLowerCase() === \"a\") {\n                return node.parentNode;\n            } else {\n                return node;\n            }\n        },\n        Element = function (node, svg) {\n            var X = 0,\n                Y = 0;\n            /*\\\n             * Element.node\n             [ property (object) ]\n             **\n             * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n             **\n             * Note: Dont mess with it.\n             > Usage\n             | // draw a circle at coordinate 10,10 with radius of 10\n             | var c = paper.circle(10, 10, 10);\n             | c.node.onclick = function () {\n             |     c.attr(\"fill\", \"red\");\n             | };\n             \\*/\n            this[0] = this.node = node;\n            /*\\\n             * Element.raphael\n             [ property (object) ]\n             **\n             * Internal reference to @Raphael object. In case it is not available.\n             > Usage\n             | Raphael.el.red = function () {\n             |     var hsb = this.paper.raphael.rgb2hsb(this.attr(\"fill\"));\n             |     hsb.h = 1;\n             |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});\n             | }\n             \\*/\n            node.raphael = true;\n            /*\\\n             * Element.id\n             [ property (number) ]\n             **\n             * Unique id of the element. Especially useful when you want to listen to events of the element,\n             * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.\n             \\*/\n            this.id = R._oid++;\n            node.raphaelid = this.id;\n            this.matrix = R.matrix();\n            this.realPath = null;\n            /*\\\n             * Element.paper\n             [ property (object) ]\n             **\n             * Internal reference to paper where object drawn. Mainly for use in plugins and element extensions.\n             > Usage\n             | Raphael.el.cross = function () {\n             |     this.attr({fill: \"red\"});\n             |     this.paper.path(\"M10,10L50,50M50,10L10,50\")\n             |         .attr({stroke: \"red\"});\n             | }\n             \\*/\n            this.paper = svg;\n            this.attrs = this.attrs || {};\n            this._ = {\n                transform: [],\n                sx: 1,\n                sy: 1,\n                deg: 0,\n                dx: 0,\n                dy: 0,\n                dirty: 1\n            };\n            !svg.bottom && (svg.bottom = this);\n            /*\\\n             * Element.prev\n             [ property (object) ]\n             **\n             * Reference to the previous element in the hierarchy.\n             \\*/\n            this.prev = svg.top;\n            svg.top && (svg.top.next = this);\n            svg.top = this;\n            /*\\\n             * Element.next\n             [ property (object) ]\n             **\n             * Reference to the next element in the hierarchy.\n             \\*/\n            this.next = null;\n        },\n        elproto = R.el;\n\n    Element.prototype = elproto;\n    elproto.constructor = Element;\n\n    R._engine.path = function (pathString, SVG) {\n        var el = $(\"path\");\n        SVG.canvas && SVG.canvas.appendChild(el);\n        var p = new Element(el, SVG);\n        p.type = \"path\";\n        setFillAndStroke(p, {\n            fill: \"none\",\n            stroke: \"#000\",\n            path: pathString\n        });\n        return p;\n    };\n    /*\\\n     * Element.rotate\n     [ method ]\n     **\n     * Deprecated! Use @Element.transform instead.\n     * Adds rotation by given angle around given point to the list of\n     * transformations of the element.\n     > Parameters\n     - deg (number) angle in degrees\n     - cx (number) #optional x coordinate of the centre of rotation\n     - cy (number) #optional y coordinate of the centre of rotation\n     * If cx & cy arent specified centre of the shape is used as a point of rotation.\n     = (object) @Element\n     \\*/\n    elproto.rotate = function (deg, cx, cy) {\n        if (this.removed) {\n            return this;\n        }\n        deg = Str(deg).split(separator);\n        if (deg.length - 1) {\n            cx = toFloat(deg[1]);\n            cy = toFloat(deg[2]);\n        }\n        deg = toFloat(deg[0]);\n        (cy == null) && (cx = cy);\n        if (cx == null || cy == null) {\n            var bbox = this.getBBox(1);\n            cx = bbox.x + bbox.width / 2;\n            cy = bbox.y + bbox.height / 2;\n        }\n        this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n        return this;\n    };\n    /*\\\n     * Element.scale\n     [ method ]\n     **\n     * Deprecated! Use @Element.transform instead.\n     * Adds scale by given amount relative to given point to the list of\n     * transformations of the element.\n     > Parameters\n     - sx (number) horisontal scale amount\n     - sy (number) vertical scale amount\n     - cx (number) #optional x coordinate of the centre of scale\n     - cy (number) #optional y coordinate of the centre of scale\n     * If cx & cy arent specified centre of the shape is used instead.\n     = (object) @Element\n     \\*/\n    elproto.scale = function (sx, sy, cx, cy) {\n        if (this.removed) {\n            return this;\n        }\n        sx = Str(sx).split(separator);\n        if (sx.length - 1) {\n            sy = toFloat(sx[1]);\n            cx = toFloat(sx[2]);\n            cy = toFloat(sx[3]);\n        }\n        sx = toFloat(sx[0]);\n        (sy == null) && (sy = sx);\n        (cy == null) && (cx = cy);\n        if (cx == null || cy == null) {\n            var bbox = this.getBBox(1);\n        }\n        cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n        cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n        this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n        return this;\n    };\n    /*\\\n     * Element.translate\n     [ method ]\n     **\n     * Deprecated! Use @Element.transform instead.\n     * Adds translation by given amount to the list of transformations of the element.\n     > Parameters\n     - dx (number) horisontal shift\n     - dy (number) vertical shift\n     = (object) @Element\n     \\*/\n    elproto.translate = function (dx, dy) {\n        if (this.removed) {\n            return this;\n        }\n        dx = Str(dx).split(separator);\n        if (dx.length - 1) {\n            dy = toFloat(dx[1]);\n        }\n        dx = toFloat(dx[0]) || 0;\n        dy = +dy || 0;\n        this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n        return this;\n    };\n    /*\\\n     * Element.transform\n     [ method ]\n     **\n     * Adds transformation to the element which is separate to other attributes,\n     * i.e. translation doesnt change `x` or `y` of the rectange. The format\n     * of transformation string is similar to the path string syntax:\n     | \"t100,100r30,100,100s2,2,100,100r45s1.5\"\n     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for\n     * scale and `m` is for matrix.\n     *\n     * There are also alternative absolute translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.\n     *\n     * So, the example line above could be read like translate by 100, 100; rotate 30 around 100, 100; scale twice around 100, 100;\n     * rotate 45 around centre; scale 1.5 times relative to centre. As you can see rotate and scale commands have origin\n     * coordinates as optional parameters, the default is the centre point of the element.\n     * Matrix accepts six parameters.\n     > Usage\n     | var el = paper.rect(10, 20, 300, 200);\n     | // translate 100, 100, rotate 45, translate -100, 0\n     | el.transform(\"t100,100r45t-100,0\");\n     | // if you want you can append or prepend transformations\n     | el.transform(\"...t50,50\");\n     | el.transform(\"s2...\");\n     | // or even wrap\n     | el.transform(\"t50,50...t-50-50\");\n     | // to reset transformation call method with empty string\n     | el.transform(\"\");\n     | // to get current value call it without parameters\n     | console.log(el.transform());\n     > Parameters\n     - tstr (string) #optional transformation string\n     * If tstr isnt specified\n     = (string) current transformation string\n     * else\n     = (object) @Element\n     \\*/\n    elproto.transform = function (tstr) {\n        var _ = this._;\n        if (tstr == null) {\n            return _.transform;\n        }\n        R._extractTransform(this, tstr);\n\n        this.clip && $(this.clip, {transform: this.matrix.invert()});\n        this.pattern && updatePosition(this);\n        this.node && $(this.node, {transform: this.matrix});\n\n        if (_.sx != 1 || _.sy != 1) {\n            var sw = this.attrs[has](\"stroke-width\") ? this.attrs[\"stroke-width\"] : 1;\n            this.attr({\"stroke-width\": sw});\n        }\n\n        //Reduce transform string\n        _.transform = this.matrix.toTransformString();\n\n        return this;\n    };\n    /*\\\n     * Element.hide\n     [ method ]\n     **\n     * Makes element invisible. See @Element.show.\n     = (object) @Element\n     \\*/\n    elproto.hide = function () {\n        if(!this.removed) this.node.style.display = \"none\";\n        return this;\n    };\n    /*\\\n     * Element.show\n     [ method ]\n     **\n     * Makes element visible. See @Element.hide.\n     = (object) @Element\n     \\*/\n    elproto.show = function () {\n        if(!this.removed) this.node.style.display = \"\";\n        return this;\n    };\n    /*\\\n     * Element.remove\n     [ method ]\n     **\n     * Removes element from the paper.\n     \\*/\n    elproto.remove = function () {\n        var node = getRealNode(this.node);\n        if (this.removed || !node.parentNode) {\n            return;\n        }\n        var paper = this.paper;\n        paper.__set__ && paper.__set__.exclude(this);\n        eve.unbind(\"raphael.*.*.\" + this.id);\n        if (this.gradient) {\n            paper.defs.removeChild(this.gradient);\n        }\n        R._tear(this, paper);\n\n        node.parentNode.removeChild(node);\n\n        // Remove custom data for element\n        this.removeData();\n\n        for (var i in this) {\n            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n        }\n        this.removed = true;\n    };\n    elproto._getBBox = function () {\n        if (this.node.style.display == \"none\") {\n            this.show();\n            var hide = true;\n        }\n        var canvasHidden = false,\n            containerStyle;\n        if (this.paper.canvas.parentElement) {\n            containerStyle = this.paper.canvas.parentElement.style;\n        } //IE10+ can't find parentElement\n        else if (this.paper.canvas.parentNode) {\n            containerStyle = this.paper.canvas.parentNode.style;\n        }\n\n        if(containerStyle && containerStyle.display == \"none\") {\n            canvasHidden = true;\n            containerStyle.display = \"\";\n        }\n        var bbox = {};\n        try {\n            bbox = this.node.getBBox();\n        } catch(e) {\n            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix\n            bbox = {\n                x: this.node.clientLeft,\n                y: this.node.clientTop,\n                width: this.node.clientWidth,\n                height: this.node.clientHeight\n            }\n        } finally {\n            bbox = bbox || {};\n            if(canvasHidden){\n                containerStyle.display = \"none\";\n            }\n        }\n        hide && this.hide();\n        return bbox;\n    };\n    /*\\\n     * Element.attr\n     [ method ]\n     **\n     * Sets the attributes of the element.\n     > Parameters\n     - attrName (string) attributes name\n     - value (string) value\n     * or\n     - params (object) object of name/value pairs\n     * or\n     - attrName (string) attributes name\n     * or\n     - attrNames (array) in this case method returns array of current values for given attribute names\n     = (object) @Element if attrsName & value or params are passed in.\n     = (...) value of the attribute if only attrsName is passed in.\n     = (array) array of values of the attribute if attrsNames is passed in.\n     = (object) object of attributes if nothing is passed in.\n     > Possible parameters\n     # <p>Please refer to the <a href=\"http://www.w3.org/TR/SVG/\" title=\"The W3C Recommendation for the SVG language describes these properties in detail.\">SVG specification</a> for an explanation of these parameters.</p>\n     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.\n     o clip-rect (string) comma or space separated values: x, y, width and height\n     o cursor (string) CSS type of the cursor\n     o cx (number) the x-axis coordinate of the center of the circle, or ellipse\n     o cy (number) the y-axis coordinate of the center of the circle, or ellipse\n     o fill (string) colour, gradient or image\n     o fill-opacity (number)\n     o font (string)\n     o font-family (string)\n     o font-size (number) font size in pixels\n     o font-weight (string)\n     o height (number)\n     o href (string) URL, if specified element behaves as hyperlink\n     o opacity (number)\n     o path (string) SVG path string format\n     o r (number) radius of the circle, ellipse or rounded corner on the rect\n     o rx (number) horisontal radius of the ellipse\n     o ry (number) vertical radius of the ellipse\n     o src (string) image URL, only works for @Element.image element\n     o stroke (string) stroke colour\n     o stroke-dasharray (string) [, none, `-`, `.`, `-.`, `-..`, `. `, `- `, `--`, `- .`, `--.`, `--..`]\n     o stroke-linecap (string) [`butt`, `square`, `round`]\n     o stroke-linejoin (string) [`bevel`, `round`, `miter`]\n     o stroke-miterlimit (number)\n     o stroke-opacity (number)\n     o stroke-width (number) stroke width in pixels, default is '1'\n     o target (string) used with href\n     o text (string) contents of the text element. Use `\\n` for multiline text\n     o text-anchor (string) [`start`, `middle`, `end`], default is `middle`\n     o title (string) will create tooltip with a given text\n     o transform (string) see @Element.transform\n     o width (number)\n     o x (number)\n     o y (number)\n     > Gradients\n     * Linear gradient format: `angle-colour[-colour[:offset]]*-colour`, example: `90-#fff-#000`  90\n     * gradient from white to black or `0-#fff-#f00:20-#000`  0 gradient from white via red (at 20%) to black.\n     *\n     * radial gradient: `r[(fx, fy)]colour[-colour[:offset]]*-colour`, example: `r#fff-#000` \n     * gradient from white to black or `r(0.25, 0.75)#fff-#000`  gradient from white to black with focus point\n     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.\n     > Path String\n     # <p>Please refer to <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a paths data attributes format are described in the SVG specification.\">SVG documentation regarding path string</a>. Raphal fully supports it.</p>\n     > Colour Parsing\n     # <ul>\n     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>\n     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>\n     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n     #     <li>rgba(, , , )  red, green and blue channels values: (<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>)</li>\n     #     <li>rgba(%, %, %, %)  same as above, but in %: (<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>)</li>\n     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n     #     <li>hsb(%, %, %)  same as above, but in %</li>\n     #     <li>hsba(, , , )  same as above, but with opacity</li>\n     #     <li>hsl(, , )  almost the same as hsb, see <a href=\"http://en.wikipedia.org/wiki/HSL_and_HSV\" title=\"HSL and HSV - Wikipedia, the free encyclopedia\">Wikipedia page</a></li>\n     #     <li>hsl(%, %, %)  same as above, but in %</li>\n     #     <li>hsla(, , , )  same as above, but with opacity</li>\n     #     <li>Optionally for hsb and hsl you could specify hue as a degree: <code>hsl(240deg,&nbsp;1,&nbsp;.5)</code> or, if you want to go fancy, <code>hsl(240,&nbsp;1,&nbsp;.5)</code></li>\n     # </ul>\n     \\*/\n    elproto.attr = function (name, value) {\n        if (this.removed) {\n            return this;\n        }\n        if (name == null) {\n            var res = {};\n            for (var a in this.attrs) if (this.attrs[has](a)) {\n                res[a] = this.attrs[a];\n            }\n            res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n            res.transform = this._.transform;\n            return res;\n        }\n        if (value == null && R.is(name, \"string\")) {\n            if (name == \"fill\" && this.attrs.fill == \"none\" && this.attrs.gradient) {\n                return this.attrs.gradient;\n            }\n            if (name == \"transform\") {\n                return this._.transform;\n            }\n            var names = name.split(separator),\n                out = {};\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                name = names[i];\n                if (name in this.attrs) {\n                    out[name] = this.attrs[name];\n                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n                    out[name] = this.paper.customAttributes[name].def;\n                } else {\n                    out[name] = R._availableAttrs[name];\n                }\n            }\n            return ii - 1 ? out : out[names[0]];\n        }\n        if (value == null && R.is(name, \"array\")) {\n            out = {};\n            for (i = 0, ii = name.length; i < ii; i++) {\n                out[name[i]] = this.attr(name[i]);\n            }\n            return out;\n        }\n        if (value != null) {\n            var params = {};\n            params[name] = value;\n        } else if (name != null && R.is(name, \"object\")) {\n            params = name;\n        }\n        for (var key in params) {\n            eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n        }\n        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n            this.attrs[key] = params[key];\n            for (var subkey in par) if (par[has](subkey)) {\n                params[subkey] = par[subkey];\n            }\n        }\n        setFillAndStroke(this, params);\n        return this;\n    };\n    /*\\\n     * Element.toFront\n     [ method ]\n     **\n     * Moves the element so it is the closest to the viewers eyes, on top of other elements.\n     = (object) @Element\n     \\*/\n    elproto.toFront = function () {\n        if (this.removed) {\n            return this;\n        }\n        var node = getRealNode(this.node);\n        node.parentNode.appendChild(node);\n        var svg = this.paper;\n        svg.top != this && R._tofront(this, svg);\n        return this;\n    };\n    /*\\\n     * Element.toBack\n     [ method ]\n     **\n     * Moves the element so it is the furthest from the viewers eyes, behind other elements.\n     = (object) @Element\n     \\*/\n    elproto.toBack = function () {\n        if (this.removed) {\n            return this;\n        }\n        var node = getRealNode(this.node);\n        var parentNode = node.parentNode;\n        parentNode.insertBefore(node, parentNode.firstChild);\n        R._toback(this, this.paper);\n        var svg = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.insertAfter\n     [ method ]\n     **\n     * Inserts current object after the given one.\n     = (object) @Element\n     \\*/\n    elproto.insertAfter = function (element) {\n        if (this.removed || !element) {\n            return this;\n        }\n\n        var node = getRealNode(this.node);\n        var afterNode = getRealNode(element.node || element[element.length - 1].node);\n        if (afterNode.nextSibling) {\n            afterNode.parentNode.insertBefore(node, afterNode.nextSibling);\n        } else {\n            afterNode.parentNode.appendChild(node);\n        }\n        R._insertafter(this, element, this.paper);\n        return this;\n    };\n    /*\\\n     * Element.insertBefore\n     [ method ]\n     **\n     * Inserts current object before the given one.\n     = (object) @Element\n     \\*/\n    elproto.insertBefore = function (element) {\n        if (this.removed || !element) {\n            return this;\n        }\n\n        var node = getRealNode(this.node);\n        var beforeNode = getRealNode(element.node || element[0].node);\n        beforeNode.parentNode.insertBefore(node, beforeNode);\n        R._insertbefore(this, element, this.paper);\n        return this;\n    };\n    elproto.blur = function (size) {\n        // Experimental. No Safari support. Use it on your own risk.\n        var t = this;\n        if (+size !== 0) {\n            var fltr = $(\"filter\"),\n                blur = $(\"feGaussianBlur\");\n            t.attrs.blur = size;\n            fltr.id = R.createUUID();\n            $(blur, {stdDeviation: +size || 1.5});\n            fltr.appendChild(blur);\n            t.paper.defs.appendChild(fltr);\n            t._blur = fltr;\n            $(t.node, {filter: \"url(#\" + fltr.id + \")\"});\n        } else {\n            if (t._blur) {\n                t._blur.parentNode.removeChild(t._blur);\n                delete t._blur;\n                delete t.attrs.blur;\n            }\n            t.node.removeAttribute(\"filter\");\n        }\n        return t;\n    };\n    R._engine.circle = function (svg, x, y, r) {\n        var el = $(\"circle\");\n        svg.canvas && svg.canvas.appendChild(el);\n        var res = new Element(el, svg);\n        res.attrs = {cx: x, cy: y, r: r, fill: \"none\", stroke: \"#000\"};\n        res.type = \"circle\";\n        $(el, res.attrs);\n        return res;\n    };\n    R._engine.rect = function (svg, x, y, w, h, r) {\n        var el = $(\"rect\");\n        svg.canvas && svg.canvas.appendChild(el);\n        var res = new Element(el, svg);\n        res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: \"none\", stroke: \"#000\"};\n        res.type = \"rect\";\n        $(el, res.attrs);\n        return res;\n    };\n    R._engine.ellipse = function (svg, x, y, rx, ry) {\n        var el = $(\"ellipse\");\n        svg.canvas && svg.canvas.appendChild(el);\n        var res = new Element(el, svg);\n        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: \"none\", stroke: \"#000\"};\n        res.type = \"ellipse\";\n        $(el, res.attrs);\n        return res;\n    };\n    R._engine.image = function (svg, src, x, y, w, h) {\n        var el = $(\"image\");\n        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: \"none\"});\n        el.setAttributeNS(xlink, \"href\", src);\n        svg.canvas && svg.canvas.appendChild(el);\n        var res = new Element(el, svg);\n        res.attrs = {x: x, y: y, width: w, height: h, src: src};\n        res.type = \"image\";\n        return res;\n    };\n    R._engine.text = function (svg, x, y, text) {\n        var el = $(\"text\");\n        svg.canvas && svg.canvas.appendChild(el);\n        var res = new Element(el, svg);\n        res.attrs = {\n            x: x,\n            y: y,\n            \"text-anchor\": \"middle\",\n            text: text,\n            \"font-family\": R._availableAttrs[\"font-family\"],\n            \"font-size\": R._availableAttrs[\"font-size\"],\n            stroke: \"none\",\n            fill: \"#000\"\n        };\n        res.type = \"text\";\n        setFillAndStroke(res, res.attrs);\n        return res;\n    };\n    R._engine.setSize = function (width, height) {\n        this.width = width || this.width;\n        this.height = height || this.height;\n        this.canvas.setAttribute(\"width\", this.width);\n        this.canvas.setAttribute(\"height\", this.height);\n        if (this._viewBox) {\n            this.setViewBox.apply(this, this._viewBox);\n        }\n        return this;\n    };\n    R._engine.create = function () {\n        var con = R._getContainer.apply(0, arguments),\n            container = con && con.container,\n            x = con.x,\n            y = con.y,\n            width = con.width,\n            height = con.height;\n        if (!container) {\n            throw new Error(\"SVG container not found.\");\n        }\n        var cnvs = $(\"svg\"),\n            css = \"overflow:hidden;\",\n            isFloating;\n        x = x || 0;\n        y = y || 0;\n        width = width || 512;\n        height = height || 342;\n        $(cnvs, {\n            height: height,\n            version: 1.1,\n            width: width,\n            xmlns: \"http://www.w3.org/2000/svg\",\n            \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\"\n        });\n        if (container == 1) {\n            cnvs.style.cssText = css + \"position:absolute;left:\" + x + \"px;top:\" + y + \"px\";\n            R._g.doc.body.appendChild(cnvs);\n            isFloating = 1;\n        } else {\n            cnvs.style.cssText = css + \"position:relative\";\n            if (container.firstChild) {\n                container.insertBefore(cnvs, container.firstChild);\n            } else {\n                container.appendChild(cnvs);\n            }\n        }\n        container = new R._Paper;\n        container.width = width;\n        container.height = height;\n        container.canvas = cnvs;\n        container.clear();\n        container._left = container._top = 0;\n        isFloating && (container.renderfix = function () {});\n        container.renderfix();\n        return container;\n    };\n    R._engine.setViewBox = function (x, y, w, h, fit) {\n        eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n        var paperSize = this.getSize(),\n            size = mmax(w / paperSize.width, h / paperSize.height),\n            top = this.top,\n            aspectRatio = fit ? \"xMidYMid meet\" : \"xMinYMin\",\n            vb,\n            sw;\n        if (x == null) {\n            if (this._vbSize) {\n                size = 1;\n            }\n            delete this._vbSize;\n            vb = \"0 0 \" + this.width + S + this.height;\n        } else {\n            this._vbSize = size;\n            vb = x + S + y + S + w + S + h;\n        }\n        $(this.canvas, {\n            viewBox: vb,\n            preserveAspectRatio: aspectRatio\n        });\n        while (size && top) {\n            sw = \"stroke-width\" in top.attrs ? top.attrs[\"stroke-width\"] : 1;\n            top.attr({\"stroke-width\": sw});\n            top._.dirty = 1;\n            top._.dirtyT = 1;\n            top = top.prev;\n        }\n        this._viewBox = [x, y, w, h, !!fit];\n        return this;\n    };\n    /*\\\n     * Paper.renderfix\n     [ method ]\n     **\n     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant\n     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.\n     * This method fixes the issue.\n     **\n     Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.\n     \\*/\n    R.prototype.renderfix = function () {\n        var cnvs = this.canvas,\n            s = cnvs.style,\n            pos;\n        try {\n            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();\n        } catch (e) {\n            pos = cnvs.createSVGMatrix();\n        }\n        var left = -pos.e % 1,\n            top = -pos.f % 1;\n        if (left || top) {\n            if (left) {\n                this._left = (this._left + left) % 1;\n                s.left = this._left + \"px\";\n            }\n            if (top) {\n                this._top = (this._top + top) % 1;\n                s.top = this._top + \"px\";\n            }\n        }\n    };\n    /*\\\n     * Paper.clear\n     [ method ]\n     **\n     * Clears the paper, i.e. removes all the elements.\n     \\*/\n    R.prototype.clear = function () {\n        R.eve(\"raphael.clear\", this);\n        var c = this.canvas;\n        while (c.firstChild) {\n            c.removeChild(c.firstChild);\n        }\n        this.bottom = this.top = null;\n        (this.desc = $(\"desc\")).appendChild(R._g.doc.createTextNode(\"Created with Rapha\\xebl \" + R.version));\n        c.appendChild(this.desc);\n        c.appendChild(this.defs = $(\"defs\"));\n    };\n    /*\\\n     * Paper.remove\n     [ method ]\n     **\n     * Removes the paper from the DOM.\n     \\*/\n    R.prototype.remove = function () {\n        eve(\"raphael.remove\", this);\n        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);\n        for (var i in this) {\n            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n        }\n    };\n    var setproto = R.st;\n    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {\n        setproto[method] = (function (methodname) {\n            return function () {\n                var arg = arguments;\n                return this.forEach(function (el) {\n                    el[methodname].apply(el, arg);\n                });\n            };\n        })(method);\n    }\n}));\n\n//  \\\\\n//  Raphal 2.1.4 - JavaScript Vector Library                        \\\\\n//  \\\\\n//  VML Module                                                           \\\\\n//  \\\\\n//  Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)    \\\\\n//  Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)              \\\\\n//  Licensed under the MIT (http://raphaeljs.com/license.html) license.  \\\\\n//  \\\\\n\n(function (glob, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(\"raphael.vml\", [\"raphael.core\"], function(raphael) {\n            return factory(raphael);\n        });\n    } else if (typeof exports === \"object\") {\n        factory(require(\"./raphael.core\"));\n    } else {\n        factory(glob.Raphael);\n    }\n}(this, function(R) {\n    if (R && !R.vml) {\n        return;\n    }\n\n    var has = \"hasOwnProperty\",\n        Str = String,\n        toFloat = parseFloat,\n        math = Math,\n        round = math.round,\n        mmax = math.max,\n        mmin = math.min,\n        abs = math.abs,\n        fillString = \"fill\",\n        separator = /[, ]+/,\n        eve = R.eve,\n        ms = \" progid:DXImageTransform.Microsoft\",\n        S = \" \",\n        E = \"\",\n        map = {M: \"m\", L: \"l\", C: \"c\", Z: \"x\", m: \"t\", l: \"r\", c: \"v\", z: \"x\"},\n        bites = /([clmz]),?([^clmz]*)/gi,\n        blurregexp = / progid:\\S+Blur\\([^\\)]+\\)/g,\n        val = /-?[^,\\s-]+/g,\n        cssDot = \"position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)\",\n        zoom = 21600,\n        pathTypes = {path: 1, rect: 1, image: 1},\n        ovalTypes = {circle: 1, ellipse: 1},\n        path2vml = function (path) {\n            var total =  /[ahqstv]/ig,\n                command = R._pathToAbsolute;\n            Str(path).match(total) && (command = R._path2curve);\n            total = /[clmz]/g;\n            if (command == R._pathToAbsolute && !Str(path).match(total)) {\n                var res = Str(path).replace(bites, function (all, command, args) {\n                    var vals = [],\n                        isMove = command.toLowerCase() == \"m\",\n                        res = map[command];\n                    args.replace(val, function (value) {\n                        if (isMove && vals.length == 2) {\n                            res += vals + map[command == \"m\" ? \"l\" : \"L\"];\n                            vals = [];\n                        }\n                        vals.push(round(value * zoom));\n                    });\n                    return res + vals;\n                });\n                return res;\n            }\n            var pa = command(path), p, r;\n            res = [];\n            for (var i = 0, ii = pa.length; i < ii; i++) {\n                p = pa[i];\n                r = pa[i][0].toLowerCase();\n                r == \"z\" && (r = \"x\");\n                for (var j = 1, jj = p.length; j < jj; j++) {\n                    r += round(p[j] * zoom) + (j != jj - 1 ? \",\" : E);\n                }\n                res.push(r);\n            }\n            return res.join(S);\n        },\n        compensation = function (deg, dx, dy) {\n            var m = R.matrix();\n            m.rotate(-deg, .5, .5);\n            return {\n                dx: m.x(dx, dy),\n                dy: m.y(dx, dy)\n            };\n        },\n        setCoords = function (p, sx, sy, dx, dy, deg) {\n            var _ = p._,\n                m = p.matrix,\n                fillpos = _.fillpos,\n                o = p.node,\n                s = o.style,\n                y = 1,\n                flip = \"\",\n                dxdy,\n                kx = zoom / sx,\n                ky = zoom / sy;\n            s.visibility = \"hidden\";\n            if (!sx || !sy) {\n                return;\n            }\n            o.coordsize = abs(kx) + S + abs(ky);\n            s.rotation = deg * (sx * sy < 0 ? -1 : 1);\n            if (deg) {\n                var c = compensation(deg, dx, dy);\n                dx = c.dx;\n                dy = c.dy;\n            }\n            sx < 0 && (flip += \"x\");\n            sy < 0 && (flip += \" y\") && (y = -1);\n            s.flip = flip;\n            o.coordorigin = (dx * -kx) + S + (dy * -ky);\n            if (fillpos || _.fillsize) {\n                var fill = o.getElementsByTagName(fillString);\n                fill = fill && fill[0];\n                o.removeChild(fill);\n                if (fillpos) {\n                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));\n                    fill.position = c.dx * y + S + c.dy * y;\n                }\n                if (_.fillsize) {\n                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);\n                }\n                o.appendChild(fill);\n            }\n            s.visibility = \"visible\";\n        };\n    R.toString = function () {\n        return  \"Your browser doesn\\u2019t support SVG. Falling down to VML.\\nYou are running Rapha\\xebl \" + this.version;\n    };\n    var addArrow = function (o, value, isEnd) {\n            var values = Str(value).toLowerCase().split(\"-\"),\n                se = isEnd ? \"end\" : \"start\",\n                i = values.length,\n                type = \"classic\",\n                w = \"medium\",\n                h = \"medium\";\n            while (i--) {\n                switch (values[i]) {\n                    case \"block\":\n                    case \"classic\":\n                    case \"oval\":\n                    case \"diamond\":\n                    case \"open\":\n                    case \"none\":\n                        type = values[i];\n                        break;\n                    case \"wide\":\n                    case \"narrow\": h = values[i]; break;\n                    case \"long\":\n                    case \"short\": w = values[i]; break;\n                }\n            }\n            var stroke = o.node.getElementsByTagName(\"stroke\")[0];\n            stroke[se + \"arrow\"] = type;\n            stroke[se + \"arrowlength\"] = w;\n            stroke[se + \"arrowwidth\"] = h;\n        },\n        setFillAndStroke = function (o, params) {\n            // o.paper.canvas.style.display = \"none\";\n            o.attrs = o.attrs || {};\n            var node = o.node,\n                a = o.attrs,\n                s = node.style,\n                xy,\n                newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),\n                isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),\n                res = o;\n\n\n            for (var par in params) if (params[has](par)) {\n                a[par] = params[par];\n            }\n            if (newpath) {\n                a.path = R._getPath[o.type](o);\n                o._.dirty = 1;\n            }\n            params.href && (node.href = params.href);\n            params.title && (node.title = params.title);\n            params.target && (node.target = params.target);\n            params.cursor && (s.cursor = params.cursor);\n            \"blur\" in params && o.blur(params.blur);\n            if (params.path && o.type == \"path\" || newpath) {\n                node.path = path2vml(~Str(a.path).toLowerCase().indexOf(\"r\") ? R._pathToAbsolute(a.path) : a.path);\n                o._.dirty = 1;\n                if (o.type == \"image\") {\n                    o._.fillpos = [a.x, a.y];\n                    o._.fillsize = [a.width, a.height];\n                    setCoords(o, 1, 1, 0, 0, 0);\n                }\n            }\n            \"transform\" in params && o.transform(params.transform);\n            if (isOval) {\n                var cx = +a.cx,\n                    cy = +a.cy,\n                    rx = +a.rx || +a.r || 0,\n                    ry = +a.ry || +a.r || 0;\n                node.path = R.format(\"ar{0},{1},{2},{3},{4},{1},{4},{1}x\", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));\n                o._.dirty = 1;\n            }\n            if (\"clip-rect\" in params) {\n                var rect = Str(params[\"clip-rect\"]).split(separator);\n                if (rect.length == 4) {\n                    rect[2] = +rect[2] + (+rect[0]);\n                    rect[3] = +rect[3] + (+rect[1]);\n                    var div = node.clipRect || R._g.doc.createElement(\"div\"),\n                        dstyle = div.style;\n                    dstyle.clip = R.format(\"rect({1}px {2}px {3}px {0}px)\", rect);\n                    if (!node.clipRect) {\n                        dstyle.position = \"absolute\";\n                        dstyle.top = 0;\n                        dstyle.left = 0;\n                        dstyle.width = o.paper.width + \"px\";\n                        dstyle.height = o.paper.height + \"px\";\n                        node.parentNode.insertBefore(div, node);\n                        div.appendChild(node);\n                        node.clipRect = div;\n                    }\n                }\n                if (!params[\"clip-rect\"]) {\n                    node.clipRect && (node.clipRect.style.clip = \"auto\");\n                }\n            }\n            if (o.textpath) {\n                var textpathStyle = o.textpath.style;\n                params.font && (textpathStyle.font = params.font);\n                params[\"font-family\"] && (textpathStyle.fontFamily = '\"' + params[\"font-family\"].split(\",\")[0].replace(/^['\"]+|['\"]+$/g, E) + '\"');\n                params[\"font-size\"] && (textpathStyle.fontSize = params[\"font-size\"]);\n                params[\"font-weight\"] && (textpathStyle.fontWeight = params[\"font-weight\"]);\n                params[\"font-style\"] && (textpathStyle.fontStyle = params[\"font-style\"]);\n            }\n            if (\"arrow-start\" in params) {\n                addArrow(res, params[\"arrow-start\"]);\n            }\n            if (\"arrow-end\" in params) {\n                addArrow(res, params[\"arrow-end\"], 1);\n            }\n            if (params.opacity != null ||\n                params[\"stroke-width\"] != null ||\n                params.fill != null ||\n                params.src != null ||\n                params.stroke != null ||\n                params[\"stroke-width\"] != null ||\n                params[\"stroke-opacity\"] != null ||\n                params[\"fill-opacity\"] != null ||\n                params[\"stroke-dasharray\"] != null ||\n                params[\"stroke-miterlimit\"] != null ||\n                params[\"stroke-linejoin\"] != null ||\n                params[\"stroke-linecap\"] != null) {\n                var fill = node.getElementsByTagName(fillString),\n                    newfill = false;\n                fill = fill && fill[0];\n                !fill && (newfill = fill = createNode(fillString));\n                if (o.type == \"image\" && params.src) {\n                    fill.src = params.src;\n                }\n                params.fill && (fill.on = true);\n                if (fill.on == null || params.fill == \"none\" || params.fill === null) {\n                    fill.on = false;\n                }\n                if (fill.on && params.fill) {\n                    var isURL = Str(params.fill).match(R._ISURL);\n                    if (isURL) {\n                        fill.parentNode == node && node.removeChild(fill);\n                        fill.rotate = true;\n                        fill.src = isURL[1];\n                        fill.type = \"tile\";\n                        var bbox = o.getBBox(1);\n                        fill.position = bbox.x + S + bbox.y;\n                        o._.fillpos = [bbox.x, bbox.y];\n\n                        R._preload(isURL[1], function () {\n                            o._.fillsize = [this.offsetWidth, this.offsetHeight];\n                        });\n                    } else {\n                        fill.color = R.getRGB(params.fill).hex;\n                        fill.src = E;\n                        fill.type = \"solid\";\n                        if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != \"r\") && addGradientFill(res, params.fill, fill)) {\n                            a.fill = \"none\";\n                            a.gradient = params.fill;\n                            fill.rotate = false;\n                        }\n                    }\n                }\n                if (\"fill-opacity\" in params || \"opacity\" in params) {\n                    var opacity = ((+a[\"fill-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);\n                    opacity = mmin(mmax(opacity, 0), 1);\n                    fill.opacity = opacity;\n                    if (fill.src) {\n                        fill.color = \"none\";\n                    }\n                }\n                node.appendChild(fill);\n                var stroke = (node.getElementsByTagName(\"stroke\") && node.getElementsByTagName(\"stroke\")[0]),\n                    newstroke = false;\n                !stroke && (newstroke = stroke = createNode(\"stroke\"));\n                if ((params.stroke && params.stroke != \"none\") ||\n                    params[\"stroke-width\"] ||\n                    params[\"stroke-opacity\"] != null ||\n                    params[\"stroke-dasharray\"] ||\n                    params[\"stroke-miterlimit\"] ||\n                    params[\"stroke-linejoin\"] ||\n                    params[\"stroke-linecap\"]) {\n                    stroke.on = true;\n                }\n                (params.stroke == \"none\" || params.stroke === null || stroke.on == null || params.stroke == 0 || params[\"stroke-width\"] == 0) && (stroke.on = false);\n                var strokeColor = R.getRGB(params.stroke);\n                stroke.on && params.stroke && (stroke.color = strokeColor.hex);\n                opacity = ((+a[\"stroke-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);\n                var width = (toFloat(params[\"stroke-width\"]) || 1) * .75;\n                opacity = mmin(mmax(opacity, 0), 1);\n                params[\"stroke-width\"] == null && (width = a[\"stroke-width\"]);\n                params[\"stroke-width\"] && (stroke.weight = width);\n                width && width < 1 && (opacity *= width) && (stroke.weight = 1);\n                stroke.opacity = opacity;\n\n                params[\"stroke-linejoin\"] && (stroke.joinstyle = params[\"stroke-linejoin\"] || \"miter\");\n                stroke.miterlimit = params[\"stroke-miterlimit\"] || 8;\n                params[\"stroke-linecap\"] && (stroke.endcap = params[\"stroke-linecap\"] == \"butt\" ? \"flat\" : params[\"stroke-linecap\"] == \"square\" ? \"square\" : \"round\");\n                if (\"stroke-dasharray\" in params) {\n                    var dasharray = {\n                        \"-\": \"shortdash\",\n                        \".\": \"shortdot\",\n                        \"-.\": \"shortdashdot\",\n                        \"-..\": \"shortdashdotdot\",\n                        \". \": \"dot\",\n                        \"- \": \"dash\",\n                        \"--\": \"longdash\",\n                        \"- .\": \"dashdot\",\n                        \"--.\": \"longdashdot\",\n                        \"--..\": \"longdashdotdot\"\n                    };\n                    stroke.dashstyle = dasharray[has](params[\"stroke-dasharray\"]) ? dasharray[params[\"stroke-dasharray\"]] : E;\n                }\n                newstroke && node.appendChild(stroke);\n            }\n            if (res.type == \"text\") {\n                res.paper.canvas.style.display = E;\n                var span = res.paper.span,\n                    m = 100,\n                    fontSize = a.font && a.font.match(/\\d+(?:\\.\\d*)?(?=px)/);\n                s = span.style;\n                a.font && (s.font = a.font);\n                a[\"font-family\"] && (s.fontFamily = a[\"font-family\"]);\n                a[\"font-weight\"] && (s.fontWeight = a[\"font-weight\"]);\n                a[\"font-style\"] && (s.fontStyle = a[\"font-style\"]);\n                fontSize = toFloat(a[\"font-size\"] || fontSize && fontSize[0]) || 10;\n                s.fontSize = fontSize * m + \"px\";\n                res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, \"&#60;\").replace(/&/g, \"&#38;\").replace(/\\n/g, \"<br>\"));\n                var brect = span.getBoundingClientRect();\n                res.W = a.w = (brect.right - brect.left) / m;\n                res.H = a.h = (brect.bottom - brect.top) / m;\n                // res.paper.canvas.style.display = \"none\";\n                res.X = a.x;\n                res.Y = a.y + res.H / 2;\n\n                (\"x\" in params || \"y\" in params) && (res.path.v = R.format(\"m{0},{1}l{2},{1}\", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));\n                var dirtyattrs = [\"x\", \"y\", \"text\", \"font\", \"font-family\", \"font-weight\", \"font-style\", \"font-size\"];\n                for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {\n                    res._.dirty = 1;\n                    break;\n                }\n\n                // text-anchor emulation\n                switch (a[\"text-anchor\"]) {\n                    case \"start\":\n                        res.textpath.style[\"v-text-align\"] = \"left\";\n                        res.bbx = res.W / 2;\n                        break;\n                    case \"end\":\n                        res.textpath.style[\"v-text-align\"] = \"right\";\n                        res.bbx = -res.W / 2;\n                        break;\n                    default:\n                        res.textpath.style[\"v-text-align\"] = \"center\";\n                        res.bbx = 0;\n                        break;\n                }\n                res.textpath.style[\"v-text-kern\"] = true;\n            }\n            // res.paper.canvas.style.display = E;\n        },\n        addGradientFill = function (o, gradient, fill) {\n            o.attrs = o.attrs || {};\n            var attrs = o.attrs,\n                pow = Math.pow,\n                opacity,\n                oindex,\n                type = \"linear\",\n                fxfy = \".5 .5\";\n            o.attrs.gradient = gradient;\n            gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {\n                type = \"radial\";\n                if (fx && fy) {\n                    fx = toFloat(fx);\n                    fy = toFloat(fy);\n                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);\n                    fxfy = fx + S + fy;\n                }\n                return E;\n            });\n            gradient = gradient.split(/\\s*\\-\\s*/);\n            if (type == \"linear\") {\n                var angle = gradient.shift();\n                angle = -toFloat(angle);\n                if (isNaN(angle)) {\n                    return null;\n                }\n            }\n            var dots = R._parseDots(gradient);\n            if (!dots) {\n                return null;\n            }\n            o = o.shape || o.node;\n            if (dots.length) {\n                o.removeChild(fill);\n                fill.on = true;\n                fill.method = \"none\";\n                fill.color = dots[0].color;\n                fill.color2 = dots[dots.length - 1].color;\n                var clrs = [];\n                for (var i = 0, ii = dots.length; i < ii; i++) {\n                    dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);\n                }\n                fill.colors = clrs.length ? clrs.join() : \"0% \" + fill.color;\n                if (type == \"radial\") {\n                    fill.type = \"gradientTitle\";\n                    fill.focus = \"100%\";\n                    fill.focussize = \"0 0\";\n                    fill.focusposition = fxfy;\n                    fill.angle = 0;\n                } else {\n                    // fill.rotate= true;\n                    fill.type = \"gradient\";\n                    fill.angle = (270 - angle) % 360;\n                }\n                o.appendChild(fill);\n            }\n            return 1;\n        },\n        Element = function (node, vml) {\n            this[0] = this.node = node;\n            node.raphael = true;\n            this.id = R._oid++;\n            node.raphaelid = this.id;\n            this.X = 0;\n            this.Y = 0;\n            this.attrs = {};\n            this.paper = vml;\n            this.matrix = R.matrix();\n            this._ = {\n                transform: [],\n                sx: 1,\n                sy: 1,\n                dx: 0,\n                dy: 0,\n                deg: 0,\n                dirty: 1,\n                dirtyT: 1\n            };\n            !vml.bottom && (vml.bottom = this);\n            this.prev = vml.top;\n            vml.top && (vml.top.next = this);\n            vml.top = this;\n            this.next = null;\n        };\n    var elproto = R.el;\n\n    Element.prototype = elproto;\n    elproto.constructor = Element;\n    elproto.transform = function (tstr) {\n        if (tstr == null) {\n            return this._.transform;\n        }\n        var vbs = this.paper._viewBoxShift,\n            vbt = vbs ? \"s\" + [vbs.scale, vbs.scale] + \"-1-1t\" + [vbs.dx, vbs.dy] : E,\n            oldt;\n        if (vbs) {\n            oldt = tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, this._.transform || E);\n        }\n        R._extractTransform(this, vbt + tstr);\n        var matrix = this.matrix.clone(),\n            skew = this.skew,\n            o = this.node,\n            split,\n            isGrad = ~Str(this.attrs.fill).indexOf(\"-\"),\n            isPatt = !Str(this.attrs.fill).indexOf(\"url(\");\n        matrix.translate(1, 1);\n        if (isPatt || isGrad || this.type == \"image\") {\n            skew.matrix = \"1 0 0 1\";\n            skew.offset = \"0 0\";\n            split = matrix.split();\n            if ((isGrad && split.noRotation) || !split.isSimple) {\n                o.style.filter = matrix.toFilter();\n                var bb = this.getBBox(),\n                    bbt = this.getBBox(1),\n                    dx = bb.x - bbt.x,\n                    dy = bb.y - bbt.y;\n                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);\n                setCoords(this, 1, 1, dx, dy, 0);\n            } else {\n                o.style.filter = E;\n                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);\n            }\n        } else {\n            o.style.filter = E;\n            skew.matrix = Str(matrix);\n            skew.offset = matrix.offset();\n        }\n        if (oldt !== null) { // empty string value is true as well\n            this._.transform = oldt;\n            R._extractTransform(this, oldt);\n        }\n        return this;\n    };\n    elproto.rotate = function (deg, cx, cy) {\n        if (this.removed) {\n            return this;\n        }\n        if (deg == null) {\n            return;\n        }\n        deg = Str(deg).split(separator);\n        if (deg.length - 1) {\n            cx = toFloat(deg[1]);\n            cy = toFloat(deg[2]);\n        }\n        deg = toFloat(deg[0]);\n        (cy == null) && (cx = cy);\n        if (cx == null || cy == null) {\n            var bbox = this.getBBox(1);\n            cx = bbox.x + bbox.width / 2;\n            cy = bbox.y + bbox.height / 2;\n        }\n        this._.dirtyT = 1;\n        this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n        return this;\n    };\n    elproto.translate = function (dx, dy) {\n        if (this.removed) {\n            return this;\n        }\n        dx = Str(dx).split(separator);\n        if (dx.length - 1) {\n            dy = toFloat(dx[1]);\n        }\n        dx = toFloat(dx[0]) || 0;\n        dy = +dy || 0;\n        if (this._.bbox) {\n            this._.bbox.x += dx;\n            this._.bbox.y += dy;\n        }\n        this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n        return this;\n    };\n    elproto.scale = function (sx, sy, cx, cy) {\n        if (this.removed) {\n            return this;\n        }\n        sx = Str(sx).split(separator);\n        if (sx.length - 1) {\n            sy = toFloat(sx[1]);\n            cx = toFloat(sx[2]);\n            cy = toFloat(sx[3]);\n            isNaN(cx) && (cx = null);\n            isNaN(cy) && (cy = null);\n        }\n        sx = toFloat(sx[0]);\n        (sy == null) && (sy = sx);\n        (cy == null) && (cx = cy);\n        if (cx == null || cy == null) {\n            var bbox = this.getBBox(1);\n        }\n        cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n        cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n\n        this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n        this._.dirtyT = 1;\n        return this;\n    };\n    elproto.hide = function () {\n        !this.removed && (this.node.style.display = \"none\");\n        return this;\n    };\n    elproto.show = function () {\n        !this.removed && (this.node.style.display = E);\n        return this;\n    };\n    // Needed to fix the vml setViewBox issues\n    elproto.auxGetBBox = R.el.getBBox;\n    elproto.getBBox = function(){\n        var b = this.auxGetBBox();\n        if (this.paper && this.paper._viewBoxShift)\n        {\n            var c = {};\n            var z = 1/this.paper._viewBoxShift.scale;\n            c.x = b.x - this.paper._viewBoxShift.dx;\n            c.x *= z;\n            c.y = b.y - this.paper._viewBoxShift.dy;\n            c.y *= z;\n            c.width  = b.width  * z;\n            c.height = b.height * z;\n            c.x2 = c.x + c.width;\n            c.y2 = c.y + c.height;\n            return c;\n        }\n        return b;\n    };\n    elproto._getBBox = function () {\n        if (this.removed) {\n            return {};\n        }\n        return {\n            x: this.X + (this.bbx || 0) - this.W / 2,\n            y: this.Y - this.H,\n            width: this.W,\n            height: this.H\n        };\n    };\n    elproto.remove = function () {\n        if (this.removed || !this.node.parentNode) {\n            return;\n        }\n        this.paper.__set__ && this.paper.__set__.exclude(this);\n        R.eve.unbind(\"raphael.*.*.\" + this.id);\n        R._tear(this, this.paper);\n        this.node.parentNode.removeChild(this.node);\n        this.shape && this.shape.parentNode.removeChild(this.shape);\n        for (var i in this) {\n            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n        }\n        this.removed = true;\n    };\n    elproto.attr = function (name, value) {\n        if (this.removed) {\n            return this;\n        }\n        if (name == null) {\n            var res = {};\n            for (var a in this.attrs) if (this.attrs[has](a)) {\n                res[a] = this.attrs[a];\n            }\n            res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n            res.transform = this._.transform;\n            return res;\n        }\n        if (value == null && R.is(name, \"string\")) {\n            if (name == fillString && this.attrs.fill == \"none\" && this.attrs.gradient) {\n                return this.attrs.gradient;\n            }\n            var names = name.split(separator),\n                out = {};\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                name = names[i];\n                if (name in this.attrs) {\n                    out[name] = this.attrs[name];\n                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n                    out[name] = this.paper.customAttributes[name].def;\n                } else {\n                    out[name] = R._availableAttrs[name];\n                }\n            }\n            return ii - 1 ? out : out[names[0]];\n        }\n        if (this.attrs && value == null && R.is(name, \"array\")) {\n            out = {};\n            for (i = 0, ii = name.length; i < ii; i++) {\n                out[name[i]] = this.attr(name[i]);\n            }\n            return out;\n        }\n        var params;\n        if (value != null) {\n            params = {};\n            params[name] = value;\n        }\n        value == null && R.is(name, \"object\") && (params = name);\n        for (var key in params) {\n            eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n        }\n        if (params) {\n            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n                this.attrs[key] = params[key];\n                for (var subkey in par) if (par[has](subkey)) {\n                    params[subkey] = par[subkey];\n                }\n            }\n            // this.paper.canvas.style.display = \"none\";\n            if (params.text && this.type == \"text\") {\n                this.textpath.string = params.text;\n            }\n            setFillAndStroke(this, params);\n            // this.paper.canvas.style.display = E;\n        }\n        return this;\n    };\n    elproto.toFront = function () {\n        !this.removed && this.node.parentNode.appendChild(this.node);\n        this.paper && this.paper.top != this && R._tofront(this, this.paper);\n        return this;\n    };\n    elproto.toBack = function () {\n        if (this.removed) {\n            return this;\n        }\n        if (this.node.parentNode.firstChild != this.node) {\n            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);\n            R._toback(this, this.paper);\n        }\n        return this;\n    };\n    elproto.insertAfter = function (element) {\n        if (this.removed) {\n            return this;\n        }\n        if (element.constructor == R.st.constructor) {\n            element = element[element.length - 1];\n        }\n        if (element.node.nextSibling) {\n            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);\n        } else {\n            element.node.parentNode.appendChild(this.node);\n        }\n        R._insertafter(this, element, this.paper);\n        return this;\n    };\n    elproto.insertBefore = function (element) {\n        if (this.removed) {\n            return this;\n        }\n        if (element.constructor == R.st.constructor) {\n            element = element[0];\n        }\n        element.node.parentNode.insertBefore(this.node, element.node);\n        R._insertbefore(this, element, this.paper);\n        return this;\n    };\n    elproto.blur = function (size) {\n        var s = this.node.runtimeStyle,\n            f = s.filter;\n        f = f.replace(blurregexp, E);\n        if (+size !== 0) {\n            this.attrs.blur = size;\n            s.filter = f + S + ms + \".Blur(pixelradius=\" + (+size || 1.5) + \")\";\n            s.margin = R.format(\"-{0}px 0 0 -{0}px\", round(+size || 1.5));\n        } else {\n            s.filter = f;\n            s.margin = 0;\n            delete this.attrs.blur;\n        }\n        return this;\n    };\n\n    R._engine.path = function (pathString, vml) {\n        var el = createNode(\"shape\");\n        el.style.cssText = cssDot;\n        el.coordsize = zoom + S + zoom;\n        el.coordorigin = vml.coordorigin;\n        var p = new Element(el, vml),\n            attr = {fill: \"none\", stroke: \"#000\"};\n        pathString && (attr.path = pathString);\n        p.type = \"path\";\n        p.path = [];\n        p.Path = E;\n        setFillAndStroke(p, attr);\n        vml.canvas.appendChild(el);\n        var skew = createNode(\"skew\");\n        skew.on = true;\n        el.appendChild(skew);\n        p.skew = skew;\n        p.transform(E);\n        return p;\n    };\n    R._engine.rect = function (vml, x, y, w, h, r) {\n        var path = R._rectPath(x, y, w, h, r),\n            res = vml.path(path),\n            a = res.attrs;\n        res.X = a.x = x;\n        res.Y = a.y = y;\n        res.W = a.width = w;\n        res.H = a.height = h;\n        a.r = r;\n        a.path = path;\n        res.type = \"rect\";\n        return res;\n    };\n    R._engine.ellipse = function (vml, x, y, rx, ry) {\n        var res = vml.path(),\n            a = res.attrs;\n        res.X = x - rx;\n        res.Y = y - ry;\n        res.W = rx * 2;\n        res.H = ry * 2;\n        res.type = \"ellipse\";\n        setFillAndStroke(res, {\n            cx: x,\n            cy: y,\n            rx: rx,\n            ry: ry\n        });\n        return res;\n    };\n    R._engine.circle = function (vml, x, y, r) {\n        var res = vml.path(),\n            a = res.attrs;\n        res.X = x - r;\n        res.Y = y - r;\n        res.W = res.H = r * 2;\n        res.type = \"circle\";\n        setFillAndStroke(res, {\n            cx: x,\n            cy: y,\n            r: r\n        });\n        return res;\n    };\n    R._engine.image = function (vml, src, x, y, w, h) {\n        var path = R._rectPath(x, y, w, h),\n            res = vml.path(path).attr({stroke: \"none\"}),\n            a = res.attrs,\n            node = res.node,\n            fill = node.getElementsByTagName(fillString)[0];\n        a.src = src;\n        res.X = a.x = x;\n        res.Y = a.y = y;\n        res.W = a.width = w;\n        res.H = a.height = h;\n        a.path = path;\n        res.type = \"image\";\n        fill.parentNode == node && node.removeChild(fill);\n        fill.rotate = true;\n        fill.src = src;\n        fill.type = \"tile\";\n        res._.fillpos = [x, y];\n        res._.fillsize = [w, h];\n        node.appendChild(fill);\n        setCoords(res, 1, 1, 0, 0, 0);\n        return res;\n    };\n    R._engine.text = function (vml, x, y, text) {\n        var el = createNode(\"shape\"),\n            path = createNode(\"path\"),\n            o = createNode(\"textpath\");\n        x = x || 0;\n        y = y || 0;\n        text = text || \"\";\n        path.v = R.format(\"m{0},{1}l{2},{1}\", round(x * zoom), round(y * zoom), round(x * zoom) + 1);\n        path.textpathok = true;\n        o.string = Str(text);\n        o.on = true;\n        el.style.cssText = cssDot;\n        el.coordsize = zoom + S + zoom;\n        el.coordorigin = \"0 0\";\n        var p = new Element(el, vml),\n            attr = {\n                fill: \"#000\",\n                stroke: \"none\",\n                font: R._availableAttrs.font,\n                text: text\n            };\n        p.shape = el;\n        p.path = path;\n        p.textpath = o;\n        p.type = \"text\";\n        p.attrs.text = Str(text);\n        p.attrs.x = x;\n        p.attrs.y = y;\n        p.attrs.w = 1;\n        p.attrs.h = 1;\n        setFillAndStroke(p, attr);\n        el.appendChild(o);\n        el.appendChild(path);\n        vml.canvas.appendChild(el);\n        var skew = createNode(\"skew\");\n        skew.on = true;\n        el.appendChild(skew);\n        p.skew = skew;\n        p.transform(E);\n        return p;\n    };\n    R._engine.setSize = function (width, height) {\n        var cs = this.canvas.style;\n        this.width = width;\n        this.height = height;\n        width == +width && (width += \"px\");\n        height == +height && (height += \"px\");\n        cs.width = width;\n        cs.height = height;\n        cs.clip = \"rect(0 \" + width + \" \" + height + \" 0)\";\n        if (this._viewBox) {\n            R._engine.setViewBox.apply(this, this._viewBox);\n        }\n        return this;\n    };\n    R._engine.setViewBox = function (x, y, w, h, fit) {\n        R.eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n        var paperSize = this.getSize(),\n            width = paperSize.width,\n            height = paperSize.height,\n            H, W;\n        if (fit) {\n            H = height / h;\n            W = width / w;\n            if (w * H < width) {\n                x -= (width - w * H) / 2 / H;\n            }\n            if (h * W < height) {\n                y -= (height - h * W) / 2 / W;\n            }\n        }\n        this._viewBox = [x, y, w, h, !!fit];\n        this._viewBoxShift = {\n            dx: -x,\n            dy: -y,\n            scale: paperSize\n        };\n        this.forEach(function (el) {\n            el.transform(\"...\");\n        });\n        return this;\n    };\n    var createNode;\n    R._engine.initWin = function (win) {\n        var doc = win.document;\n        if (doc.styleSheets.length < 31) {\n            doc.createStyleSheet().addRule(\".rvml\", \"behavior:url(#default#VML)\");\n        } else {\n            // no more room, add to the existing one\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n            doc.styleSheets[0].addRule(\".rvml\", \"behavior:url(#default#VML)\");\n        }\n        try {\n            !doc.namespaces.rvml && doc.namespaces.add(\"rvml\", \"urn:schemas-microsoft-com:vml\");\n            createNode = function (tagName) {\n                return doc.createElement('<rvml:' + tagName + ' class=\"rvml\">');\n            };\n        } catch (e) {\n            createNode = function (tagName) {\n                return doc.createElement('<' + tagName + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">');\n            };\n        }\n    };\n    R._engine.initWin(R._g.win);\n    R._engine.create = function () {\n        var con = R._getContainer.apply(0, arguments),\n            container = con.container,\n            height = con.height,\n            s,\n            width = con.width,\n            x = con.x,\n            y = con.y;\n        if (!container) {\n            throw new Error(\"VML container not found.\");\n        }\n        var res = new R._Paper,\n            c = res.canvas = R._g.doc.createElement(\"div\"),\n            cs = c.style;\n        x = x || 0;\n        y = y || 0;\n        width = width || 512;\n        height = height || 342;\n        res.width = width;\n        res.height = height;\n        width == +width && (width += \"px\");\n        height == +height && (height += \"px\");\n        res.coordsize = zoom * 1e3 + S + zoom * 1e3;\n        res.coordorigin = \"0 0\";\n        res.span = R._g.doc.createElement(\"span\");\n        res.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;\";\n        c.appendChild(res.span);\n        cs.cssText = R.format(\"top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden\", width, height);\n        if (container == 1) {\n            R._g.doc.body.appendChild(c);\n            cs.left = x + \"px\";\n            cs.top = y + \"px\";\n            cs.position = \"absolute\";\n        } else {\n            if (container.firstChild) {\n                container.insertBefore(c, container.firstChild);\n            } else {\n                container.appendChild(c);\n            }\n        }\n        res.renderfix = function () {};\n        return res;\n    };\n    R.prototype.clear = function () {\n        R.eve(\"raphael.clear\", this);\n        this.canvas.innerHTML = E;\n        this.span = R._g.doc.createElement(\"span\");\n        this.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;\";\n        this.canvas.appendChild(this.span);\n        this.bottom = this.top = null;\n    };\n    R.prototype.remove = function () {\n        R.eve(\"raphael.remove\", this);\n        this.canvas.parentNode.removeChild(this.canvas);\n        for (var i in this) {\n            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n        }\n        return true;\n    };\n\n    var setproto = R.st;\n    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {\n        setproto[method] = (function (methodname) {\n            return function () {\n                var arg = arguments;\n                return this.forEach(function (el) {\n                    el[methodname].apply(el, arg);\n                });\n            };\n        })(method);\n    }\n}));\n\n//  \\\\\n//  Raphal @VERSION - JavaScript Vector Library                        \\\\\n//  \\\\\n//  Copyright  2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)     \\\\\n//  Copyright  2008-2012 Sencha Labs (http://sencha.com)               \\\\\n//  \\\\\n//  Licensed under the MIT (http://raphaeljs.com/license.html) license. \\\\\n//  \\\\\n\n(function (glob, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define(\"raphael\", [\"raphael.core\", \"raphael.svg\", \"raphael.vml\"], function(Raphael) {\n            return (glob.Raphael = factory(Raphael));\n        });\n    } else if (typeof exports === \"object\") {\n        var raphael = require(\"raphael.core\");\n\n        require(\"raphael.svg\");\n        require(\"raphael.vml\");\n\n        module.exports = factory(raphael);\n    } else {\n        glob.Raphael = factory(glob.Raphael);\n    }\n}(this, function (Raphael) {\n    return Raphael.ninja();\n}));\n\n\n\n\n\n\n\n\n\n/**\n * FRaphael\n * \tAn extension for Raphael.js to make it easier to work with Filter Effects\n *\n * Copyright  2013 Chris Scott <chris.scott@factmint.com>\n * Delivered with and licensed under the MIT licence\n *\n */\n\n// Create the global FRaphael object\n(function(scope) {\n    var\tversion = \"0.0.1\",\n        license = \"MIT\";\n\n    var\tns = \"http://www.w3.org/2000/svg\",\n        idCounter = 0;\n\n    var FR = {\n        // Object prototype for a filter\n        Filter: function(id) {\n            if (id == undefined) {\n                id = \"filter-\" + idCounter++;\n                while(FR.filters[id] != undefined) {\n                    id = \"filter-\" + idCounter++;\n                }\n            }\n\n            if (FR.filters[id] != undefined) {\n                throw \"A filter with id \" + id + \" already exists\";\n            }\n\n            this.element = document.createElementNS(ns, \"filter\");\n            this.element.setAttribute(\"id\", id);\n            this.element.setAttribute(\"x\", \"-25%\");\n            this.element.setAttribute(\"y\", \"-25%\");\n            this.element.setAttribute(\"width\", \"150%\");\n            this.element.setAttribute(\"height\", \"150%\");\n\n            this.lastFEResult = null;\n\n            FR.filters[id] = this;\n            this.id = id;\n        },\n\n        // Object prototype for an effect\n        FilterEffect: function(type, attributes) {\n            this.element = document.createElementNS(ns, type);\n            for (var key in attributes) {\n                this.element.setAttribute(key, attributes[key]);\n            }\n        },\n\n        // Return the filter applied to an element or a new filter if none are currently applied\n        getFilter: function(element) {\n            var filterId = element.data(\"filterId\");\n            var filter = null;\n\n            if (filterId == undefined) {\n                filterId = \"element-filter-\" + element.id;\n                filter = element.paper.createFilter(filterId);\n                element.filter(filterId);\n            } else {\n                filter = FR.filters[filterId];\n            }\n\n            return filter;\n        },\n\n        // maintain a list of filters by id\n        filters: {}\n    };\n\n    FR.Filter.prototype = {\n        addEffect: function(type, attributes, children) {\n            var effect = new FR.FilterEffect(type, attributes);\n\n            if (children) {\n                if (children instanceof Array) {\n                    for (var x in children) {\n                        if (!children.hasOwnProperty(x)) continue;\n\n                        effect.element.appendChild(children[x].element);\n                    }\n                } else {\n                    effect.element.appendChild(children.element);\n                }\n            }\n\n            this.element.appendChild(effect.element);\n\n            return this;\n        },\n\n        chainEffect: function(type, attributes, children) {\n            if (attributes == undefined) {\n                attributes = {};\n            }\n\n            var inId;\n            var outId;\n            if (attributes.in == undefined) {\n                inId = this.getLastResult();\n            } else {\n                inId = attributes.in;\n            }\n            if (attributes.result == undefined) {\n                outId = idCounter++;\n            } else {\n                outId = attributes.result;\n            }\n\n            this.lastFEResult = outId;\n\n            attributes.in = inId;\n            attributes.result = outId;\n\n            this.addEffect(type, attributes, children);\n\n            return this;\n        },\n\n        getLastResult: function() {\n            return (this.lastFEResult == undefined) ? \"SourceGraphic\" : this.lastFEResult;\n        },\n\n        merge: function(in1, in2, attributes) {\n            var mergeNode1 = new FR.FilterEffect(\"feMergeNode\", {\n                in: in1\n            });\n            var mergeNode2 = new FR.FilterEffect(\"feMergeNode\", {\n                in: in2\n            });\n\n            this.chainEffect(\"feMerge\", attributes, [mergeNode1, mergeNode2]);\n\n            return this;\n        },\n\n        compose: function(in1, in2, operator, attributes) {\n            if (attributes == undefined) {\n                attributes = {};\n            }\n\n            if (operator == undefined) {\n                operator = \"over\";\n            }\n\n            attributes.in = in1;\n            attributes.in2 = in2;\n            attributes.operator = operator;\n\n            this.chainEffect(\"feComposite\", attributes);\n\n            return this;\n        },\n\n        arithmeticCompose: function(in1, in2, k1, k2, k3, k4) {\n            if (k1 == undefined) {\n                k1 = 0;\n            }\n            if (k2 == undefined) {\n                k2 = 0;\n            }\n            if (k3 == undefined) {\n                k3 = 0;\n            }\n            if (k4 == undefined) {\n                k4 = 0;\n            }\n\n            this.compose(in1, in2, \"arithmetic\", {\n                k1: k1,\n                k2: k2,\n                k3: k3,\n                k4: k4\n            });\n\n            return this;\n        },\n\n        addBlur: function(stdDeviation, attributes) {\n            if (!stdDeviation) {\n                throw \"Standard deviation is required to perform a blur filter\";\n            }\n\n            if (attributes == undefined) {\n                attributes = {};\n            }\n            attributes.stdDeviation = stdDeviation;\n\n            this.chainEffect(\"feGaussianBlur\", attributes);\n\n            return this;\n        },\n\n        addOffset: function(dx, dy, attributes) {\n            if (dx == undefined | dy == undefined) {\n                throw \"dx and dy values are required to perform an offset FE\";\n            }\n\n            if (attributes == undefined) {\n                attributes = {};\n            }\n            attributes.dx = dx;\n            attributes.dy = dy;\n\n            this.chainEffect(\"feOffset\", attributes);\n\n            return this;\n        },\n\n        addLighting: function(x, y, z, color, type, attributes) {\n            if (x == undefined | y == undefined | z == undefined) {\n                throw \"Three co-ordinates are required to create a light source\";\n            }\n\n            var previousResult = this.getLastResult();\n\n            var id = idCounter++;\n\n            if (attributes == undefined) {\n                attributes = {};\n            }\n\n            attributes.result = id;\n            if (color != undefined) {\n                attributes[\"lighting-color\"] = color;\n            }\n\n            if (type == undefined || type == \"diffuse\") {\n                type = \"feDiffuseLighting\";\n            } else if (type == \"specular\") {\n                type = \"feSpecularLighting\";\n            }\n\n            var lightSource = new FR.FilterEffect(\"fePointLight\", {\n                x: x,\n                y: y,\n                z: z\n            });\n\n            this.chainEffect(type, attributes, lightSource).arithmeticCompose(previousResult, id, 3, 0.2, 0, 0);\n\n            return this;\n        },\n\n        addShiftToColor: function(color, moveBy, attributes) {\n            if (color == undefined) {\n                throw \"A colour string is a required argument to create a colorMatrix\";\n            }\n            if (moveBy == undefined) {\n                moveBy = 0.5;\n            }\n\n            var remainingColor = 1 - moveBy, x = remainingColor;\n\n            if (attributes == undefined) {\n                attributes = {};\n            }\n\n            var colorObject = Raphael.color(color);\n            var\tr = colorObject.r * moveBy / 255,\n                g = colorObject.g * moveBy / 255,\n                b = colorObject.b * moveBy / 255;\n\n            /**\n             * r'\tx 0 0 0 r\t\tr\n             * g'\t0 x 0 0 g\t\tg\n             * b' =\t0 0 x 0 b\t.\tb\n             * a'\t0 0 0 1 0\t\to\n             * 1\t\t\t\t\t1\n             */\n            attributes.values = x + \" 0 0 0 \" + r + \" 0 \" + x + \" 0 0 \" + g + \" 0 0 \" + x + \" 0 \" + b + \" 0 0 0 1 0 \";\n\n            this.chainEffect(\"feColorMatrix\", attributes);\n\n            return this;\n        },\n\n        addRecolor: function(color, opacity, attributes) {\n            if (color == undefined) {\n                throw \"A colour string is a required argument to create a colorMatrix\";\n            }\n            if (opacity == undefined) {\n                opacity = 1;\n            }\n\n            if (attributes == undefined) {\n                attributes = {};\n            }\n\n            var colorObject = Raphael.color(color);\n            var\tr = colorObject.r / 255,\n                g = colorObject.g / 255,\n                b = colorObject.b / 255;\n\n            /**\n             * r'\t0 0 0 0 r\t\tr\n             * g'\t0 0 0 0 g\t\tg\n             * b' =\t0 0 0 0 b\t.\tb\n             * a'\t0 0 0 a 0\t\ta\n             * 1\t\t\t\t\t1\n             */\n            attributes.values = \"0 0 0 0 \" + r + \" 0 0 0 0 \" + g + \" 0 0 0 0 \" + b + \" 0 0 0 \" + opacity + \" 0 \";\n\n            this.chainEffect(\"feColorMatrix\", attributes);\n\n            return this;\n        },\n\n        addDesaturate: function(saturation, attributes) {\n            if (saturation == undefined) {\n                saturnation = 0;\n            }\n\n            if (attributes == undefined) {\n                attributes = {};\n            }\n\n            attributes.values = saturation;\n            attributes.type = \"saturate\";\n\n            this.chainEffect(\"feColorMatrix\", attributes);\n\n            return this;\n        },\n\n        addConvolveMatrix: function(matrix, attributes) {\n            if (matrix == undefined) {\n                throw \"A matrix (usually 9 numbers) must be provided to apply a convolve matrix transform\";\n            }\n\n            if (attributes == undefined) {\n                attributes = {};\n            }\n\n            attributes.kernelMatrix = matrix;\n\n            this.chainEffect(\"feConvolveMatrix\", attributes);\n\n            return this;\n        },\n\n        createShadow: function(dx, dy, blur, opacity, color) {\n            if (dx == undefined) {\n                throw \"dx is required for the shadow effect\";\n            }\n            if (dy == undefined) {\n                throw \"dy is required for the shadow effect\";\n            }\n            if (blur == undefined) {\n                throw \"blur (stdDeviation) is required for the shadow effect\";\n            }\n\n            if (opacity == undefined) {\n                opacity = 0.6;\n            }\n\n            var previousResult = this.getLastResult();\n\n            if (color == undefined) {\n                color = \"#000000\";\n            }\n\n            this.addOffset(dx, dy, {\n                in: \"SourceAlpha\"\n            });\n\n            this.addRecolor(color, opacity);\n\n            this.addBlur(blur);\n\n            this.merge(this.getLastResult(), previousResult);\n\n            return this;\n        },\n\n        createEmboss: function(height, x, y, z) {\n            if (height == undefined) {\n                height = 2;\n            }\n            if (x == undefined) {\n                x = -1000;\n            }\n            if (y == undefined) {\n                y = -5000;\n            }\n            if (z == undefined) {\n                z = 300;\n            }\n\n            // Create the highlight\n\n            this.addOffset(height * x / (x + y), height * y / (x + y), {\n                in: \"SourceAlpha\"\n            });\n\n            this.addBlur(height * 0.5);\n\n            var whiteLightSource = new FR.FilterEffect(\"fePointLight\", {\n                x: x,\n                y: y,\n                z: z\n            });\n\n            this.chainEffect(\"feSpecularLighting\", {\n                surfaceScale: height,\n                specularConstant: 0.8,\n                specularExponent: 15\n            }, whiteLightSource);\n\n            this.compose(this.getLastResult(), \"SourceAlpha\", \"in\");\n            var whiteLight = this.getLastResult();\n\n            // Create the lowlight\n\n            this.addOffset(height * -1 * x / (x + y), height * -1 * y / (x + y), {\n                in: \"SourceAlpha\"\n            });\n\n            this.addBlur(height * 0.5);\n\n            var darkLightSource = new FR.FilterEffect(\"fePointLight\", {\n                x: -1 * x,\n                y: -1 * y,\n                z:      z\n            });\n\n            this.chainEffect(\"feSpecularLighting\", {\n                surfaceScale: height,\n                specularConstant: 1.8,\n                specularExponent: 6\n            }, darkLightSource);\n\n            this.compose(this.getLastResult(), \"SourceAlpha\", \"in\");\n            this.chainEffect(\"feColorMatrix\", {\n                values: \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0\"\n            });\n            var darkLight = this.getLastResult();\n\n            this.arithmeticCompose(whiteLight, darkLight, 0, 0.8, 0.5, 0);\n\n            this.merge(\"SourceGraphic\", this.getLastResult());\n\n            return this;\n        }\n    };\n\n    scope.FRaphael = FR;\n})(this);\n\n/**\n * add a filter to the paper by id\n */\nRaphael.fn.createFilter = function(id) {\n    var paper = this;\n    var filter = new FRaphael.Filter(id);\n    paper.defs.appendChild(filter.element);\n\n    return filter;\n};\n\n/**\n * Apply a filter to an element by id\n */\nRaphael.el.filter = function(filter) {\n    var id = (filter instanceof FRaphael.Filter) ? filter.id : filter;\n\n    this.node.setAttribute(\"filter\", \"url(#\" + id + \")\");\n    this.data(\"filterId\", id);\n\n    return this;\n};\n\n/**\n * Get the current filter for an element or a new one if not\n */\nRaphael.el.getFilter = function() {\n    return FRaphael.getFilter(this);\n};\n\n/**\n * A shorthand method for applying blur\n */\nRaphael.el.blur = function(stdDeviation) {\n    if (stdDeviation == undefined) {\n        stdDeviation = 3;\n    }\n\n    this.getFilter().addBlur(stdDeviation);\n\n    return this;\n};\n\n/**\n * A shorthand method for applying a drop shadow\n */\nRaphael.el.shadow = function(dx, dy, blur, opacity, color) {\n    if (dx == undefined) {\n        dx = 3;\n    }\n    if (dy == undefined) {\n        dy = 3;\n    }\n    if (blur == undefined) {\n        blur = 3;\n    }\n\n    this.getFilter().createShadow(dx, dy, blur, opacity, color);\n\n    return this;\n};\n\n/**\n * A shorthand method for applying lighting\n */\nRaphael.el.light = function(x, y, z, color, type) {\n    if (x == undefined) {\n        x = this.paper.width;\n    }\n    if (y == undefined) {\n        y = 0;\n    }\n    if (z == undefined) {\n        z = 20;\n    }\n\n    this.getFilter().addLighting(x, y, z, color, type);\n\n    return this;\n};\n\n/**\n * A shorthand method for applying a colour shift\n */\nRaphael.el.colorShift = function(color, shift) {\n    if (color == undefined) {\n        color = \"black\";\n    }\n    if (shift == undefined) {\n        shift = 0.5;\n    }\n\n    this.getFilter().addShiftToColor(color, shift);\n\n    return this;\n};\n\n/**\n * A shorthand method for embossing\n */\nRaphael.el.emboss = function(height) {\n    this.getFilter().createEmboss(height);\n\n    return this;\n};\n\n/**\n * A shorthand method for desaturating\n */\nRaphael.el.desaturate = function(saturation) {\n    this.getFilter().addDesaturate(saturation);\n\n    return this;\n};\n\n/**\n * A shorthand method for complete desaturation\n */\nRaphael.el.greyScale = function() {\n    this.getFilter().addDesaturate(0);\n\n    return this;\n};\n"

/***/ }),

/***/ "./node_modules/rgbcolor/index.js":
/*!****************************************!*\
  !*** ./node_modules/rgbcolor/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	Based on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>
	http://www.phpied.com/rgb-color-parser-in-javascript/
*/

module.exports = function(color_string) {
    this.ok = false;
    this.alpha = 1.0;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    color_string = simple_colors[color_string] || color_string;
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
            example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3]),
                    parseFloat(bits[4])
                ];
            }
        },
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            var channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            if (channels.length > 3) {
                this.alpha = channels[3];
            }
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
    this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toRGBA = function () {
        return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}


/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/shifty/dist/shifty.js":
/*!********************************************!*\
  !*** ./node_modules/shifty/dist/shifty.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*! 2.3.1 */
!function(t,e){ true?module.exports=e():undefined}(this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="/assets/",e(e.s=6)}([function(t,e,n){"use strict";(function(t){function r(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=new j,n=e.tween(t);return n.tweenable=e,n}Object.defineProperty(e,"__esModule",{value:!0}),e.Tweenable=e.composeEasingObject=e.tweenProps=e.clone=e.each=void 0;var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};e.tween=o;var c=n(5),s=r(c),f=n(1),h=function(t){return t&&t.__esModule?t:{default:t}}(f),l=n(7),p=r(l),d="undefined"!=typeof window?window:t,m=d.cancelAnimationFrame||d.webkitCancelAnimationFrame||d.oCancelAnimationFrame||d.msCancelAnimationFrame||d.mozCancelRequestAnimationFrame||d.clearTimeout,_=d.requestAnimationFrame||d.webkitRequestAnimationFrame||d.oRequestAnimationFrame||d.msRequestAnimationFrame||d.mozCancelRequestAnimationFrame&&d.mozRequestAnimationFrame||setTimeout,v=function(){},y=e.each=function(t,e){return Object.keys(t).forEach(e)},w=e.clone=function(t){return(0,h.default)({},t)},g=w(s),b=function(t,e,n,r){return t+(e-t)*n(r)},O=e.tweenProps=function(t,e,n,r,i,o,u){var a=t<o?0:(t-o)/i;return y(e,function(t){var i=u[t],o="function"==typeof i?i:g[i];e[t]=b(n[t],r[t],o,a)}),e},M=e.composeEasingObject=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"linear",n={},r=void 0===e?"undefined":a(e);return"string"===r||"function"===r?y(t,function(t){return n[t]=e}):y(t,function(t){return n[t]=n[t]||e[t]||"linear"}),n},j=e.Tweenable=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;i(this,t),this._currentState=e,this._configured=!1,this._scheduleFunction=_,void 0!==n&&this.setConfig(n)}return u(t,[{key:"_applyFilter",value:function(e){var n=this,r=t.filters,i=this._filterArgs;y(r,function(t){var o=r[t][e];void 0!==o&&o.apply(n,i)})}},{key:"_timeoutHandler",value:function(e){var n=this,r=arguments,i=this._currentState,o=this._delay,u=this._duration,a=this._step,c=this._targetState,s=this._timestamp,f=s+o+u,h=Math.min(e||t.now(),f),l=h>=f,p=u-(f-h);this.isPlaying()&&(l?(a(c,this._attachment,p),this.stop(!0)):(this._scheduleId=this._scheduleFunction.call(d,function(){return n._timeoutHandler.apply(n,r)},1e3/60),this._applyFilter("beforeTween"),h<s+o?(h=1,u=1,s=1):s+=o,O(h,i,this._originalState,c,u,s,this._easing),this._applyFilter("afterTween"),a(i,this._attachment,p)))}},{key:"tween",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,n=this._attachment,r=this._configured;return this._isTweening?this:(void 0===e&&r||this.setConfig(e),this._timestamp=t.now(),this._start(this.get(),n),this.resume())}},{key:"setConfig",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._configured=!0,this._attachment=e.attachment,(0,h.default)(this,{_pausedAtTime:null,_scheduleId:null,_delay:e.delay||0,_start:e.start||v,_step:e.step||v,_duration:e.duration||500,_currentState:w(e.from||this.get())}),(0,h.default)(this,{_originalState:this.get(),_targetState:w(e.to||this.get())});var n=this._currentState;this._targetState=(0,h.default)({},n,this._targetState),this._easing=M(n,e.easing),this._filterArgs=[n,this._originalState,this._targetState,this._easing],this._applyFilter("tweenCreated");var r=e.promise||Promise;return this._promise=new r(function(e,n){t._resolve=e,t._reject=n}),this._promise.catch(v),this}},{key:"get",value:function(){return w(this._currentState)}},{key:"set",value:function(t){this._currentState=t}},{key:"pause",value:function(){return this._pausedAtTime=t.now(),this._isPaused=!0,this}},{key:"resume",value:function(){return this._isPaused&&(this._timestamp+=t.now()-this._pausedAtTime),this._isPaused=!1,this._isTweening=!0,this._timeoutHandler(),this._promise}},{key:"seek",value:function(e){e=Math.max(e,0);var n=t.now();return this._timestamp+e===0?this:(this._timestamp=n-e,this.isPlaying()||(this._isTweening=!0,this._isPaused=!1,this._timeoutHandler(n),this.pause()),this)}},{key:"stop",value:function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=this._attachment,n=this._currentState,r=this._easing,i=this._originalState,o=this._targetState;return this._isTweening=!1,this._isPaused=!1,m(this._scheduleId),t?(this._applyFilter("beforeTween"),O(1,n,i,o,1,0,r),this._applyFilter("afterTween"),this._applyFilter("afterTweenEnd"),this._resolve(n,e)):this._reject(n,e),this}},{key:"isPlaying",value:function(){return this._isTweening&&!this._isPaused}},{key:"setScheduleFunction",value:function(t){this._scheduleFunction=t}},{key:"dispose",value:function(){var t=this;y(this,function(e){return delete t[e]})}}]),t}();(0,h.default)(j,{formulas:g,filters:{token:p},now:Date.now||function(t){return+new Date}})}).call(e,n(4))},function(t,e,n){"use strict";function r(t){if(null===t||void 0===t)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(t)}var i=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable;t.exports=function(){try{if(!Object.assign)return!1;var t=new String("abc");if(t[5]="de","5"===Object.getOwnPropertyNames(t)[0])return!1;for(var e={},n=0;n<10;n++)e["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(e).map(function(t){return e[t]}).join(""))return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach(function(t){r[t]=t}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(t){return!1}}()?Object.assign:function(t,e){for(var n,a,c=r(t),s=1;s<arguments.length;s++){n=Object(arguments[s]);for(var f in n)o.call(n,f)&&(c[f]=n[f]);if(i){a=i(n);for(var h=0;h<a.length;h++)u.call(n,a[h])&&(c[a[h]]=n[a[h]])}}return c}},function(t,e,n){"use strict";function r(t,e,n,r,i,o){var u=0,a=0,c=0,s=0,f=0,h=0,l=function(t){return((u*t+a)*t+c)*t},p=function(t){return((s*t+f)*t+h)*t},d=function(t){return(3*u*t+2*a)*t+c},m=function(t){return t>=0?t:0-t},_=function(t,e){var n=void 0,r=void 0,i=void 0,o=void 0,u=void 0,a=void 0;for(i=t,a=0;a<8;a++){if(o=l(i)-t,m(o)<e)return i;if(u=d(i),m(u)<1e-6)break;i-=o/u}if(n=0,r=1,(i=t)<n)return n;if(i>r)return r;for(;n<r;){if(o=l(i),m(o-t)<e)return i;t>o?n=i:r=i,i=.5*(r-n)+n}return i};return c=3*e,a=3*(r-e)-c,u=1-c-a,h=3*n,f=3*(i-n)-h,s=1-h-f,function(t,e){return p(_(t,e))}(t,function(t){return 1/(200*t)}(o))}Object.defineProperty(e,"__esModule",{value:!0}),e.unsetBezierFunction=e.setBezierFunction=void 0;var i=n(0),o=n(1),u=function(t){return t&&t.__esModule?t:{default:t}}(o),a=function(t,e,n,i){return function(o){return r(o,t,e,n,i,1)}};e.setBezierFunction=function(t,e,n,r,o){return i.Tweenable.formulas[t]=(0,u.default)(a(e,n,r,o),{displayName:t,x1:e,y1:n,x2:r,y2:o})},e.unsetBezierFunction=function(t){return delete i.Tweenable.formulas[t]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.interpolate=void 0;var r=n(0),i=new r.Tweenable;i._filterArgs=[];e.interpolate=function(t,e,n,o){var u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=(0,r.clone)(t),c=(0,r.composeEasingObject)(t,o);i.set({}),i._filterArgs=[a,t,e,c],i._applyFilter("tweenCreated"),i._applyFilter("beforeTween");var s=(0,r.tweenProps)(n,a,t,e,1,u,c);return i._applyFilter("afterTween"),s}},function(t,e,n){"use strict";var r,i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t};r=function(){return this}();try{r=r||Function("return this")()||(0,eval)("this")}catch(t){"object"===("undefined"==typeof window?"undefined":i(window))&&(r=window)}t.exports=r},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.linear=function(t){return t},e.easeInQuad=function(t){return Math.pow(t,2)},e.easeOutQuad=function(t){return-(Math.pow(t-1,2)-1)},e.easeInOutQuad=function(t){return(t/=.5)<1?.5*Math.pow(t,2):-.5*((t-=2)*t-2)},e.easeInCubic=function(t){return Math.pow(t,3)},e.easeOutCubic=function(t){return Math.pow(t-1,3)+1},e.easeInOutCubic=function(t){return(t/=.5)<1?.5*Math.pow(t,3):.5*(Math.pow(t-2,3)+2)},e.easeInQuart=function(t){return Math.pow(t,4)},e.easeOutQuart=function(t){return-(Math.pow(t-1,4)-1)},e.easeInOutQuart=function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},e.easeInQuint=function(t){return Math.pow(t,5)},e.easeOutQuint=function(t){return Math.pow(t-1,5)+1},e.easeInOutQuint=function(t){return(t/=.5)<1?.5*Math.pow(t,5):.5*(Math.pow(t-2,5)+2)},e.easeInSine=function(t){return 1-Math.cos(t*(Math.PI/2))},e.easeOutSine=function(t){return Math.sin(t*(Math.PI/2))},e.easeInOutSine=function(t){return-.5*(Math.cos(Math.PI*t)-1)},e.easeInExpo=function(t){return 0===t?0:Math.pow(2,10*(t-1))},e.easeOutExpo=function(t){return 1===t?1:1-Math.pow(2,-10*t)},e.easeInOutExpo=function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},e.easeInCirc=function(t){return-(Math.sqrt(1-t*t)-1)},e.easeOutCirc=function(t){return Math.sqrt(1-Math.pow(t-1,2))},e.easeInOutCirc=function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},e.easeOutBounce=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},e.easeInBack=function(t){var e=1.70158;return t*t*((e+1)*t-e)},e.easeOutBack=function(t){var e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},e.easeInOutBack=function(t){var e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},e.elastic=function(t){return-1*Math.pow(4,-8*t)*Math.sin((6*t-1)*(2*Math.PI)/2)+1},e.swingFromTo=function(t){var e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},e.swingFrom=function(t){var e=1.70158;return t*t*((e+1)*t-e)},e.swingTo=function(t){var e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},e.bounce=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},e.bouncePast=function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?2-(7.5625*(t-=1.5/2.75)*t+.75):t<2.5/2.75?2-(7.5625*(t-=2.25/2.75)*t+.9375):2-(7.5625*(t-=2.625/2.75)*t+.984375)},e.easeFromTo=function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},e.easeFrom=function(t){return Math.pow(t,4)},e.easeTo=function(t){return Math.pow(t,.25)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(0);Object.defineProperty(e,"Tweenable",{enumerable:!0,get:function(){return r.Tweenable}}),Object.defineProperty(e,"tween",{enumerable:!0,get:function(){return r.tween}});var i=n(3);Object.defineProperty(e,"interpolate",{enumerable:!0,get:function(){return i.interpolate}});var o=n(2);Object.defineProperty(e,"setBezierFunction",{enumerable:!0,get:function(){return o.setBezierFunction}}),Object.defineProperty(e,"unsetBezierFunction",{enumerable:!0,get:function(){return o.unsetBezierFunction}})},function(t,e,n){"use strict";function r(t){return parseInt(t,16)}function i(t,e,n){[t,e,n].forEach(_),this._tokenData=g(t)}function o(t,e,n,r){var i=this._tokenData;P(r,i),[t,e,n].forEach(function(t){return b(t,i)})}function u(t,e,n,r){var i=this._tokenData;[t,e,n].forEach(function(t){return F(t,i)}),S(r,i)}Object.defineProperty(e,"__esModule",{value:!0}),e.tweenCreated=i,e.beforeTween=o,e.afterTween=u;var a=n(0),c=function(){var t=/[0-9.\-]+/g.source,e=/,\s*/.source;return new RegExp("rgb\\("+t+e+t+e+t+"\\)","g")}(),s=/#([0-9]|[a-f]){3,6}/gi,f=function(t,e){return t.map(function(t,n){return"_"+e+"_"+n})},h=function(t){var e=t.match(/([^\-0-9\.]+)/g);return e?(1===e.length||t.charAt(0).match(/(\d|\-|\.)/))&&e.unshift(""):e=["",""],e.join("VAL")},l=function(t){return t=t.replace(/#/,""),3===t.length&&(t=t.split(""),t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]),[r(t.substr(0,2)),r(t.substr(2,2)),r(t.substr(4,2))]},p=function(t){return"rgb("+l(t).join(",")+")"},d=function(t,e,n){var r=e.match(t),i=e.replace(t,"VAL");return r&&r.forEach(function(t){return i=i.replace("VAL",n(t))}),i},m=function(t){return d(s,t,p)},_=function(t){(0,a.each)(t,function(e){var n=t[e];"string"==typeof n&&n.match(s)&&(t[e]=m(n))})},v=function(t){var e=t.match(/[0-9.\-]+/g).map(Math.floor);return""+t.match(/^.*\(/)[0]+e.join(",")+")"},y=function(t){return d(c,t,v)},w=function(t){return t.match(/[0-9.\-]+/g)},g=function(t){var e={};return(0,a.each)(t,function(n){var r=t[n];"string"==typeof r&&(e[n]={formatString:h(r),chunkNames:f(w(r),n)})}),e},b=function(t,e){(0,a.each)(e,function(n){w(t[n]).forEach(function(r,i){return t[e[n].chunkNames[i]]=+r}),delete t[n]})},O=function(t,e){var n={};return e.forEach(function(e){n[e]=t[e],delete t[e]}),n},M=function(t,e){return e.map(function(e){return t[e]})},j=function(t,e){return e.forEach(function(e){return t=t.replace("VAL",+e.toFixed(4))}),t},F=function(t,e){(0,a.each)(e,function(n){var r=e[n],i=r.chunkNames,o=r.formatString,u=j(o,M(O(t,i),i));t[n]=y(u)})},P=function(t,e){(0,a.each)(e,function(n){var r=e[n].chunkNames,i=t[n];"string"==typeof i?function(){var e=i.split(" "),n=e[e.length-1];r.forEach(function(r,i){return t[r]=e[i]||n})}():r.forEach(function(e){return t[e]=i}),delete t[n]})},S=function(t,e){(0,a.each)(e,function(n){var r=e[n].chunkNames,i=(r.length,t[r[0]]);t[n]="string"==typeof i?r.map(function(e){var n=t[e];return delete t[e],n}).join(" "):i})}}])});
//# sourceMappingURL=shifty.js.map

/***/ }),

/***/ "./node_modules/stackblur/index.js":
/*!*****************************************!*\
  !*** ./node_modules/stackblur/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
        
   
var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
		17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
		23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function blur( pixels, width, height, radius )
{
	if ( isNaN(radius) || radius < 1 ) return;
	radius |= 0;

	var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
	r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
	pr, pg, pb, pa, rbs;
			
	var div = radius + radius + 1;
	var w4 = width << 2;
	var widthMinus1  = width - 1;
	var heightMinus1 = height - 1;
	var radiusPlus1  = radius + 1;
	var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
	
	var stackStart = new BlurStack();
	var stack = stackStart;
	for ( i = 1; i < div; i++ )
	{
		stack = stack.next = new BlurStack();
		if ( i == radiusPlus1 ) var stackEnd = stack;
	}
	stack.next = stackStart;
	var stackIn = null;
	var stackOut = null;
	
	yw = yi = 0;
	
	var mul_sum = mul_table[radius];
	var shg_sum = shg_table[radius];
	
	for ( y = 0; y < height; y++ )
	{
		r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
		
		r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		for( i = 1; i < radiusPlus1; i++ )
		{
			p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
			r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		}
		
		
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( x = 0; x < width; x++ )
		{
			pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
			if ( pa != 0 )
			{
				pa = 255 / pa;
				pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
				pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
				pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
			} else {
				pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
			}
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
			
			r_in_sum += ( stackIn.r = pixels[p]);
			g_in_sum += ( stackIn.g = pixels[p+1]);
			b_in_sum += ( stackIn.b = pixels[p+2]);
			a_in_sum += ( stackIn.a = pixels[p+3]);
			
			r_sum += r_in_sum;
			g_sum += g_in_sum;
			b_sum += b_in_sum;
			a_sum += a_in_sum;
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;

			yi += 4;
		}
		yw += width;
	}

	
	for ( x = 0; x < width; x++ )
	{
		g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
		
		yi = x << 2;
		r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		yp = width;
		
		for( i = 1; i <= radius; i++ )
		{
			yi = ( yp + x ) << 2;
			
			r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
		   
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		
			if( i < heightMinus1 )
			{
				yp += width;
			}
		}
		
		yi = x;
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( y = 0; y < height; y++ )
		{
			p = yi << 2;
			pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
			if ( pa > 0 )
			{
				pa = 255 / pa;
				pixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;
				pixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
				pixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
			} else {
				pixels[p] = pixels[p+1] = pixels[p+2] = 0;
			}
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
		   
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
			
			r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
			g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
			b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
			a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
		   
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += width;
		}
	}
}

function BlurStack()
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 0;
	this.next = null;
}

module.exports = blur;

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/xmldom/dom-parser.js":
/*!*******************************************!*\
  !*** ./node_modules/xmldom/dom-parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid doc source");
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

//if(typeof require == 'function'){
	var XMLReader = __webpack_require__(/*! ./sax */ "./node_modules/xmldom/sax.js").XMLReader;
	var DOMImplementation = exports.DOMImplementation = __webpack_require__(/*! ./dom */ "./node_modules/xmldom/dom.js").DOMImplementation;
	exports.XMLSerializer = __webpack_require__(/*! ./dom */ "./node_modules/xmldom/dom.js").XMLSerializer ;
	exports.DOMParser = DOMParser;
//}


/***/ }),

/***/ "./node_modules/xmldom/dom.js":
/*!************************************!*\
  !*** ./node_modules/xmldom/dom.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
			
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9?this.documentElement:this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;
	
	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}
function needNamespaceDefine(node,isHTML, visibleNamespaces) {
	var prefix = node.prefix||'';
	var uri = node.namespaceURI;
	if (!prefix && !uri){
		return false;
	}
	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
		|| uri == 'http://www.w3.org/2000/xmlns/'){
		return false;
	}
	
	var i = visibleNamespaces.length 
	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
		if (ns.prefix == prefix){
			return ns.namespace != uri;
		}
	}
	//console.log(isHTML,uri,prefix=='')
	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
	//	return false;
	//}
	//node.flag = '11111'
	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
	return true;
}
function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}
	switch(node.nodeType){
	case ELEMENT_NODE:
		if (!visibleNamespaces) visibleNamespaces = [];
		var startVisibleNamespaces = visibleNamespaces.length;
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		
		isHTML =  (htmlns === node.namespaceURI) ||isHTML 
		buf.push('<',nodeName);
		
		
		
		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}
		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}
		// add namespace for current node		
		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
			buf.push(ns, '="' , uri , '"');
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}
		
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),

/***/ "./node_modules/xmldom/sax.js":
/*!************************************!*\
  !*** ./node_modules/xmldom/sax.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart+2,end);
				var config = parseStack.pop();
				if(end<0){
					
	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		//console.error('#@@@@@@'+tagName)
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				//console.error(parseStack.length,parseStack)
				//console.error(config);
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
					}
		        }else{
		        	parseStack.push(config)
		        }
				
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;
				
				
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					//}catch(e){console.error('@@@@@'+e)}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}
				
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}
		}catch(e){
			errorHandler.error('element parse error: '+e)
			//errorHandler.error('element parse error: '+e);
			end = -1;
			//throw e;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: sax
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
			case S_ATTR_SPACE:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;



/***/ }),

/***/ "./src/Canvas.js":
/*!***********************!*\
  !*** ./src/Canvas.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @class
 * A scrolling Canvas that contains Figures. Call `add(draw2d.Figure)` to add shapes to the Viewport.
 *
 *
 * @author Andreas Herz
 */
_packages2.default.Canvas = Class.extend(
/** @lends draw2d.Canvas.prototype */
{

  NAME: "draw2d.Canvas",

  /**
   * Create a new canvas with the given HTML DOM references.
   *
   * @param {String} canvasId the id of the DOM element to use a parent container
   */
  init: function init(canvasId, width, height) {
    var _this = this;

    this.setScrollArea(document.body);
    this.canvasId = canvasId;
    this.html = $("#" + canvasId);
    this.html.css({ "cursor": "default" });
    if (!isNaN(parseFloat(width)) && !isNaN(parseFloat(height))) {
      this.initialWidth = parseInt(width);
      this.initialHeight = parseInt(height);
      this.html.height(this.initialHeight).width(this.initialWidth);
    } else {
      this.initialWidth = this.getWidth();
      this.initialHeight = this.getHeight();
    }

    // avoid the "highlighting" in iPad, iPhone if the user tab/touch on the canvas.
    // .... I didn't like this.
    this.html.css({ "-webkit-tap-highlight-color": "rgba(0,0,0,0)" });

    // Drag&Drop handling from foreign DIV into the Canvas
    // Only available in combination with jQuery-UI
    //
    // Create the droppable area for the css class "draw2d_droppable"
    // This can be done by a palette of toolbar or something else.
    // For more information see : http://jqueryui.com/demos/droppable/
    //
    $(this.html).droppable({
      accept: '.draw2d_droppable',
      over: function over(event, ui) {
        _this.onDragEnter(ui.draggable);
      },
      out: function out(event, ui) {
        _this.onDragLeave(ui.draggable);
      },
      drop: function drop(event, ui) {
        event = _this._getEvent(event);
        var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
        _this.onDrop(ui.draggable, pos.getX(), pos.getY(), event.shiftKey, event.ctrlKey);
      }
    });

    // Create the jQuery-Draggable for the palette -> canvas drag&drop interaction
    //
    $(".draw2d_droppable").draggable({
      appendTo: "body",
      stack: "body",
      zIndex: 27000,
      helper: "clone",
      drag: function drag(event, ui) {
        event = _this._getEvent(event);
        var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
        _this.onDrag(ui.draggable, pos.getX(), pos.getY(), event.shiftKey, event.ctrlKey);
      },
      stop: function stop(e, ui) {},
      start: function start(e, ui) {
        $(ui.helper).addClass("shadow");
      }
    });

    // painting stuff
    //
    if (!isNaN(parseFloat(height))) {
      this.paper = Raphael(canvasId, width, height);
    } else {
      this.paper = Raphael(canvasId, this.getWidth(), this.getHeight());
    }
    this.paper.canvas.style.position = "absolute";

    // Status handling
    //
    this.zoomPolicy = null; // default ZoomEditPolicy
    this.zoomFactor = 1.0; // range [0.001..10]
    this.selection = new _packages2.default.Selection();
    this.currentDropTarget = null;
    this.currentHoverFigure = null;

    // installed to all added figures to avoid that a figure can be placed outside the canvas area
    // during a drag&drop operation
    this.regionDragDropConstraint = new _packages2.default.policy.figure.RegionEditPolicy(0, 0, this.getWidth(), this.getHeight());

    // event handling since version 5.0.0
    this.eventSubscriptions = {};

    this.editPolicy = new _packages2.default.util.ArrayList();

    // internal document with all figures, ports, ....
    //
    this.figures = new _packages2.default.util.ArrayList();
    this.lines = new _packages2.default.util.ArrayList(); // crap - why are connections not just figures. Design by accident
    this.commonPorts = new _packages2.default.util.ArrayList();

    // all visible resize handles which can be drag&drop around. Selection handles like AntRectangleSelectionFeedback
    // are not part of this collection. Required for hitTest only
    this.resizeHandles = new _packages2.default.util.ArrayList();

    // The CommandStack for undo/redo operations
    //
    this.commandStack = new _packages2.default.command.CommandStack();

    // INTERSECTION/CROSSING handling for connections and lines
    //
    this.linesToRepaintAfterDragDrop = new _packages2.default.util.ArrayList();
    this.lineIntersections = new _packages2.default.util.ArrayList();

    // alternative/legacy zoom implementation
    // this.installEditPolicy( new draw2d.policy.canvas.ZoomPolicy());                  // Responsible for zooming
    this.installEditPolicy(new _packages2.default.policy.canvas.WheelZoomPolicy()); // Responsible for zooming with mouse wheel
    this.installEditPolicy(new _packages2.default.policy.canvas.DefaultKeyboardPolicy()); // Handles the keyboard interaction
    this.installEditPolicy(new _packages2.default.policy.canvas.BoundingboxSelectionPolicy()); // Responsible for selection handling
    this.installEditPolicy(new _packages2.default.policy.canvas.DropInterceptorPolicy()); // Responsible for drop operations
    this.installEditPolicy(new _packages2.default.policy.connection.ComposedConnectionCreatePolicy( // Responsible for connection creation....
    [new _packages2.default.policy.connection.DragConnectionCreatePolicy(), // ....via drag/drop
    new _packages2.default.policy.connection.ClickConnectionCreatePolicy() // or clicking on the ports and canvas.
    ]));

    // Calculate all intersection between the different lines
    //
    this.commandStack.addEventListener(function (event) {
      if (event.isPostChangeEvent() === true) {
        _this.calculateConnectionIntersection();
        _this.linesToRepaintAfterDragDrop.each(function (i, line) {
          line.svgPathString = null;
          line.repaint();
        });
        _this.linesToRepaintAfterDragDrop = new _packages2.default.util.ArrayList();
      }
    });

    // DragDrop status handling
    //
    this.mouseDown = false;
    this.mouseDownX = 0;
    this.mouseDownY = 0;
    this.mouseDragDiffX = 0;
    this.mouseDragDiffY = 0;

    this.html.bind("mouseup touchend", function (event) {
      if (_this.mouseDown === false) {
        return;
      }

      event = _this._getEvent(event);
      _this.calculateConnectionIntersection();

      _this.mouseDown = false;
      var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
      _this.editPolicy.each(function (i, policy) {
        policy.onMouseUp(_this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
      });

      _this.mouseDragDiffX = 0;
      _this.mouseDragDiffY = 0;
    });

    this.html.bind("mousemove touchmove", function (event) {
      event = _this._getEvent(event);
      var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
      if (_this.mouseDown === false) {
        // mouseEnter/mouseLeave events for Figures. Don't use the Raphael or DOM native functions.
        // Raphael didn't work for Rectangle with transparent fill (events only fired for the border line)
        // DOM didn't work well for lines. No eclipse area - you must hit the line exact to retrieve the event.
        // In this case I implement my own stuff...again and again.
        //
        // don't break the main event loop if one element fires an error during enter/leave event.
        try {
          var hover = _this.getBestFigure(pos.x, pos.y);
          if (hover !== _this.currentHoverFigure && _this.currentHoverFigure !== null) {
            _this.currentHoverFigure.onMouseLeave(); // deprecated
            _this.currentHoverFigure.fireEvent("mouseleave");
            _this.fireEvent("mouseleave", { figure: _this.currentHoverFigure });
          }
          if (hover !== _this.currentHoverFigure && hover !== null) {
            hover.onMouseEnter();
            hover.fireEvent("mouseenter");
            _this.fireEvent("mouseenter", { figure: hover });
          }
          _this.currentHoverFigure = hover;
        } catch (exc) {
          // just write it to the console
          console.log(exc);
        }

        _this.editPolicy.each(function (i, policy) {
          policy.onMouseMove(_this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
        });
        _this.fireEvent("mousemove", {
          x: pos.x,
          y: pos.y,
          shiftKey: event.shiftKey,
          ctrlKey: event.ctrlKey,
          hoverFigure: _this.currentHoverFigure
        });
      } else {
        var diffXAbs = (event.clientX - _this.mouseDownX) * _this.zoomFactor;
        var diffYAbs = (event.clientY - _this.mouseDownY) * _this.zoomFactor;
        _this.editPolicy.each(function (i, policy) {
          policy.onMouseDrag(_this, diffXAbs, diffYAbs, diffXAbs - _this.mouseDragDiffX, diffYAbs - _this.mouseDragDiffY, event.shiftKey, event.ctrlKey);
        });
        _this.mouseDragDiffX = diffXAbs;
        _this.mouseDragDiffY = diffYAbs;
        _this.fireEvent("mousemove", {
          x: pos.x,
          y: pos.y,
          shiftKey: event.shiftKey,
          ctrlKey: event.ctrlKey,
          hoverFigure: _this.currentHoverFigure
        });
      }
    });

    this.html.bind("mousedown touchstart", function (event) {
      try {
        var pos = null;
        switch (event.which) {
          case 1: //touch pressed
          case 0:
            //Left mouse button pressed
            try {
              event.preventDefault();
              event = _this._getEvent(event);
              _this.mouseDownX = event.clientX;
              _this.mouseDownY = event.clientY;
              _this.mouseDragDiffX = 0;
              _this.mouseDragDiffY = 0;
              pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
              _this.mouseDown = true;
              _this.editPolicy.each(function (i, policy) {
                policy.onMouseDown(_this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
              });
            } catch (exc) {
              console.log(exc);
            }
            break;
          case 3:
            //Right mouse button pressed
            event.preventDefault();
            if (typeof event.stopPropagation !== "undefined") event.stopPropagation();
            event = _this._getEvent(event);
            pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
            _this.onRightMouseDown(pos.x, pos.y, event.shiftKey, event.ctrlKey);
            return false;
            break;
          case 2:
            //Middle mouse button pressed
            break;
          default:
          //You have a strange mouse
        }
      } catch (exc) {
        console.log(exc);
      }
    });

    // Catch the dblclick and route them to the Canvas hook.
    //
    this.html.on("dblclick", function (event) {
      event = _this._getEvent(event);

      _this.mouseDownX = event.clientX;
      _this.mouseDownY = event.clientY;
      var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
      _this.onDoubleClick(pos.x, pos.y, event.shiftKey, event.ctrlKey);
    });

    // Catch the click event and route them to the canvas hook
    //
    this.html.on("click", function (event) {
      event = _this._getEvent(event);

      // fire only the click event if we didn't move the mouse (drag&drop)
      //
      if (_this.mouseDownX === event.clientX || _this.mouseDownY === event.clientY) {
        var pos = _this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
        _this.onClick(pos.x, pos.y, event.shiftKey, event.ctrlKey);
      }
    });

    // Important: MozMousePixelScroll is required to prevent 1px scrolling
    // in FF event if we call "e.preventDefault()"
    this.html.on('MozMousePixelScroll DOMMouseScroll mousewheel', function (e) {
      var event = _this._getEvent(e);
      var pos = _this.fromDocumentToCanvasCoordinate(event.originalEvent.clientX, event.originalEvent.clientY);

      var delta = 0;
      if (e.type === 'mousewheel') {
        delta = e.originalEvent.wheelDelta * -1;
      } else if (e.type === 'DOMMouseScroll') {
        delta = 40 * e.originalEvent.detail;
      }

      var returnValue = _this.onMouseWheel(delta, pos.x, pos.y, event.shiftKey, event.ctrlKey);

      if (returnValue === false) {
        e.preventDefault();
      }
    });

    // Catch the keyUp and CTRL-key and route them to the Canvas hook.
    //
    this.keyupCallback = function (event) {
      // don't initiate the delete command if the event comes from an INPUT field. In this case the user want delete
      // a character in the input field and not the related shape
      var target = $(event.target);
      if (!target.is("input") && !target.is("textarea")) {
        _this.editPolicy.each(function (i, policy) {
          if (policy instanceof _packages2.default.policy.canvas.KeyboardPolicy) {
            policy.onKeyUp(_this, event.keyCode, event.shiftKey, event.ctrlKey);
          }
        });
      }
    };
    $(document).bind("keyup", this.keyupCallback);

    // Catch the keyDown and CTRL-key and route them to the Canvas hook.
    //
    this.keydownCallback = function (event) {
      // don't initiate the delete command if the event comes from an INPUT field. In this case the user want delete
      // a character in the input field and not the related shape
      var target = $(event.target);
      if (!target.is("input") && !target.is("textarea")) {
        _this.editPolicy.each(function (i, policy) {
          if (policy instanceof _packages2.default.policy.canvas.KeyboardPolicy) {
            policy.onKeyDown(_this, event.keyCode, event.shiftKey, event.ctrlKey);
          }
        });
      }
    };
    $(document).bind("keydown", this.keydownCallback);
  },

  /**
   *
   * Call this method if you didn't need the canvas anymore. The method unregister all even handlers
   * and frees all resources. The canvas is unusable after this call
   *
   * @since. 4.7.4
   */
  destroy: function destroy() {
    this.clear();
    $(document).unbind("keydown", this.keydownCallback);
    $(document).unbind("keyup", this.keyupCallback);
    // reset the event handlers of the canvas without any notice
    //
    this.eventSubscriptions = {};

    try {
      this.paper.remove();
    } catch (exc) {
      // breaks in some ie7 version....don't care about this because ie7/8 isn't a state of the art browser  ;-)
    }
  },

  /**
   *
   * Reset the canvas and delete all model elements.<br>
   * You can now reload another model to the canvas with a {@link draw2d.io.Reader}
   *
   * @since 1.1.0
   * @returns {this}
   */
  clear: function clear() {
    // notice all listener that the canvas will be cleared
    this.fireEvent("clear");

    var _this = this;

    this.lines.clone().each(function (i, e) {
      _this.remove(e);
    });

    this.figures.clone().each(function (i, e) {
      _this.remove(e);
    });

    this.zoomFactor = 1.0;
    this.selection.clear();
    this.currentDropTarget = null;

    // internal document with all figures, ports, ....
    //
    this.figures = new _packages2.default.util.ArrayList();
    this.lines = new _packages2.default.util.ArrayList();
    this.commonPorts = new _packages2.default.util.ArrayList();

    this.commandStack.markSaveLocation();

    // INTERSECTION/CROSSING handling for connections and lines
    //
    this.linesToRepaintAfterDragDrop = new _packages2.default.util.ArrayList();
    this.lineIntersections = new _packages2.default.util.ArrayList();

    // Inform all listener that the selection has been cleanup. Normally this will be done
    // by the edit policies of the canvas..but exceptional this is done in the clear method as well -
    // Design flaw.
    this.fireEvent("select", { figure: null });

    return this;
  },

  /**
   *
   * Callback for any kind of image export tools to trigger the canvas to hide all unwanted
   * decorations. The method is called e.g. from the draw2d.io.png.Writer
   *
   * @since 4.0.0
   * @@interface
   */
  hideDecoration: function hideDecoration() {},

  /**
   *
   * callback method for any image export writer to reactivate the decoration
   * of the canvas. e.g. grids, rulers,...
   *
   *
   * @since 4.0.0
   * @template
   */
  showDecoration: function showDecoration() {},

  /**
   *
   * Calculate all connection intersection of the canvas.
   * Required for "bridging" or "crossing decoration"
   *
   * @private
   */
  calculateConnectionIntersection: function calculateConnectionIntersection() {
    var _this2 = this;

    this.lineIntersections = new _packages2.default.util.ArrayList();
    var lines = this.getLines().clone();

    var _loop = function _loop() {
      var l1 = lines.removeElementAt(0);
      lines.each(function (ii, l2) {
        var partInter = l1.intersection(l2);
        if (partInter.getSize() > 0) {
          _this2.lineIntersections.add({ line: l1, other: l2, intersection: partInter });
          _this2.lineIntersections.add({ line: l2, other: l1, intersection: partInter });
        }
      });
    };

    while (lines.getSize() > 0) {
      _loop();
    }

    return this;
  },

  /**
   *
   *
   * Install a new selection and edit policy into the canvas
   *
   * @since 2.2.0
   * @param {draw2d.policy.EditPolicy} policy
   */
  installEditPolicy: function installEditPolicy(policy) {
    var _this3 = this;

    // a canvas can handle only one selection policy
    //
    if (policy instanceof _packages2.default.policy.canvas.SelectionPolicy) {
      // reset old selection before install new selection strategy
      this.getSelection().getAll().each(function (i, figure) {
        figure.unselect();
      });

      // remove existing selection policy
      this.editPolicy.grep(function (p) {
        var stay = !(p instanceof _packages2.default.policy.canvas.SelectionPolicy);
        if (stay === false) {
          p.onUninstall(_this3);
        }
        return stay;
      });
    }
    // only one zoom policy at once
    //
    else if (policy instanceof _packages2.default.policy.canvas.ZoomPolicy) {
        // remove existing zoom policy
        this.editPolicy.grep(function (p) {
          var stay = !(p instanceof _packages2.default.policy.canvas.ZoomPolicy);
          if (stay === false) {
            p.onUninstall(_this3);
          }
          return stay;
        });
        // replace the short cut handle for faster access
        this.zoomPolicy = policy;
      } else if (policy instanceof _packages2.default.policy.connection.ConnectionCreatePolicy) {
        this.editPolicy.grep(function (p) {
          var stay = !(p instanceof _packages2.default.policy.connection.ConnectionCreatePolicy);
          if (stay === false) {
            p.onUninstall(_this3);
          }
          return stay;
        });
      } else if (policy instanceof _packages2.default.policy.canvas.DropInterceptorPolicy) {
        // think about if I allow to install only one drop policy
      }

    policy.onInstall(this);
    this.editPolicy.add(policy);

    return this;
  },

  /**
   *
   *
   * UnInstall the selection and edit policy from the canvas.
   *
   * @since 2.2.0
   * @param {draw2d.policy.EditPolicy|String} policy
   */
  uninstallEditPolicy: function uninstallEditPolicy(policy) {
    if (policy === null) {
      return; //silently
    }

    // either remove exact the policy instance...
    //
    var removed = this.editPolicy.remove(policy);
    if (removed !== null) {
      removed.onUninstall(this);
      if (removed instanceof _packages2.default.policy.canvas.ZoomPolicy) {
        this.zoomPolicy = null;
      }
    } else {
      // ..or all of the same class if the policy isn't installed before
      // With this kind of behaviour it is possible to deinstall all policies with
      // the same class at once
      //
      var _this = this;
      var name = typeof policy === "string" ? policy : policy.NAME;
      this.editPolicy.grep(function (p) {
        if (p.NAME === name) {
          p.onUninstall(_this);
          // remove short cut handle to the zoom policy
          if (p instanceof _packages2.default.policy.canvas.ZoomPolicy) {
            _this.zoomPolicy = null;
          }
          return false;
        }
        return true;
      });
    }
    return this;
  },

  getDropInterceptorPolicies: function getDropInterceptorPolicies() {
    return this.editPolicy.clone().grep(function (p) {
      return p instanceof _packages2.default.policy.canvas.DropInterceptorPolicy;
    });
  },

  /**
   *
   * Set the new zoom factor for the canvas. The value must be between [0.01..10]
   *
   *     // you can register an eventhandler if the zoom factor did change
   *     canvas.on("zoom", function(emitterFigure, zoomData){
   *         alert("canvas zoomed to:"+zoomData.value);
   *     });
   *
   * @param {Number} zoomFactor new zoom factor.
   * @param {Boolean} [animated] set it to true for smooth zoom in/out
   */
  setZoom: function setZoom(zoomFactor, animated) {
    // redirect this legacy method to the new CanvasEditPolicy
    //
    if (this.zoomPolicy) {
      this.zoomPolicy.setZoom(zoomFactor, animated);
    }
  },

  /**
   *
   * Return the current zoom factor of the canvas.
   *
   * @returns {Number}
   */
  getZoom: function getZoom() {
    return this.zoomFactor;
  },

  /**
   *
   * Return the dimension of the drawing area
   *
   * @since 4.4.0
   * @returns {draw2d.geo.Rectangle}
   */
  getDimension: function getDimension() {
    return new _packages2.default.geo.Rectangle(0, 0, this.initialWidth, this.initialHeight);
  },

  /**
   *
   * Tells the canvas to resize. If you do not specific any parameters
   * the canvas will attempt to determine the height and width by the enclosing bounding box
   * of all elements and set the dimension accordingly. If you would like to set the dimension
   * explicitly pass in an draw2d.geo.Rectangle or an object with <b>height</b> and <b>width</b> properties.
   *
   * @since 4.4.0
   * @param {draw2d.geo.Rectangle} [dim] the dimension to set or null for autodetect
   */
  setDimension: function setDimension(dim, height) {
    if (typeof dim === "undefined") {
      var widths = this.getFigures().clone().map(function (f) {
        return f.getAbsoluteX() + f.getWidth();
      });
      var heights = this.getFigures().clone().map(function (f) {
        return f.getAbsoluteY() + f.getHeight();
      });
      this.initialHeight = Math.max.apply(Math, _toConsumableArray(heights.asArray()));
      this.initialWidth = Math.max.apply(Math, _toConsumableArray(widths.asArray()));
    } else if (dim instanceof _packages2.default.geo.Rectangle) {
      this.initialWidth = dim.w;
      this.initialHeight = dim.h;
    } else if (typeof dim.width === "number" && typeof dim.height === "number") {
      this.initialWidth = dim.width;
      this.initialHeight = dim.height;
    } else if (typeof dim === "number" && typeof height === "number") {
      this.initialWidth = dim;
      this.initialHeight = height;
    }
    this.html.css({ "width": this.initialWidth + "px", "height": this.initialHeight + "px" });
    this.paper.setSize(this.initialWidth, this.initialHeight);
    this.setZoom(this.zoomFactor, false);

    return this;
  },

  /**
   *
   * Transforms a document coordinate to canvas coordinate.
   *
   * @param {Number} x the x coordinate relative to the window
   * @param {Number} y the y coordinate relative to the window
   *
   * @returns {draw2d.geo.Point} The coordinate in relation to the canvas [0,0] position
   */
  fromDocumentToCanvasCoordinate: function fromDocumentToCanvasCoordinate(x, y) {
    return new _packages2.default.geo.Point((x - this.getAbsoluteX() + this.getScrollLeft()) * this.zoomFactor, (y - this.getAbsoluteY() + this.getScrollTop()) * this.zoomFactor);
  },

  /**
   *
   * Transforms a canvas coordinate to document coordinate.
   *
   * @param {Number} x the x coordinate in the canvas
   * @param {Number} y the y coordinate in the canvas
   *
   * @returns {draw2d.geo.Point} the coordinate in relation to the document [0,0] position
   */
  fromCanvasToDocumentCoordinate: function fromCanvasToDocumentCoordinate(x, y) {
    return new _packages2.default.geo.Point(x * (1 / this.zoomFactor) + this.getAbsoluteX() - this.getScrollLeft(), y * (1 / this.zoomFactor) + this.getAbsoluteY() - this.getScrollTop());
  },

  /**
   *
   * The DOM host of the canvas
   *
   * @returns {HTMLElement}
   */
  getHtmlContainer: function getHtmlContainer() {
    return this.html;
  },

  /**
   *
   * Return a common event object independed if we run on an iPad or desktop.
   *
   * @param event
   * @returns {DOMEventObject}
   * @private
   */
  _getEvent: function _getEvent(event) {
    // check for iPad, Android touch events
    //
    if (typeof event.originalEvent !== "undefined") {
      if (event.originalEvent.touches && event.originalEvent.touches.length) {
        return event.originalEvent.touches[0];
      } else if (event.originalEvent.changedTouches && event.originalEvent.changedTouches.length) {
        return event.originalEvent.changedTouches[0];
      }
    }
    return event;
  },

  /**
   *
   *
   * Set the area which are scrolling the canvas. This can be a jquery selector or
   * a jQuery node.
   *
   * @param {String/HTMLElement} elementSelector
   * @returns {this}
   **/
  setScrollArea: function setScrollArea(elementSelector) {
    this.scrollArea = $(elementSelector);

    return this;
  },

  /**
   *
   *
   * return the scrolling area of the canvas. This is jQuery object
   *
   * @returns {JQueryElement}
   **/
  getScrollArea: function getScrollArea() {
    return this.scrollArea;
  },

  /**
   *
   * The left scroll position.
   *
   * @returns {Number} the left scroll offset of the canvas
   **/
  getScrollLeft: function getScrollLeft() {
    return this.getScrollArea().scrollLeft();
  },

  /**
   *
   * The top scroll position
   *
   * @returns {Number} the top scroll offset of the cnavas.
   **/
  getScrollTop: function getScrollTop() {
    return this.getScrollArea().scrollTop();
  },

  /**
   *
   * Set left scroll position.
   *
   * @param {Number} left the left scroll offset of the canvas
   **/
  setScrollLeft: function setScrollLeft(left) {
    this.getScrollArea().scrollLeft(left);

    return this;
  },

  /**
   *
   * set top scroll position
   *
   * @param {Number} top the top scroll offset of the canvas.
   **/
  setScrollTop: function setScrollTop(top) {
    this.getScrollArea().scrollTop(top);

    return this;
  },

  /**
   *
   * set the new scroll position of the canvas
   *
   * @param {Number} top the top scroll offset of the canvas.
   * @param {Number} left the left scroll offset of the canvas
   * @since 5.8.0
   **/
  scrollTo: function scrollTo(top, left) {
    this.getScrollArea().scrollTop(top).scrollLeft(left);

    return this;
  },

  /**
   *
   * The absolute document x offset.
   *
   * @returns {Number}
   **/
  getAbsoluteX: function getAbsoluteX() {
    return this.html.offset().left;
  },

  /**
   *
   * The absolute document y offset.
   *
   * @returns {Number}
   **/
  getAbsoluteY: function getAbsoluteY() {
    return this.html.offset().top;
  },

  /**
   *
   * Return the width of the canvas
   *
   * @returns {Number}
   **/
  getWidth: function getWidth() {
    return this.html.width();
  },

  /**
   *
   * Return the height of the canvas.
   *
   * @returns {Number}
   **/
  getHeight: function getHeight() {
    return this.html.height();
  },

  /**
   *
   * Add a figure at the given x/y coordinate. This method fires an event.
   *
   * Example:
   *
   *     canvas.on("figure:add", function(emitter, event){
   *        alert("figure added:");
   *     });
   *
   *     // or more general if you want catch all figure related events
   *     //
   *     canvas.on("figure", function(emitter, event){
   *        // use event.figure.getCanvas()===null to determine if the
   *        // figure part of the canvas
   *
   *        alert("figure added or removed:");
   *     });
   *
   * @param {draw2d.Figure} figure The figure to add.
   * @param {Number/draw2d.geo.Point} [x] The new x coordinate of the figure or the x/y coordinate if it is an draw2d.geo.Point
   * @param {Number} [y] The y position.
   **/
  add: function add(figure, x, y) {
    if (figure.getCanvas() === this) {
      return;
    }

    if (figure instanceof _packages2.default.shape.basic.Line) {
      this.lines.add(figure);
      this.linesToRepaintAfterDragDrop = this.lines;
    } else {
      this.figures.add(figure);
      if (typeof y !== "undefined") {
        figure.setPosition(x, y);
      } else if (typeof x !== "undefined") {
        figure.setPosition(x);
      }
    }
    figure.setCanvas(this);

    // to avoid drag&drop outside of this canvas
    figure.installEditPolicy(this.regionDragDropConstraint);

    // important inital call
    figure.getShapeElement();

    // init a repaint of the figure. This enforce that all properties
    // ( color, dim, stroke,...) will be set and pushed to SVG node.
    figure.repaint();

    // fire the figure:add event before the "move" event and after the figure.repaint() call!
    //   - the move event can only be fired if the figure part of the canvas.
    //     and in this case the notification event should be fired to the listener before
    this.fireEvent("figure:add", { figure: figure, canvas: this });

    // fire the event that the figure is part of the canvas
    figure.fireEvent("added", { figure: figure, canvas: this });

    // ...now we can fire the initial move event
    figure.fireEvent("move", { figure: figure, dx: 0, dy: 0 });

    // this is only required if the used router requires the crossing information
    // of the connections
    if (figure instanceof _packages2.default.shape.basic.PolyLine) {
      this.calculateConnectionIntersection();
      this.linesToRepaintAfterDragDrop.each(function (i, line) {
        line.svgPathString = null;
        line.repaint();
      });
      this.linesToRepaintAfterDragDrop = new _packages2.default.util.ArrayList();
    }

    return this;
  },

  /**
   *
   * Remove a figure or connection from the Canvas. This method fires an event
   * which can be catched.
   *
   * Example:
   *
   *     canvas.on("figure:remove", function(emitter, event){
   *        alert("figure removed:");
   *     });
   *
   *     // or more general if you want catch all figure related events
   *     //
   *     canvas.on("figure", function(emitter, event){
   *        // use event.figure.getCanvas()===null to determine if the
   *        // figure part of the canvas
   *
   *        alert("figure added or removed:");
   *     });
   *
   *
   * @param {draw2d.Figure} figure The figure to remove
   **/
  remove: function remove(figure) {
    var _this4 = this;

    // don't fire events of calll callbacks if the fire isn'T part of this canvas
    //
    if (figure.getCanvas() !== this) {
      return this;
    }

    // remove the figure from a selection handler as well and cleanup the
    // selection feedback
    if (this.getSelection().contains(figure)) {
      this.editPolicy.each(function (i, policy) {
        if (typeof policy.unselect === "function") {
          policy.unselect(_this4, figure);
        }
      });
    }

    if (figure instanceof _packages2.default.shape.basic.Line) {
      this.lines.remove(figure);
    } else {
      this.figures.remove(figure);
    }

    figure.setCanvas(null);

    if (figure instanceof _packages2.default.Connection) {
      figure.disconnect();
    }

    this.fireEvent("figure:remove", { figure: figure });

    figure.fireEvent("removed", { figure: figure, canvas: this });

    return this;
  },

  /**
   *
   * Returns all lines/connections in this workflow/canvas.<br>
   *
   * @returns {draw2d.util.ArrayList}
   **/
  getLines: function getLines() {
    return this.lines;
  },

  /**
   *
   * Returns the internal figures.<br>
   *
   * @returns {draw2d.util.ArrayList}
   **/
  getFigures: function getFigures() {
    return this.figures;
  },

  /**
   *
   * Returns the line or connection with the given id.
   *
   * @param {String} id The id of the line.
   *
   * @returns {draw2d.shape.basic.Line}
   **/
  getLine: function getLine(id) {
    var count = this.lines.getSize();
    for (var i = 0; i < count; i++) {
      var line = this.lines.get(i);
      if (line.getId() === id) {
        return line;
      }
    }
    return null;
  },

  /**
   *
   * Returns the figure with the given id.
   *
   * @param {String} id The id of the figure.
   * @returns {draw2d.Figure}
   **/
  getFigure: function getFigure(id) {
    var figure = null;
    this.figures.each(function (i, e) {
      if (e.id === id) {
        figure = e;
        return false;
      }
    });
    return figure;
  },

  /**
   *
   * Return all intersections draw2d.geo.Point between the given line and all other
   * lines in the canvas.
   *
   * @param {draw2d.shape.basic.Line} line the line for the intersection test
   * @returns {draw2d.util.ArrayList}
   */
  getIntersection: function getIntersection(line) {
    var result = new _packages2.default.util.ArrayList();

    this.lineIntersections.each(function (i, entry) {
      if (entry.line === line) {
        entry.intersection.each(function (j, p) {
          result.add({ x: p.x, y: p.y, justTouching: p.justTouching, other: entry.other });
        });
      }
    });

    return result;
  },

  /**
   *
   *  Adjust the coordinate with the installed SnapToHelper.
   *
   * @param  {draw2d.Figure} figure The related figure
   * @param  {draw2d.geo.Point} pos The position to adjust
   *
   * @returns {draw2d.geo.Point} the adjusted position
   * @private
   **/
  snapToHelper: function snapToHelper(figure, pos) {
    var _this5 = this;

    // disable snapToPos if we have select more than one element
    // which are currently in Drag&Drop operation
    //
    if (this.getSelection().getSize() > 1) {
      return pos;
    }

    var orig = pos.clone();
    this.editPolicy.each(function (i, policy) {
      if (policy instanceof _packages2.default.policy.canvas.SnapToEditPolicy) {
        pos = policy.snap(_this5, figure, pos, orig);
      }
    });

    return pos;
  },

  /**
   *
   * Register a port to the canvas. This is required for other ports to find a valid drop target.
   *
   * @param {draw2d.Port} port The new port which has been added to the Canvas.
   **/
  registerPort: function registerPort(port) {
    // All elements have the same drop targets.
    //
    if (!this.commonPorts.contains(port)) {
      this.commonPorts.add(port);
    }

    return this;
  },

  /**
   *
   * Remove a port from the internal cnavas registration. Now other ports can't find the
   * port anymore as drop target. The port itself is still visible.
   *
   * @param {draw2d.Port} port The port to unregister as potential drop target
   * @private
   * @returns {this}
   **/
  unregisterPort: function unregisterPort(port) {
    this.commonPorts.remove(port);

    return this;
  },

  /**
   *
   * Return all ports in the canvas
   *
   * @returns {draw2d.util.ArrayList} all ports from all figures
   */
  getAllPorts: function getAllPorts() {
    return this.commonPorts;
  },

  /**
   *
   * Returns the command stack for the Canvas. Required for undo/redo support.
   *
   * @returns {draw2d.command.CommandStack}
   **/
  getCommandStack: function getCommandStack() {
    return this.commandStack;
  },

  /**
   *
   * Returns the current selected figure in the Canvas.
   *
   * @returns {draw2d.Figure}
   **/
  getPrimarySelection: function getPrimarySelection() {
    return this.selection.getPrimary();
  },

  /**
   *
   * Returns the current selection.
   *
   * @returns {draw2d.Selection}
   **/
  getSelection: function getSelection() {
    return this.selection;
  },

  /**
   *
   * Set the current selected figure or figures in the canvas.<br>
   * <br>
   * You can hand over a draw2d.util.ArrayList since version 4.8.0 for multiple selection.
   *
   * @param {draw2d.Figure| draw2d.util.ArrayList} object The figure or list of figures to select.
   * @returns {this}
   **/
  setCurrentSelection: function setCurrentSelection(object) {
    var _this6 = this;

    // deselect the current selected figures
    //
    // clone the array (getAll) before iterate and modify the initial array
    this.selection.getAll().each(function (i, e) {
      _this6.editPolicy.each(function (i, policy) {
        if (typeof policy.unselect === "function") {
          policy.unselect(_this6, e);
        }
      });
    });
    this.addSelection(object);

    return this;
  },

  /**
   *
   * Add the current figure to the selection. If a single selection policy is installed in the
   * canvas the selection before is reseted and the figure is the one and only selection.
   *
   * @param {draw2d.Figure | draw2d.util.ArrayList} object The figure(s) to add to the selection
   * @since 4.6.0
   * @returns {this}
   **/
  addSelection: function addSelection(object) {
    var _this = this;

    var add = function add(i, figure) {
      _this.editPolicy.each(function (i, policy) {
        if (typeof policy.select === "function") {
          policy.select(_this, figure);
        }
      });
    };

    if (object instanceof _packages2.default.util.ArrayList) {
      object.each(add);
    } else {
      add(0, object);
    }

    return this;
  },

  /**
   *
   * Returns the best figure at the location [x,y]. It is a simple hit test. Keep in mind that only visible objects
   * are returned.
   *
   *
   * @param {Number} x The x position.
   * @param {Number} y The y position.
   * @param {draw2d.Figure|Array|Class} [blacklist] The figures or class which should be ignored.
   * @param {draw2d.Figure|Array|Class} [whitelist] The figures or class should be considered.
   *
   * @returns {draw2d.Figure}
   **/
  getBestFigure: function getBestFigure(x, y, blacklist, whitelist) {
    if (!Array.isArray(blacklist)) {
      if (blacklist) blacklist = [blacklist];else blacklist = [];
    }

    if (!Array.isArray(whitelist)) {
      if (whitelist) whitelist = [whitelist];else whitelist = [];
    }

    var result = null;
    var testFigure = null;

    var isInList = function isInList(testFigure, list) {
      for (var i = 0, len = list.length; i < len; i++) {
        var considering = list[i];
        if (typeof considering === "function") {
          if (testFigure instanceof considering) {
            return true;
          }
        } else if (considering === testFigure || considering.contains(testFigure)) {
          return true;
        }
      }
      return false;
    };
    var isInBlacklist = function isInBlacklist(item) {
      return isInList(item, blacklist);
    };
    // empty whitelist means that every kind of object is allowed
    var isInWhitelist = whitelist.length === 0 ? function () {
      return true;
    } : function (item) {
      return isInList(item, whitelist);
    };

    // tool method to check recursive a figure for hitTest
    //
    var checkRecursive = function checkRecursive(children) {
      children.each(function (i, e) {
        var c = e.figure;
        checkRecursive(c.children);
        if (result === null && c.isVisible() && c.hitTest(x, y) && !isInBlacklist(c) && isInWhitelist(c)) {
          result = c;
        }
        return result === null; // break the each-loop if we found an element
      });
    };

    // ResizeHandles
    //
    for (var i = 0, len = this.resizeHandles.getSize(); i < len; i++) {
      testFigure = this.resizeHandles.get(i);
      if (testFigure.isVisible() && testFigure.hitTest(x, y) && !isInBlacklist(testFigure) && isInWhitelist(testFigure)) {
        return testFigure;
      }
    }

    // Checking ports
    //
    for (var _i = 0, _len = this.commonPorts.getSize(); _i < _len; _i++) {
      var port = this.commonPorts.get(_i);
      // check first a children of the figure
      //
      checkRecursive(port.children);

      if (result === null && port.isVisible() && port.hitTest(x, y) && !isInBlacklist(port) && isInWhitelist(port)) {
        result = port;
      }

      if (result !== null) {
        return result;
      }
    }

    //  Check now the common objects.
    //  run reverse to aware the z-oder of the figures
    for (var _i2 = this.figures.getSize() - 1; _i2 >= 0; _i2--) {
      var figure = this.figures.get(_i2);
      // check first a children of the figure
      //
      checkRecursive(figure.children);

      // ...and the figure itself
      //
      if (result === null && figure.isVisible() && figure.hitTest(x, y) && !isInBlacklist(figure) && isInWhitelist(figure)) {
        result = figure;
        break;
      }
    }

    var figureResult = result;
    var childResult = null;
    var lineResult = null;
    result = null;

    // Check the children of the lines as well
    // Not selectable/draggable. But should receive onClick/onDoubleClick events
    // as well.
    var count = this.lines.getSize();
    for (var _i3 = 0; _i3 < count; _i3++) {
      var line = this.lines.get(_i3);
      // check first a children of the figure
      //
      checkRecursive(line.children);

      if (result !== null) {
        childResult = result;
        break;
      }
    }

    lineResult = this.getBestLine(x, y, blacklist, whitelist);

    var figureIndex = figureResult !== null ? $(figureResult.shape.node).index() : -1;
    var childIndex = childResult !== null ? $(childResult.shape.node).index() : -1;
    var lineIndex = lineResult !== null ? $(lineResult.shape.node).index() : -1;
    var array = [{ i: figureIndex, f: figureResult }, { i: childIndex, f: childResult }, { i: lineIndex, f: lineResult }];
    array = array.filter(function (e) {
      return e.i !== -1;
    });
    array = array.sort(function (a, b) {
      return b.i - a.i;
    });

    if (array.length > 0) {
      result = array[0].f;
    }

    return result;
  },

  /**
   *
   * Return the line which match the hands over coordinate
   *
   * @param {Number} x the x-coordinate for the hit test
   * @param {Number} y the x-coordinate for the hit test
   * @param {draw2d.shape.basic.Line} [lineToIgnore] a possible line which should be ignored for the hit test
   *
   * @private
   * @returns {draw2d.shape.basic.Line}
   **/
  getBestLine: function getBestLine(x, y, lineToIgnore) {
    if (!Array.isArray(lineToIgnore)) {
      if (lineToIgnore instanceof _packages2.default.Figure) {
        lineToIgnore = [lineToIgnore];
      } else {
        lineToIgnore = [];
      }
    }
    var count = this.lines.getSize();

    for (var i = 0; i < count; i++) {
      var line = this.lines.get(i);
      if (line.isVisible() === true && line.hitTest(x, y) === true && $.inArray(line, lineToIgnore) === -1) {
        return line;
      }
    }
    return null;
  },

  /**
   *
   * Called by the framework during drag&drop operations.<br>
   * Droppable can be setup with:
   * <pre>
   *    $(".draw2d_droppable").draggable({
   *         appendTo:"#container",
   *         stack:"#container",
   *         zIndex: 27000,
   *         helper:"clone",
   *         start: function(e, ui){$(ui.helper).addClass("shadow");}
   *    });
   * </pre>
   * Draw2D use the jQuery draggable/droppable lib. Please inspect
   * http://jqueryui.com/demos/droppable/ for further information.
   *
   * @param {HTMLElement} draggedDomNode The DOM element which is currently dragging
   *
   * @template
   **/
  onDragEnter: function onDragEnter(draggedDomNode) {},

  /**
   *
   * Called if the DragDrop object is moving around.<br>
   * <br>
   * Draw2D use the jQuery draggable/droppable lib. Please inspect
   * http://jqueryui.com/demos/droppable/ for further information.
   *
   * @param {HTMLElement} draggedDomNode The dragged DOM element.
   * @param {Number} x the x coordinate of the drag
   * @param {Number} y the y coordinate of the drag
   *
   * @template
   **/
  onDrag: function onDrag(draggedDomNode, x, y) {},

  /**
   *
   * Called if the DragDrop object leaving the current hover figure.<br>
   * <br>
   * Graphiti use the jQuery draggable/droppable lib. Please inspect
   * http://jqueryui.com/demos/droppable/ for further information.
   *
   * @param {HTMLElement} draggedDomNode The figure which is currently dragging
   *
   * @template
   **/
  onDragLeave: function onDragLeave(draggedDomNode) {},

  /**
   *
   * Called if the user drop the droppedDomNode onto the canvas.<br>
   * <br>
   * Draw2D use the jQuery draggable/droppable lib. Please inspect
   * http://jqueryui.com/demos/droppable/ for further information.
   *
   * @param {HTMLElement} droppedDomNode The dropped DOM element.
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @template
   **/
  onDrop: function onDrop(droppedDomNode, x, y, shiftKey, ctrlKey) {},

  /**
   *
   * Callback method for the double click event. The x/y coordinates are relative to the top left
   * corner of the canvas.
   *
   * @private
   **/
  onDoubleClick: function onDoubleClick(x, y, shiftKey, ctrlKey) {
    // check if a line has been hit
    //
    var figure = this.getBestFigure(x, y);

    // or a line/connection. May we should test the line before a figure..?
    // (since 4.0.0)
    if (figure === null) {
      figure = this.getBestLine(x, y);
    }

    this.fireEvent("dblclick", { figure: figure, x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });

    // forward the event to all install policies as well.
    // (since 4.0.0)
    this.editPolicy.each(function (i, policy) {
      policy.onDoubleClick(figure, x, y, shiftKey, ctrlKey);
    });
  },

  /**
   *
   * @param {Number} x the x coordinate of the event
   * @param {Number} y the y coordinate of the event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onClick: function onClick(x, y, shiftKey, ctrlKey) {
    // check if a figure has been hit
    //
    var figure = this.getBestFigure(x, y);

    this.fireEvent("click", {
      figure: figure,
      x: x,
      y: y,
      relX: figure !== null ? x - figure.getAbsoluteX() : 0,
      relY: figure !== null ? y - figure.getAbsoluteY() : 0,
      shiftKey: shiftKey,
      ctrlKey: ctrlKey
    });

    // forward the event to all install policies as well.
    // (since 3.0.0)
    this.editPolicy.each(function (i, policy) {
      policy.onClick(figure, x, y, shiftKey, ctrlKey);
    });
  },

  /**
   *
   * The user has triggered a right click. Redirect them to a responsible figure.
   *
   * @param {Number} x The x-coordinate of the click
   * @param {Number} y The y-coordinate of the click
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @private
   * @since 1.1.0
   **/
  onRightMouseDown: function onRightMouseDown(x, y, shiftKey, ctrlKey) {
    var figure = this.getBestFigure(x, y);
    this.fireEvent("contextmenu", { figure: figure, x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });

    if (figure !== null) {
      figure.fireEvent("contextmenu", { figure: figure, x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
      // @deprecated legacy call
      figure.onContextMenu(x, y);

      // forward the event to all installed policies of the figure
      // soft migration from onHookXYZ to Policies.
      // since 4.4.0
      figure.editPolicy.each(function (i, policy) {
        policy.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
      });
    }

    // forward the event to all install policies as well.
    // (since 4.4.0)
    this.editPolicy.each(function (i, policy) {
      policy.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
    });
  },

  /**
   *
   * @param {Number} wheelDelta the delata of the wheel rotation
   * @param {Number} x the x coordinate of the event
   * @param {Number} y the y coordinate of the event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onMouseWheel: function onMouseWheel(wheelDelta, x, y, shiftKey, ctrlKey) {
    var returnValue = true;
    this.fireEvent("wheel", { wheelDelta: wheelDelta, x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });

    // forward the event to all install policies as well.
    // (since 3.0.0)
    this.editPolicy.each(function (i, policy) {
      returnValue = policy.onMouseWheel(wheelDelta, x, y, shiftKey, ctrlKey) && returnValue;
    });

    return returnValue;
  },

  // NEW EVENT HANDLING SINCE VERSION 5.0.0
  /**
   *
   * Execute all handlers and behaviors attached to the canvas for the given event type.
   *
   *
   * @param {String} event the event to trigger
   * @param {Object} [args] optional parameters for the triggered event callback
   * @private
   * @since 5.0.0
   */
  fireEvent: function fireEvent(event, args) {
    if (typeof this.eventSubscriptions[event] === 'undefined') {
      return;
    }

    var subscribers = this.eventSubscriptions[event];
    for (var i = 0; i < subscribers.length; i++) {
      try {
        subscribers[i](this, args);
      } catch (exc) {
        console.log(exc);
        console.log(subscribers[i]);
        debugger;
      }
    }
  },

  /**
   *
   * Attach an event handler function for one or more events to the canvas.
   * To remove events bound with .on(), see {@link #off}.
   *
   * possible events are:<br>
   * <ul>
   *   <li>reset</li>
   *   <li>select</li>
   * </ul>
   *
   * Example:
   *
   *     canvas.on("clear", function(emitter, event){
   *        alert("canvas.clear() called.");
   *     });
   *
   *     canvas.on("select", function(emitter,event){
   *        alert("figure selected");
   *     });
   *
   *     canvas.on("unselect", function(emitter,event){
   *        alert("figure unselected");
   *     });
   * 
   * @param {String}   event One or more space-separated event types
   * @param {Function} callback A function to execute when the event is triggered.
   * @param {draw2d.Canvas} callback.emitter the emitter of the event
   * @param {Object} [callback.obj] optional event related data
   *
   * @since 5.0.0
   */
  on: function on(event, callback) {
    var events = event.split(" ");
    for (var i = 0; i < events.length; i++) {
      if (typeof this.eventSubscriptions[events[i]] === 'undefined') {
        this.eventSubscriptions[events[i]] = [];
      }
      this.eventSubscriptions[events[i]].push(callback);
    }
    return this;
  },

  /**
   *
   * The `off()` method removes event handlers that were attached with {@link #on}.<br>
   * Calling .off() with no arguments removes all handlers attached to the canvas.<br>
   * <br>
   * If a simple event name such as "reset" is provided, all events of that type are removed from the canvas.
   *
   *
   * @param {String|Function} eventOrFunction the event name of the registerd function
   * @since 5.0.0
   */
  off: function off(eventOrFunction) {
    if (typeof eventOrFunction === "undefined") {
      this.eventSubscriptions = {};
    } else if (typeof eventOrFunction === 'string') {
      this.eventSubscriptions[eventOrFunction] = [];
    } else {
      for (var event in this.eventSubscriptions) {
        this.eventSubscriptions[event] = this.eventSubscriptions[event].filter(function (callback) {
          return callback !== eventOrFunction;
        });
      }
    }

    return this;
  }
});

/***/ }),

/***/ "./src/Configuration.js":
/*!******************************!*\
  !*** ./src/Configuration.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.Configuration = {
    version: "@VERSION@",
    i18n: {
        command: {
            move: "Move Shape",
            assignShape: "Add Shapes to Composite",
            groupShapes: "Group Shapes",
            ungroupShapes: "Ungroup Shapes",
            deleteShape: "Delete Shape",
            moveShape: "Move Shape",
            moveLine: "Move Line",
            addShape: "Add Shape",
            moveVertex: "Move Vertex",
            moveVertices: "Move Vertices",
            deleteVertex: "Delete Vertex",
            resizeShape: "Resize Shape",
            rotateShape: "Rotate Shape",
            collection: "Execute Commands",
            addVertex: "Add Vertex",
            changeAttributes: "Change Attributes",
            connectPorts: "Connect Ports"
        },
        menu: {
            deleteSegment: "Delete Segment",
            addSegment: "Add Segment"
        },
        dialog: {
            filenamePrompt: "Enter Filename:"
        }
    },

    factory: {
        // all selection policies calles this method to create a ResizeHandle.
        // It is possible to replace this method with a custom implementation
        // @since 5.2.0
        createResizeHandle: function createResizeHandle(owner, type, width, height) {
            // create a custom SelectionPolicy instead
            console.log("deprecated call factory.createResizeHandle");

            return new _packages2.default.ResizeHandle({ owner: owner, type: type, width: width, height: height });
        },
        // The commands an canvas calles this method to create a new connection.
        // all parameters are optional.
        // @since 5.3.0
        // @deprecated
        createConnection: function createConnection(sourcePort, targetPort, callback, dropTarget) {
            console.log("deprecated call factory.createConnection");
            debugger;
            return new _packages2.default.Connection();
        },
        // @since 5.3.0
        createInputPort: function createInputPort(relatedFigure) {
            return new _packages2.default.InputPort();
        },
        // @since 5.3.0
        createOutputPort: function createOutputPort(relatedFigure) {
            return new _packages2.default.OutputPort();
        },
        // @since 5.3.0
        createHybridPort: function createHybridPort(relatedFigure) {
            return new _packages2.default.HybridPort();
        }
    }
};

/***/ }),

/***/ "./src/Connection.js":
/*!***************************!*\
  !*** ./src/Connection.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Connections figures are used to display a line between two points. The Connection interface extends
 * {@link draw2d.shape.basic.PolyLine PolyLine}.<br>
 * The source and target endpoints of a connection are each defined using a {@link draw2d.layout.anchor.ConnectionAnchor ConnectionAnchor}.
 * These endpoints, along with any other points on the connection, are set by the connection's  {@link draw2d.layout.connection.ConnectionRouter ConnectionRouter}.
 * <br>
 * Usually every connection in a drawing has the same router instance. Connections with
 * common endpoints can share anchor instances as well.
 *
 * <h2>Connection Usage</h2>
 *
 * Connections are created and added just like any other figure. Unlike normal figures, you must not set the
 * bounds of a connection. Instead, you must provide the source and target port and let the connection router
 * calculate the connection's points. The connection then determines its own bounding box.<br>
 * <br>
 * A connection has a simple router by default - one that can connect the source and target anchors. But additional routers
 * are available and can be set on the connection. Some routers can handle constraints for the connection. Note that when
 * setting a routing constraint on a connection, you must first set the router which will use that constraint.<br>
 * <br>
 *
 * <b>TODO:<br></b>
 * <i>
 * A convenient way to share the router with all connections and to place connections above the drawing is to use a
 * ConnectionLayer. The layer has a connection router property which it shares with every child that's a connection.
 * You can update this property and easily change every connection's router at once.
 * </i>
 * <br>
 * <br>
 * <h2>Routing and Anchors</h2>
 * A connection always has a router and it must set at least two ports on the connection: the source and target
 * endpoints. By default, or when set to null, the connection's routing will be performed by an internal default router.
 * The ends are placed with the help of {@link draw2d.layout.anchor.ConnectionAnchor anchors}. An
 * {@link draw2d.layout.anchor.ConnectionAnchor anchors} is a fixed or calculated location, usually associated with some
 * figure. For example, the {@link draw2d.layout.anchor.ChopboxConnectionAnchor ChopboxAnchor} finds the point at which a
 * line going to the reference point intersects a box, such as the bounds of a figure. The reference point is either
 * the anchor at the opposite end, or a bendpoint or some other point nearest to the anchor.
 * <br>
 * {@img jsdoc_chopbox.gif ChopboxAnchor}
 * <br>
 * The router calculates the endpoints and any other points in the middle of the connection. It then sets the points on the
 * connection by calling {@link draw2d.shape.basic.PolyLine#addPoint Polyline.addPoint}. The connection's existing point list
 * can be reused to reduce garbage, but the points must be set on the connection anyway so that it knows about any changes made.
 * <br>
 * <h2>Adding Decorations and Children to Connections</h2>
 * Like most figures, Connection supports the addition of children. The children might be a label that
 * decorate the connection. The placement of each type of decoration can vary, so a {@link draw2d.layout.locator.ConnectionLocator ConnectionLocator}
 * is used to delegate to each child's constraint object, a Locator. <br>
 * <br>
 * {@link draw2d.decoration.connection.Decorator Decorator} can be used to create and render a rotatable shape at
 * the end or start of a connection like arrows or boxes. Examples are {@link draw2d.decoration.connection.ArrowDecorator ArrowDecorator}, {@link draw2d.decoration.connection.BarDecorator BarDecorator} or {@link draw2d.decoration.connection.CircleDecorator CircleDecorator}
 * <br>
 * <h2>Connection Layout</h2>
 * Connections extend the process of validation and layout to include routing. Since layout is the process of positioning children, routing must
 * come first. This allows a child's locator to operate on the connection's newly-routed points.<br>
 * Check out [Class System Guide](#!/guide/class_system) for additional reading.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.PolyLine
 */

_packages2.default.Connection = _packages2.default.shape.basic.PolyLine.extend(
/** @lends draw2d.Connection.prototype */
{

  NAME: "draw2d.Connection",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.sourcePort = null;
    this.targetPort = null;

    this.oldPoint = null;

    this.sourceDecorator = null;
    /*:draw2d.ConnectionDecorator*/
    this.targetDecorator = null;
    /*:draw2d.ConnectionDecorator*/

    // decoration of the polyline
    //
    this.sourceDecoratorNode = null;
    this.targetDecoratorNode = null;

    // helper let to restore the initial visual representation if the user drag&drop
    // the port outside of the browser window. In this case some events get lost and
    // I can restore the initial state of the connection if the mouse comes in the browser window
    // again.
    this.isMoving = false;

    var _this = this;
    this.moveListener = function (figure) {
      if (figure === _this.sourcePort) {
        _this.setStartPoint(_this.sourcePort.getAbsoluteX(), _this.sourcePort.getAbsoluteY());
      } else {
        _this.setEndPoint(_this.targetPort.getAbsoluteX(), _this.targetPort.getAbsoluteY());
      }
    };

    this._super((0, _extend2.default)({
      color: "#129CE4",
      stroke: 2,
      //    outlineStroke:1,
      //    outlineColor:"#ffffff",
      radius: 3
    }, attr), (0, _extend2.default)({
      sourceDecorator: this.setSourceDecorator,
      targetDecorator: this.setTargetDecorator,
      source: this.setSource,
      target: this.setTarget
    }, setter), (0, _extend2.default)({
      sourceDecorator: this.getSourceDecorator,
      targetDecorator: this.getTargetDecorator,
      source: this.getSource,
      target: this.getTarget
    }, getter));
  },

  /**
   * @private
   **/
  disconnect: function disconnect() {
    if (this.sourcePort !== null) {
      this.sourcePort.off(this.moveListener);
      this.sourcePort.connections.remove(this);

      // fire the events to all listener
      this.sourcePort.fireEvent("disconnect", { port: this.sourcePort, connection: this });
      if (this.canvas !== null) {
        this.canvas.fireEvent("disconnect", { "port": this.sourcePort, "connection": this });
      }
      this.sourcePort.onDisconnect(this);

      this.fireSourcePortRouteEvent();
    }

    if (this.targetPort !== null) {
      this.targetPort.off(this.moveListener);
      this.targetPort.connections.remove(this);

      // fire the events to all listener
      this.targetPort.fireEvent("disconnect", { port: this.targetPort, connection: this });
      if (this.canvas !== null) {
        this.canvas.fireEvent("disconnect", { "port": this.targetPort, "connection": this });
      }
      this.targetPort.onDisconnect(this);

      this.fireTargetPortRouteEvent();
    }
  },

  /**
   * @private
   **/
  reconnect: function reconnect() {
    if (this.sourcePort !== null) {
      this.sourcePort.on("move", this.moveListener);
      this.sourcePort.connections.add(this);

      // fire the events to all listener
      this.sourcePort.fireEvent("connect", { port: this.sourcePort, connection: this });
      if (this.canvas !== null) {
        this.canvas.fireEvent("connect", { "port": this.sourcePort, "connection": this });
      }
      this.sourcePort.onConnect(this);

      this.fireSourcePortRouteEvent();
    }

    if (this.targetPort !== null) {
      this.targetPort.on("move", this.moveListener);
      this.targetPort.connections.add(this);

      // fire the events to all listener
      this.targetPort.fireEvent("connect", { port: this.targetPort, connection: this });
      if (this.canvas !== null) {
        this.canvas.fireEvent("connect", { "port": this.targetPort, "connection": this });
      }
      this.targetPort.onConnect(this);

      this.fireTargetPortRouteEvent();
    }
    this.routingRequired = true;
    this.repaint();
  },

  /**
   * You can't drag&drop the resize handles of a connector.
   * @type boolean
   **/
  isResizeable: function isResizeable() {
    return this.isDraggable();
  },

  /**
   *
   * Add a child figure to the Connection. The hands over figure doesn't support drag&drop
   * operations. It's only a decorator for the connection.<br>
   * Mainly for labels or other fancy decorations :-)
   *
   * @param {draw2d.Figure} child the figure to add as decoration to the connection.
   * @param {draw2d.layout.locator.ConnectionLocator} locator the locator for the child.
   * @param {Number} [index] optional index where to insert the figure
   **/
  add: function add(child, locator, index) {
    // just to ensure the right interface for the locator.
    // The base class needs only 'draw2d.layout.locator.Locator'.
    if (!(locator instanceof _packages2.default.layout.locator.ConnectionLocator)) {
      throw "Locator must implement the class draw2d.layout.locator.ConnectionLocator";
    }

    this._super(child, locator, index);
  },

  /**
   *
   * Set the ConnectionDecorator for this object.
   *
   * @param {draw2d.decoration.connection.Decorator} decorator the new source decorator for the connection
   * @returns {this}
   **/
  setSourceDecorator: function setSourceDecorator(decorator) {
    if (this.sourceDecorator) {
      this.sourceDecorator.setParent(null);
    }
    this.sourceDecorator = decorator;
    this.routingRequired = true;
    this.sourceDecorator.setParent(this);
    if (this.sourceDecoratorNode !== null) {
      this.sourceDecoratorNode.remove();
      this.sourceDecoratorNode = null;
    }
    this.repaint();

    return this;
  },

  /**
   *
   * Get the current source ConnectionDecorator for this object.
   *
   * @returns draw2d.decoration.connection.Decorator
   **/
  getSourceDecorator: function getSourceDecorator() {
    return this.sourceDecorator;
  },

  /**
   *
   * Set the ConnectionDecorator for this object.
   *
   * @param {draw2d.decoration.connection.Decorator} decorator the new target decorator for the connection
   * @returns {this}
   **/
  setTargetDecorator: function setTargetDecorator(decorator) {
    if (this.targetDecorator) {
      this.targetDecorator.setParent(null);
    }
    this.targetDecorator = decorator;
    this.routingRequired = true;
    this.targetDecorator.setParent(this);
    if (this.targetDecoratorNode !== null) {
      this.targetDecoratorNode.remove();
      this.targetDecoratorNode = null;
    }
    this.repaint();

    return this;
  },

  /**
   *
   * Get the current target ConnectionDecorator for this object.
   *
   * @returns draw2d.decoration.connection.Decorator
   **/
  getTargetDecorator: function getTargetDecorator() {
    return this.targetDecorator;
  },

  /**
   *
   * Calculate the path of the polyline.
   *
   * @param {Object} routingHints some helper attributes for the router
   * @param {Boolean} routingHints.startMoved is true if just the start location has moved
   * @param {Boolean} routingHints.destMoved is true if the destination location has changed
   * @private
   */
  calculatePath: function calculatePath(routingHints) {

    if (this.sourcePort === null || this.targetPort === null) {
      return this;
    }

    this._super(routingHints);

    if (this.shape !== null) {
      var z1 = this.sourcePort.getZOrder();
      var z2 = this.targetPort.getZOrder();
      z1 < z2 ? this.toBack(this.sourcePort) : this.toBack(this.targetPort);
    }

    return this;
  },

  /**
   * @private
   **/
  repaint: function repaint(attributes) {
    var _this2 = this;

    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    if (this.sourcePort === null || this.targetPort === null) {
      return;
    }

    this._super(attributes);

    // paint the decorator if any exists
    //
    if (this.targetDecorator !== null && this.targetDecoratorNode === null) {
      this.targetDecoratorNode = this.targetDecorator.paint(this.getCanvas().paper);
    }

    if (this.sourceDecorator !== null && this.sourceDecoratorNode === null) {
      this.sourceDecoratorNode = this.sourceDecorator.paint(this.getCanvas().paper);
    }

    // translate/transform the decorations to the end/start of the connection
    // and rotate them as well
    //
    if (this.sourceDecoratorNode !== null) {
      var start = this.getVertices().first();
      this.sourceDecoratorNode.transform("r" + this.getStartAngle() + "," + start.x + "," + start.y + " t" + start.x + "," + start.y);
      // propagate the color and the opacity to the decoration as well
      this.sourceDecoratorNode.attr({ opacity: this.alpha });
      // apply the color of the connection if the decoration doesn't have any
      if (this.sourceDecorator.getColor() === null) {
        this.sourceDecoratorNode.attr({ "stroke": "#" + this.lineColor.hex() });
      } else {
        this.sourceDecoratorNode.attr({ "stroke": "#" + this.sourceDecorator.getColor().hex() });
      }
      this.sourceDecoratorNode.forEach(function (shape) {
        shape.node.setAttribute("class", _this2.cssClass !== null ? _this2.cssClass : "");
      });
    }

    if (this.targetDecoratorNode !== null) {
      var end = this.getVertices().last();
      this.targetDecoratorNode.transform("r" + this.getEndAngle() + "," + end.x + "," + end.y + " t" + end.x + "," + end.y);
      this.targetDecoratorNode.attr({ opacity: this.alpha });
      // apply the color of the connection if the decoration doesn't have any
      if (this.targetDecorator.getColor() === null) {
        this.targetDecoratorNode.attr({ "stroke": "#" + this.lineColor.hex() });
      } else {
        this.targetDecoratorNode.attr({ "stroke": "#" + this.targetDecorator.getColor().hex() });
      }
      this.targetDecoratorNode.forEach(function (shape) {
        shape.node.setAttribute("class", _this2.cssClass !== null ? _this2.cssClass : "");
      });
    }
  },

  /**
   *
   * The x-offset related to the canvas.
   * Didn't provided by a connection. Return always '0'. This is required
   * for children position calculation. (e.g. Label decoration)
   *
   * @returns {Number} the x-offset to the parent figure
   **/
  getAbsoluteX: function getAbsoluteX() {
    return 0;
  },

  /**
   *
   * The y-offset related to the canvas.
   * Didn't provided by a connection. Return always '0'. This is required
   * for children position calculation. (e.g. Label decoration)
   *
   * @returns {Number} The y-offset to the parent figure.
   **/
  getAbsoluteY: function getAbsoluteY() {
    return 0;
  },

  postProcess: function postProcess(postProcessCache) {
    this.router.postProcess(this, this.getCanvas(), postProcessCache);
  },

  /**
   *
   * Don't call them manually. This will be done by the framework.<br>
   * Will be called if the object are moved via drag and drop.
   * Sub classes can override this method to implement additional stuff. Don't forget to call
   * the super implementation via <code>this._super(dx, dy, dx2, dy2);</code>
   * @private
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2) {
    if (this.command === null) {
      return;
    }

    // Delegate the drag&drop operation to the router. The router has
    // all the meta information how to update start/end vertices
    //
    this.router.onDrag(this, dx, dy, dx2, dy2);

    this.command.updateVertices(this.getVertices().clone());

    var _this = this;

    // notify all installed policies
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.onDrag(_this.canvas, _this);
      }
    });

    this.svgPathString = null;
    this.repaint();

    // Update the resize handles if the user change the position of the
    // element via an API call.
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    this.fireEvent("move", { figure: this, dx: dx, dy: dx });
  },

  /**
   *
   * Moves the element so it is the closest to the viewers eyes, on top of other elements. Additional
   * the internal model changed as well.
   *
   * Optional: Inserts current object in front of the given one.
   *
   * @param {draw2d.Figure} [figure] move current object in front of the given one.
   * @since 3.0.0
   */
  toFront: function toFront(figure) {
    this._super(figure);

    // ensure that the decoration is always in front of the connection
    //
    if (this.shape !== null) {
      if (this.targetDecoratorNode !== null) {
        this.targetDecoratorNode.insertAfter(this.shape);
      }
      if (this.sourceDecoratorNode !== null) {
        this.sourceDecoratorNode.insertAfter(this.shape);
      }
    }

    return this;
  },

  /**
   *
   * Moves the element to the background. Additional
   * the internal model changed as well.
   *
   * @param {draw2d.Figure} [figure] move this object behind of the 'figure'.
   * @since 4.7.2
   */
  toBack: function toBack(figure) {
    this._super(figure);

    if (this.shape !== null) {
      if (this.targetDecoratorNode !== null) {
        this.targetDecoratorNode.insertAfter(this.shape);
      }
      if (this.sourceDecoratorNode !== null) {
        this.sourceDecoratorNode.insertAfter(this.shape);
      }
    }

    return this;
  },

  /**
   *
   * Return the recalculated position of the start point with the usage of
   * the installed connection anchor locator.
   *
   * @returns {draw2d.geo.Point}
   * @deprecated
   **/
  getStartPoint: function getStartPoint(refPoint) {
    return this.getStartPosition(refPoint);
  },

  getStartPosition: function getStartPosition(refPoint) {
    if (this.isMoving === false) {
      if (refPoint) {
        return this.sourcePort.getConnectionAnchorLocation(refPoint, this);
      }
      return this.sourcePort.getConnectionAnchorLocation(this.targetPort.getConnectionAnchorReferencePoint(this), this);
    }

    return this._super();
  },

  /**
   *
   * Return the recalculated position of the start point with the usage of
   * the installed connection anchor locator.
   *
   * @returns {draw2d.geo.Point}
   * @deprecated
   **/
  getEndPoint: function getEndPoint(refPoint) {
    return this.getEndPosition(refPoint);
  },

  getEndPosition: function getEndPosition(refPoint) {
    if (this.isMoving === false) {
      if (refPoint) {
        return this.targetPort.getConnectionAnchorLocation(refPoint, this);
      }
      return this.targetPort.getConnectionAnchorLocation(this.sourcePort.getConnectionAnchorReferencePoint(this), this);
    }

    return this._super();
  },

  /**
   *
   * Set the new source port of this connection. This enforce a repaint of the connection.
   *
   * @param {draw2d.Port} port The new source port of this connection.
   *
   **/
  setSource: function setSource(port) {
    if (this.sourcePort !== null) {
      this.sourcePort.off(this.moveListener);
      this.sourcePort.connections.remove(this);
      this.sourcePort.fireEvent("disconnect", { port: this.sourcePort, connection: this });
      // it is possible that a connection has already a port but is not assigned to
      // a canvas. In this case we must check if the canvas set correct before we fire this event
      if (this.canvas !== null) {
        this.canvas.fireEvent("disconnect", { "port": this.sourcePort, "connection": this });
      }
      this.sourcePort.onDisconnect(this);
    }

    this.sourcePort = port;
    if (this.sourcePort === null) {
      return;
    }

    this.routingRequired = true;
    this.fireSourcePortRouteEvent();
    this.sourcePort.connections.add(this);
    this.sourcePort.on("move", this.moveListener);
    if (this.canvas !== null) {
      this.canvas.fireEvent("connect", { "port": this.sourcePort, "connection": this });
    }
    this.sourcePort.fireEvent("connect", { port: this.sourcePort, connection: this });
    this.sourcePort.onConnect(this);

    this.setStartPoint(port.getAbsoluteX(), port.getAbsoluteY());
    this.fireEvent("connect", { "port": this.sourcePort, "connection": this });
  },

  /**
   *
   * Returns the source port of this connection.
   *
   * @returns {draw2d.Port}
   **/
  getSource: function getSource() {
    return this.sourcePort;
  },

  /**
   *
   * Set the target port of this connection. This enforce a repaint of the connection.
   *
   * @param {draw2d.Port} port The new target port of this connection
   **/
  setTarget: function setTarget(port) {
    if (this.targetPort !== null) {
      this.targetPort.off(this.moveListener);
      this.targetPort.connections.remove(this);
      this.targetPort.fireEvent("disconnect", { port: this.targetPort, connection: this });
      // it is possible that a connection has already a port but is not assigned to
      // a canvas. In this case we must check if the canvas set correct before we fire this event
      if (this.canvas !== null) {
        this.canvas.fireEvent("disconnect", { "port": this.targetPort, "connection": this });
      }
      this.targetPort.onDisconnect(this);
    }

    this.targetPort = port;
    if (this.targetPort === null) {
      return;
    }

    this.routingRequired = true;
    this.fireTargetPortRouteEvent();
    this.targetPort.connections.add(this);
    this.targetPort.on("move", this.moveListener);
    if (this.canvas !== null) {
      this.canvas.fireEvent("connect", { "port": this.targetPort, "connection": this });
    }
    this.targetPort.fireEvent("connect", { port: this.targetPort, connection: this });
    this.targetPort.onConnect(this);

    this.setEndPoint(port.getAbsoluteX(), port.getAbsoluteY());
    this.fireEvent("connect", { "port": this.targetPort, "connection": this });
  },

  /**
   *
   * Returns the target port of this connection.
   *
   * @returns {draw2d.Port}
   **/
  getTarget: function getTarget() {
    return this.targetPort;
  },

  /**
   *
   * Method returns true if the connection has at least one common draw2d.Port with the given connection.
   *
   * @param {draw2d.Connection} other
   *
   * @returns {Boolean}
   */
  sharingPorts: function sharingPorts(other) {
    return this.sourcePort == other.sourcePort || this.sourcePort == other.targetPort || this.targetPort == other.sourcePort || this.targetPort == other.targetPort;
  },

  /**
   *
   * Set the canvas element of this figures.
   *
   * @param {draw2d.Canvas} canvas the new parent of the figure or null
   */
  setCanvas: function setCanvas(canvas) {
    if (this.canvas === canvas) {
      return; // nothing to do
    }

    var notiCanvas = this.canvas == null ? canvas : this.canvas;

    this._super(canvas);

    if (canvas !== null && _packages2.default.Connection.DROP_FILTER === null) {
      _packages2.default.Connection.DROP_FILTER = canvas.paper.createFilter();
      _packages2.default.Connection.DROP_FILTER.element.setAttribute("width", "250%");
      _packages2.default.Connection.DROP_FILTER.element.setAttribute("height", "250%");
      _packages2.default.Connection.DROP_FILTER.element.setAttribute("filterUnits", "userSpaceOnUse");
      _packages2.default.Connection.DROP_FILTER.createShadow(1, 1, 2, 0.3);
    }

    if (this.sourceDecoratorNode !== null) {
      this.sourceDecoratorNode.remove();
      this.sourceDecoratorNode = null;
    }

    if (this.targetDecoratorNode !== null) {
      this.targetDecoratorNode.remove();
      this.targetDecoratorNode = null;
    }

    if (this.canvas === null) {
      if (this.sourcePort !== null) {
        this.sourcePort.off(this.moveListener);
        notiCanvas.fireEvent("disconnect", { "port": this.sourcePort, "connection": this });
        this.sourcePort.onDisconnect(this);
      }
      if (this.targetPort !== null) {
        this.targetPort.off(this.moveListener);
        notiCanvas.fireEvent("disconnect", { "port": this.targetPort, "connection": this });
        this.targetPort.onDisconnect(this);
      }
    } else {
      this.shape.items[0].filter(_packages2.default.Connection.DROP_FILTER);

      if (this.sourcePort !== null) {
        this.sourcePort.on("move", this.moveListener);
        this.canvas.fireEvent("connect", { "port": this.sourcePort, "connection": this });
        this.sourcePort.onConnect(this);
      }
      if (this.targetPort !== null) {
        this.targetPort.on("move", this.moveListener);
        this.canvas.fireEvent("connect", { "port": this.targetPort, "connection": this });
        this.targetPort.onConnect(this);
      }
    }
  },

  /**
   * Returns the angle of the connection at the output port (source)
   *
   **/
  getStartAngle: function getStartAngle() {
    // return a good default value if the connection is not routed at the
    //  moment
    if (this.lineSegments.getSize() === 0) {
      return 0;
    }

    var p1 = this.lineSegments.get(0).start;
    var p2 = this.lineSegments.get(0).end;
    if (this.router instanceof _packages2.default.layout.connection.SplineConnectionRouter) {
      p2 = this.lineSegments.get(5).end;
    }
    var length = Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
    var angle = -(180 / Math.PI) * Math.asin((p1.y - p2.y) / length);

    if (angle < 0) {
      if (p2.x < p1.x) {
        angle = Math.abs(angle) + 180;
      } else {
        angle = 360 - Math.abs(angle);
      }
    } else {
      if (p2.x < p1.x) {
        angle = 180 - angle;
      }
    }
    return angle;
  },

  getEndAngle: function getEndAngle() {
    // return a good default value if the connection is not routed at the
    //  moment
    if (this.lineSegments.getSize() === 0) {
      return 90;
    }

    var p1 = this.lineSegments.get(this.lineSegments.getSize() - 1).end;
    var p2 = this.lineSegments.get(this.lineSegments.getSize() - 1).start;
    if (this.router instanceof _packages2.default.layout.connection.SplineConnectionRouter) {
      p2 = this.lineSegments.get(this.lineSegments.getSize() - 5).end;
    }
    var length = Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
    var angle = -(180 / Math.PI) * Math.asin((p1.y - p2.y) / length);

    if (angle < 0) {
      if (p2.x < p1.x) {
        angle = Math.abs(angle) + 180;
      } else {
        angle = 360 - Math.abs(angle);
      }
    } else {
      if (p2.x < p1.x) {
        angle = 180 - angle;
      }
    }
    return angle;
  },

  /**
   * @private
   **/
  fireSourcePortRouteEvent: function fireSourcePortRouteEvent() {
    this.sourcePort.getConnections().each(function (i, conn) {
      conn.routingRequired = true;
      conn.repaint();
    });
  },

  /**
   * @private
   **/
  fireTargetPortRouteEvent: function fireTargetPortRouteEvent() {
    // enforce a repaint of all connections which are related to this port
    // this is required for a "FanConnectionRouter" or "ShortesPathConnectionRouter"
    //
    this.targetPort.getConnections().each(function (i, conn) {
      conn.routingRequired = true;
      conn.repaint();
    });
  },

  /**
   *
   * Returns the Command to perform the specified Request or null.
   *
   * @param {draw2d.command.CommandType} request describes the Command being requested
   *
   * @returns {draw2d.command.Command} null or a Command
   **/
  createCommand: function createCommand(request) {
    if (request.getPolicy() === _packages2.default.command.CommandType.MOVE) {
      if (this.isDraggable()) {
        return new _packages2.default.command.CommandMoveVertices(this);
      }
    }

    if (request.getPolicy() === _packages2.default.command.CommandType.MOVE_BASEPOINT) {
      // DragDrop of a connection doesn't create a undo command at this point. This will be done in
      // the onDrop method
      return new _packages2.default.command.CommandReconnect(this);
    }

    return this._super(request);
  },

  /**
   *
   * Return an objects with all important attributes for XML or JSON serialization
   *
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    var parentNode = this.getSource().getParent();
    while (parentNode.getParent() !== null) {
      parentNode = parentNode.getParent();
    }
    memento.source = {
      node: parentNode.getId(),
      port: this.getSource().getName()
    };

    parentNode = this.getTarget().getParent();
    while (parentNode.getParent() !== null) {
      parentNode = parentNode.getParent();
    }
    memento.target = {
      node: parentNode.getId(),
      port: this.getTarget().getName()
    };

    if (this.sourceDecorator !== null) {
      memento.source.decoration = this.sourceDecorator.NAME;
    }

    if (this.targetDecorator !== null) {
      memento.target.decoration = this.targetDecorator.NAME;
    }

    return memento;
  },

  /**
   *
   * Read all attributes from the serialized properties and transfer them into the shape.
   *
   * @param {Object} memento
   * @returns {this}
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    // nothing to to for the connection creation. This will be done in the draw2d.io.Reader
    // implementation
    //
    // restore your custom attributes here
    if (typeof memento.target.decoration !== "undefined" && memento.target.decoration != null) {
      this.setTargetDecorator(eval("new " + memento.target.decoration));
    }

    if (typeof memento.source.decoration !== "undefined" && memento.source.decoration != null) {
      this.setSourceDecorator(eval("new " + memento.source.decoration));
    }

    return this;
  }
});

_packages2.default.Connection.DROP_FILTER = null;

/***/ }),

/***/ "./src/Figure.js":
/*!***********************!*\
  !*** ./src/Figure.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _JSONUtil = __webpack_require__(/*! util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

var _UUID = __webpack_require__(/*! util/UUID */ "./src/util/UUID.js");

var _UUID2 = _interopRequireDefault(_UUID);

var _extend = __webpack_require__(/*! util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @class
 * Base class for all draw2d shapes-
 *
 */
_packages2.default.Figure = Class.extend(
/**  @lends draw2d.Figure.prototype */
{
  NAME: "draw2d.Figure",
  MIN_TIMER_INTERVAL: 50, // minimum timer interval in milliseconds

  /**
   * Creates a new Figure object
   *
   * @param attr
   * @param setter
   * @param getter
   */
  init: function init(attr, setter, getter) {
    var _this2 = this;

    // @private
    this.setterWhitelist = (0, _extend2.default)({
      //  id the unique id of the figure
      id: this.setId,
      //  x the x offset of the figure in relation to the parent figure or canvas 
      x: this.setX,
      //  y the y offset of the figure in relation to the parent figure or canvas 
      y: this.setY,
      //  width the new width of the figure. Considering the minWidth of the shape 
      width: this.setWidth,
      //  height the new height of the figure. Considering the minHeight of the shape 
      height: this.setHeight,
      //  boundingBox set the new bounding box of the shape 
      boundingBox: this.setBoundingBox,
      //   minWidth the new min width of the figure. 
      minWidth: this.setMinWidth,
      // minHeight the new min height of the figure. 
      minHeight: this.setMinHeight,
      //  cssClass the css class of the shape. can be used to style the shape via CSS3 (SVG only) 
      cssClass: this.setCssClass,
      //  userData additional custom data which can be stored by the shape 
      userData: this.setUserData,
      // draggable drives the dragging behaviour of the shape 
      draggable: this.setDraggable,
      //  resizeable drives the resizeable behaviour of the shape 
      resizeable: this.setResizeable,
      //  selectable drives the selectable behaviour of the shape 
      selectable: this.setSelectable,
      //  angle the rotation angle of the shape. At the moment only 90 degree increments are possible 
      angle: this.setRotationAngle,
      //  alpha the the alpha/opacity of the shape. value must be between [0..1] 
      alpha: this.setAlpha,
      //  opacity the the alpha/opacity of the shape. value must be between [0..1] 
      opacity: this.setAlpha,
      //  glow the glow flag for the shape. The representation of the "glow" depends on the shape 
      glow: this.setGlow,
      //  visible set the visibility flag of the shape 
      visible: this.setVisible,
      //  keepAspectRatio indicate if the shape should keep the aspect ratio during resize 
      keepAspectRatio: this.setKeepAspectRatio
    }, setter);

    this.getterWhitelist = (0, _extend2.default)({
      id: this.getId,
      visible: this.isVisible,
      angle: this.getRotationAngle,
      x: this.getX,
      y: this.getY,
      width: this.getWidth,
      height: this.getHeight,
      draggable: this.isDraggable,
      resizeable: this.isResizeable,
      selectable: this.isSelectable,
      alpha: this.getAlpha,
      opacity: this.getAlpha
    }, getter);

    // all figures has an unique id. Required for figure get and persistence storage
    this.id = _UUID2.default.create();

    // required for the SelectionEditPolicy to indicate the type of figure
    // which the user clicks
    this.isResizeHandle = false;

    // for undo/redo operation. It holds the command during a drag/drop operation
    // and execute it on the CommandStack if the user drop the figure.
    this.command = null;

    // the assigned canvas
    this.canvas = null;

    // the RaphaelJS element reference
    this.shape = null;

    // possible decorations ( e.g. a Label) of the Connection
    // children are fixed bounded the figure. Most of the events of the child will bee
    // routed to the parent
    this.children = new _packages2.default.util.ArrayList();

    // behavior flags
    //
    this.selectable = true;
    this.deleteable = true;
    this.resizeable = true;
    this.draggable = true;
    this.visible = true;
    // since 4.1.0.
    this.keepAspectRatio = false;

    this.canSnapToHelper = true;
    this.snapToGridAnchor = new _packages2.default.geo.Point(0, 0); // hot spot for snap to grid
    this.editPolicy = new _packages2.default.util.ArrayList();

    // timer for animation or automatic update
    //
    this.timerId = -1;
    this.timerInterval = 0;

    // possible parent of the figure.
    // @see: this.children
    this.parent = null;

    // a figure can be part of a StrongComposite like a group, ...
    //
    this.composite = null;

    // generic handle for the JSON read/write of user defined data
    this.userData = null;

    // appearance, position and dim properties
    //
    this.x = 0;
    this.y = 0;
    this.minHeight = 5;
    this.minWidth = 5;
    this.rotationAngle = 0;
    // add the name of the class to the css attribute
    this.cssClass = this.NAME.replace(new RegExp("[.]", "g"), "_");

    this.width = this.getMinWidth();
    this.height = this.getMinHeight();

    this.alpha = 1.0;

    // internal status flags for the Drag&Drop operation handling and other stuff
    //
    this.isInDragDrop = false;

    this.ox = 0;
    this.oy = 0;
    this.repaintBlocked = false;
    this.lastAppliedAttributes = {};
    this.selectionHandles = new _packages2.default.util.ArrayList();
    this.panningDelegate = null;

    // even handling since version 5.0.0
    this.eventSubscriptions = {};

    this.relocateChildrenEventCallback = function () {
      _this2.children.each(function (i, e) {
        e.locator.relocate(i, e.figure);
      });
    };

    // new approach to delegate selection requests.
    //
    this.defaultSelectionAdapter = this.selectionAdapter = function () {
      return _this2;
    };

    // install default selection handler. Can be overridden or replaced
    this.installEditPolicy(new _packages2.default.policy.figure.RectangleSelectionFeedbackPolicy());

    // the new style attr call with object attributes
    this.attr(attr);
  },

  /**
   * 
   * Read or set shape attributes.<br>
   * When no value is given, reads specified attribute from the element.<br>
   * When value is given, sets the attribute to that value.
   * Multiple attributes can be set by passing an object with name-value pairs.
   *
   *    let figure = new draw2d.shape.basic.Rectangle();
   *    figure.attr('x');      //=> read value
   *    figure.attr('x', 30);  //=> set value
   *
   *    // multiple attributes:
   *    figure.attr({
   *      x: 30,
   *      y: 40,
   *      width : 200,
   *      height: 50,
   *      cssClass: "red_border_figure"
   *    });
   *
   *    // it is possible to override any method of the figure as well
   *    // Instead of inheritance you can just override the callback methods
   *    // like
   *    //
   *    figure.attr({
   *       onClick : function(){
   *           alert("click");
   *       }
   *    });
   *
   *    // or you can pass the attr values in the constructor
   *    //
   *    let clickFigure = new draw2d.shape.basic.Rectangle({
   *       onClick : function(){
   *           alert("click");
   *       }
   *    });
   *
   *
   * Additional you can set the user defined values (userData) with this method
   * using the dot-notation. User defined values are always part of the exported
   * JSON data.
   *
   *    // setting multiple attributes:
   *    figure.attr({
   *      "userData.my.property.x": 30,
   *      "userData.my.property.y": 40
   *    });
   *
   * Also set using array notation is possible for the userData:
   *
   *    // dot notation and array brackets:
   *    figure.attr({
   *      "userData.my.names[0]": "John",
   *      "userData.my.names[1]": "Doe"
   *    });
   *
   *
   * The Object returned should be the equivalent structured object:
   *
   *    let obj = figure.getUserData();
   *
   * That is, where obj is equivalent to:
   *
   *    let obj = {
   *        my:{
   *            property:{
   *                x: 30,
   *                y: 40
   *           },
   *           names:  ["John", "Doe"]
   *       }
   *    };
   *
   *
   *
   * @param {String/Object} name
   * @param {Object} [value]
   * @since 5.0.1
   * @experimental
   * @returns {Object} either the requested attribute if this method used as getter or `this` if the method uses as setter
   **/
  attr: function attr(name, value) {
    var _this = this;
    var orig = this.repaintBlocked;

    try {
      // call of attr as setter method with {name1:val1, name2:val2 }  argument list
      //
      if ($.isPlainObject(name)) {
        for (var key in name) {
          // user can set the "userData" with path notation. In this case we
          // expand the path to a real JSON object and set the data.
          // index/brackets are allowed too.
          //
          if (key.substring(0, 9) === "userData.") {
            if (this.userData === null) {
              this.userData = {};
            }
            _JSONUtil2.default.set({ userData: this.userData }, key, name[key]);
            this.fireEvent("change:" + key, { value: name[key] });
          } else {
            var func = this.setterWhitelist[key];
            var param = name[key];
            if (func && param !== undefined) {
              func.call(this, param);
            }
            // maybe the user adds a function as property to the attr call
            // e.g.:
            // {
            //     doIt: function(){}
            // }
            //
            // in this case we assign the method to this object and wrap it with "this" as context
            // a very, very simple method to replace default implemenations of the object
            else if (typeof name[key] === "function") {
                this[key] = param.bind(this);
              }
          }
        }
      } else if (typeof name === "string") {
        // call attr as getter
        //
        if (typeof value === "undefined") {
          var getter = this.getterWhitelist[name];
          if (typeof getter === "function") {
            return getter.call(this);
          }
          // or it is a userData path notation like "userData.any.path.value"
          else if (name.substring(0, 9) === "userData.") {
              var data = { userData: this.userData };
              return _JSONUtil2.default.get(data, name);
            }
          return; // undefined
        }
        // call attr as simple setter with (key , value)
        //

        // the value can be a function. In this case we must call the value().
        if (typeof value === "function") {
          value = value();
        }
        if (name.substring(0, 9) === "userData.") {
          if (this.userData === null) {
            this.userData = {};
          }
          _JSONUtil2.default.set({ userData: this.userData }, name, value);
          this.fireEvent("change:" + name, { value: value });
        } else {
          var setter = this.setterWhitelist[name];
          if (setter) {
            setter.call(this, value);
          }
        }
      }
      // may it is a array of attributes used for the getter
      //
      else if (Array.isArray(name)) {
          return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.keys(name).map(function (k) {
            return _defineProperty({}, k, _this.attr(k));
          }))));
        }
        // generic getter of all registered attributes
        else if (typeof name === "undefined") {
            var result = {};
            for (var _key in this.getterWhitelist) {
              result[_key] = this.getterWhitelist[_key].call(this);
            }
            return result;
          }
    } finally {
      this.repaintBlocked = orig;
    }
    //  this.repaint();

    return this;
  },

  /**
   * Return a copy of the object, filtered to only have values for the whitelisted keys.
   * @deprecated
   */
  pick: function pick(obj, var_keys) {
    var keys = typeof arguments[1] !== 'string' ? arguments[1] : Array.prototype.slice.call(arguments, 1);
    var out = {},
        key = void 0;
    for (key in keys) {
      if (typeof obj[key] !== "undefined") out[key] = obj[key];
    }
    return out;
  },

  /**
   * 
   * Add the figure to the current selection and propagate this to all edit policies.
   *
   * @param {Boolean} [asPrimarySelection] true if the element should be the primary selection
   * @private
   */
  select: function select(asPrimarySelection) {
    if (typeof asPrimarySelection === "undefined") {
      asPrimarySelection = true;
    }

    // apply all EditPolicy for select Operations
    //
    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.SelectionPolicy) {
        e.onSelect(_this.canvas, _this, asPrimarySelection);
      }
    });

    if (this.canvas !== null) {
      this.canvas.getSelection().add(this);
    }

    this.fireEvent("select", { figure: this });

    return this;
  },

  /**
   * 
   * Unselect the figure and propagete this event to all edit policies.
   *
   * @private
   **/
  unselect: function unselect() {
    var _this = this;
    // apply all EditPolicy for select Operations
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.SelectionPolicy) {
        e.onUnselect(_this.canvas, _this);
      }
    });

    if (this.canvas !== null) {
      this.canvas.getSelection().remove(this);
    }

    this.fireEvent("unselect", { figure: this });
    return this;
  },

  /**
   * 
   * Returns a function which returns the the figure which must handle the selection handling.
   *
   * @param {Function} [adapter] function which returns the figure which handles the selection handling
   */
  setSelectionAdapter: function setSelectionAdapter(adapter) {
    if (adapter == null) {
      this.selectionAdapter = this.defaultSelectionAdapter;
    } else {
      this.selectionAdapter = adapter;
    }

    return this;
  },

  /**
   * 
   *
   * @returns {Function}
   */
  getSelectionAdapter: function getSelectionAdapter() {
    return this.selectionAdapter;
  },

  /**
   * 
   * Returns true if the figure part of the current canvas selection.
   *
   * @since 5.5.6
   *
   * @returns {Boolean}
   */
  isSelected: function isSelected() {
    if (this.canvas !== null) {
      return this.canvas.getSelection().contains(this);
    }

    return false;
  },

  /**
   * 
   * Allows a user to attach (or remove) data to an element, without needing to create a custom figure or shape.
   * The data must be a valid JSON object.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       userData: object
   *     });
   *
   * @since 2.7.2
   * @param {Object} object
   */
  setUserData: function setUserData(object) {
    this.userData = object;
    this.fireEvent("change:userData", { value: object });
    return this;
  },

  /**
   * 
   * Returns any user data set previously on the given figure by setUserData.
   *
   * @since 2.7.2
   * @returns {Object}
   */
  getUserData: function getUserData() {
    return this.userData;
  },

  /**
   * 
   * Return the UUID of this element.
   *
   * @returns {String}
   */
  getId: function getId() {
    return this.id;
  },

  /**
   * 
   * Set the id of this element.
   *
   *    // Alternatively you can use the attr method:
   *    figure.attr({
   *      id: newId
   *    });
   *
   * @param {String} newId the new id for this figure
   */
  setId: function setId(newId) {
    this.id = newId;

    return this;
  },

  /**
   * 
   * Return the css styling class name of the element.
   *
   *
   * @returns {String}
   */
  getCssClass: function getCssClass() {
    return this.cssClass;
  },

  /**
   * 
   * Set the css class of the node.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       "cssClass": "red_border_figure"
   *     });
   *
   * @param {String} cssClass the new css class name of the node
   * @since 2.9.0
   */
  setCssClass: function setCssClass(cssClass) {
    this.cssClass = cssClass === null ? null : cssClass.trim();

    if (this.shape === null) {
      return this;
    }

    if (this.cssClass === null) {
      this.shape.node.removeAttribute("class");
    } else {
      this.shape.node.setAttribute("class", this.cssClass);
    }
    this.fireEvent("change:cssClass", { value: this.cssClass });

    return this;
  },

  /**
   * 
   * The method will return true if the class is assigned to the element, even if other classes also are.
   *
   * @param {String} className the class name to check
   * @since 2.9.0
   */
  hasCssClass: function hasCssClass(className) {
    if (this.cssClass === null) {
      return false;
    }

    return new RegExp(' ' + className.trim() + ' ').test(' ' + this.cssClass + ' ');
  },

  /**
   * 
   * Add a CSS class to the figure.<br>
   * It's important to note that this method does not replace a class. It simply adds the class,
   * appending it to any which may already be assigned to the elements.
   *
   * @param {String} className
   * @since 2.9.0
   */
  addCssClass: function addCssClass(className) {
    className = className.trim();
    if (!this.hasCssClass(className)) {
      if (this.cssClass === null) {
        this.setCssClass(className);
      } else {
        this.setCssClass(this.cssClass + ' ' + className);
      }
      this.fireEvent("change:cssClass", { value: this.cssClass });
    }

    return this;
  },

  /**
   * 
   *
   * Remove the given css class name from the figure
   *
   * @param {String} className the css class name to add
   */
  removeCssClass: function removeCssClass(className) {
    className = className.trim();
    var newClass = ' ' + this.cssClass.replace(/[\t\r\n]/g, ' ') + ' ';
    if (this.hasCssClass(className)) {
      while (newClass.indexOf(' ' + className + ' ') >= 0) {
        newClass = newClass.replace(' ' + className + ' ', ' ');
      }
      this.setCssClass(newClass.replace(/^\s+|\s+$/g, ''));
      this.fireEvent("change:cssClass", { value: this.cssClass });
    }

    return this;
  },

  /**
   * 
   *
   * Add or remove the given css class name from the figure
   *
   * @param {String} className the class name to toggle
   */
  toggleCssClass: function toggleCssClass(className) {
    className = className.trim();
    var newClass = ' ' + this.cssClass.replace(/[\t\r\n]/g, ' ') + ' ';
    if (this.hasCssClass(className)) {
      while (newClass.indexOf(' ' + className + ' ') >= 0) {
        newClass = newClass.replace(' ' + className + ' ', ' ');
      }
      this.setCssClass(newClass.replace(/^\s+|\s+$/g, ''));
    } else {
      this.setCssClass(this.cssClass + ' ' + className);
    }
    this.fireEvent("change:cssClass", { value: this.cssClass });

    return this;
  },

  /**
   * 
   * Set the canvas element of this figures. This can be used to determine whenever an element
   * is added or removed to the canvas.
   *
   * @param {draw2d.Canvas} canvas the new parent of the figure or null
   */
  setCanvas: function setCanvas(canvas) {
    // remove the shape if we reset the canvas and the element
    // was already drawn
    if (canvas === null && this.shape !== null) {
      if (this.isSelected()) {
        this.unselect();
      }
      this.shape.remove();
      this.shape = null;
    }

    this.canvas = canvas;

    if (this.canvas !== null) {
      this.getShapeElement();
    }

    // reset the attribute cache. We must start by paint all attributes
    //
    this.lastAppliedAttributes = {};

    if (canvas === null) {
      this.stopTimer();
    } else {
      if (this.timerInterval >= this.MIN_TIMER_INTERVAL) {
        this.startTimer(this.timerInterval);
      }
    }

    this.children.each(function (i, e) {
      e.figure.setCanvas(canvas);
    });

    return this;
  },

  /**
   * 
   * Return the current assigned canvas container.
   *
   * @returns {draw2d.Canvas}
   */
  getCanvas: function getCanvas() {
    return this.canvas;
  },

  /**
   * 
   * Start a timer which calls the onTimer method in the given interval.
   *
   * @param {Number} milliSeconds
   */
  startTimer: function startTimer(milliSeconds) {
    var _this3 = this;

    this.stopTimer();
    this.timerInterval = Math.max(this.MIN_TIMER_INTERVAL, milliSeconds);

    if (this.canvas !== null) {
      this.timerId = window.setInterval(function () {
        _this3.onTimer();
        _this3.fireEvent("timer");
      }, this.timerInterval);
    }

    return this;
  },

  /**
   * 
   * Stop the internal timer.
   *
   */
  stopTimer: function stopTimer() {
    if (this.timerId >= 0) {
      window.clearInterval(this.timerId);
      this.timerId = -1;
    }

    return this;
  },

  /**
   * 
   * Callback method for the internal timer handling<br>
   * Inherit classes must override this method if they want use the timer feature.
   *
   *     // Alternatively you can register for this event with
   *     figure.on("timer", function(emitter){
   *         alert("timer fired");
   *     });
   *
   * @template
   */
  onTimer: function onTimer() {},

  /**
   * 
   * Moves the element so it is the closest to the viewers eyes, on top of other elements. Additional
   * the internal model changed as well.
   *
   * Optional: Inserts current object in front of the given one.
   *
   * @param {draw2d.Figure} [figure] move current object in front of the given one.
   * @since 3.0.0
   */
  toFront: function toFront(figure) {
    // ensure that the z-oder is still correct if the figure is assigned
    // to a StrongComposite
    //
    if (this.composite instanceof _packages2.default.shape.composite.StrongComposite && typeof figure !== "undefined") {
      var indexFigure = figure.getZOrder();
      var indexComposite = this.composite.getZOrder();
      if (indexFigure < indexComposite) {
        figure = this.composite;
      }
    }

    if (typeof figure === "undefined") {
      this.getShapeElement().toFront();

      if (this.canvas !== null) {
        var figures = this.canvas.getFigures();
        var lines = this.canvas.getLines();
        if (figures.remove(this) !== null) {
          figures.add(this);
        } else if (lines.remove(this) !== null) {
          lines.add(this);
        }
      }
    } else {
      this.getShapeElement().insertAfter(figure.getTopLevelShapeElement());

      if (this.canvas !== null) {
        var _figures = this.canvas.getFigures();
        var _lines = this.canvas.getLines();
        if (_figures.remove(this) !== null) {
          var index = _figures.indexOf(figure);
          _figures.insertElementAt(this, index + 1);
        } else if (_lines.remove(this) !== null) {
          _lines.add(this);
        }
      }
    }

    // bring all children in front of the parent
    var _this = this;
    this.children.each(function (i, child) {
      child.figure.toFront(_this);
    });

    // and last but not lease the ResizeHandles if any present
    //
    this.selectionHandles.each(function (i, handle) {
      handle.toFront();
    });

    return this;
  },

  /**
   * 
   * Moves the element to the background. Additional
   * the internal model changed as well.
   *
   * @since 4.7.2
   */
  toBack: function toBack(figure) {
    // it is not allowed that a figure is behind an assigned composite
    //
    if (this.composite instanceof _packages2.default.shape.composite.StrongComposite) {
      this.toFront(this.composite);
      return;
    }

    if (this.canvas !== null) {
      var figures = this.canvas.getFigures();
      var lines = this.canvas.getLines();
      if (figures.remove(this) !== null) {
        figures.insertElementAt(this, 0);
      } else if (lines.remove(this) !== null) {
        lines.insertElementAt(this, 0);
      }
      if (typeof figure !== "undefined") {
        this.getShapeElement().insertBefore(figure.getShapeElement());
      } else {
        this.getShapeElement().toBack();
      }
    }

    // Bring all children in front of "this" figure
    //
    var _this = this;
    this.children.each(function (i, child) {
      child.figure.toFront(_this);
    }, true);

    return this;
  },

  /**
   * 
   * Install a new edit policy to the figure. Each editpolicy is able to focus on a single editing
   * task or group of related tasks. This also allows editing behavior to be selectively reused across
   * different figure implementations. Also, behavior can change dynamically, such as when the layouts
   * or routing methods change.
   *
   * Example for limited DragDrop behavior can be a draw2d.layout.constraint.RegionConstriantPolicy.
   *
   * @param {draw2d.policy.EditPolicy} policy
   */
  installEditPolicy: function installEditPolicy(policy) {
    var _this4 = this;

    // it is only possible to install one SelectionFeedbackPolicy at once
    //
    if (policy instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy) {
      this.editPolicy.grep(function (p) {
        var stay = !(p instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy);
        if (!stay) {

          p.onUninstall(_this4);
        }
        return stay;
      });
    }
    policy.onInstall(this);
    this.editPolicy.add(policy);

    return this;
  },

  /**
   * 
   *
   * UnInstall the edit policy from the figure. Either the instance itself if found
   * or all kind of the given edit policies.
   *
   *
   * @param {draw2d.policy.EditPolicy} policy
   * @since 4.81
   */
  uninstallEditPolicy: function uninstallEditPolicy(policy) {
    var removedPolicy = this.editPolicy.remove(policy);

    // we found the policy and we are happy
    //
    if (removedPolicy !== null) {
      removedPolicy.onUninstall(this);
      return;
    }

    // The policy isn'T part of the figure. In this case we "think" the user want
    // deinstall all instances of the policy
    //
    var _this = this;
    var name = typeof policy === "string" ? policy : policy.NAME;
    this.editPolicy.grep(function (p) {
      if (p.NAME === name) {
        p.onUninstall(_this);
        return false;
      }
      return true;
    });
  },

  /**
   * Add a child figure to the figure. The hands over figure doesn't support drag&drop
   * operations. It's only a decorator for the connection.<br>
   * Mainly for labels or other decorations
   *
   *
   *    let start = new draw2d.shape.node.Start({x:80, y:150});
   *    start.add(new draw2d.shape.basic.Label({text:"Test Label"}), new draw2d.layout.locator.TopLocator());
   *
   *    canvas.add( start);
   *
   * 
   * @param {draw2d.Figure} child the figure to add as decoration to the connection.
   * @param {draw2d.layout.locator.Locator} locator the locator for the child.
   * @param {Number} [index] optional index where to insert the figure
   **/
  add: function add(child, locator, index) {
    if (typeof locator === "undefined" || locator === null) {
      throw "Second parameter 'locator' is required for method 'Figure#add'";
    }

    // the child is now a slave of the parent
    //
    child.setParent(this);

    // inform the locator that a new child is bounded to the parent
    // The call must happen after parent assignment. Reason: the locator
    // can override some behaviours which are propagated from the parent.
    //
    locator.bind(this, child);

    child.on("resize", this.relocateChildrenEventCallback);

    if (!isNaN(parseInt(index))) {
      this.children.insertElementAt({ figure: child, locator: locator }, index);
    } else {
      this.children.add({ figure: child, locator: locator });
    }

    if (this.canvas !== null) {
      child.setCanvas(this.canvas);
    }

    this.repaint();

    return this;
  },

  /**
   * 
   * Remove the child figure from this figure and the canvas
   *
   * @param {draw2d.Figure} child the figure to remove.
   *
   * @returns {Object} the removed tupple of figure/locator or null if the child isn't found
   * @returns {draw2d.Figure} return.figure The removed figure
   * @returns {draw2d.shape.layout.Layout} return.locator The used locator of the figure
   *
   * @since 5.0.0
   **/
  remove: function remove(child) {
    if (typeof child === "undefined" || child === null) {
      debug.warn("The parameter child is required for Figure.remove");
      return null;
    }

    var removed = null;
    this.children.grep(function (e) {
      var stay = e.figure !== child;
      if (!stay) {
        removed = e;
      }
      return stay;
    });

    if (removed !== null) {
      child.setParent(null);
      child.setCanvas(null);
      removed.locator.unbind(this, child);
      child.off(this.relocateChildrenEventCallback);

      this.repaint();
      return removed;
    }

    return null;
  },

  /**
   * 
   * Return all children/decorations of this shape which has been added with
   * draw2d.Figure.add
   *
   * @returns {draw2d.util.ArrayList}
   */
  getChildren: function getChildren() {
    return this.children.clone().map(function (e) {
      return e.figure;
    });
  },

  /**
   * 
   * Remove all children/decorations of this shape
   *
   */
  resetChildren: function resetChildren() {
    this.children.each(function (i, e) {
      e.figure.setCanvas(null);
    });
    this.children = new _packages2.default.util.ArrayList();
    this.repaint();

    return this;
  },

  /**
   * 
   * return the current SVG shape element or create it on demand.
   *
   * @protected
   */
  getShapeElement: function getShapeElement() {
    if (this.shape !== null) {
      return this.shape;
    }

    this.shape = this.createShapeElement();
    if (!this.isVisible()) {
      this.shape.hide();
    }

    // add CSS class to enable styling of the element with CSS rules/files
    //
    if (this.cssClass !== null) {
      this.shape.node.setAttribute("class", this.cssClass);
    }

    return this.shape;
  },

  /**
   * 
   * Get the top level shape element. May the figure has a set of SVG elements. In this case this
   * method must return the top level node.<br>
   * This method is used for the toFront/toBack method to order the nodes in the correct way.
   *
   * @since 5.0.0
   * @private
   */
  getTopLevelShapeElement: function getTopLevelShapeElement() {
    return this.getShapeElement();
  },

  /**
   * 
   * Inherited classes must override this method to implement it's own draw functionality.
   *
   * @template
   * @abstract
   */
  createShapeElement: function createShapeElement() {
    throw "Inherited class [" + this.NAME + "] must override the abstract method createShapeElement";
  },

  /**
   * 
   * propagate all attributes like color, stroke,... to the shape element
   *
   * @param {Object} [attributes] the style attributes for the SVG shape
   * @private
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return this;
    }
    var _this = this;
    attributes = attributes || {};

    if (this.visible === true) {
      if (this.shape.isVisible() === false) {
        if (!isNaN(parseFloat(attributes.visibleDuration))) {
          $(this.shape.node).fadeIn(attributes.visibleDuration, function () {
            _this.shape.show();
          });
        } else {
          this.shape.show();
        }
      }
    } else {
      if (this.shape.isVisible() === true) {
        if (!isNaN(parseFloat(attributes.visibleDuration))) {
          $(this.shape.node).fadeOut(attributes.visibleDuration, function () {
            _this.shape.hide();
          });
        } else {
          this.shape.hide();
        }
      }
      return this;
    }

    // enrich with common properties
    attributes.opacity = this.alpha;

    // performance improvement
    // Only apply attributes which has changed. This ends in a big performance improvement
    // because the raphael shape isn't redraw at all.
    //
    attributes = _JSONUtil2.default.flatDiff(attributes, this.lastAppliedAttributes);
    this.lastAppliedAttributes = attributes;

    if (Object.getOwnPropertyNames(attributes).length > 0) {
      this.shape.attr(attributes);
    }

    this.applyTransformation();

    // Relocate all children of the figure.
    // This means that the Locator can calculate the new Position of the child.
    // This is not the best place for this. Move it to dim/size/shape changing
    // methods of the figure. A "repaint" isn't always dimension changing the figure.
    //
    this.children.each(function (i, e) {
      e.locator.relocate(i, e.figure);
    });

    return this;
  },

  /**
   * 
   * apply a transformation to the shape like rotation, translate,..
   *
   * @private
   * @template
   */
  applyTransformation: function applyTransformation() {
    return this;
  },

  /**
   * 
   * Highlight the element or remove the highlighting
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       glow: flag
   *     });
   *
   * @param {Boolean} flag indicates glow/noGlow
   * @template
   */
  setGlow: function setGlow(flag) {
    // do nothing in the base class.
    // Subclasses must implement this method.

    return this;
  },

  /**
   * 
   * Allow dragging only when the cursor is over a specific part of the figure.
   * <br>
   * Override this method to specify the bounding box of an element or a draw2d.util.ArrayList
   * of draw2d.geo.Rectangle of bounding boxes used to drag the figure. The returned coordinates
   * are absolute coordinates to the canvas.
   * <br>
   * <br>
   * Default implementation returns <b>null</b> to indicate to use the complete figures as
   * drag handle.
   *
   * @since 5.6.0
   * @returns {draw2d.geo.Rectangle|draw2d.util.ArrayList}
   */
  getHandleBBox: function getHandleBBox() {
    return null;
  },

  /**
   * 
   * Called if the drag and drop action begins. You can return [false] if you
   * want avoid that the figure can be move.
   *
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean} true if the figure accepts dragging
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
    this.isInDragDrop = false;

    // Check whenever the figures has a drag-handle. Allow drag&drop
    // operation only if the x/y is inside this area.
    //
    // @since 5.6.0
    var bbox = this.getHandleBBox();
    if (bbox !== null && bbox.translate(this.getAbsolutePosition().scale(-1)).hitTest(x, y) === false) {
      // design failure: we must catch the figure below the mouse to forward
      // the panning event to this figure. Special handling to provide sliders
      // and other UI elements which requires the panning event. Hack.
      this.panningDelegate = this.getBestChild(this.getX() + x, this.getY() + y);
      if (this.panningDelegate !== null) {
        // transform x/y relative to the panning figure and request the dragStart event
        this.panningDelegate.onDragStart(x - this.panningDelegate.x, y - this.panningDelegate.y, shiftKey, ctrlKey);
      }
      return false;
    }

    this.command = this.createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.MOVE));

    if (this.command !== null) {
      this.ox = this.getX();
      this.oy = this.getY();
      this.isInDragDrop = true;

      // notify all installed policies
      //
      var _this = this;
      var canStartDrag = true;

      this.editPolicy.each(function (i, e) {
        if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
          canStartDrag = canStartDrag && e.onDragStart(_this.canvas, _this, x, y, shiftKey, ctrlKey);
        }
      });

      if (canStartDrag) {
        // fire an event
        // @since 5.3.3
        this.fireEvent("dragstart", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
      }
      return canStartDrag;
    }

    return false;
  },

  /**
   * 
   * Don't call them manually. This will be done by the framework.<br>
   * Will be called if the object are moved via drag and drop.
   * Sub classes can override this method to implement additional stuff. Don't forget to call
   * the super implementation via <code>this._super(dx, dy, dx2, dy2);</code>
   *
   * @private
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    var _this5 = this;

    // apply all EditPolicy for DragDrop Operations. This is something like
    // an policy that forces that an object can only move vertical, horizontal or in a given
    // rectangle.
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        var _newPos = e.adjustPosition(_this5, _this5.ox + dx, _this5.oy + dy);
        if (_newPos) {
          dx = _newPos.x - _this5.ox;
          dy = _newPos.y - _this5.oy;
        }
      }
    });
    var newPos = new _packages2.default.geo.Point(this.ox + dx, this.oy + dy);

    // Adjust the new location if the object can snap to a helper
    // like grid, geometry, ruler,...
    //
    if (this.getCanSnapToHelper()) {
      newPos = this.getCanvas().snapToHelper(this, newPos);
    }

    this.setPosition(newPos);

    // notify all installed policies that the object has moved.
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.onDrag(_this5.canvas, _this5);
      }
    });

    // notify all installed listener that th object has moved
    // @since 5.3.3
    this.fireEvent("drag", { dx: dx, dy: dy, dx2: dx2, dy2: dy2, shiftKey: shiftKey, ctrlKey: ctrlKey });
  },

  /**
   * 
   * Called by the framework if the figure returns false for the drag operation. In this
   * case we send a "panning" event - mouseDown + mouseMove. This is very useful for
   * UI-Widget like slider, spinner,...
   *
   *     // You can alternatively register an event handler with:
   *     figure.on("panning", function(emitter, eventData){
   *         alert("panning of the figure called");
   *     });
   *
   * @param {Number} dx the x difference between the mouse down operation and now
   * @param {Number} dy the y difference between the mouse down operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onPanning: function onPanning(dx, dy, dx2, dy2, shiftKey, ctrlKey) {},

  /**
   * 
   * Called by the framework if the panning event of the figures ends. This happens
   * after the mous up event if the panning is active.
   *
   *     // You can alternatively register an event handler with:
   *     figure.on("panningEnd", function(emitter){
   *         alert("panning of the figure called");
   *     });
   *
   */
  onPanningEnd: function onPanningEnd() {},

  /**
   * 
   * Will be called after a drag and drop action.<br>
   * Sub classes can override this method to implement additional stuff. Don't forget to call
   * the super implementation via <code>this._super();</code>
   *
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   **/
  onDragEnd: function onDragEnd(x, y, shiftKey, ctrlKey) {
    var _this6 = this;

    // Element ist zwar schon an seine Position, das Command muss aber trotzdem
    // in dem CommandStack gelegt werden damit das Undo funktioniert.
    //
    if (this.command !== null) {
      this.command.setPosition(this.x, this.y);
      this.canvas.getCommandStack().execute(this.command);
      this.command = null;
    }
    this.isInDragDrop = false;
    this.panningDelegate = null;

    // notify all installed policies
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.onDragEnd(_this6.canvas, _this6, x, y, shiftKey, ctrlKey);
      }
    });

    this.fireEvent("move", { figure: this, dx: 0, dy: 0 });
    this.fireEvent("change:x", { figure: this, dx: 0 });
    this.fireEvent("change:y", { figure: this, dy: 0 });

    // fire an event
    // @since 5.3.3
    this.fireEvent("dragend", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
  },

  /**
   * 
   * Called by the framework during drag&drop operations if the user drag a figure over this figure
   *
   * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
   *
   * @returns {draw2d.Figure} the figure which should receive the drop event or null if the element didn't want a drop event
   * @since 6.1.0
   * @private
   **/
  delegateTarget: function delegateTarget(draggedFigure) {
    var _this7 = this;

    var delegate = draggedFigure;
    this.getCanvas().getDropInterceptorPolicies().each(function (i, policy) {
      delegate = policy.delegateTarget(draggedFigure, _this7);
      if (delegate !== null) {
        return false; // break the loop
      }
    });

    return delegate;
  },

  /**
   * 
   * Called by the framework during drag&drop operations if the user drag a figure over this figure
   *
   * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
   *
   * @template
   **/
  onDragEnter: function onDragEnter(draggedFigure) {},

  /**
   * 
   * Called if the DragDrop object leaving the current hover figure.
   *
   * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
   * @template
   **/
  onDragLeave: function onDragLeave(draggedFigure) {},

  /**
   * 
   * Called if the user drop this element onto the dropTarget. This event is ONLY fired if the
   * shape return "this" in the {@link draw2d.Figure#onDragEnter} method.
   *
   *
   * @param {draw2d.Figure} dropTarget The drop target.
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   **/
  onDrop: function onDrop(dropTarget, x, y, shiftKey, ctrlKey) {},

  /**
   * 
   * Called if the user dropped an figure onto this element. This event is ONLY fired if the
   * in the canvas installed {@link draw2d.policy.canvas.DropInterceptorPolicy} allow this.
   *
   *
   * @param {draw2d.Figure} droppedFigure The dropped figure.
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   * @since 4.8.0
   **/
  onCatch: function onCatch(droppedFigure, x, y, shiftKey, ctrlKey) {},

  /**
   * 
   * Callback method for the mouse enter event. Usefull for mouse hover-effects.
   * Override this method for your own effects. Don't call them manually.
   *
   * @template
   **/
  onMouseEnter: function onMouseEnter() {},

  /**
   * 
   * Callback method for the mouse leave event. Useful for mouse hover-effects.
   *
   * @template
   **/
  onMouseLeave: function onMouseLeave() {},

  /**
   * 
   * Called when a user dbl clicks on the element
   *
   *     // Alternatively you can register an event with:
   *     //
   *     figure.on("dblclick", function(emitter, event){
   *         alert("user dbl click on the figure");
   *     });
   *
   * @template
   */
  onDoubleClick: function onDoubleClick() {},

  /**
   * 
   * Called when a user clicks on the element.
   *
   *     // You can alternatively register an event handler with:
   *     figure.on("click", function(emitter, event){
   *         alert("user click on the figure");
   *     });
   *
   * @template
   * @deprecated
   */
  onClick: function onClick() {},

  /**
   * 
   * called by the framework if the figure should show the context menu.<br>
   * The strategy to show the context menu depends on the platform. Either looong press or
   * right click with the mouse.
   *
   *     // Alternatively you register for this event with:
   *     figure.on("contextmenu", function(emitter, event){
   *         alert("user press the right mouse button for a context menu");
   *     });
   *
   * @param {Number} x the x-coordinate to show the menu
   * @param {Number} y the y-coordinate to show the menu
   * @since 1.1.0
   * @template
   */
  onContextMenu: function onContextMenu(x, y) {},

  /**
   * 
   * Set the alpha blending of this figure.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       "alpha": percent
   *     });
   *
   *     // ...or:
   *     figure.attr({
   *       "opacity": percent
   *     });
   *
   * @param {Number} percent value between [0..1].
   **/
  setAlpha: function setAlpha(percent) {
    percent = Math.min(1, Math.max(0, parseFloat(percent)));
    if (percent === this.alpha) {
      return;
    }

    this.alpha = percent;
    this.repaint();
    this.fireEvent("change:opacity", { value: this.alpha });

    return this;
  },

  /**
   * 
   * Return the alpha blending of the figure
   *
   * @returns {Number} the current alpha blending
   */
  getAlpha: function getAlpha() {
    return this.alpha;
  },

  /**
   * 
   * Set the rotation angle in degree [0..356]<br>
   * <b>Only steps of 90 degree is working well</b>
   * <br>
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       angle: angle
   *     });
   *
   * @param {Number} angle the rotation angle in degree
   */
  setRotationAngle: function setRotationAngle(angle) {
    var _this8 = this;

    this.rotationAngle = angle;

    // Update the resize handles if the user change the position of the element via an API call.
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this8.canvas, _this8);
      }
    });

    this.fireEvent("change:angle", { value: this.rotationAngle });
    this.repaint();

    return this;
  },

  /**
   * 
   * return the rotation angle of the figure in degree of [0..356].
   *
   * <br>
   * <b>NOTE: this method is pre alpha and not for production. Only steps of 90 degree is working well</b>
   * <br>
   * @returns {Number}
   */
  getRotationAngle: function getRotationAngle() {
    return this.rotationAngle;
  },

  /**
   * 
   * Show/hide the element. The element didn't receive any mouse events (click, dblclick) if you hide the
   * figure.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       visible: flag
   *     });
   *
   * @param {Boolean} flag
   * @param {Number} [duration] the optional number for the fadeIn /fadeOut of the figure
   * @since 1.1.0
   */
  setVisible: function setVisible(flag, duration) {
    flag = !!flag;
    if (flag === this.visible) {
      return;
    }
    this.visible = flag;

    this.repaint({ visibleDuration: duration });

    if (this.visible) {
      this.fireEvent("show");
    } else {
      this.fireEvent("hide");
    }
    this.fireEvent("change:visibility", { value: this.visible });

    return this;
  },

  /**
   * 
   * Return true if the figure visible.
   *
   * @returns {Boolean}
   * @since 1.1.0
   */
  isVisible: function isVisible() {
    return this.visible && this.shape !== null;
  },

  /**
   * 
   * Guarantee, that the figure width/height will not be distorted. Applicable before calling setDimension().
   * It is false by default.
   *
   * @since 4.1.0
   * @param {Boolean} flag boolean flag if the figure should respect the aspect ratio
   */
  setKeepAspectRatio: function setKeepAspectRatio(flag) {
    this.keepAspectRatio = flag;

    return this;
  },

  /**
   * 
   * Return the flag if the shape keep the aspect ratio.
   *
   * @since 4.1.0
   */
  getKeepAspectRatio: function getKeepAspectRatio() {
    return this.keepAspectRatio;
  },

  /**
   * 
   * Return the current z-index of the element. Currently this is an expensive method. The index will be calculated
   * all the time. Caching is not implemented at the moment.
   *
   * @returns {Number}
   */
  getZOrder: function getZOrder() {
    if (this.shape === null) {
      return -1;
    }

    var i = 0;
    var child = this.shape.node;
    while ((child = child.previousSibling) !== null) {
      i++;
    }
    return i;
  },

  /**
   * 
   * Set the flag if this object can snap to grid or geometry.
   * A window of dialog should set this flag to false.
   *
   * @param {Boolean} flag The snap to grid/geometry enable flag.
   *
   **/
  setCanSnapToHelper: function setCanSnapToHelper(flag) {
    this.canSnapToHelper = !!flag;

    return this;
  },

  /**
   * 
   * Returns true if the figure can snap to any helper like a grid, guide, geometrie
   * or something else.
   *
   * @returns {Boolean}
   **/
  getCanSnapToHelper: function getCanSnapToHelper() {
    return this.canSnapToHelper;
  },

  /**
   *
   * @returns {draw2d.geo.Point}
   **/
  getSnapToGridAnchor: function getSnapToGridAnchor() {
    return this.snapToGridAnchor;
  },

  /**
   * 
   * Set the hot spot for all snapTo### operations.
   *
   * @param {draw2d.geo.Point} point
   **/
  setSnapToGridAnchor: function setSnapToGridAnchor(point) {
    this.snapToGridAnchor = point;

    return this;
  },

  /**
   * 
   * Set the width of the figure and consider the minWidth attribute
   *
   * @param {Number} width the new width of the figure
   * @since 5.1.0
   */
  setWidth: function setWidth(width) {
    this.setDimension(parseFloat(width), this.getHeight());
    this.fireEvent("change:width", { value: this.width });

    return this;
  },

  /**
   * 
   * The current width of the figure.
   *
   * @type {Number}
   **/
  getWidth: function getWidth() {
    return this.width;
  },

  /**
   * 
   * Set the heigth of the figure and consider the minWidth attribute
   *
   * @param {Number} height the new height of the figure
   * @since 5.1.0
   */
  setHeight: function setHeight(height) {
    this.setDimension(this.getWidth(), parseFloat(height));
    this.fireEvent("change:height", { value: this.height });

    return this;
  },

  /**
   * 
   * The current height of the figure.
   *
   * @returns {Number}
   **/
  getHeight: function getHeight() {
    return this.height;
  },

  /**
   * 
   * This value is relevant for the interactive resize of the figure.
   *
   * @returns {Number} Returns the min. width of this object.
   */
  getMinWidth: function getMinWidth() {
    return this.minWidth;
  },

  /**
   * 
   * Set the minimum width of this figure
   *
   * @param {Number} w
   */
  setMinWidth: function setMinWidth(w) {
    this.minWidth = parseFloat(w);
    this.fireEvent("change:minWidth", { value: this.minWidth });

    // fit the width with the new constraint
    this.setWidth(this.getWidth());

    return this;
  },

  /**
   * 
   * This value is relevant for the interactive resize of the figure.
   *
   * @returns {Number} Returns the min. height of this object.
   */
  getMinHeight: function getMinHeight() {
    return this.minHeight;
  },

  /**
   * 
   * Set the minimum height of the figure.
   *
   * @param {Number} h
   */
  setMinHeight: function setMinHeight(h) {
    this.minHeight = parseFloat(h);
    this.fireEvent("change:minHeight", { value: this.minHeight });

    // fit the height with the new constraint
    this.setHeight(this.getHeight());

    return this;
  },

  /**
   * 
   * the the x-offset related to the parent figure or canvas
   *
   * @param {Number} x the new x offset of the figure
   * @since 5.0.8
   */
  setX: function setX(x) {
    this.setPosition(parseFloat(x), this.y);
    this.fireEvent("change:x", { value: this.x });

    return this;
  },

  /**
   * 
   * The x-offset related to the parent figure or canvas.
   *
   * @returns {Number} the x-offset to the parent figure
   **/
  getX: function getX() {
    return this.x;
  },

  /**
   * 
   * the the y-offset related to the parent figure or canvas
   *
   * @param {Number} y the new x offset of the figure
   * @since 5.0.8
   */
  setY: function setY(y) {
    this.setPosition(this.x, parseFloat(y));
    this.fireEvent("change:y", { value: this.y });

    return this;
  },

  /**
   * 
   * The y-offset related to the parent figure or canvas.
   *
   * @returns {Number} The y-offset to the parent figure.
   **/
  getY: function getY() {
    return this.y;
  },

  /**
   * 
   * The x-offset related to the canvas.
   *
   * @returns {Number} the x-offset to the canvas
   **/
  getAbsoluteX: function getAbsoluteX() {
    if (!this.parent) {
      return this.getX();
    }

    return this.getX() + this.parent.getAbsoluteX();
  },

  /**
   * 
   * The y-offset related to the canvas.
   *
   * @returns {Number} The y-offset to the canvas.
   **/
  getAbsoluteY: function getAbsoluteY() {
    if (!this.parent) {
      return this.getY();
    }
    return this.getY() + this.parent.getAbsoluteY();
  },

  /**
   * 
   * Returns the absolute y-position of the port.
   *
   * @type {draw2d.geo.Point}
   **/
  getAbsolutePosition: function getAbsolutePosition() {
    return new _packages2.default.geo.Point(this.getAbsoluteX(), this.getAbsoluteY());
  },

  /**
   * 
   * Returns the absolute y-position of the port.
   *
   * @returns {draw2d.geo.Rectangle}
   **/
  getAbsoluteBounds: function getAbsoluteBounds() {
    return new _packages2.default.geo.Rectangle(this.getAbsoluteX(), this.getAbsoluteY(), this.getWidth(), this.getHeight());
  },

  /**
   * 
   * Set the position of the object.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       x: x,
   *       y: y
   *     });
   *
   * @param {Number|draw2d.geo.Point} x The new x coordinate of the figure or the x/y coordinate if it is an draw2d.geo.Point
   * @param {Number} [y] The new y coordinate of the figure
   **/
  setPosition: function setPosition(x, y) {
    var _this9 = this;

    if (typeof x === "undefined") {
      debugger;
    }

    var oldPos = { x: this.x, y: this.y };

    if (x instanceof _packages2.default.geo.Point) {
      this.x = x.x;
      this.y = x.y;
    } else {
      this.x = x;
      this.y = y;
    }

    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        var newPos = e.adjustPosition(_this9, _this9.x, _this9.y);
        _this9.x = newPos.x;
        _this9.y = newPos.y;
      }
    });

    this.repaint();

    // Update the resize handles if the user change the position of the
    // element via an API call.
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this9.canvas, _this9);
      }
    });

    var event = { figure: this, dx: this.x - oldPos.x, dy: this.y - oldPos.y };
    this.fireEvent("move", event);
    this.fireEvent("change:x", event);
    this.fireEvent("change:y", event);

    return this;
  },

  /**
   * 
   * Get the current position of the figure
   *
   * @returns {draw2d.geo.Point}
   * @since 2.0.0
   */
  getPosition: function getPosition() {
    return new _packages2.default.geo.Point(this.getX(), this.getY());
  },

  /**
   * 
   * Translate the figure with the given x/y offset.
   *
   * @param {Number} dx The x offset to translate
   * @param {Number} dy The y offset to translate
   **/
  translate: function translate(dx, dy) {
    this.setPosition(this.getX() + dx, this.getY() + dy);

    return this;
  },

  /**
   * 
   * Set the new width and height of the figure.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *        width:  w,
   *        height: h
   *     });
   *
   * @param {Number} w The new width of the figure
   * @param {Number} h The new height of the figure
   **/
  setDimension: function setDimension(w, h) {
    var _this10 = this;

    var old = { width: this.width, height: this.height };

    w = Math.max(this.getMinWidth(), w);
    h = Math.max(this.getMinHeight(), h);

    if (this.width === w && this.height === h) {
      // required if an inherit figure changed the w/h to a given constraint.
      // In this case the Resize handles must be informed that the shape didn't resized.
      // because the minWidth/minHeight did have a higher prio.
      this.editPolicy.each(function (i, e) {
        if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
          e.moved(_this10.canvas, _this10);
        }
      });
      return this;
    }

    // apply all EditPolicy to adjust/modify the new dimension
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        var newDim = e.adjustDimension(_this10, w, h);
        w = newDim.w;
        h = newDim.h;
      }
    });

    // respect the aspect ratio if required
    //
    if (this.keepAspectRatio === true) {
      if (w >= this.getMinWidth()) {
        // scale the height to the given ratio
        h = this.getHeight() * (w / this.getWidth());
        // and apply the new dimension only if the values are in range of the given constraints
        if (h >= this.getMinHeight()) {
          this.width = w;
          this.height = h;
        }
      }
    } else {
      this.width = Math.max(this.getMinWidth(), w);
      this.height = Math.max(this.getMinHeight(), h);
    }

    this.repaint();

    this.fireEvent("resize");
    this.fireEvent("change:dimension", { value: { height: this.height, width: this.width, old: old } });

    // Update the resize handles if the user change the position of the element via an API call.
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this10.canvas, _this10);
      }
    });

    return this;
  },

  /**
   * 
   * Set the bounding box of the figure
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       width: w,
   *       height: h,
   *       x: x,
   *       y: y
   *     });
   *
   *     // or
   *     figure.attr({
   *       boundingBox: {x:1, y:100, width:30, height:30}
   *     });
   *
   * @param {draw2d.geo.Rectangle} rect
   * @since 4.8.0
   */
  setBoundingBox: function setBoundingBox(rect) {
    rect = new _packages2.default.geo.Rectangle(rect);

    var orig = this.repaintBlocked;
    this.repaintBlocked = true;
    this.setPosition(rect.x, rect.y);
    this.repaintBlocked = orig;
    this.setDimension(rect.w, rect.h);

    return this;
  },

  /**
   * 
   * Returns the bounding box of the figure in absolute position to the canvas.
   *
   * @returns {draw2d.geo.Rectangle}
   **/
  getBoundingBox: function getBoundingBox() {
    return new _packages2.default.geo.Rectangle(this.getAbsoluteX(), this.getAbsoluteY(), this.getWidth(), this.getHeight());
  },

  /**
   * 
   * Detect whenever the hands over coordinate is inside the figure.
   * The default implementation is a simple bounding box test.
   *
   * @param {Number} iX
   * @param {Number} iY
   * @param {Number} [corona]
   *
   * @returns {Boolean}
   */
  hitTest: function hitTest(iX, iY, corona) {
    if (typeof corona === "number") {
      return this.getBoundingBox().scale(corona, corona).hitTest(iX, iY);
    }
    return this.getBoundingBox().hitTest(iX, iY);
  },

  /**
   * 
   * Switch on/off the drag drop behaviour of this object
   *
   * @param {Boolean} flag The new drag drop indicator
   **/
  setDraggable: function setDraggable(flag) {
    this.draggable = !!flag;

    return this;
  },

  /**
   * 
   * Get the Drag drop enable flag
   *
   * @returns {Boolean} The new drag drop indicator
   **/
  isDraggable: function isDraggable() {
    // delegate to the composite if given
    if (this.composite !== null) {
      return this.composite.isMemberDraggable(this, this.draggable);
    }

    return this.draggable;
  },

  /**
   * 
   * Returns the true if the figure can be resized.
   *
   * @returns {Boolean}
   **/
  isResizeable: function isResizeable() {
    return this.resizeable;
  },

  /**
   * 
   * You can change the resizeable behaviour of this object. Hands over [false] and
   * the figure has no resizehandles if you select them with the mouse.<br>
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       resizeable: flag
   *     });
   *
   * @param {Boolean} flag The resizeable flag.
   **/
  setResizeable: function setResizeable(flag) {
    this.resizeable = !!flag;
    this.fireEvent("change:resizeable", { value: this.resizeable });

    return this;
  },

  /**
   * 
   * Indicates whenever the element is selectable by user interaction or API.
   *
   * @returns {Boolean}
   **/
  isSelectable: function isSelectable() {
    // delegate to the composite if given
    if (this.composite !== null) {
      return this.composite.isMemberSelectable(this, this.selectable);
    }

    return this.selectable;
  },

  /**
   * 
   * You can change the selectable behavior of this object. Hands over [false] and
   * the figure has no selection handles if you try to select them with the mouse.<br>
   *
   * @param {Boolean} flag The selectable flag.
   **/
  setSelectable: function setSelectable(flag) {
    this.selectable = !!flag;
    this.fireEvent("change:selectable", { value: this.selectable });

    return this;
  },

  /**
   * 
   * Return true if the object doesn't care about the aspect ratio.
   * You can change the height and width independent.<br>
   *
   * Replaced with "getKeepAspectRatio"
   * @returns {Boolean}
   * @deprecated
   */
  isStrechable: function isStrechable() {
    return !this.getKeepAspectRatio();
  },

  /**
   * 
   * Return false if you avoid that the user can delete your figure.
   * Sub class can override this method.
   *
   * @returns {Boolean}
   **/
  isDeleteable: function isDeleteable() {
    return this.deleteable;
  },

  /**
   * 
   * Set the flag if the shape is deleteable.
   *
   * @param {Boolean} flag enable or disable flag for the delete operation
   **/
  setDeleteable: function setDeleteable(flag) {
    this.deleteable = !!flag;
    this.fireEvent("change:deleteable", { value: this.deleteable });

    return this;
  },

  /**
   * 
   * Set the parent of this figure.
   * Don't call them manually.
   *
   * @param {draw2d.Figure} parent The new parent of this figure
   * @private
   **/
  setParent: function setParent(parent) {
    this.parent = parent;

    if (parent !== null) {
      // inherit the selection handling impl from the parent
      this.setSelectionAdapter(parent.getSelectionAdapter());
    } else {
      // use default
      this.setSelectionAdapter(null);
    }

    return this;
  },

  /**
   * 
   * Get the parent of this figure.
   *
   * @returns {draw2d.Figure}
   **/
  getParent: function getParent() {
    return this.parent;
  },

  /**
   * 
   * Check to see if a figure is a descendant of another figure.
   * <br>
   * The contains() method returns true if the figure provided by the argument is a descendant of this figure,
   * whether it is a direct child or nested more deeply. Otherwise, it returns false.
   *
   * @param {draw2d.Figure} containedFigure The figure that may be contained by (a descendant of) this figure.
   * @since 5.5.4
   */
  contains: function contains(containedFigure) {
    if (containedFigure.getParent() === this) {
      return true;
    }

    for (var i = 0, len = this.children.getSize(); i < len; i++) {
      var child = this.children.get(i).figure;
      if (child.contains(containedFigure)) {
        return true;
      }
    }
    return false;
  },

  /**
   * 
   * Get the top most parent of this figure. This can be an layout figure or parent container
   *
   * @returns {draw2d.Figure}
   * @since 5.0.6
   **/
  getRoot: function getRoot() {
    var root = this.parent;
    while (root !== null && root.parent !== null) {
      root = root.parent;
    }
    return root;
  },

  /**
   * 
   * Set the assigned composite of this figure.
   *
   * @param {draw2d.shape.composite.StrongComposite} composite The assigned composite of this figure
   * @since 4.8.0
   **/
  setComposite: function setComposite(composite) {
    if (composite !== null && !(composite instanceof _packages2.default.shape.composite.StrongComposite)) {
      throw "'composite must inherit from 'draw2d.shape.composite.StrongComposite'";
    }

    this.composite = composite;

    return this;
  },

  /**
   * 
   * Get the assigned composite of this figure.
   *
   * @returns {draw2d.shape.composite.StrongComposite}
   * @since 4.8.0
   **/
  getComposite: function getComposite() {
    return this.composite;
  },

  /**
   * 
   * Execute all handlers and behaviors attached to the figure for the given event type.
   *
   *
   * @param {String} event the event to trigger
   * @param {Object} [args] optional parameters for the triggered event callback
   *
   * @since 5.0.0
   */
  fireEvent: function fireEvent(event, args) {
    try {
      if (typeof this.eventSubscriptions[event] === 'undefined') {
        return;
      }

      // avoid recursion
      if (this._inEvent === true) {
        return;
      }
      this._inEvent = true;
      var subscribers = this.eventSubscriptions[event];
      for (var i = 0; i < subscribers.length; i++) {
        subscribers[i](this, args);
      }
    } catch (exc) {
      console.log(exc);
      throw exc;
    } finally {
      this._inEvent = false;

      // fire a generic change event if an attribute has changed
      // required for some DataBinding frameworks or for the Backbone.Model compatibility
      // the event "change" with the corresponding attribute name as additional parameter
      if (event.substring(0, 7) === "change:") {
        this.fireEvent("change", event.substring(7));
      }
    }
  },

  /**
   * 
   * Attach an event handler function for one or more events to the figure.
   * To remove events bound with .on(), see {@link #off}.
   *
   * possible events are:<br>
   * <ul>
   *   <li>click</li>
   *   <li>dblclick</li>
   *   <li>move</li>
   *   <li>resize</li>
   *   <li>timer</li>
   *   <li>contextmenu</li>
   *   <li>show</li>
   *   <li>hide</li>
   *   <li>added</li>
   *   <li>removed</li>
   *   <li>change:[attr]</li>
   * </ul>
   *
   * @param {String}   event One or more space-separated event types
   * @param {Function} callback A function to execute when the event is triggered.
   * @param {draw2d.Figure} callback.emitter the emitter of the event
   * @param {Object} [callback.obj] optional event related data
   * @param {Object} [context] optional context of the function callback.
   * @since 5.0.0
   */
  on: function on(event, callback, context) {
    var events = event.split(" ");
    if (typeof callback === "undefined") {
      debugger;
    }
    // the "context" param is add to be compatible with Backbone.Model.
    // The project "backbone.ModelBinder" requires this signature and we want to be nice.
    //
    if (context) {
      callback = callback.bind(context);
      callback.___originalCallback = callback;
    }

    for (var i = 0; i < events.length; i++) {
      if (typeof this.eventSubscriptions[events[i]] === 'undefined') {
        this.eventSubscriptions[events[i]] = [];
      }
      // avoid duplicate registration for the same event with the same callback method
      if (-1 !== $.inArray(callback, this.eventSubscriptions[events[i]])) {
        //   debugger
      } else {
        this.eventSubscriptions[events[i]].push(callback);
      }
    }
    return this;
  },

  /**
   * 
   * The .off() method removes event handlers that were attached with {@link #on}.<br>
   * Calling .off() with no arguments removes all handlers attached to the elements.<br>
   * <br>
   * If a simple event name such as "move" is provided, all events of that type are removed from the figure.
   *
   *
   * @param {String|Function} eventOrFunction the event name of the registerd function or the function itself
   * @since 5.0.0
   */
  off: function off(eventOrFunction) {
    if (typeof eventOrFunction === "undefined") {
      this.eventSubscriptions = {};
    } else if (typeof eventOrFunction === 'string') {
      this.eventSubscriptions[eventOrFunction] = [];
    } else {
      for (var event in this.eventSubscriptions) {
        this.eventSubscriptions[event] = this.eventSubscriptions[event].filter(function (callback) {
          if (typeof callback.___originalCallback !== "undefined") {
            return callback.___originalCallback !== eventOrFunction;
          }
          return callback !== eventOrFunction;
        });
      }
    }

    return this;
  },

  /**
   * 
   * Returns the best figure at the location [x,y]. It is a simple hit test. Keep in mind that only visible objects
   * are returned.
   *
   * @param {Number} x The x position.
   * @param {Number} y The y position.
   * @param {draw2d.Figure|Array} [figureToIgnore] The figures which should be ignored.
   **/
  getBestChild: function getBestChild(x, y, figureToIgnore) {
    if (!Array.isArray(figureToIgnore)) {
      if (figureToIgnore instanceof _packages2.default.Figure) {
        figureToIgnore = [figureToIgnore];
      } else {
        figureToIgnore = [];
      }
    }

    var result = null;

    // tool method to check recursive a figure for hitTest
    //
    var checkRecursive = function checkRecursive(children) {
      children.each(function (i, e) {
        var c = e.figure;
        checkRecursive(c.children);
        if (result === null && c.isVisible() === true && c.hitTest(x, y) === true && $.inArray(c, figureToIgnore) === -1) {
          result = c;
        }
        return result === null; // break the each-loop if we found an element
      });
    };

    checkRecursive(this.children);

    return result;
  },

  /**
   * 
   * Returns the Command to perform the specified Request or null.
   *
   * @param {draw2d.command.CommandType} request describes the Command being requested
   * @returns {draw2d.command.Command} null or a Command
   * @private
   **/
  createCommand: function createCommand(request) {
    if (request === null) {
      return null;
    }

    if (request.getPolicy() === _packages2.default.command.CommandType.MOVE) {
      if (!this.isDraggable()) {
        return null;
      }
      return new _packages2.default.command.CommandMove(this);
    }

    if (request.getPolicy() === _packages2.default.command.CommandType.DELETE) {
      if (!this.isDeleteable()) {
        return null;
      }
      return new _packages2.default.command.CommandDelete(this);
    }

    if (request.getPolicy() === _packages2.default.command.CommandType.RESIZE) {
      if (!this.isResizeable()) {
        return null;
      }
      return new _packages2.default.command.CommandResize(this);
    }

    return null;
  },

  /**
   * 
   * Clone the figure. <br>
   * You must override and implement the methods <b>getPersistentAttributes</b> and <b>setPersistentAttributes</b> for your custom
   * figures if the have special attributes.
   *
   * The clone() method performs a deep copy of the object, meaning that it copies the children, ports and decorations
   * per default. You can control the clone procedure with the 'cloneMetaData'.
   *
   *
   * @param {Object} [cloneMetaData] controls the clone procedure
   * @param {Boolean} [cloneMetaData.excludeChildren] set it to true if you want exclude the children.
   *
   * @since 4.1.0
   * @experimental
   */
  clone: function clone(cloneMetaData) {
    cloneMetaData = (0, _extend2.default)({ exludeChildren: false }, cloneMetaData);

    var clone = eval("new " + this.NAME + "();");
    var initialId = clone.id;

    clone.setPersistentAttributes(this.getPersistentAttributes());

    clone.id = initialId;

    // add all decorations to the memento
    //
    if (cloneMetaData.exludeChildren === false) {
      clone.resetChildren();
      this.children.each(function (i, entry) {
        var child = entry.figure.clone();
        // we can ignore the locator if this didn't provide a "correct" name, this can happen in some
        // Layout shapes like VerticalLayout or Horziontal Layout. This figures injects it own kind
        // of layouter...so didn'T care about this.

        var locator = entry.locator.NAME ? eval("new " + entry.locator.NAME + "();") : null;
        clone.add(child, locator);
      });
    }

    return clone;
  },

  /**
   * 
   * Return an objects with all important attributes for XML or JSON serialization
   *
   * @return {Object} all attributes of the figure required for the persistency
   */
  getPersistentAttributes: function getPersistentAttributes() {
    // force deep copy of userData to avoid side effects in the clone method.
    //
    var memento = {
      type: this.NAME,
      id: this.id,
      x: this.getX(),
      y: this.getY(),
      width: this.width,
      height: this.height,
      alpha: this.alpha,
      selectable: this.selectable,
      draggable: this.draggable,
      angle: this.rotationAngle,
      userData: (0, _extend2.default)(true, {}, this.userData)
    };

    if (this.cssClass !== null) {
      memento.cssClass = this.cssClass;
    }

    if (this.composite !== null) {
      memento.composite = this.composite.getId();
    }

    return memento;
  },

  /**
   * 
   * Read all attributes from the serialized properties and transfer them into the shape.
   *
   * @param {Object} memento
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this.id = memento.id;
    this.setPosition(parseFloat(memento.x), parseFloat(memento.y));

    // width and height are optional parameter for the JSON stuff.
    // We use the defaults if the attributes not present
    if (typeof memento.width !== "undefined") {
      this.width = parseFloat(memento.width);
    }

    if (typeof memento.height !== "undefined") {
      this.height = parseFloat(memento.height);
    }

    if (typeof memento.userData !== "undefined") {
      this.userData = memento.userData;
    }

    if (typeof memento.selectable !== "undefined") {
      this.selectable = memento.selectable;
    }

    if (typeof memento.draggable !== "undefined") {
      this.draggable = memento.draggable;
    }

    if (typeof memento.cssClass !== "undefined") {
      this.setCssClass(memento.cssClass);
    }

    if (typeof memento.alpha !== "undefined") {
      this.setAlpha(parseFloat(memento.alpha));
    }

    if (typeof memento.angle !== "undefined") {
      this.rotationAngle = parseFloat(memento.angle);
    }

    return this;
  }
});

/***/ }),

/***/ "./src/HeadlessCanvas.js":
/*!*******************************!*\
  !*** ./src/HeadlessCanvas.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Required for Node.js draw2d model read/write operations.
 *
 * @inheritable
 * @author Andreas Herz
 */

_packages2.default.HeadlessCanvas = Class.extend(
/** @lends draw2d.HeadlessCanvas.prototype */

/** @lends draw2d.HeadlessCanvas.prototype */
{

    NAME: "draw2d.HeadlessCanvas",

    /**
     * Create a new canvas with the given HTML DOM references.
     *
     * @param {String} canvasId the id of the DOM element to use a parent container
     */
    init: function init() {
        // internal document with all figures, ports, ....
        //
        this.figures = new _packages2.default.util.ArrayList();
        this.lines = new _packages2.default.util.ArrayList(); // crap - why are connections not just figures. Design by accident
        this.commonPorts = new _packages2.default.util.ArrayList();

        this.eventSubscriptions = {};

        // The CommandStack for undo/redo operations
        //
        this.commandStack = new _packages2.default.command.CommandStack();
    },

    /**
     * 
     * Reset the canvas and delete all model elements.<br>
     * You can now reload another model to the canvas with a {@link draw2d.io.Reader}
     *
     * @since 1.1.0
     */
    clear: function clear() {
        // internal document with all figures, ports, ....
        //
        this.figures = new _packages2.default.util.ArrayList();
        this.lines = new _packages2.default.util.ArrayList();
        this.commonPorts = new _packages2.default.util.ArrayList();

        this.commandStack.markSaveLocation();

        return this;
    },

    calculateConnectionIntersection: function calculateConnectionIntersection() {},

    /**
     * 
     * Callback for any kind of image export tools to trigger the canvas to hide all unwanted
     * decorations. The method is called e.g. from the draw2d.io.png.Writer
     *
     * @since 4.0.0
     * @template
     */
    hideDecoration: function hideDecoration() {},

    /**
     * 
     * callback method for any image export writer to reactivate the decoration
     * of the canvas. e.g. grids, rulers,...
     *
     *
     * @since 4.0.0
     * @template
     */
    showDecoration: function showDecoration() {},

    /**
     * 
     * Add a figure at the given x/y coordinate. This method fires an event.
     *
     * Example:
     *
     *     canvas.on("figure:add", function(emitter, event){
     *        alert("figure added:");
     *     });
     *
     *     // or more general if you want catch all figure related events
     *     //
     *     canvas.on("figure", function(emitter, event){
     *        // use event.figure.getCanvas()===null to determine if the
     *        // figure part of the canvas
     *
     *        alert("figure added or removed:");
     *     });
     *
     * @param {draw2d.Figure} figure The figure to add.
     * @param {Number/draw2d.geo.Point} [x] The new x coordinate of the figure or the x/y coordinate if it is an draw2d.geo.Point
     * @param {Number} [y] The y position.
     **/
    add: function add(figure, x, y) {
        if (figure.getCanvas() === this) {
            return;
        }

        if (figure instanceof _packages2.default.shape.basic.Line) {
            this.lines.add(figure);
        } else {
            this.figures.add(figure);
        }
        figure.canvas = this;

        return this;
    },

    /**
     * 
     * Returns all lines/connections in this workflow/canvas.<br>
     *
     * @protected
     * @returns {draw2d.util.ArrayList}
     **/
    getLines: function getLines() {
        return this.lines;
    },

    /**
     * 
     * Returns the internal figures.<br>
     *
     * @protected
     * @returns {draw2d.util.ArrayList}
     **/
    getFigures: function getFigures() {
        return this.figures;
    },

    /**
     * 
     * Returns the line or connection with the given id.
     *
     * @param {String} id The id of the line.
     *
     * @returns {draw2d.shape.basic.Line}
     **/
    getLine: function getLine(id) {
        var count = this.lines.getSize();
        for (var i = 0; i < count; i++) {
            var line = this.lines.get(i);
            if (line.getId() === id) {
                return line;
            }
        }
        return null;
    },

    /**
     * 
     * Returns the figure with the given id.
     *
     * @param {String} id The id of the figure.
     * @returns {draw2d.Figure}
     **/
    getFigure: function getFigure(id) {
        var figure = null;
        this.figures.each(function (i, e) {
            if (e.id === id) {
                figure = e;
                return false;
            }
        });
        return figure;
    },

    /**
     * 
     * Register a port to the canvas. This is required for other ports to find a valid drop target.
     *
     * @param {draw2d.Port} port The new port which has been added to the Canvas.
     **/
    registerPort: function registerPort(port) {
        // All elements have the same drop targets.
        //
        if (!this.commonPorts.contains(port)) {
            this.commonPorts.add(port);
        }

        return this;
    },

    /**
     * 
     * Return all ports in the canvas
     *
     */
    getAllPorts: function getAllPorts() {
        return this.commonPorts;
    },

    /**
     * 
     * Returns the command stack for the Canvas. Required for undo/redo support.
     *
     * @returns {draw2d.command.CommandStack}
     **/
    getCommandStack: function getCommandStack() {
        return this.commandStack;
    },

    // NEW EVENT HANDLING SINCE VERSION 5.0.0
    /**
     * 
     * Execute all handlers and behaviors attached to the canvas for the given event type.
     *
     *
     * @param {String} event the event to trigger
     * @param {Object} [args] optional parameters for the triggered event callback
     *
     * @since 5.0.0
     */
    fireEvent: function fireEvent(event, args) {
        if (typeof this.eventSubscriptions[event] === 'undefined') {
            return;
        }

        var subscribers = this.eventSubscriptions[event];
        for (var i = 0; i < subscribers.length; i++) {
            try {
                subscribers[i](this, args);
            } catch (exc) {
                console.log(exc);
                console.log(subscribers[i]);
                debugger;
            }
        }
    },

    /**
     * 
     * Attach an event handler function for one or more events to the canvas.
     * To remove events bound with .on(), see {@link #off}.
     *
     * possible events are:<br>
     * <ul>
     *   <li>reset</li>
     *   <li>select</li>
     * </ul>
     *
     * Example:
     *
     *     canvas.on("clear", function(emitter, event){
     *        alert("canvas.clear() called.");
     *     });
     *
     *     canvas.on("select", function(emitter,event){
     *         if(event.figure!==null){
     *             alert("figure selected");
     *         }
     *         else{
     *             alert("selection cleared");
     *         }
     *     });
     *
     * @param {String}   event One or more space-separated event types
     * @param {Function} callback A function to execute when the event is triggered.
     * @param {draw2d.Canvas} callback.emitter the emitter of the event
     * @param {Object} [callback.obj] optional event related data
     *
     * @since 5.0.0
     */
    on: function on(event, callback) {
        var events = event.split(" ");
        for (var i = 0; i < events.length; i++) {
            if (typeof this.eventSubscriptions[events[i]] === 'undefined') {
                this.eventSubscriptions[events[i]] = [];
            }
            this.eventSubscriptions[events[i]].push(callback);
        }
        return this;
    },

    /**
     * 
     * The .off() method removes event handlers that were attached with {@link #on}.<br>
     * Calling .off() with no arguments removes all handlers attached to the canvas.<br>
     * <br>
     * If a simple event name such as "reset" is provided, all events of that type are removed from the canvas.
     *
     *
     * @param {String|Function} eventOrFunction the event name of the registerd function
     * @since 5.0.0
     */
    off: function off(eventOrFunction) {
        if (typeof eventOrFunction === "undefined") {
            this.eventSubscriptions = {};
        } else if (typeof eventOrFunction === 'string') {
            this.eventSubscriptions[eventOrFunction] = [];
        } else {
            for (var event in this.eventSubscriptions) {
                this.eventSubscriptions[event] = this.eventSubscriptions[event].filter(function (callback) {
                    return callback !== eventOrFunction;
                });
            }
        }

        return this;
    }
});

/***/ }),

/***/ "./src/HybridPort.js":
/*!***************************!*\
  !*** ./src/HybridPort.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A HybridPort can work as Input and as Output port in the same way for a {@link draw2d.Connection}.
 *
 * @author Andreas Herz
 * @extends draw2d.Port
 */
_packages2.default.HybridPort = _packages2.default.Port.extend(
/** @lends draw2d.HybridPort.prototype */
{
   NAME: "draw2d.HybridPort",

   /**
    * Create a new HybridPort element
    *
    * @param {Object} [attr] the configuration of the shape
    */
   init: function init(attr, setter, getter) {
      this._super(attr, setter, getter);

      // responsive for the arrangement of the port
      // calculates the x/y coordinates in relation to the parent node
      this.locator = new _packages2.default.layout.locator.InputPortLocator();
   },

   /**
    * @param {draw2d.command.CommandType} request The requested operation to perform on the object
    * @returns {draw2d.command.Command} The matching command to the requested operation.
    */
   createCommand: function createCommand(request) {
      // Connect request between two ports
      //
      if (request.getPolicy() === _packages2.default.command.CommandType.CONNECT) {

         if (request.source.getParent().getId() === request.target.getParent().getId()) {
            return null;
         }

         if (request.source instanceof _packages2.default.InputPort) {
            // This is the difference to the InputPort implementation of createCommand.
            return new _packages2.default.command.CommandConnect(request.target, request.source, request.source);
         } else if (request.source instanceof _packages2.default.OutputPort) {
            // This is the different to the OutputPort implementation of createCommand
            return new _packages2.default.command.CommandConnect(request.source, request.target, request.source);
         } else if (request.source instanceof _packages2.default.HybridPort) {
            // This is the different to the OutputPort implementation of createCommand
            return new _packages2.default.command.CommandConnect(request.target, request.source, request.source);
         }

         return null;
      }

      // ...else call the base class
      return this._super(request);
   }
});

/***/ }),

/***/ "./src/InputPort.js":
/*!**************************!*\
  !*** ./src/InputPort.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A InputPort is the start anchor for a {@link draw2d.Connection}.
 *
 * @author Andreas Herz
 * @extend draw2d.Port
 */
_packages2.default.InputPort = _packages2.default.Port.extend(
/** @lends draw2d.InputPort.prototype */
{

  NAME: "draw2d.InputPort",

  /**
   * Create a new InputPort element
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    // responsive for the arrangement of the port
    // calculates the x/y coordinates in relation to the parent node
    this.locator = new _packages2.default.layout.locator.InputPortLocator();
  },

  /**
   * @inheritdoc
   */
  createCommand: function createCommand(request) {
    // Connect request between two ports
    //
    if (request.getPolicy() === _packages2.default.command.CommandType.CONNECT) {
      return new _packages2.default.command.CommandConnect(request.source, request.target, request.source);
    }

    // ...else call the base class
    return this._super(request);
  }
});

/***/ }),

/***/ "./src/OutputPort.js":
/*!***************************!*\
  !*** ./src/OutputPort.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A OutputPort is the start anchor for a {@link draw2d.Connection}.
 *
 * @author Andreas Herz
 * @extends draw2d.Port
 */
_packages2.default.OutputPort = _packages2.default.Port.extend(
/** @lends draw2d.OutputPort.prototype */
{

  NAME: "draw2d.OutputPort",

  /**
   * Create a new OutputPort element
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    // responsive for the arrangement of the port
    // calculates the x/y coordinates in relation to the parent node
    this.locator = new _packages2.default.layout.locator.OutputPortLocator();
  },

  /**
   * @inheritdoc
   */
  createCommand: function createCommand(request) {
    // Connect request between two ports
    //
    if (request.getPolicy() === _packages2.default.command.CommandType.CONNECT) {
      // source and target are changed.
      return new _packages2.default.command.CommandConnect(request.target, request.source, request.source);
    }

    // ...else call the base class
    return this._super(request);
  }
});

/***/ }),

/***/ "./src/Port.js":
/*!*********************!*\
  !*** ./src/Port.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ./util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *  A port is an object that is used to establish a connection between a node and a {@link draw2d.Connection}. The port can
 * be placed anywhere within a node ( see {@link draw2d.layout.locator.PortLocator} for details)
 *
 *
 * @author Andreas Herz
 * @param {Object} [attr] the configuration of the shape
 * @extends draw2d.shape.basic.Circle
 */

_packages2.default.Port = _packages2.default.shape.basic.Circle.extend(
/** @lends draw2d.Port.prototype */
{

  NAME: "draw2d.Port",

  DEFAULT_BORDER_COLOR: new _packages2.default.util.Color("#1B1B1B"),

  init: function init(attr, setter, getter) {
    var _this2 = this;

    this.locator = null;
    this.lighterBgColor = null;
    this.name = null;

    this._super((0, _extend2.default)({
      bgColor: "#4f6870",
      stroke: 1,
      diameter: 10,
      color: "#1B1B1B",
      selectable: false
    }, attr), (0, _extend2.default)({
      semanticGroup: this.setSemanticGroup
    }, setter), (0, _extend2.default)({
      semanticGroup: this.getSemanticGroup
    }, getter));

    // status vars for user interaction
    //
    this.ox = this.x;
    this.oy = this.y;
    this.coronaWidth = 5; // the corona width for the hitTest method. Useful during drag&drop of ports. Better SnapTo behavior.
    this.corona = null; // draw2d.shape.basic.Circle
    this.useGradient = true;

    this.preferredConnectionDirection = null;

    // current attached connections
    this.connections = new _packages2.default.util.ArrayList();

    this.moveListener = function (emitter, event) {
      _this2.repaint();
      // Falls sich der parent bewegt hat, dann muss der Port dies seinen
      // Connections mitteilen
      _this2.fireEvent("move", { figure: _this2, dx: 0, dy: 0 });
    };

    this.connectionAnchor = new _packages2.default.layout.anchor.ConnectionAnchor(this);

    // for dynamic diagrams. A Port can have a value which is set by a connector
    //
    this.value = null;
    this.maxFanOut = Number.MAX_SAFE_INTEGER;

    // semantic group. Only ports in the same semantic group can be connected
    //
    this.semanticGroup = "global";

    this.setCanSnapToHelper(false);

    // uninstall all default selection policies. This is not required for Ports
    this.editPolicy.each(function (i, policy) {
      return _this2.uninstallEditPolicy(policy);
    });

    this.installEditPolicy(new _packages2.default.policy.port.IntrusivePortsFeedbackPolicy());
    // this.installEditPolicy(new draw2d.policy.port.ElasticStrapFeedbackPolicy());

    // a port handles the selection handling always by its own regardless if
    // the port is part of an composite, node, group or whatever.
    this.portSelectionAdapter = function () {
      return _this2;
    };
  },

  getSelectionAdapter: function getSelectionAdapter() {
    return this.portSelectionAdapter;
  },

  /**
   * 
   * set the maximal possible count of connections for this port.<br>
   * This method din't delete any connection if you reduce the number and a bunch of
   * connection are bounded already.
   *
   * @param {Number} count the maximal number of connection related to this port
   * @returns {this}
   */
  setMaxFanOut: function setMaxFanOut(count) {
    this.maxFanOut = Math.max(1, count);
    this.fireEvent("change:maxFanOut", { value: this.maxFanOut });

    return this;
  },

  /**
   * 
   * return the maximal possible connections (in+out) for this port.
   *
   * @returns {Number}
   */
  getMaxFanOut: function getMaxFanOut() {
    return this.maxFanOut;
  },

  /**
   *
   * Set the semantic group of this port. Only ports in the same semantic group
   * can be connected.
   *
   * The default for all ports is "global"
   *
   * @param {String} group the semantic group of this port
   * @returns {this}
   */
  setSemanticGroup: function setSemanticGroup(group) {
    this.semanticGroup = group;
    this.fireEvent("change:semanticGroup", { value: this.semanticGroup });

    return this;
  },

  /**
   *
   * Get the semantic group of this port. Only ports in the same semantic group
   * can be connected.
   *
   * The default for all ports is "global"
   *
   * @returns {String}
   */
  getSemanticGroup: function getSemanticGroup() {
    return this.semanticGroup;
  },

  /**
   * 
   * Set the Anchor for this object. An anchor is responsible for the endpoint calculation
   * of an connection. just visible representation.
   *
   * @param {draw2d.layout.anchor.ConnectionAnchor} [anchor] the new source anchor for the connection or "null" to use the default anchor.
   * @returns {this}
   **/
  setConnectionAnchor: function setConnectionAnchor(anchor) {
    // set some good defaults.
    if (typeof anchor === "undefined" || anchor === null) {
      anchor = new _packages2.default.layout.anchor.ConnectionAnchor();
    }

    this.connectionAnchor = anchor;
    this.connectionAnchor.setOwner(this);

    // the anchor has changed. In this case all connections needs an change event to recalculate
    // the anchor and the routing itself
    this.fireEvent("move", { figure: this, dx: 0, dy: 0 });

    return this;
  },

  getConnectionAnchorLocation: function getConnectionAnchorLocation(referencePoint, inquiringConnection) {
    return this.connectionAnchor.getLocation(referencePoint, inquiringConnection);
  },

  getConnectionAnchorReferencePoint: function getConnectionAnchorReferencePoint(inquiringConnection) {
    return this.connectionAnchor.getReferencePoint(inquiringConnection);
  },

  /**
   * 
   * Returns the **direction** for the connection in relation to the given port and it's parent.
   *
   * <p>
   * Possible values:
   * <ul>
   *   <li>draw2d.geo.Rectangle.DIRECTION_UP</li>
   *   <li>draw2d.geo.Rectangle.DIRECTION_RIGHT</li>
   *   <li>draw2d.geo.Rectangle.DIRECTION_DOWN</li>
   *   <li>draw2d.geo.Rectangle.DIRECTION_LEFT</li>
   * </ul>
   * <p>
   *
   * @param {draw2d.Port} peerPort the counterpart port
   *
   * @returns {Number} the direction.
   */
  getConnectionDirection: function getConnectionDirection(peerPort) {
    // return the calculated connection direction if the port didn't have set any
    //
    if (typeof this.preferredConnectionDirection === "undefined" || this.preferredConnectionDirection === null) {
      return this.getParent().getBoundingBox().getDirection(this.getAbsolutePosition());
    }

    return this.preferredConnectionDirection;
  },

  /**
   * 
   * Set the **direction** for the connection in relation to the given port and it's parent.
   *
   * <p>
   * Possible values:
   * <ul>
   *   <li>up -&gt; 0</li>
   *   <li>right -&gt; 1</li>
   *   <li>down -&gt; 2</li>
   *   <li>left -&gt; 3</li>
   *   <li>calculated -&gt; null</li>
   * </ul>
   * <p>
   *
   * @since 5.2.1
   * @param {Number} direction the preferred connection direction.
   * @returns {this}
   */
  setConnectionDirection: function setConnectionDirection(direction) {
    this.preferredConnectionDirection = direction;

    // needs an change event to recalculate the route
    this.fireEvent("move", { figure: this, dx: 0, dy: 0 });

    return this;
  },

  /**
   * 
   * Set the locator/layouter of the port. A locator is responsive for the x/y arrangement of the
   * port in relation to the parent node.
   *
   * @param {draw2d.layout.locator.Locator} locator
   * @returns {this}
   */
  setLocator: function setLocator(locator) {
    this.locator = locator;

    return this;
  },

  /**
   * 
   * Get the locator/layouter of the port. A locator is responsive for the x/y arrangement of the
   * port in relation to the parent node.
   *
   * @since 4.2.0
   */
  getLocator: function getLocator() {
    return this.locator;
  },

  /**
   * 
   * Set the new background color of the figure. It is possible to hands over
   * <code>null</code> to set the background transparent.
   *
   * @param {draw2d.util.Color|String} color The new background color of the figure
   * @returns {this}
   **/
  setBackgroundColor: function setBackgroundColor(color) {
    this._super(color);
    this.lighterBgColor = this.bgColor.lighter(0.3).rgba();

    return this;
  },

  /**
   * 
   * Set a value for the port. This is useful for interactive/dynamic diagrams like circuits, simulator,...
   *
   * @param {Object} value the new value for the port
   * @returns {this}
   */
  setValue: function setValue(value) {

    if (value === this.value) {
      return this;
    }
    var old = this.value;
    this.value = value;
    if (this.getParent() !== null) {
      this.getParent().onPortValueChanged(this);
    }
    this.fireEvent("change:value", { value: this.value, old: old });

    return this;
  },

  /**
   * 
   * Return the user defined value of the port.
   *
   * @returns {Object}
   */
  getValue: function getValue() {
    return this.value;
  },

  /**
   * @private
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    // a port did have the 0/0 coordinate in the center and not in the top/left corner
    //
    attributes.cx = this.getAbsoluteX();
    attributes.cy = this.getAbsoluteY();
    attributes.rx = this.width / 2;
    attributes.ry = attributes.rx;
    attributes.cursor = "move";

    if (this.getAlpha() < 0.9 || this.useGradient === false) {
      attributes.fill = this.bgColor.rgba();
    } else {
      attributes.fill = ["90", this.bgColor.hash(), this.lighterBgColor].join("-");
    }

    this._super(attributes);
  },

  /**
   * @inheritdoc
   *
   **/
  onMouseEnter: function onMouseEnter() {
    this._oldstroke = this.getStroke();
    this.setStroke(2);
  },

  /**
   * @inheritdoc
   *
   **/
  onMouseLeave: function onMouseLeave() {
    this.setStroke(this._oldstroke);
  },

  /**
   * 
   * Returns a {@link draw2d.util.ArrayList} of {@link draw2d.Connection}s of all related connections to this port.
   *
   * @returns {draw2d.util.ArrayList}
   **/
  getConnections: function getConnections() {
    return this.connections;
  },

  /**
   * @private
   */
  setParent: function setParent(parent) {
    if (this.parent !== null) {
      this.parent.off(this.moveListener);
    }

    this._super(parent);

    if (this.parent !== null) {
      this.parent.on("move", this.moveListener);
    }
  },

  /**
   * 
   * Returns the corona width of the Port. The corona width will be used during the
   * drag&drop of a port.
   *
   * @returns {Number}
   **/
  getCoronaWidth: function getCoronaWidth() {
    return this.coronaWidth;
  },

  /**
   * 
   * Set the corona width of the Port. The corona width will be used during the
   * drag&drop of a port. You can drop a port in the corona of this port to create
   * a connection. It is not neccessary to drop exactly on the port.
   *
   * @param {Number} width The new corona width of the port
   * @returns {this}
   **/
  setCoronaWidth: function setCoronaWidth(width) {
    this.coronaWidth = width;

    return this;
  },

  /**
   * @inheritdoc
   *
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean}
   * @private
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
    // just allow the DragOperation if the port didn't have reached the max fanOut
    // limit.
    if (this.getConnections().getSize() >= this.maxFanOut) {
      return false;
    }

    var _this = this;

    //        this.getShapeElement().insertAfter(this.parent.getShapeElement());
    // don't call the super method. This creates a command and this is not necessary for a port
    this.ox = this.x;
    this.oy = this.y;

    var canStartDrag = true;

    // notify all installed policies
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        // DragStart operation can send a veto for the dragStart
        // @since 6.1.0
        canStartDrag = canStartDrag && e.onDragStart(_this.canvas, _this, x, y, shiftKey, ctrlKey);
      }
    });

    return canStartDrag;
  },

  /**
   * @inheritdoc
   *
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   *
   * @private
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    // TODO: warum wurde diese methode berschrieben?!
    this._super(dx, dy);
  },

  /**
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @private
   **/
  onDragEnd: function onDragEnd(x, y, shiftKey, ctrlKey) {
    // Don't call the parent implementation. This will create an CommandMove object
    // and store them o the CommandStack for the undo operation. This makes no sense for a
    // port.
    // draw2d.shape.basic.Rectangle.prototype.onDragEnd.call(this); DON'T call the super implementation!!!

    this.setAlpha(1.0);

    // 1.) Restore the old Position of the node
    //
    this.setPosition(this.ox, this.oy);
  },

  /**
   * 
   * Called if the user drop this element onto the dropTarget
   *
   * @param {draw2d.Figure} dropTarget The drop target.
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @@private
   **/
  onDrop: function onDrop(dropTarget, x, y, shiftKey, ctrlKey) {},

  /**
   * 
   * Callback method if a new connection has created with this port
   *
   *     // Alternatively you register for this event with:
   *     port.on("connect", function(emitterPort, connection){
   *         alert("port connected");
   *     });
   *
   * @param {draw2d.Connection} connection The connection which has been created
   * @since 2.5.1
   *
   * @template
   **/
  onConnect: function onConnect(connection) {},

  /**
   * 
   * Callback method if a new connection has created with this port
   *
   *     // Alternatively you register for this event with:
   *     port.on("connect", function(emitterPort, connection){
   *         alert("port disconnected");
   *     });
   *
   * @param {draw2d.Connection} connection The connection which has been deleted
   * @since 2.5.1
   *
   * @template
   **/
  onDisconnect: function onDisconnect(connection) {},

  /**
   * 
   * Return the name of this port.
   *
   * @returns {String}
   **/
  getName: function getName() {
    return this.name;
  },

  /**
   * 
   * Set the name of this port. The name of the port can be referenced by the lookup of
   * ports in the node.
   *
   *
   * @param {String} name The new name of this port.
   * @returns {this}
   **/
  setName: function setName(name) {
    this.name = name;

    return this;
  },

  /**
   * 
   * Hit test for ports. This method respect the corona diameter of the port for the hit test.
   * The corona width can be set with {@link draw2d.Port#setCoronaWidth}
   *
   * @param {Number} iX
   * @param {Number} iY
   * @param {Number} [corona]
   * @returns {Boolean}
   */
  hitTest: function hitTest(iX, iY, corona) {
    var x = this.getAbsoluteX() - this.coronaWidth - this.getWidth() / 2;
    var y = this.getAbsoluteY() - this.coronaWidth - this.getHeight() / 2;
    var iX2 = x + this.getWidth() + this.coronaWidth * 2;
    var iY2 = y + this.getHeight() + this.coronaWidth * 2;

    return iX >= x && iX <= iX2 && iY >= y && iY <= iY2;
  },

  /**
   * 
   * Highlight this port
   *
   * @param {Boolean} flag indicator if the figure should glow.
   * @returns {this}
   */
  setGlow: function setGlow(flag) {
    if (flag === true && this.corona === null) {
      this.corona = new _packages2.default.Corona();
      this.corona.setDimension(this.getWidth() + this.getCoronaWidth() * 2, this.getWidth() + this.getCoronaWidth() * 2);
      this.corona.setPosition(this.getAbsoluteX() - this.getCoronaWidth() - this.getWidth() / 2, this.getAbsoluteY() - this.getCoronaWidth() - this.getHeight() / 2);

      this.corona.setCanvas(this.getCanvas());

      // important inital
      this.corona.getShapeElement();
      this.corona.repaint();
    } else if (flag === false && this.corona !== null) {
      this.corona.setCanvas(null);
      this.corona = null;
    }

    return this;
  },

  /**
   * @inheritdoc
   */
  createCommand: function createCommand(request) {
    // the port has its own implementation of the CommandMove
    //
    if (request.getPolicy() === _packages2.default.command.CommandType.MOVE) {
      if (!this.isDraggable()) {
        return null;
      }
      return new _packages2.default.command.CommandMovePort(this);
    }

    return null;
  },

  /**
   * 
   * Called from the figure itself when any position changes happens. All listener
   * will be informed.
   * <br>
   * DON'T fire this event if the Port is during a Drag&Drop operation. This can happen
   * if we try to connect two ports
   *
   * @private
   **/
  fireEvent: function fireEvent(event, args) {
    if (this.isInDragDrop === true && event !== "drag") {
      return;
    }

    this._super(event, args);
  },

  /**
   * 
   * Return an objects with all important attributes for XML or JSON serialization
   *
   * @return {Object} all attributes required for the persistency
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.maxFanOut = this.maxFanOut;
    memento.name = this.name;
    memento.semanticGroup = this.semanticGroup;

    // defined by the locator. Don't persist
    //
    delete memento.x;
    delete memento.y;

    // ports didn't have children ports. In this case we
    // delete this attribute as well to avoid confusions.
    //
    delete memento.ports;

    return memento;
  },

  /**
   * 
   * Read all attributes from the serialized properties and transfer them into the shape.
   *
   * @param {Object} memento
   * @returns {this}
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.maxFanOut !== "undefined") {
      // Big bug in the past.
      // I used Number.MAX_VALUE as maxFanOut which is 1.7976931348623157e+308
      // parseInt creates "1" during the reading of the JSON - which is crap.
      // BIG BIG BUG!!! my fault.
      // Now check if the memento.maxFanOut is a number and take this without crappy parsing.
      if (typeof memento.maxFanOut === "number") {
        this.maxFanOut = memento.maxFanOut;
      } else {
        this.maxFanOut = Math.max(1, parseInt(memento.maxFanOut));
      }
    }

    if (typeof memento.name !== "undefined") {
      this.setName(memento.name);
    }

    if (typeof memento.semanticGroup !== "undefined") {
      this.setSemanticGroup(memento.semanticGroup);
    }

    return this;
  }
});

/**
 * @class
 * Glow effect for ports. Just for internal use.
 *
 * @private
 * @extend draw2d.shape.basic.Circle
 */
_packages2.default.Corona = _packages2.default.shape.basic.Circle.extend(
/** @lends draw2d.shape.basic.Circle.prototype */
{

  init: function init() {
    this._super();
    this.setAlpha(0.3);
    this.setBackgroundColor(new _packages2.default.util.Color(178, 225, 255));
    this.setColor(new _packages2.default.util.Color(102, 182, 252));
  },

  /**
   * 
   * the the opacity of the element.
   *
   * @param {Number} percent
   */
  setAlpha: function setAlpha(percent) {
    this._super(Math.min(0.3, percent));
    this.setDeleteable(false);
    this.setDraggable(false);
    this.setResizeable(false);
    this.setSelectable(false);

    return this;
  }
});

/***/ }),

/***/ "./src/ResizeHandle.js":
/*!*****************************!*\
  !*** ./src/ResizeHandle.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ./util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * The Resizehandles for Figures.

 * <pre>
 * Possible Type:
 *
 *   1             2               3
 *    O-----------O-------------O
 *    |                         |
 *    |                         |
 *   8 O           + 9           O 4
 *    |                         |
 *    |                         |
 *    O-----------O-------------O
 *   7             6               5
 * </pre>
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 */
_packages2.default.ResizeHandle = _packages2.default.shape.basic.Rectangle.extend(
/** @lends draw2d.ResizeHandle.prototype */
{

  NAME: "draw2d.ResizeHandle",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {draw2d.Figure} the owner if the resize handle
   * @param {Number} type the type of the ResizeHandle.
   */
  init: function init(attr, setter, getter) {
    var _this = this;

    this.zoomCallback = function () {
      _this.attr({
        width: _this.origWidth * _this.getCanvas().getZoom(),
        height: _this.origHeight * _this.getCanvas().getZoom(),
        radius: _this.origRadius * _this.getCanvas().getZoom(),
        stroke: _this.origStroke * _this.getCanvas().getZoom()
      });

      // size of the ResizeHandle has changed. Force a reposition of handle
      //
      if (!_this.blockEvent) _this.owner.fireEvent("move", {});
    };

    this._super((0, _extend2.default)({
      // set some good defaults
      bgColor: "#FDFDFD",
      stroke: 0.5,
      width: 10,
      height: 10,
      minWidth: 0.3,
      minHeight: 0.3,
      color: "#a0a0a0",
      radius: 1,
      selectable: false
      // and allow to override them
    }, attr), (0, _extend2.default)({
      owner: this.setOwner,
      type: this.setType
    }, setter), (0, _extend2.default)({
      owner: this.getOwner,
      type: this.getType
    }, getter));

    // required in the SelectionEditPolicy to indicate the type of figure
    // which the user clicks
    this.isResizeHandle = true;

    this.command = null;
    this.commandMove = null;
    this.commandResize = null;
    this.useGradient = true;

    this.origRadius = this.radius;
    this.origWidth = this.width;
    this.origHeight = this.height;
    this.origStroke = this.stroke;
  },

  /**
   *
   * The edge of the rectangle for the snapTo mechanism.
   *
   * @return {draw2d.SnapToHelper} enum of the direction (NORTH, NORTH_WEST, EAST,...)
   */
  getSnapToDirection: function getSnapToDirection() {
    switch (this.type) {
      case 1:
        return _packages2.default.SnapToHelper.NORTH_WEST;
      case 2:
        return _packages2.default.SnapToHelper.NORTH;
      case 3:
        return _packages2.default.SnapToHelper.NORTH_EAST;
      case 4:
        return _packages2.default.SnapToHelper.EAST;
      case 5:
        return _packages2.default.SnapToHelper.SOUTH_EAST;
      case 6:
        return _packages2.default.SnapToHelper.SOUTH;
      case 7:
        return _packages2.default.SnapToHelper.SOUTH_WEST;
      case 8:
        return _packages2.default.SnapToHelper.WEST;
      case 9:
        return _packages2.default.SnapToHelper.NSEW;
      default:
        return _packages2.default.SnapToHelper.EAST;
    }
  },

  /**
   * @inheritdoc
   */
  createShapeElement: function createShapeElement() {
    this.shape = this._super();

    this.shape.node.setAttribute("type", this.type);
    this.updateCursor(this.shape);

    return this.shape;
  },

  /**
   *
   * Returns the current used SVG as string
   *
   * @returns {String}
   */
  getOwner: function getOwner() {
    return this.owner;
  },

  setOwner: function setOwner(owner) {
    this.owner = owner;

    return this;
  },

  /**
   *
   * Returns the current used SVG as string
   *
   * @returns {String}
   */
  getType: function getType() {
    return this.type;
  },

  setType: function setType(type) {
    this.type = type;

    return this;
  },

  /**
   *
   * calculate and set the cursor of the reize handle
   * @private
   */
  updateCursor: function updateCursor(shape) {
    if (shape === null) {
      return this;
    }

    if (this.isDraggable() === false) {
      shape.attr({ "cursor": "default" });
      return this;
    }

    switch (this.type) {
      case 1:
        shape.attr({ "cursor": "nw-resize" });
        break;
      case 2:
        shape.attr({ "cursor": "n-resize" });
        break;
      case 3:
        shape.attr({ "cursor": "ne-resize" });
        break;
      case 4:
        shape.attr({ "cursor": "e-resize" });
        break;
      case 5:
        shape.attr({ "cursor": "se-resize" });
        break;
      case 6:
        shape.attr({ "cursor": "s-resize" });
        break;
      case 7:
        shape.attr({ "cursor": "sw-resize" });
        break;
      case 8:
        shape.attr({ "cursor": "w-resize" });
        break;
      default:
        shape.attr({ "cursor": "move" });
        break;
    }
    return this;
  },

  /**
   *
   * Adjust the draggable flag of the resize handle and update the cursor of the shape in relation
   * to the type of resize handle. north, south,west,..
   *
   * @param flag
   * @returns {this}
   */
  setDraggable: function setDraggable(flag) {
    this._super(flag);
    this.updateCursor(this.shape);

    return this;
  },

  /**
   *
   * Will be called if the drag and drop action beginns. You can return [false] if you
   * want avoid that the figure can be move.
   *
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean} true whenever the drag drop operation is allowed.
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
    // This happens if the selected figure has set the "nonResizeable" flag
    // In this case the ResizeHandle can't be dragged. => no resize
    //
    if (!this.isDraggable()) {
      return false;
    }

    this.ox = this.getAbsoluteX();
    this.oy = this.getAbsoluteY();

    this.commandMove = this.owner.createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.MOVE));
    this.commandResize = this.owner.createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.RESIZE));

    return true;
  },

  /**
   *
   * Called by the framework if the figure is moved by user interaction.
   *
   * @param {Number} dx the move x offset
   * @param {Number} dy the move y offset
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   *
   */
  onDrag: function onDrag(dx, dy, dx2, dy2) {
    if (this.isDraggable() === false) {
      return;
    }

    var oldX = this.getAbsoluteX();
    var oldY = this.getAbsoluteY();

    // call the super.drag method with all snapTo### handler and adjustments
    this._super(dx, dy, dx2, dy2);

    var diffX = this.getAbsoluteX() - oldX;
    var diffY = this.getAbsoluteY() - oldY;

    var obj = this.owner;
    var objPosX = obj.getAbsoluteX();
    var objPosY = obj.getAbsoluteY();
    var objWidth = obj.getWidth();
    var objHeight = obj.getHeight();

    var newX = null;
    var newY = null;
    var corrPos = null;
    switch (this.type) {
      case 1:
        obj.setDimension(objWidth - diffX, objHeight - diffY);
        newX = objPosX + (objWidth - obj.getWidth());
        newY = objPosY + (objHeight - obj.getHeight());
        obj.setPosition(newX, newY);
        break;
      case 2:
        obj.setDimension(objWidth, objHeight - diffY);
        newX = objPosX;
        newY = objPosY + (objHeight - obj.getHeight());
        obj.setPosition(newX, newY);
        break;
      case 3:
        obj.setDimension(objWidth + diffX, objHeight - diffY);
        newX = objPosX;
        newY = objPosY + (objHeight - obj.getHeight());
        obj.setPosition(newX, newY);
        break;
      case 4:
        obj.setDimension(objWidth + diffX, objHeight);
        break;
      case 5:
        obj.setDimension(objWidth + diffX, objHeight + diffY);
        break;
      case 6:
        obj.setDimension(objWidth, objHeight + diffY);
        break;
      case 7:
        obj.setDimension(objWidth - diffX, objHeight + diffY);
        newX = objPosX + (objWidth - obj.getWidth());
        newY = objPosY;
        obj.setPosition(newX, newY);
        break;
      case 8:
        obj.setDimension(objWidth - diffX, objHeight);
        newX = objPosX + (objWidth - obj.getWidth());
        newY = objPosY;
        obj.setPosition(newX, newY);
        break;
    }

    if (newX !== null) {
      // may the setPosition has changed regarding any constraint or edit policies. In this case
      // we must adjust the dimension with the related correction
      //
      corrPos = obj.getPosition();
      if (corrPos.x !== newX || corrPos.y !== newY) {
        obj.setDimension(obj.getWidth() - (corrPos.x - newX), obj.getHeight() - (corrPos.y - newY));
      }
    }
  },

  /**
   *
   * Will be called after a drag and drop action.<br>
   *
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onDragEnd: function onDragEnd(x, y, shiftKey, ctrlKey) {
    if (!this.isDraggable()) {
      return;
    }

    // An non draggable resizeHandle doesn't create a move/resize command.
    // This happens if the selected figure has set the "nonResizeable" flag.
    //
    if (this.commandMove !== null) {
      this.commandMove.setPosition(this.owner.getX(), this.owner.getY());
      this.canvas.getCommandStack().execute(this.commandMove);
      this.commandMove = null;
    }

    if (this.commandResize !== null) {
      this.commandResize.setDimension(this.owner.getWidth(), this.owner.getHeight());
      this.canvas.getCommandStack().execute(this.commandResize);
      this.commandResize = null;
    }
  },

  /**
   * Set the position of the object.<br>
   * The ResizeHandle overrides the Figure.setPosition method. The base
   * class updates the resize handles during the update of the Dimension/Position. This
   * is not neccessary for the ResizeHandles. Performance issue.
   *
   * @param {Number|draw2d.geo.Point} x The new x coordinate of the figure
   * @param {Number} y The new y coordinate of the figure
   **/
  setPosition: function setPosition(x, y) {
    // don't call base implementation. Base implementation will show
    // ResizeHandles...but I'm the ResizeHandle
    if (x instanceof _packages2.default.geo.Point) {
      this.x = x.x;
      this.y = x.y;
    } else {
      this.x = x;
      this.y = y;
    }

    if (this.repaintBlocked === true || this.shape === null) {
      return this;
    }

    // performance improvement by setting the coordinates direct.
    this.shape.attr({ x: this.x, y: this.y });

    this.applyTransformation();
  },

  /**
   *
   * Set the new dimension of the the ResizeHandle. If you didn't pass any width/height the best default for the
   * platform will be used.
   *
   * Additional the "snapTo" anchor is re-calculated in relation to the type of ResizeHandle
   *
   * @param {Number} [width] new width of the resize handle
   * @param {Number} [height] new width of the resize handle
   */
  setDimension: function setDimension(width, height) {

    if (typeof height !== "undefined") {
      this._super(width, height);
    } else {
      if (_packages2.default.isTouchDevice) {
        this._super(15, 15);
      } else {
        this._super(8, 8);
      }
    }

    var offset = this.getWidth();
    var offset2 = offset / 2;

    switch (this.type) {
      case 1:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(offset, offset));
        break;
      case 2:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(offset2, offset));
        break;
      case 3:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(0, offset));
        break;
      case 4:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(0, offset2));
        break;
      case 5:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(0, 0));
        break;
      case 6:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(offset2, 0));
        break;
      case 7:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(offset, 0));
        break;
      case 8:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(offset, offset2));
        break;
      case 9:
        this.setSnapToGridAnchor(new _packages2.default.geo.Point(offset2, offset2));
        break;
    }

    return this;
  },

  /**
   *
   * Show the ResizeHandle and add it to the canvas.<br>
   * Additional bring it in to the front of other figures if we didn't use
   * an overlayCanvas.
   *
   * If the ResizeHandle is place inside an overlayCanvas it is automatically on top.
   *
   * @param {draw2d.Canvas} canvas the canvas to use
   **/
  show: function show(canvas) {
    // don't call the parent function. The parent functions delete this object
    // and a resize handle can't be deleted.
    this.setCanvas(canvas);

    this.canvas.resizeHandles.add(this);
    this.shape.insertAfter(this.owner.getShapeElement());

    try {
      this.blockEvent = true;
      this.zoomCallback();
    } finally {
      this.blockEvent = false;
    }
    this.repaint();

    return this;
  },

  /**
   *
   * Hide the resize handle and remove it from the canvas.
   *
   **/
  hide: function hide() {
    // don't call the parent function. The parent functions delete this object
    // and a resize handle shouldn't be deleted.
    if (this.shape === null) {
      return;
    }

    this.canvas.resizeHandles.remove(this);
    this.setCanvas(null);

    return this;
  },

  setCanvas: function setCanvas(canvas) {

    if (this.canvas !== null) {
      this.canvas.off(this.zoomCallback);
    }

    this._super(canvas);

    if (this.canvas !== null) {
      this.canvas.on("zoom", this.zoomCallback);
    }
  },

  /**
   *
   * Set the new background color of the figure. It is possible to hands over
   * <code>null</code> to set the background transparent.
   *
   * @param {draw2d.util.Color} color The new background color of the figure
   **/
  setBackgroundColor: function setBackgroundColor(color) {
    color = new _packages2.default.util.Color(color);

    this.bgGradient = "90-" + color.darker(0.2).hash() + "-" + color.hash();
    this._super(color);

    return this;
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {

    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    if (this.bgColor.hash() === "none") {
      attributes.fill = "none";
    } else if (this.getAlpha() < 0.9 || this.useGradient === false) {
      attributes.fill = this.bgColor.rgba();
    } else {
      attributes.fill = this.bgGradient;
    }

    this._super(attributes);
  },

  /**
   *
   * return true if the element can be used in combination with the
   * SnapToHelper feature.
   *
   * @returns {Boolean}
   **/
  supportsSnapToHelper: function supportsSnapToHelper() {
    return true;
  },

  /**
   *
   * Override this method and redirect them to the cavas. A ResizeHandle didn't support
   * Keyboard interaction at the moment.
   *
   * @param {Number} keyCode the id of the pressed key
   * @param {Boolean} ctrl true if the user has pressed the CTRL/STRG key as well.
   **/
  onKeyDown: function onKeyDown(keyCode, ctrl) {
    // don't call the parent function. The parent functions delete this object
    // and a resize handle can't be deleted.
    this.canvas.onKeyDown(keyCode, ctrl);
  },

  /**
   * @inheritdoc
   */
  fireEvent: function fireEvent(event, args) {
    // A resizeHandle doesn't fire this event.
    // Normally this set the document dirty. This is not necessary for a ResizeHandle.
  }
});

/***/ }),

/***/ "./src/SVGFigure.js":
/*!**************************!*\
  !*** ./src/SVGFigure.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Abstract class which can handle plain SVG content.
 *
 * @author Andreas Herz
 * @extends draw2d.SetFigure
 */
_packages2.default.SVGFigure = _packages2.default.SetFigure.extend(
/** @lends draw2d.SVGFigure.prototype */
{

    NAME: "draw2d.SVGFigure",

    /**
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function init(attr, setter, getter) {
        this.svg = null;

        this._super((0, _extend2.default)({}, attr), (0, _extend2.default)({
            svg: this.setSVG
        }, setter), (0, _extend2.default)({
            svg: this.getSVG
        }, getter));
    },

    /**
     * @inheritdoc
     */
    createSet: function createSet() {
        // legacy behaviour. Legacy code of Draw2D didn't have the "svg" attribute.
        // in this case we must call the overridden method "getSVG" to retrieve the SVG from inherit
        // the inherit class.
        //
        if (this.svg === null) {
            this.svg = this.getSVG();
        }

        return this.importSVG(this.canvas, this.svg);
    },

    /**
     * 
     * Returns the current used SVG as string
     * @returns {String}
     */
    getSVG: function getSVG() {
        return this.svg;
    },

    /**
     * 
     * Set the SVG of this shape
     *
     * @param {String} svg The new SVG to render as String
     * @param {Number} [duration] the optional duration for the change of the SVG of the figure
     *
     * @returns {draw2d.SVGFigure}
     */
    setSVG: function setSVG(svg, duration) {
        this.svg = svg;

        // SVG has changed. Update the rendering
        //
        if (this.canvas !== null && this.svgNodes !== null) {
            var newSVGNodes = this.createSet();
            if (!isNaN(parseFloat(duration))) {
                newSVGNodes.hide();
                newSVGNodes.insertAfter(this.svgNodes);
                var oldSVG = this.svgNodes;
                this.svgNodes = newSVGNodes;
                this.applyTransformation();
                oldSVG.forEach(function (shape) {
                    $(shape.node).fadeOut(duration, function () {
                        shape.remove();
                    });
                });
                newSVGNodes.forEach(function (shape) {
                    $(shape.node).fadeIn(duration);
                });
            } else {
                newSVGNodes.insertAfter(this.svgNodes);
                this.svgNodes.remove();
                this.svgNodes = newSVGNodes;
                this.applyTransformation();
            }
        }

        return this;
    },

    /**
     * 
     * Helper method to transform the SVG string into a raphaelJS set.
     *
     * @private
     */
    importSVG: function importSVG(canvas, rawSVG) {

        var set = canvas.paper.set();

        try {
            if (typeof rawSVG === 'undefined') {
                throw 'No data was provided.';
            }

            // Override the dimension from the JSON if the SVG contains any
            //
            var svgDOM = $(rawSVG);

            // set the dimension of the element if the JSON import didn't provide
            // a dimension already
            //
            if (typeof this._dimensionReadFromJSON === "undefined") {
                if (svgDOM.attr("width") && svgDOM.attr("height")) {
                    this.setDimension(parseFloat(svgDOM.attr("width")), parseFloat(svgDOM.attr("height")));
                }
                delete this._dimensionReadFromJSON;
            }

            var findStyle = new RegExp('([a-z0-9\-]+) ?: ?([^ ;]+)[ ;]?', 'gi');

            svgDOM.children().each(function (i, element) {
                //element = $(element);
                var shape = null;
                var style = null;
                var attr = {};
                var node = element.tagName;

                // remove the namespace of the node if existing. This can happen in IE8
                //
                var index = node.indexOf(":");
                if (index != -1) node = node.substr(index + 1);

                // map some element to Raphael specifix attributes or ignore some unknown attributes
                //
                $(element.attributes).each(function () {
                    switch (this.nodeName) {
                        case 'stroke-dasharray':
                            attr[this.nodeName] = '- ';
                            break;
                        case 'style':
                            style = this.nodeValue;
                            break;
                        case 'id':
                        case 'xml:space':
                            // just to ignore
                            break;
                        default:
                            if (this.value) {
                                attr[this.nodeName] = this.value;
                            } else {
                                // @deprecated
                                attr[this.nodeName] = this.nodeValue;
                            }
                            break;
                    }
                });

                if (style !== null) {
                    while (findStyle.exec(style)) {
                        attr[RegExp.$1] = RegExp.$2;
                    }
                }

                // set some good defaults if the element didn't provide a stroke-width but has a "stroke" attribute
                //
                if (typeof attr['stroke-width'] === 'undefined') {
                    attr['stroke-width'] = typeof attr.stroke === 'undefined' ? 0 : 1.2;
                }

                switch (node) {
                    case 'rect':
                        shape = canvas.paper.rect();

                        // transfer rx-SVG attribute to the "r" attribute of raphael
                        if (typeof attr["rx"] !== "undefined") {
                            attr.r = parseInt(attr.rx);
                            delete attr.rx;
                        }
                        break;
                    case 'circle':
                        shape = canvas.paper.circle();
                        break;
                    case 'ellipse':
                        shape = canvas.paper.ellipse();
                        break;
                    case 'path':
                        attr.fill = "none";
                        shape = canvas.paper.path(attr.d);
                        break;
                    case 'line':
                        attr.d = "M " + attr.x1 + " " + attr.y1 + "L" + attr.x2 + " " + attr.y2;
                        attr.fill = "none";
                        shape = canvas.paper.path(attr.d);
                        break;
                    case 'polyline':
                        var path = attr.points;
                        attr.d = "M " + path.replace(" ", " L");
                        shape = canvas.paper.path(attr.d);
                        break;
                    case 'polygon':
                        shape = canvas.paper.polygon(attr.points);
                        break;
                    case 'image':
                        shape = canvas.paper.image();
                        break;
                    case 'tspan':
                    case 'text':
                        if (element.childNodes.length > 0) {
                            var child = element.firstChild;
                            do {
                                switch (child.nodeType) {
                                    case 2: //ATTRIBUTE_NODE
                                    case 4: //CDATA_SECTION_NODE
                                    case 5: //ENTITY_REFERENCE_NODE
                                    case 6: //ENTITY_NODE
                                    case 7: //PROCESSING_INSTRUCTION_NODE
                                    case 8: //COMMENT_NODE
                                    case 9: //DOCUMENT_NODE
                                    case 10: //DOCUMENT_TYPE_NODE
                                    case 11: //DOCUMENT_FRAGMENT_NODE
                                    case 12:
                                        //NOTATION_NODE
                                        return;
                                    case 3:
                                        //TEXT_NODE
                                        // redirect to the parent node if we found a simple TEXT without any attributes
                                        child = element;
                                        break;
                                    case 1: //ELEMENT_NODE
                                }
                                var subShape = canvas.paper.text(0, 0, $(child).text());
                                var subAttr = { "x": parseFloat(child.attributes.x.value), "y": parseFloat(child.attributes.y.value) };
                                subAttr["text-anchor"] = "start";
                                if (typeof child.attributes["text-anchor"] !== "undefined") {
                                    subAttr["text-anchor"] = child.attributes["text-anchor"].value;
                                } else if (typeof attr["text-anchor"] !== "undefined") {
                                    subAttr["text-anchor"] = attr["text-anchor"];
                                }

                                if (typeof child.attributes["font-size"] !== "undefined") {
                                    subAttr["font-size"] = parseInt(child.attributes["font-size"].value);
                                } else if (typeof attr["font-size"] !== "undefined") {
                                    // inherit the font size from the parent node
                                    subAttr["font-size"] = parseInt(attr["font-size"]);
                                }

                                if (typeof child.attributes["font-family"] !== "undefined") {
                                    subAttr["font-family"] = child.attributes["font-family"].value;
                                } else if (typeof attr["font-family"] !== "undefined") {
                                    // inherit the font size from the parent node
                                    subAttr["font-family"] = attr["font-family"];
                                }

                                subAttr["fill"] = "#000000";
                                if (typeof child.attributes["fill"] !== "undefined") {
                                    subAttr["fill"] = child.attributes["fill"].value;
                                } else if (typeof attr["fill"] !== "undefined") {
                                    // inherit the font size from the parent node
                                    subAttr["fill"] = attr["fill"];
                                }

                                subAttr.y = subAttr.y + subShape.getBBox().height / 2;

                                subShape.attr(subAttr);
                                set.push(subShape);
                                child = child.nextSibling;
                            } while (child && child.nodeType === 3); // 3= TEXT_NODE
                        } else {
                            shape = canvas.paper.text(0, 0, $(element).html());
                            if (typeof attr["fill"] === "undefined") attr["fill"] = "#000000";
                            if (typeof attr["text-anchor"] === "undefined") attr["text-anchor"] = "start";
                            if (typeof attr["font-size"] !== "undefined") attr["font-size"] = parseInt(attr["font-size"]);
                            if (typeof attr["font-family"] !== "undefined") attr["font-family"] = parseInt(attr["font-family"]);
                            attr.y = parseFloat(attr.y) + shape.getBBox().height / 2;
                        }
                        break;
                }
                if (shape !== null) {
                    shape.attr(attr);
                    set.push(shape);
                }
            });
        } catch (error) {
            alert('The SVG data you entered was invalid! (' + error + ')');
        }

        return set;
    },

    /**
     * 
     * Read all attributes from the serialized properties and transfer them into the shape.
     *
     * @param {Object} memento
     */
    setPersistentAttributes: function setPersistentAttributes(memento) {
        this._super(memento);

        // keep a temp flag to indicate the we have read the dimension of the
        // element from the JSON struct. In this case we didn't care about the dimension
        // from the SVG data
        //
        if (typeof memento.width !== "undefined") {
            this._dimensionReadFromJSON = true;
        } else if (typeof memento.height !== "undefined") {
            this._dimensionReadFromJSON = true;
        }

        return this;
    }

});

/***/ }),

/***/ "./src/Selection.js":
/*!**************************!*\
  !*** ./src/Selection.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Represents the current selection in the canvas. The selection element is a pure passive element which
 * manage/store the selection.
 *
 *
 * @author Andreas Herz
 */
_packages2.default.Selection = Class.extend(
/** @lends draw2d.Selection.prototype */
{

  NAME: "draw2d.Selection",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   */
  init: function init() {
    this.primary = null;
    this.all = new _packages2.default.util.ArrayList();
  },

  /**
   * 
   * Reset the current selection
   *
   */
  clear: function clear() {
    this.primary = null;
    this.all = new _packages2.default.util.ArrayList();

    return this;
  },

  /**
   * 
   * Return the primary selection. This can only one figure at once.
   *
   * @returns {draw2d.Figure} the primary selected figure
   */
  getPrimary: function getPrimary() {
    return this.primary;
  },

  /**
   * 
   * Set the primary selection.
   *
   * @param {draw2d.Figure} figure The new primary selection
   */
  setPrimary: function setPrimary(figure) {
    this.primary = figure;
    this.add(figure);

    return this;
  },

  /**
   * 
   * Remove the given figure from the selection (primary,all)
   *
   * @param {draw2d.Figure} figure
   */
  remove: function remove(figure) {
    this.all.remove(figure);
    if (this.primary === figure) {
      this.primary = null;
    }

    return this;
  },

  /**
   * 
   * Add a figure to the selection. No events are fired or update the selection handle. This method just
   * add the figure to the internal management data structure.
   *
   * @param figure
   * @private
   */
  add: function add(figure) {
    if (figure !== null && !this.all.contains(figure)) {
      this.all.add(figure);
    }

    return this;
  },

  /**
   * 
   * return true if the given figure part of the selection.
   *
   * @param {draw2d.Figure} figure The figure to check
   * @param {Boolean} [checkDescendant] Check if the figure provided by the argument is a descendant of the selection whether it is a direct child or nested more deeply.
   *
   * @since 2.2.0
   * @returns {Boolean}
   */
  contains: function contains(figure, checkDescendant) {
    if (checkDescendant) {
      for (var i = 0; i < this.all.getSize(); i++) {
        var figureToCheck = this.all.get(i);
        if (figureToCheck === figure || figureToCheck.contains(figure)) {
          return true;
        }
      }
      return false;
    }
    return this.all.contains(figure);
  },

  /**
   * 
   * Return the size of the selection
   *
   * @since 4.8.0
   */
  getSize: function getSize() {
    return this.all.getSize();
  },

  /**
   * 
   * Return the complete selection - including the primary selection.
   *
   * @param {Boolean} [expand] expand all StrongComposite and WeakComposite to get all figures. Didn't expand any SetFigures or LayoutFigures
   * @returns {draw2d.util.ArrayList}
   *
   */
  getAll: function getAll(expand) {
    if (expand === true) {
      var result = new _packages2.default.util.ArrayList();
      var addRecursive = function addRecursive(figures) {
        result.addAll(figures, true);
        figures.each(function (index, figure) {
          if (figure instanceof _packages2.default.shape.composite.StrongComposite) {
            addRecursive(figure.getAssignedFigures());
          }
        });
      };
      addRecursive(this.all);

      return result;
    }

    return this.all.clone();
  },

  /**
   * 
   * Iterates over the current selection with <b>func</b> as callback handler.
   *
   * @param {Function} func the callback function to call for each element
   * @param {Number} func.i index of the element in iteration
   * @param {Object} func.value value of the element in iteration.
   * @param {Boolean} [reverse] optional parameter. Iterate the collection reverse if it set to <b>true</b>
   */
  each: function each(func, reverse) {
    this.all.each(func, reverse);

    return this;
  }
});

/***/ }),

/***/ "./src/SetFigure.js":
/*!**************************!*\
  !*** ./src/SetFigure.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A SetFigure is a composition of different SVG elements.
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 */
_packages2.default.SetFigure = _packages2.default.shape.basic.Rectangle.extend(
/** @lends draw2d.SetFigure.prototype */
{

  NAME: "draw2d.SetFigure",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    // collection of SVG DOM nodes
    this.svgNodes = null;

    this.originalWidth = null;
    this.originalHeight = null;

    this.scaleX = 1;
    this.scaleY = 1;

    this.strokeScale = true; // scale the stroke width of the children nodes if the parent resize

    this._super((0, _extend2.default)({ stroke: 0, bgColor: null }, attr), setter, getter);
  },

  /**
   * 
   * Set/Reset the canvas for the element.
   *
   * @param {draw2d.Canvas} canvas the canvas to use
   */
  setCanvas: function setCanvas(canvas) {
    // remove the shape if we reset the canvas and the element
    // was already drawn
    if (canvas === null && this.svgNodes !== null) {
      this.svgNodes.remove();
      this.svgNodes = null;
    }

    this._super(canvas);
  },

  /**
   * 
   * Set the css class if the node.
   *
   * @param {String} cssClass the new css class name of the node
   * @since 2.9.0
   */
  setCssClass: function setCssClass(cssClass) {
    this._super(cssClass);

    if (this.svgNodes === null) {
      return this;
    }

    if (this.cssClass === null) {
      this.svgNodes.forEach(function (e) {
        e.node.removeAttribute("class");
      });
    } else {
      this.svgNodes.forEach(function (e) {
        e.node.setAttribute("class", cssClass);
      });
    }

    return this;
  },

  /**
   * 
   * propagate all attributes like color, stroke,... to the shape element and
   * repaint them.
   *
   * @protected
   **/
  repaint: function repaint(attributes) {
    // repaint can be blocked during deserialization and if the shape
    // not part of any canvas.
    //
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    if (this.originalWidth !== null) {
      this.scaleX = this.width / this.originalWidth;
      this.scaleY = this.height / this.originalHeight;
    }

    attributes = attributes || {};

    this.applyAlpha();

    this._super(attributes);
  },

  /**
   * @inheritdoc
   */
  setVisible: function setVisible(flag, duration) {
    this._super(flag, duration);

    if (this.svgNodes !== null) {
      if (duration) {
        if (this.visible === true) {
          this.svgNodes.forEach(function (shape) {
            $(shape.node).fadeIn(duration, function () {
              return shape.show();
            });
          });
        } else {
          this.svgNodes.forEach(function (shape) {
            $(shape.node).fadeOut(duration, function () {
              return shape.hide();
            });
          });
        }
      } else {
        if (this.visible === true) {
          this.svgNodes.show();
        } else {
          this.svgNodes.hide();
        }
      }
    }
  },

  /**
   * 
   * Apply the opacity to all child set elements. Override this if you want to avoid opacity changes.
   * @private
   *
   */
  applyAlpha: function applyAlpha() {
    this.svgNodes.attr({ opacity: this.alpha });
  },

  /**
   * @private
   */
  applyTransformation: function applyTransformation() {
    var s = "S" + this.scaleX + "," + this.scaleY + ",0,0 " + "R" + this.rotationAngle + "," + (this.getWidth() / 2 | 0) + "," + (this.getHeight() / 2 | 0) + "T" + this.getAbsoluteX() + "," + this.getAbsoluteY() + "";
    this.svgNodes.transform(s);
    if (this.rotationAngle === 90 || this.rotationAngle === 270) {
      var before = this.svgNodes.getBBox(true);
      var ratio = before.height / before.width;
      var reverseRatio = before.width / before.height;
      var rs = "...S" + ratio + "," + reverseRatio + "," + (this.getAbsoluteX() + this.getWidth() / 2) + "," + (this.getAbsoluteY() + this.getHeight() / 2);
      this.svgNodes.transform(rs);
    }

    return this;
  },

  /**
   * 
   * Moves the element so it is the closest to the viewers eyes, on top of other elements. Additional
   * the internal model changed as well.
   *
   * Optional: Inserts current object in front of the given one.
   *
   * @param {draw2d.Figure} [figure] move current object in front of the given one.
   * @since 3.0.0
   */
  toFront: function toFront(figure) {
    ////////////////////////////////////////////////////////////////////
    // NOTE: the code has a complete different order of draw2d.Figure.
    //       we must respect the svgNodes here
    ////////////////////////////////////////////////////////////////////

    // ensure that the z-oder is still correct if the figure is assigned
    // to a StrongComposite
    //
    if (this.composite instanceof _packages2.default.shape.composite.StrongComposite && typeof figure !== "undefined") {
      var indexFigure = figure.getZOrder();
      var indexComposite = this.composite.getZOrder();
      if (indexFigure < indexComposite) {
        figure = this.composite;
      }
    }

    if (typeof figure === "undefined") {
      // bring the outer frame in front...
      this.getShapeElement().toFront();

      // and all inner children
      //
      if (this.svgNodes !== null) {
        this.svgNodes.toFront();
      }

      if (this.canvas !== null) {
        var figures = this.canvas.getFigures();
        var lines = this.canvas.getLines();
        if (figures.remove(this) !== null) {
          figures.add(this);
        } else if (lines.remove(this) !== null) {
          lines.add(this);
        }
      }
    } else {
      // Bring the SVG shapes between the "figure" and the container of this shape
      //
      if (this.svgNodes !== null) {
        this.svgNodes.insertAfter(figure.getTopLevelShapeElement());
      }
      this.getShapeElement().insertAfter(figure.getTopLevelShapeElement());

      if (this.canvas !== null) {
        var _figures = this.canvas.getFigures();
        var _lines = this.canvas.getLines();
        if (_figures.remove(this) !== null) {
          var index = _figures.indexOf(figure);
          _figures.insertElementAt(this, index + 1);
        } else if (_lines.remove(this) !== null) {
          _lines.add(this);
        }
      }
    }

    // bring all children in front of the parent
    //
    this.children.each(function (i, child) {
      child.figure.toFront(figure);
    });

    // the ports are always on top
    //
    var _this = this;
    this.getPorts().each(function (i, port) {
      port.getConnections().each(function (i, connection) {
        connection.toFront(figure);
      });
      // a port should always be in front of the shape doesn't matter what the
      // "figure" parameter says.
      //
      port.toFront(_this);
    });

    // and last but not lease the ResizeHandles if any present
    //
    this.selectionHandles.each(function (i, handle) {
      handle.toFront();
    });

    return this;
  },

  /**
   * 
   * Moves the element to the background. Additional
   * the internal model changed as well.
   *
   * Optional: Inserts current object in front of the given one.
   *
   * @param {draw2d.Figure} [figure] move current object in front of the given one.
   * @since 4.7.2
   */
  toBack: function toBack(figure) {
    // it is not allowed that a figure is behind the assigned composite
    //
    if (this.composite instanceof _packages2.default.shape.composite.StrongComposite) {
      this.toFront(this.composite);
      return;
    }

    // sort the JSON Doc
    //
    if (this.canvas !== null) {
      var figures = this.canvas.getFigures();
      var lines = this.canvas.getLines();
      if (figures.remove(this) !== null) {
        figures.insertElementAt(this, 0);
      } else if (lines.remove(this) !== null) {
        lines.insertElementAt(this, 0);
      }
    }

    // bring all children figures in front of the parent
    // run reverse to the collection to care about the z-order of the children)
    this.children.each(function (i, child) {
      child.figure.toBack(figure);
    }, true);

    if (this.svgNodes !== null) {
      if (typeof figure !== "undefined") {
        this.svgNodes.insertBefore(figure.getShapeElement());
      } else {
        this.svgNodes.toBack();
      }
    }

    if (this.canvas !== null) {
      if (typeof figure !== "undefined") {
        this.getShapeElement().insertBefore(figure.getShapeElement());
      } else {
        this.getShapeElement().toBack();
      }
    }

    // and last but not least - the ports are always on top
    //
    var _this = this;
    this.getPorts().each(function (i, port) {
      port.getConnections().each(function (i, connection) {
        connection.toFront(_this);
      });
      // a port should always be in front of the shape doesn't matter what the
      // "figure" parameter says.
      //
      port.toFront(_this);
    });

    return this;
  },

  /**
   * @inheritdoc
   */
  getTopLevelShapeElement: function getTopLevelShapeElement() {
    if (this.svgNodes.length === 0) {
      return this.shape;
    }
    return this.svgNodes;
  },

  /**
   * @private
   */
  createShapeElement: function createShapeElement() {
    // NOTE: don't change the order of the two calls. This defines the z-oder in the canvas.
    // The "set" must always be on top.
    var shape = this.canvas.paper.rect(this.getX(), this.getY(), this.getWidth(), this.getHeight());
    this.svgNodes = this.createSet();

    // check if the element is a "set" or a simple raphael shape. otherwise we wrap them into a set
    //
    if (typeof this.svgNodes.forEach === "undefined") {
      var set = this.canvas.paper.set();
      set.push(this.svgNodes);
      this.svgNodes = set;
    }

    this.svgNodes.attr({ "stroke-scale": this.strokeScale });

    // update the visibility of the children
    this.setVisible(this.visible);

    // propagate the CSS style to all set elements
    this.setCssClass(this.cssClass);

    var bb = this.svgNodes.getBBox();
    this.originalWidth = bb.width;
    this.originalHeight = bb.height;

    return shape;
  },

  /**
   * 
   * Override this method to add your own SVG elements. See {@link draw2d.shape.basic.Label} as example.
   *
   * @template
   */
  createSet: function createSet() {
    return this.canvas.paper.set(); // return empty set as default;
  }

});

/***/ }),

/***/ "./src/VectorFigure.js":
/*!*****************************!*\
  !*** ./src/VectorFigure.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _JSONUtil = __webpack_require__(/*! util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

var _extend = __webpack_require__(/*! util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * The base class for all vector based figures like {@link draw2d.shape.basic.Rectangle}  or {@link draw2d.shape.basic.Oval}
 * inside a canvas.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.node.Node
 */
_packages2.default.VectorFigure = _packages2.default.shape.node.Node.extend(
/** @lends draw2d.VectorFigure.prototype */
{

    NAME: "draw2d.VectorFigure",

    /**
     * Creates a new figure element which are not assigned to any canvas.
     *
     * @param {Object} [attr] the configuration of the shape
     */
    init: function init(attr, setter, getter) {
        this.stroke = 1;
        this.radius = 0;
        this.bgColor = new _packages2.default.util.Color("#ffffff");
        this.color = new _packages2.default.util.Color("#303030");
        this.dasharray = null;

        // memento for the stroke if we reset the glow effect of this shape
        //
        this.strokeBeforeGlow = this.stroke;
        this.glowIsActive = false;

        this._super(attr, (0, _extend2.default)({
            // @attr {String} dasharray the line pattern see {@link draw2d.shape.basic.Line#setDashArray} for more information*/
            dasharray: this.setDashArray,
            // @attr {Number} radius the radius to render the line edges */
            radius: this.setRadius,
            // @attr {String|draw2d.util.Color} bgColor the background color of the shape */
            bgColor: this.setBackgroundColor,
            // @attr {String|draw2d.util.Color} color the main color of the shape */
            color: this.setColor,
            // @attr {Number} stroke the stroke width */
            stroke: this.setStroke
        }, setter), (0, _extend2.default)({
            dasharray: this.getDashArray,
            radius: this.getRadius,
            bgColor: this.getBackgroundColor,
            color: this.getColor,
            stroke: this.getStroke
        }, getter));
    },

    /**
     * 
     * Sets the corner radius or the edges.
     *
     * @param {Number} radius
     * @since 4.2.1
     */
    setRadius: function setRadius(radius) {
        this.radius = radius;
        this.repaint();
        this.fireEvent("change:radius", { value: this.radius });

        return this;
    },

    /**
     * 
     * Get the corner radius of the edges.
     *
     * @returns {Number}
     * @since 4.2.1
     */
    getRadius: function getRadius() {
        return this.radius;
    },

    /**
     * 
     * Set the line style for this object.
     *
     *     // Alternatively you can use the attr method:
     *     figure.attr({
    *       dash: dashPattern
    *     });
     *
     * @param {String} dash can be one of this ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]
     */
    setDashArray: function setDashArray(dashPattern) {
        this.dasharray = dashPattern;
        this.repaint();

        this.fireEvent("change:dashArray", { value: this.dasharray });

        return this;
    },

    /**
     * 
     * Get the line style for this object.
     *
     *     // Alternatively you can use the attr method:
     *     figure.attr("dash");
     *
     * @since 5.1.0
     */
    getDashArray: function getDashArray() {
        return this.dasharray;
    },

    /**
     * 
     * Highlight the element or remove the highlighting
     *
     * @param {Boolean} flag indicates glow/noGlow
     */
    setGlow: function setGlow(flag) {

        if (flag === this.glowIsActive) {
            return this;
        }

        this.glowIsActive = flag;
        if (flag === true) {
            this.strokeBeforeGlow = this.getStroke();
            this.setStroke(this.strokeBeforeGlow * 2.5);
        } else {
            this.setStroke(this.strokeBeforeGlow);
        }

        return this;
    },

    /**
     * @inheritdoc
     */
    repaint: function repaint(attributes) {
        if (this.repaintBlocked === true || this.shape === null) {
            return;
        }

        attributes = attributes || {};

        attributes.x = this.getAbsoluteX();
        attributes.y = this.getAbsoluteY();

        if (typeof attributes.stroke === "undefined") {
            if (this.color === null || this.stroke === 0) {
                attributes.stroke = "none";
            } else {
                attributes.stroke = this.color.rgba();
            }
        }

        _JSONUtil2.default.ensureDefault(attributes, "stroke-width", this.stroke);
        _JSONUtil2.default.ensureDefault(attributes, "fill", this.bgColor.rgba());
        _JSONUtil2.default.ensureDefault(attributes, "dasharray", this.dasharray);
        _JSONUtil2.default.ensureDefault(attributes, "stroke-dasharray", this.dasharray);

        this._super(attributes);

        return this;
    },

    /**
     * 
     * Set the new background color of the figure. It is possible to hands over
     * <code>null</code> to set the background transparent.
     *
     *     // Alternatively you can use the attr method:
     *     figure.attr({
     *       "bgColor": "#f0f0f0"
     *     });
     *
     * @param {String|draw2d.util.Color} color The new background color of the figure
     **/
    setBackgroundColor: function setBackgroundColor(color) {
        this.bgColor = new _packages2.default.util.Color(color);

        this.repaint();
        this.fireEvent("change:bgColor", { value: this.bgColor });

        return this;
    },

    /**
     * 
     * The current used background color.
     *
     *     // Alternatively you can use the attr method:
     *     var color =figure.attr("bgColor");
     *
     * @returns {draw2d.util.Color}
     */
    getBackgroundColor: function getBackgroundColor() {
        return this.bgColor;
    },

    /**
     * 
     * Set the stroke to use.
     *
     *     // Alternatively you can use the attr method:
     *     figure.attr({
     *       "stroke": 2
     *     });
     *
     * @param {Number} w The new line width of the figure
     **/
    setStroke: function setStroke(w) {
        this.stroke = w;
        this.repaint();
        this.fireEvent("change:stroke", { value: this.stroke });

        return this;
    },

    /**
     * 
     * The used line width.
     *
     * @returns {Number}
     **/
    getStroke: function getStroke() {
        return this.stroke;
    },

    /**
     * 
     * Set the foreground color of the figure.
     * This method fires a <i>document dirty</i> event.
     *
     *     // Alternatively you can use the attr method:
     *     figure.attr({
     *       "color": "#f3f3f3"
     *     });
     *
     * @param {String|draw2d.util.Color} color The new color of the line.
     **/
    setColor: function setColor(color) {
        this.color = new _packages2.default.util.Color(color);
        this.repaint();
        this.fireEvent("change:color", { value: this.color });

        return this;
    },

    /**
     * 
     * Get the current used foreground color
     *
     *
     * @returns {draw2d.util.Color}
     */
    getColor: function getColor() {
        return this.color;
    },

    /**
     * @inheritdoc
     */
    getPersistentAttributes: function getPersistentAttributes() {
        return (0, _extend2.default)(this._super(), {
            bgColor: this.bgColor.rgba(),
            color: this.color.rgba(),
            stroke: this.stroke,
            radius: this.radius,
            dasharray: this.dasharray
        });
    },

    /**
     * @inheritdoc
     */
    setPersistentAttributes: function setPersistentAttributes(memento) {
        this._super(memento);

        if (typeof memento.radius !== "undefined") {
            this.setRadius(memento.radius);
        }

        if (typeof memento.bgColor !== "undefined") {
            this.setBackgroundColor(memento.bgColor);
        }

        if (typeof memento.color !== "undefined") {
            this.setColor(memento.color);
        }

        if (typeof memento.stroke !== "undefined") {
            this.setStroke(memento.stroke === null ? 0 : parseFloat(memento.stroke));
        }

        if (typeof memento.dasharray === "string") {
            this.dasharray = memento.dasharray;
        }

        return this;
    }

});

/***/ }),

/***/ "./src/command/Command.js":
/*!********************************!*\
  !*** ./src/command/Command.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Commands are passed around throughout editing. They are used to encapsulate and combine
 * changes to the application's model. An application has a single command stack. Commands must
 * be executed using the command stack rather than directly calling execute.
 * <br>
 * This is required for a generic support for the undo/redo concept within draw2d.<br>
 *
 * @inheritable
 * @author Andreas Herz
 */
_packages2.default.command.Command = Class.extend(
/** @lends draw2d.command.Command.prototype */
{

  NAME: "draw2d.command.Command",

  /**
   * Create a new Command objects which can be execute via the CommandStack.
   *
   * @param {String} label
   */
  init: function init(label) {
    this.label = label;
  },

  /**
   * 
   * Returns a label of the Command. e.g. `move figure`.
   *
   * @returns {String} the label for this command
   **/
  getLabel: function getLabel() {
    return this.label;
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
   * return false. The execution of this Command doesn't modify the model.
   *
   * @returns {Boolean} return try if the command modify the model or make any relevant changes
   **/
  canExecute: function canExecute() {
    return true;
  },

  /**
   * 
   * Execute the command the first time.
   * Sup-classes must implement this method.
   *
   * @template
   **/
  execute: function execute() {},

  /**
   * 
   * Will be called if the user cancel the operation.
   *
   * @template
   **/
  cancel: function cancel() {},

  /**
   * 
   * Undo the command.
   * Sup-classes must implement this method.
   *
   * @template
   **/
  undo: function undo() {},

  /**
   * 
   * Redo the command after the user has undo this command.
   * Sup-classes must implement this method.
   *
   * @template
   **/
  redo: function redo() {}
});

/***/ }),

/***/ "./src/command/CommandAdd.js":
/*!***********************************!*\
  !*** ./src/command/CommandAdd.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Command to add a figure with CommandStack support.
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandAdd = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandAdd.prototype */
{

  NAME: "draw2d.command.CommandAdd",

  /**
   * Create a add command for the given figure.
   *
   * @param {draw2d.Canvas} canvas the canvas to use
   * @param {draw2d.Figure} figure the figure to add
   * @param {Number|draw2d.geo.Point} x the x-coordinate or a complete point where to place the figure
   * @param {Number} [y] the y-coordinate if x is a number and not a complete point
   */
  init: function init(canvas, figure, x, y) {
    this._super(_packages2.default.Configuration.i18n.command.addShape);
    this.figure = figure;
    this.canvas = canvas;
    this.pos = new _packages2.default.geo.Point(x, y);
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
   * return false. The execution of this Command doesn't modify the model.
   *
   * @returns {Boolean} return try if the command modify the model or make any relevant changes
   **/
  canExecute: function canExecute() {
    // we can only add the figure once to the canvas
    return this.figure.getCanvas() === null;
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.canvas.add(this.figure, this.pos.x, this.pos.y);
  },

  /**
   * 
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.execute();
  },

  /**
   * 
   * Undo the command
   *
   **/
  undo: function undo() {
    this.canvas.remove(this.figure);
  }

});

/***/ }),

/***/ "./src/command/CommandAddVertex.js":
/*!*****************************************!*\
  !*** ./src/command/CommandAddVertex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Add a vertex to a polyline or polygon
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandAddVertex = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandAddVertex.prototype */
{

  NAME: "draw2d.command.CommandAddVertex",

  /**
   * Create a new Command objects which add a vertex to a PolyLine / Polygon.
   *
   * @param {draw2d.shape.basic.PolyLine} line the related line
   * @param {Number} index the index where to add
   * @param {Number} x the x coordinate for the new vertex
   * @param {Number} y the y coordinate for the new vertex
   */
  init: function init(line, index, x, y) {
    this._super(_packages2.default.Configuration.i18n.command.addVertex);

    this.line = line;
    this.index = index;
    this.newPoint = new _packages2.default.geo.Point(x, y);
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return true;
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   *
   *
   * Undo the move command
   *
   **/
  undo: function undo() {
    this.line.removeVertexAt(this.index);
  },

  /**
   *
   *
   * Redo the move command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.line.insertVertexAt(this.index, this.newPoint.x, this.newPoint.y);
  }
});

/***/ }),

/***/ "./src/command/CommandAssignFigure.js":
/*!********************************************!*\
  !*** ./src/command/CommandAssignFigure.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Assign a figure to a compiste
 *
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 * @since 4.9.0
 */
_packages2.default.command.CommandAssignFigure = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandAssignFigure.prototype */
{

  NAME: "draw2d.command.CommandAssignFigure",

  /**
   * Create a new Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.Figure} figure the figure to assign
   * @param {draw2d.Figure} composite the composite where the figure should assign
   */
  init: function init(figure, composite) {
    this._super(_packages2.default.Configuration.i18n.command.assignShape);

    this.figure = figure;
    this.composite = composite;
    this.assignedConnections = new _packages2.default.util.ArrayList();
    this.isNode = this.figure instanceof _packages2.default.shape.node.Node;
    this.oldBoundingBox = composite.getBoundingBox();
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return true;
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.composite.assignFigure(this.figure);

    // get all connections of the shape and check if source/target node
    // part of the composite. In this case the connection will be part of
    // the composite as well
    if (this.isNode === true) {
      var connections = this.figure.getConnections();
      var _this = this;
      connections.each(function (i, connection) {
        if (connection.getSource().getParent().getComposite() === _this.composite && connection.getTarget().getParent().getComposite() === _this.composite) {
          if (connection.getComposite() !== _this.composite) {
            _this.assignedConnections.add({ oldComposite: connection.getComposite(), connection: connection });
            _this.composite.assignFigure(connection);
          }
        }
      });
    }
  },

  /**
   *
   *
   * Undo the move command
   *
   **/
  undo: function undo() {
    this.composite.unassignFigure(this.figure);
    this.assignedConnections.each(function (i, entry) {
      if (entry.oldComposite !== null) {
        entry.oldComposite.assignFigure(entry.connection);
      } else {
        entry.connection.getComposite().unassignFigure(entry.connection);
      }
    });
    this.composite.stickFigures = true;
    this.composite.setBoundingBox(this.oldBoundingBox);
    this.composite.stickFigures = false;
  },

  /**
   *
   *
   * Redo the move command after the user has undo this command
   *
   **/
  redo: function redo() {
    var _this2 = this;

    this.composite.setBoundingBox(this.oldBoundingBox);
    this.composite.assignFigure(this.figure);
    this.assignedConnections.each(function (i, entry) {
      return _this2.composite.assignFigure(entry.connection);
    });
  }
});

/***/ }),

/***/ "./src/command/CommandAttr.js":
/*!************************************!*\
  !*** ./src/command/CommandAttr.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *Command to change attributes of a shape with undo/redo support
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandAttr = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandAttr.prototype */
{

  NAME: "draw2d.command.CommandAttr",

  /**
   * Create a new Command objects which provides undo/redo for attributes.
   *
   * @param {draw2d.Figure} figure the figure to handle
   * @param {Object} attributes new attributes to set
   */
  init: function init(figure, newAttributes) {
    var _this = this;

    this._super(_packages2.default.Configuration.i18n.command.changeAttributes);

    this.figure = figure;
    this.newAttributes = newAttributes;
    this.oldAttributes = {};
    // Get the current attributes from the shape before we modify them.
    // Required for undo/redo
    Object.keys(newAttributes).forEach(function (key) {
      _this.oldAttributes[key] = figure.attr(key);
    });
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return true;
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * 
   *
   * Undo the move command
   *
   **/
  undo: function undo() {
    this.figure.attr(this.oldAttributes);
  },

  /**
   * 
   *
   * Redo the move command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.figure.attr(this.newAttributes);
  }
});

/***/ }),

/***/ "./src/command/CommandBoundingBox.js":
/*!*******************************************!*\
  !*** ./src/command/CommandBoundingBox.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Set the bounding box of a figure with undo/redo support
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandBoundingBox = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandResize.prototype */
{

  NAME: "draw2d.command.CommandResize",

  /**
   * Create a new resize Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.Figure} figure the figure to resize
   * @param {draw2d.geo.Rectangle} boundingBox the new bounding box of the figure
   */
  init: function init(figure, boundingBox) {
    this._super(_packages2.default.Configuration.i18n.command.resizeShape);
    this.figure = figure;
    this.oldBoundingBox = this.figure.getBoundingBox();
    this.newBoundingBox = boundingBox;
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return !this.oldBoundingBox.equals(this.newBoundingBox);
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   *
   * Undo the command
   *
   **/
  undo: function undo() {
    this.figure.setBoundingBox(this.oldBoundingBox);
  },

  /**
   *
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.figure.setBoundingBox(this.newBoundingBox);
  }
});

/***/ }),

/***/ "./src/command/CommandCollection.js":
/*!******************************************!*\
  !*** ./src/command/CommandCollection.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A CommandCollection works as a single command. You can add more than one
 * Command to this CommandCollection and execute/undo them onto the CommandStack as a
 * single Command.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandCollection = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandCollection.prototype */
{

  NAME: "draw2d.command.CommandCollection",

  /**
   * Create a new CommandConnect objects which can be execute via the CommandStack.
   *
   * @param {String} [commandLabel] the label to show on the command stack for the undo/redo operation
   */
  init: function init(commandLabel) {
    this._super(typeof commandLabel === 'undefined' ? _packages2.default.Configuration.i18n.command.collection : commandLabel);

    this.commands = new _packages2.default.util.ArrayList();
  },

  /**
   *
   * Returns a label of the Command. e.g. "move figure".
   *
   * @returns {String} the label for this command
   **/
  getLabel: function getLabel() {
    //return the label of the one and only command
    //
    if (this.commands.getSize() === 1) {
      return this.commands.first().getLabel();
    }

    // return a common label if all commands have the same label.
    //
    if (this.commands.getSize() > 1) {
      var labels = this.commands.clone().map(function (e) {
        return e.getLabel();
      });
      labels.unique();
      if (labels.getSize() === 1) {
        return labels.first();
      }
    }

    // return the all purpose label.
    return this._super();
  },

  /**
   *
   * Add a command to the collection.
   *
   * @param {draw2d.command.Command} command
   */
  add: function add(command) {
    this.commands.add(command);
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
   * return false. The execution of this Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // We ask all cmd's if they make any changes.
    // Keep in mind: the command will be execute if at least ONE command return [true]!!!!
    // doesn't matter if the other commands return [false].
    // The method should be renamed into: modifiesTheModel()....design flaw.
    var canExec = false;
    this.commands.each(function (i, cmd) {
      canExec = canExec || cmd.canExecute();
    });
    return canExec;
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.commands.each(function (i, cmd) {
      cmd.execute();
    });
  },

  /**
   *
   * Redo the command after the user has undo this command.
   *
   **/
  redo: function redo() {
    this.commands.each(function (i, cmd) {
      cmd.redo();
    });
  },

  /**
   *
   * Undo the command.
   *
   **/
  undo: function undo() {
    // execute the undo operation in reverse direction.

    this.commands.reverse();
    this.commands.each(function (i, cmd) {
      cmd.undo();
    });
    this.commands.reverse();
  }
});

/***/ }),

/***/ "./src/command/CommandConnect.js":
/*!***************************************!*\
  !*** ./src/command/CommandConnect.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Connects two ports with a connection.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandConnect = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandConnect.prototype */
{

  NAME: "draw2d.command.CommandConnect",

  /**
   * Create a new CommandConnect objects which can be execute via the CommandStack.
   *
   * @param {draw2d.Port} source the source port for the connection to create
   * @param {draw2d.Port} target the target port for the connection to create
   * @param {draw2d.Port} [dropTarget] the port who has initiate the connection creation. mainly the drop target
   */
  init: function init(source, target, dropTarget) {
    this._super(_packages2.default.Configuration.i18n.command.connectPorts);
    this.canvas = target.getCanvas();
    this.source = source;
    this.target = target;
    this.connection = null;
    this.dropTarget = dropTarget; // optional
  },

  /**
   *
   * set the connection to use. called by the ConnectionCreatePolicy
   */
  setConnection: function setConnection(connection) {
    this.connection = connection;
  },

  /**
   *
   * Returns the fresh created connection if available. Used in the
   * ClickConnectionCreatePolicy to customize the router and vertices.
   *
   * @returns {null|draw2d.Connection}
   * @since 6.1.0
   */
  getConnection: function getConnection() {
    return this.connection;
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    var _this = this;

    var optionalCallback = function optionalCallback(conn) {
      _this.connection = conn;
      _this.connection.setSource(_this.source);
      _this.connection.setTarget(_this.target);
      _this.canvas.add(_this.connection);
    };

    // the createConnection must return either a connection or "undefined". If the method return "undefined"
    // the asynch callback must be called. Usefull if the createConnection shows a selection dialog
    //
    if (this.connection === null) {
      // deprecated call!!!!
      //
      var result = _packages2.default.Configuration.factory.createConnection(this.source, this.target, optionalCallback, this.dropTarget);
      debugger;
      // will be handled by the optional callback
      if (typeof result === "undefined") {
        return;
      }

      this.connection = result;
    }

    optionalCallback(this.connection);
  },

  /**
   *
   * Redo the command after the user has undo this command.
   *
   **/
  redo: function redo() {
    this.canvas.add(this.connection);
    this.connection.reconnect();
  },

  /**
   *
   * Undo the command.
   *
   **/
  undo: function undo() {
    this.canvas.remove(this.connection);
  }
});

/***/ }),

/***/ "./src/command/CommandDelete.js":
/*!**************************************!*\
  !*** ./src/command/CommandDelete.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Command to remove a figure with CommandStack support.
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandDelete = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandDelete.prototype */
{
  NAME: "draw2d.command.CommandDelete",

  /**
   * Create a delete command for the given figure.
   *
   * @param {draw2d.Figure} figure
   */
  init: function init(figure) {
    this._super(_packages2.default.Configuration.i18n.command.deleteShape);

    this.parent = figure.getParent();
    this.figure = figure;
    this.canvas = figure.getCanvas();
    this.connections = null;
    this.removedParentEntry = null; // can be null if the figure didn't have any parent shape assigned
    this.indexOfChild = -1;
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
   * return false. The execution of this Command doesn't modify the model.
   *
   * @returns {Boolean} return try if the command modify the model or make any relevant changes
   **/
  canExecute: function canExecute() {
    // we can only delete the figure if its part of the canvas.
    return this.figure.getCanvas() !== null;
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * 
   * Undo the command
   *
   **/
  undo: function undo() {
    if (this.parent !== null) {
      this.parent.add(this.removedParentEntry.figure, this.removedParentEntry.locator, this.indexOfChild);
      this.canvas.setCurrentSelection(this.parent);
    } else {
      this.canvas.add(this.figure);
      this.canvas.setCurrentSelection(this.figure);
    }

    if (this.figure instanceof _packages2.default.Connection) {
      this.figure.reconnect();
    }

    for (var i = 0; i < this.connections.getSize(); ++i) {
      this.canvas.add(this.connections.get(i));
      this.connections.get(i).reconnect();
    }
  },

  /**
   * 
   *
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.canvas.setCurrentSelection(null);

    // Collect all connections that are bounded to the figure to delete. This connections
    // must be deleted too.
    //
    if (this.connections === null) {
      if (this.figure instanceof _packages2.default.shape.node.Node) {
        this.connections = this.figure.getConnections();
      } else {
        this.connections = new _packages2.default.util.ArrayList();
      }
    }

    // already done in the canvas.remove(..) method
    //    if(this.figure instanceof draw2d.Connection){
    //        this.figure.disconnect();
    //    }


    // remove all connections
    //
    for (var i = 0; i < this.connections.getSize(); ++i) {
      this.canvas.remove(this.connections.get(i));
    }

    // remove this figure from the parent
    //
    if (this.parent !== null) {
      // determine the index of the child before remove
      this.indexOfChild = this.parent.getChildren().indexOf(this.figure);
      this.removedParentEntry = this.parent.remove(this.figure);
    }
    // or from the canvas
    else {
        this.canvas.remove(this.figure);
      }
  }
});

/***/ }),

/***/ "./src/command/CommandDeleteGroup.js":
/*!*******************************************!*\
  !*** ./src/command/CommandDeleteGroup.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Command to remove a group with all related children.
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandDeleteGroup = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandDeleteGroup.prototype */
{

  NAME: "draw2d.command.CommandDeleteGroup",

  /**
   * Create a delete command for the given figure.
   *
   * @param {draw2d.shape.composite.Group} group
   */
  init: function init(group) {
    this._super(_packages2.default.Configuration.i18n.command.deleteShape);

    this.parent = group.getParent();
    this.group = group;
    this.canvas = group.getCanvas();
    this.batchDelete = null;
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
   * return false. The execution of this Command doesn't modify the model.
   *
   * @returns {Boolean} return try if the command modify the model or make any relevant changes
   **/
  canExecute: function canExecute() {
    // we can only delete the shape if a children can be deleted
    //
    var children = this.group.getAssignedFigures();
    for (var i = 0; i < children.getSize(); i++) {
      if (children.get(i).isDeleteable() === false) {
        return false;
      }
    }

    // we can only delete the figure if its part of the canvas.
    return this.group.getCanvas() !== null;
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * 
   * Undo the command
   *
   **/
  undo: function undo() {
    this.batchDelete.undo();
    this.canvas.setCurrentSelection(this.group);
  },

  /**
   * 
   *
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    if (this.batchDelete === null) {
      this.batchDelete = new _packages2.default.command.CommandCollection();

      // remove the assignment of the children to the group before we delete the group
      //
      this.batchDelete.add(new _packages2.default.command.CommandUngroup(this.canvas, this.group));

      // add the delete command of the children to the batch
      //
      var children = this.group.getAssignedFigures();
      for (var i = 0; i < children.getSize(); i++) {
        var child = children.get(i);
        // request a delete Command from the child instead of create one by my own. May the child
        // provides its own implementation
        var cmd = child.createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.DELETE));
        this.batchDelete.add(cmd);
      }
    }

    this.batchDelete.execute();
  }
});

/***/ }),

/***/ "./src/command/CommandGroup.js":
/*!*************************************!*\
  !*** ./src/command/CommandGroup.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Command to group a given set of figures
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandGroup = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandGroup.prototype */
{

  NAME: "draw2d.command.CommandGroup",

  /**
   * Create a group command for the given figure.
   *
   * @param {draw2d.util.ArrayList} figures the figures to group
   */
  init: function init(canvas, figures) {
    this._super(_packages2.default.Configuration.i18n.command.groupShapes);
    if (figures instanceof _packages2.default.Selection) {
      this.figures = figures.getAll();
    } else {
      this.figures = figures;
    }

    // figures which already part of an non "Group" composite will be removed from the set.
    // It is not possible to assign a figure to two different composites.
    //
    this.figures.grep(function (figure) {
      return figure.getComposite() === null;
    });

    this.canvas = canvas;
    this.group = new _packages2.default.shape.composite.Group();
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
   * return false. The execution of this Command doesn't modify the model.
   *
   * @returns {Boolean} return try if the command modify the model or make any relevant changes
   **/
  canExecute: function canExecute() {
    return !this.figures.isEmpty();
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * 
   * Undo the command
   *
   **/
  undo: function undo() {
    var _this = this;
    this.figures.each(function (i, figure) {
      _this.group.unassignFigure(figure);
    });

    this.canvas.remove(this.group);
    this.canvas.setCurrentSelection(this.figures);
  },

  /**
   * 
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    var _this = this;
    this.figures.each(function (i, figure) {
      _this.group.assignFigure(figure);
    });

    this.canvas.add(this.group);
    this.canvas.setCurrentSelection(this.group);
  }
});

/***/ }),

/***/ "./src/command/CommandMove.js":
/*!************************************!*\
  !*** ./src/command/CommandMove.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Command for the movement of figures.
 *
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandMove = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandMove.prototype */
{
  NAME: "draw2d.command.CommandMove",

  /**
   * Create a new Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.Figure} figure the figure to move
   * @param {Number} [x] the current x position
   * @param {Number} [y] the current y position
   */
  init: function init(figure, x, y) {
    this._super(_packages2.default.Configuration.i18n.command.moveShape);
    this.figure = figure;
    if (typeof x === "undefined") {
      this.oldX = figure.getX();
      this.oldY = figure.getY();
    } else {
      this.oldX = x;
      this.oldY = y;
    }
  },

  /**
   * 
   * Set the initial position of the element
   *
   * @param {Number} x the new initial x position
   * @param {Number} y the new initial y position
   **/
  setStartPosition: function setStartPosition(x, y) {
    this.oldX = x;
    this.oldY = y;
  },

  /**
   * 
   * Set the target/final position of the figure move command.
   *
   * @param {Number} x the new x position
   * @param {Number} y the new y position
   **/
  setPosition: function setPosition(x, y) {
    this.newX = x;
    this.newY = y;
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return this.newX !== this.oldX || this.newY !== this.oldY;
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * 
   *
   * Undo the move command
   *
   **/
  undo: function undo() {
    this.figure.setPosition(this.oldX, this.oldY);
  },

  /**
   * 
   *
   * Redo the move command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.figure.setPosition(this.newX, this.newY);
  }
});

/***/ }),

/***/ "./src/command/CommandMoveConnection.js":
/*!**********************************************!*\
  !*** ./src/command/CommandMoveConnection.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Command for the movement of figures.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandMoveConnection = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandMoveConnection.prototype */
{

  NAME: "draw2d.command.CommandMoveConnection",

  /**
   * Create a new Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.Connection} figure the connection to move
   */
  init: function init(figure) {
    this._super(_packages2.default.Configuration.i18n.command.moveLine);
    this.line = figure;
    this.dx = 0;
    this.dy = 0;
  },

  /**
   * 
   * set the offset of the line translation
   *
   * @param {Number} dx
   * @param {Number} dy
   */
  setTranslation: function setTranslation(dx, dy) {
    this.dx = dx;
    this.dy = dy;
  },

  /**
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return this.dx !== 0 && this.dy !== 0;
  },

  /**
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * Undo the command
   *
   **/
  undo: function undo() {
    var _this = this;
    this.line.getVertices().each(function (i, e) {
      e.translate(-_this.dx, -_this.dy);
    });
    this.line.svgPathString = null;
    // required to update resize handles and the painting of the line
    this.line.setPosition(this.line.getStartPosition());
  },

  /**
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    var _this = this;
    this.line.getVertices().each(function (i, e) {
      e.translate(_this.dx, _this.dy);
    });
    this.line.svgPathString = null;

    // required to update resize handles and the painting of the line
    this.line.setPosition(this.line.getStartPosition());
  }
});

/***/ }),

/***/ "./src/command/CommandMoveLine.js":
/*!****************************************!*\
  !*** ./src/command/CommandMoveLine.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Command for the movement of figures.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandMoveLine = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandMoveLine.prototype */
{

  NAME: "draw2d.command.CommandMoveLine",

  /**
   * Create a new Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.shape.basic.Line} figure the line to move
   */
  init: function init(figure) {
    this._super(_packages2.default.Configuration.i18n.command.moveLine);
    this.line = figure;
    this.dx = 0;
    this.dy = 0;
  },

  /**
   *
   * set the offset of the line translation
   *
   * @param {Number} dx
   * @param {Number} dy
   */
  setTranslation: function setTranslation(dx, dy) {
    this.dx = dx;
    this.dy = dy;
  },

  /**
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return this.dx !== 0 && this.dy !== 0;
  },

  /**
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * Undo the command
   *
   **/
  undo: function undo() {
    var _this = this;
    this.line.getVertices().each(function (i, e) {
      e.translate(-_this.dx, -_this.dy);
    });
    this.line.svgPathString = null;
    // required to update resize handles and the painting of the line
    this.line.setPosition(this.line.getStartPosition());
  },

  /**
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    var _this = this;
    this.line.getVertices().each(function (i, e) {
      e.translate(_this.dx, _this.dy);
    });
    this.line.svgPathString = null;

    // required to update resize handles and the painting of the line
    this.line.setPosition(this.line.getStartPosition());
  }
});

/***/ }),

/***/ "./src/command/CommandMoveVertex.js":
/*!******************************************!*\
  !*** ./src/command/CommandMoveVertex.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Command for the vertex movement of a polyline/polygon.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandMoveVertex = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandMoveVertex.prototype */
{

  NAME: "draw2d.command.CommandMoveVertex",

  /**
   * Create a new Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.shape.basic.PolyLine} line the related line
   */
  init: function init(line) {
    this._super(_packages2.default.Configuration.i18n.command.moveVertex);

    this.line = line;
    this.index = -1;
    this.newPoint = null;
  },

  /**
   * 
   * Set the index of the vertex of the polyline/polygon to modify.
   *
   * @param {Number} index the related index of the vertex
   **/
  setIndex: function setIndex(index) {
    this.index = index;
    this.origPoint = this.line.getVertices().get(this.index).clone();
  },

  updatePosition: function updatePosition(x, y) {
    this.newPoint = new _packages2.default.geo.Point(x, y);
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return this.index !== -1 && this.newPoint !== null;
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * 
   *
   * Undo the move command
   *
   **/
  undo: function undo() {
    this.line.setVertex(this.index, this.origPoint.x, this.origPoint.y);
  },

  /**
   * 
   *
   * Redo the move command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.line.setVertex(this.index, this.newPoint.x, this.newPoint.y);
  }
});

/***/ }),

/***/ "./src/command/CommandMoveVertices.js":
/*!********************************************!*\
  !*** ./src/command/CommandMoveVertices.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Command for the vertices movement of a polyline/polygon.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandMoveVertices = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandMoveVertices.prototype */
{

  NAME: "draw2d.command.CommandMoveVertices",

  /**
   * Create a new Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.shape.basic.PolyLine} line the related line
   */
  init: function init(line) {
    this._super(_packages2.default.Configuration.i18n.command.moveVertices);

    this.line = line;
    this.oldVertices = line.getVertices().clone(true);
    this.newVertices = null;
  },

  updateVertices: function updateVertices(newVertices) {
    this.newVertices = newVertices;
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return this.newVertices !== null;
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   *
   *
   * Undo the move command
   *
   **/
  undo: function undo() {
    this.line.setVertices(this.oldVertices);
  },

  /**
   *
   *
   * Redo the move command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.line.setVertices(this.newVertices);
  }
});

/***/ }),

/***/ "./src/command/CommandReconnect.js":
/*!*****************************************!*\
  !*** ./src/command/CommandReconnect.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Reconnects two ports. This command is used during the DragDrop operation of a draw2d.Connection.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandReconnect = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandReconnect.prototype */
{

  NAME: "draw2d.command.CommandReconnect",

  /**
   * Create a new Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.Connection} conn the related Connection which is currently in the drag&drop operation
   */
  init: function init(conn) {
    this._super(_packages2.default.Configuration.i18n.command.connectPorts);
    this.con = conn;
    this.oldSourcePort = conn.getSource();
    this.oldTargetPort = conn.getTarget();
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return true;
  },

  /**
   *
   * The new ports to use during the execute of this command.
   *
   * @param {draw2d.Port} source
   * @param {draw2d.Port} target
   */
  setNewPorts: function setNewPorts(source, target) {
    this.newSourcePort = source;
    this.newTargetPort = target;
  },

  setIndex: function setIndex(index) {
    // do nothing....but method is required for LineResizeHandle
    // With this common interface the ResizeHandle can handle Lines and Connections
    // with the same code
  },

  /**
   * compatibily method to the CommandMoveVertex to handle Line and Connections
   * transparent in the ResizeHandles
   *
   * @param x
   * @param y
   */
  updatePosition: function updatePosition(x, y) {
    // do nothing....but method is required for LineResizeHandle
    // With this common interface the ResizeHandle can handle Lines and Connections
    // with the same code
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  cancel: function cancel() {
    this.con.setSource(this.oldSourcePort);
    this.con.setTarget(this.oldTargetPort);

    // force a routing of the connection and DON'T set the old reouter again because this reset all manual added
    // vertices
    this.con.routingRequired = true;
    this.con.repaint();
  },

  /**
   *
   * Undo the command
   *
   **/
  undo: function undo() {
    this.con.setSource(this.oldSourcePort);
    this.con.setTarget(this.oldTargetPort);
    // force a routing of the connection and DON'T set the old reouter again because this reset all manual added
    // vertices
    this.con.routingRequired = true;
    this.con.repaint();
  },

  /**
   *
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.con.setSource(this.newSourcePort);
    this.con.setTarget(this.newTargetPort);
    // force a routing of the connection and DON'T set the old reouter again because this reset all manual added
    // vertices
    this.con.routingRequired = true;
    this.con.repaint();
  }

});

/***/ }),

/***/ "./src/command/CommandRemoveVertex.js":
/*!********************************************!*\
  !*** ./src/command/CommandRemoveVertex.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Remove a vertex from a polyline or polygon
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandRemoveVertex = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandRemoveVertex.prototype */
{

  NAME: "draw2d.command.CommandRemoveVertex",

  /**
   * Create a new Command objects which add a vertex to a PloyLine.
   *
   * @param {draw2d.shape.basic.PolyLine} line the related line
   * @param {Number} index the index where to add
   */
  init: function init(line, index) {
    this._super(_packages2.default.Configuration.i18n.command.deleteVertex);

    this.line = line;
    this.index = index;
    this.oldPoint = line.getVertices().get(index).clone();
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return true;
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   *
   *
   * Undo the move command
   *
   **/
  undo: function undo() {
    this.line.insertVertexAt(this.index, this.oldPoint.x, this.oldPoint.y);
  },

  /**
   *
   *
   * Redo the move command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.line.removeVertexAt(this.index);
  }
});

/***/ }),

/***/ "./src/command/CommandReplaceVertices.js":
/*!***********************************************!*\
  !*** ./src/command/CommandReplaceVertices.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Replace the vertices of a polyline.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandReplaceVertices = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandReplaceVertices.prototype */
{

  NAME: "draw2d.command.CommandReplaceVertices",

  /**
   * Create a new Command objects which add a segment to a PolyLine / Polygon.
   *
   * @param {draw2d.shape.basic.PolyLine} line the related line
   * @param {draw2d.util.ArrayList} originalVertices the original vertices of the polyline
   * @param {draw2d.util.ArrayList} newVertices the new vertices of the polyline
   */
  init: function init(line, originalVertices, newVertices) {
    this._super(_packages2.default.Configuration.i18n.command.addSegment);

    this.line = line;
    this.originalVertices = originalVertices;
    this.newVertices = newVertices;
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return true;
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * 
   *
   * Undo the move command
   *
   **/
  undo: function undo() {
    this.line.setVertices(this.originalVertices);
  },

  /**
   * 
   *
   * Redo the move command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.line.setVertices(this.newVertices);
  }
});

/***/ }),

/***/ "./src/command/CommandResize.js":
/*!**************************************!*\
  !*** ./src/command/CommandResize.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Resize command for figures. Can be execute/undo/redo via a CommandStack.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandResize = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandResize.prototype */
{

  NAME: "draw2d.command.CommandResize",

  /**
   * Create a new resize Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.Figure} figure the figure to resize
   * @param {Number} [width] the current width
   * @param {Number} [height] the current height
   */
  init: function init(figure, width, height) {
    this._super(_packages2.default.Configuration.i18n.command.resizeShape);
    this.figure = figure;

    if (typeof width === "undefined") {
      this.oldWidth = figure.getWidth();
      this.oldHeight = figure.getHeight();
    } else {
      this.oldWidth = width;
      this.oldHeight = height;
    }
  },

  /**
   * 
   * Set the new dimension of the element.
   *
   * @param {Number} width the new width.
   * @param {Number} height the new height of the element.
   **/
  setDimension: function setDimension(width, height) {
    this.newWidth = width | 0;
    this.newHeight = height | 0;
  },

  /**
   * 
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return this.newWidth !== this.oldWidth || this.newHeight !== this.oldHeight;
  },

  /**
   * 
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   * 
   * Undo the command
   *
   **/
  undo: function undo() {
    this.figure.setDimension(this.oldWidth, this.oldHeight);
  },

  /**
   * 
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.figure.setDimension(this.newWidth, this.newHeight);
  }
});

/***/ }),

/***/ "./src/command/CommandRotate.js":
/*!**************************************!*\
  !*** ./src/command/CommandRotate.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Set the rotation angle of the given figure
 *
 * @since 4.4.1
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.command.Command
 */
_packages2.default.command.CommandRotate = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandRotate.prototype */
{

  NAME: "draw2d.command.CommandRotate",

  /**
   * Create a new resize Command objects which can be execute via the CommandStack.
   *
   * @param {draw2d.Figure} figure the figure to resize
   * @param {Number} angle the angle to rotate
   */
  init: function init(figure, angle) {
    this._super(_packages2.default.Configuration.i18n.command.rotateShape);
    this.figure = figure;

    this.oldAngle = figure.getRotationAngle();
    this.newAngle = angle;
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modify the model. A CommandMove with [startX,startX] == [endX,endY] should
   * return false. <br>
   * the execution of the Command doesn't modify the model.
   *
   * @returns {Boolean}
   **/
  canExecute: function canExecute() {
    // return false if we doesn't modify the model => NOP Command
    return this.oldAngle !== this.newAngle;
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   *
   * Undo the command
   *
   **/
  undo: function undo() {
    this.rotate(this.oldAngle);
  },

  /**
   *
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    this.rotate(this.newAngle);
  },

  rotate: function rotate(angle) {
    var w = this.figure.getWidth();
    var h = this.figure.getHeight();

    this.figure.setRotationAngle(angle);

    this.figure.setDimension(h, w);

    this.figure.portRelayoutRequired = true;
  }
});

/***/ }),

/***/ "./src/command/CommandStack.js":
/*!*************************************!*\
  !*** ./src/command/CommandStack.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * An implementation of a command stack. A stack manages the executing, undoing, and redoing of Commands. Executed
 * commands are pushed onto a a stack for undoing later. Commands which are undone are pushed onto a redo stack.
 * Whenever a new command is executed, the redo stack is flushed.
 *
 * You can retrieve the current used CommandStack just by calling <code>canvas.getCommandStack()</code>
 *
 */
_packages2.default.command.CommandStack = Class.extend(
/** @lends draw2d.command.CommandStack.prototype */
{

  NAME: "draw2d.command.CommandStack",

  /**
   * Create a new CommandStack objects which can be execute via the CommandStack.
   *
   */
  init: function init() {
    this.undostack = [];
    this.redostack = [];
    this.maxundo = 50;
    this.transactionCommand = null;
    this.eventListeners = new _packages2.default.util.ArrayList();
  },

  /**
   *
   * Set the maximal undo stack size. Entries will be remove if the max. stack
   * size has been reached.
   *
   * @param {Number} count The maximal undo stack size.
   * @returns {this}
   **/
  setUndoLimit: function setUndoLimit(count) {
    this.maxundo = count;

    return this;
  },

  /**
   *
   * Remove the undo / redo history. This is useful if the user has been save the
   * document.
   *
   * @returns {this}
   **/
  markSaveLocation: function markSaveLocation() {
    this.undostack = [];
    this.redostack = [];

    // fire an empty command to inform all listener that the stack has been changed
    this.notifyListeners(new _packages2.default.command.Command(), _packages2.default.command.CommandStack.POST_EXECUTE);

    return this;
  },

  /**
   *
   *
   * Executes the specified Command if possible. Prior to executing the command, a
   * draw2d.command.CommandStackEvent for {@link #PRE_EXECUTE} will be fired to event listeners.
   * Similarly, after attempting to execute the command, an event for {@link #POST_EXECUTE}
   * will be fired.
   *
   * @param {draw2d.command.Command} command The command to execute.
   * @returns {this}
   **/
  execute: function execute(command) {
    if (typeof command === "undefined") throw "Missing parameter [command] for method call CommandStack.execute";

    // nothing to do
    if (command === null) return this; //silently

    // return if the command can't execute or it doesn't change the model
    // => Empty command
    if (command.canExecute() === false) return this;

    // A command stack transaction is open.
    // The execution will be postpone until the transaction will commit
    //
    if (this.transactionCommand !== null) {
      this.transactionCommand.add(command);
      return this;
    }

    this.notifyListeners(command, _packages2.default.command.CommandStack.PRE_EXECUTE, "PRE_EXECUTE");

    this.undostack.push(command);
    command.execute();

    // cleanup the redo stack if the user execute a new command.
    // I think this will create a "clean" behaviour of the unde/redo mechanism.
    //
    this.redostack = [];

    // monitor only the max. undo stack size
    //
    if (this.undostack.length > this.maxundo) {
      this.undostack = this.undostack.slice(this.undostack.length - this.maxundo);
    }
    this.notifyListeners(command, _packages2.default.command.CommandStack.POST_EXECUTE, "POST_EXECUTE");

    return this;
  },

  /**
   *
   * Opens a transaction for further multiple commands. If you execute a command all
   * {@ #execute} calls will be ignored until you commit the current transaction.
   *
   * @param {String} [commandLabel] the label to show for the undo/redo operation
   * @returns {this}
   * @since 4.0.0
   */
  startTransaction: function startTransaction(commandLabel) {
    if (this.transactionCommand !== null) {
      debugger;
      throw "CommandStack is already within transactional mode. Don't call 'startTransaction";
    }

    this.transactionCommand = new _packages2.default.command.CommandCollection(commandLabel);

    return this;
  },

  /**
   *
   * Returns true if the Command Stack has an open transaction.
   * You can start or stop a transaction with `startTransaction`and `commitTransaction`.
   *
   * A transaction is one undo/redo operation.
   *
   * @returns {Boolean}
   */
  isInTransaction: function isInTransaction() {
    return this.transactionCommand !== null;
  },

  /**
   *
   * Commit the running transaction. All commands between the start/end of a transaction
   * can be undo/redo in a single step.
   *
   * @since 4.0.0
   * @returns {this}
   */
  commitTransaction: function commitTransaction() {
    if (this.transactionCommand === null) {
      return this; //silently
    }

    var cmd = this.transactionCommand;
    this.transactionCommand = null;
    // we can drop the CommandCollection if the collection contains only one command.
    if (cmd.commands.getSize() === 1) {
      this.execute(cmd.commands.first());
    } else {
      this.execute(cmd);
    }

    return this;
  },

  /**
   *
   * Undo on command from the stack and store them on the redo command stack.
   * @returns {this}
   **/
  undo: function undo() {
    var command = this.undostack.pop();
    if (command) {
      this.notifyListeners(command, _packages2.default.command.CommandStack.PRE_UNDO);
      this.redostack.push(command);
      command.undo();
      this.notifyListeners(command, _packages2.default.command.CommandStack.POST_UNDO);
    }

    return this;
  },

  /**
   *
   * Redo a command after the user has undo a command
   *
   * @returns {this}
   **/
  redo: function redo() {
    var command = this.redostack.pop();

    if (command) {
      this.notifyListeners(command, _packages2.default.command.CommandStack.PRE_REDO);
      this.undostack.push(command);
      command.redo();
      this.notifyListeners(command, _packages2.default.command.CommandStack.POST_REDO);
    }

    return this;
  },

  /**
   *
   * Return the label of the next REDO command.
   *
   * @returns {String}
   **/
  getRedoLabel: function getRedoLabel() {
    if (this.redostack.length === 0) return "";

    var command = this.redostack[this.redostack.length - 1];

    if (command) {
      return command.getLabel();
    }
    return "";
  },

  /**
   *
   * Return the label of the next UNDO command.
   *
   * @returns {String}
   **/
  getUndoLabel: function getUndoLabel() {
    if (this.undostack.length === 0) return "";

    var command = this.undostack[this.undostack.length - 1];

    if (command) {
      return command.getLabel();
    }
    return "";
  },

  /**
   *
   * Indicates whenever a REDO is possible.
   *
   * @returns {Boolean} <code>true</code> if it is appropriate to call {@link #redo()}.
   */
  canRedo: function canRedo() {
    return this.redostack.length > 0;
  },

  /**
   *
   * indicator whenever a undo is possible.
   *
   * @returns {Boolean} <code>true</code> if {@link #undo()} can be called
   **/
  canUndo: function canUndo() {
    return this.undostack.length > 0;
  },

  /**
   *
   * Adds a listener to the command stack, which will be notified whenever a command has been processed on the stack.
   * @deprecated use on/off to register events
   * @param {draw2d.command.CommandStackEventListener|Function} listener the listener to add.
   * @returns {this}
   */
  addEventListener: function addEventListener(listener) {
    return this.on("change", listener);
  },
  /**
   * Adds a listener to the command stack, which will be notified whenever a command has been processed on the stack.
   *
   * @param event
   * @param func
   * @returns {this}
   */
  on: function on(event, listener) {
    if (event !== "change") throw "only event of kind 'change' is supported";

    if (listener instanceof _packages2.default.command.CommandStackEventListener) {
      this.eventListeners.add(listener);
    } else if (typeof listener.stackChanged === "function") {
      this.eventListeners.add(listener);
    } else if (typeof listener === "function") {
      this.eventListeners.add({ stackChanged: listener });
    } else {
      throw "Object doesn't implement required callback interface [draw2d.command.CommandStackListener]";
    }

    return this;
  },

  /**
   *
   * Removes a listener from the command stack.
   *
   * @deprecated use on/off to register events
   * @param {draw2d.command.CommandStackEventListener} listener the listener to remove.
   * @returns {this}
   */
  removeEventListener: function removeEventListener(listener) {
    this.off(listener);

    return this;
  },

  /**
   *
    * @param listener
   * @returns {this}
   */
  off: function off(listener) {
    this.eventListeners.grep(function (entry) {
      return entry === listener || entry.stackChanged === listener;
    });
    /*
    let size = this.eventListeners.getSize()
    for (let i = 0; i < size; i++) {
      let entry = this.eventListeners.get(i)
      if (entry === listener || entry.stackChanged === listener) {
        this.eventListeners.remove(entry)
        return
      }
    }
    */
    return this;
  },

  /**
   *
   * Notifies command stack event listeners that the command stack has changed to the
   * specified state.
   *
   * @param {draw2d.command.Command} command the command
   * @param {Number} state the current stack state
   * @private
   **/
  notifyListeners: function notifyListeners(command, state, action) {
    var event = new _packages2.default.command.CommandStackEvent(this, command, state, action);
    var size = this.eventListeners.getSize();

    for (var i = 0; i < size; i++) {
      this.eventListeners.get(i).stackChanged(event);
    }
  }
});

//  Constant indicating notification prior to executing a command (value is 1).
_packages2.default.command.CommandStack.PRE_EXECUTE = 1;
//  Constant indicating notification prior to redoing a command (value is 2).
_packages2.default.command.CommandStack.PRE_REDO = 2;
//  Constant indicating notification prior to undoing a command (value is 4).
_packages2.default.command.CommandStack.PRE_UNDO = 4;
//   Constant indicating notification after a command has been executed (value is 8).
_packages2.default.command.CommandStack.POST_EXECUTE = 8;
//  Constant indicating notification after a command has been redone (value is 16).
_packages2.default.command.CommandStack.POST_REDO = 16;
//  Constant indicating notification after a command has been undone (value is 32).
_packages2.default.command.CommandStack.POST_UNDO = 32;
//  Constant indicating notification after the stack has been (re)init (value is 64).
_packages2.default.command.CommandStack.POST_INIT = 64;

_packages2.default.command.CommandStack.POST_MASK = _packages2.default.command.CommandStack.POST_EXECUTE | _packages2.default.command.CommandStack.POST_UNDO | _packages2.default.command.CommandStack.POST_REDO;
_packages2.default.command.CommandStack.PRE_MASK = _packages2.default.command.CommandStack.PRE_EXECUTE | _packages2.default.command.CommandStack.PRE_UNDO | _packages2.default.command.CommandStack.PRE_REDO;

/***/ }),

/***/ "./src/command/CommandStackEvent.js":
/*!******************************************!*\
  !*** ./src/command/CommandStackEvent.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Event class which will be fired for every CommandStack operation. Required for CommandStackListener.
 */
_packages2.default.command.CommandStackEvent = Class.extend(
/** @lends draw2d.command.CommandStackEvent.prototype */
{

  NAME: "draw2d.command.CommandStackEvent",

  /**
   * Create a new CommandStack objects which can be execute via the CommandStack.
   *
   * @param {draw2d.command.Command} command the related command
   * @param {Number} details the current state of the command execution
   *
   */
  init: function init(stack, command, details, action) {
    this.stack = stack;
    this.command = command;
    this.details = details; // deprecated
    this.action = action;
  },

  /**
   *
   * Return the corresponding stack of the event.
   *
   * @returns {draw2d.command.CommandStack}
   **/
  getStack: function getStack() {
    return this.stack;
  },

  /**
   *
   * Returns null or a Command if a command is relevant to the current event.
   *
   * @returns {draw2d.command.Command}
   **/
  getCommand: function getCommand() {
    return this.command;
  },

  /**
   *
   * Returns an integer identifying the type of event which has occurred.
   * Defined by {@link draw2d.command.CommandStack}.
   *
   * @returns {Number}
   **/
  getDetails: function getDetails() {
    return this.details;
  },

  /**
   *
   * Returns true if this event is fired after the stack having changed.
   *
   * @returns {Boolean} true if post-change event
   **/
  isPostChangeEvent: function isPostChangeEvent() {
    return 0 !== (this.getDetails() & _packages2.default.command.CommandStack.POST_MASK);
  },

  /**
   *
   * Returns true if this event is fired prior to the stack changing.
   *
   * @returns {Boolean} true if pre-change event
   **/
  isPreChangeEvent: function isPreChangeEvent() {
    return 0 !== (this.getDetails() & _packages2.default.command.CommandStack.PRE_MASK);
  }
});

/***/ }),

/***/ "./src/command/CommandStackEventListener.js":
/*!**************************************************!*\
  !*** ./src/command/CommandStackEventListener.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Event class which will be fired for every CommandStack operation. Required for CommandStackListener.
 * @author Andreas Herz
 */

_packages2.default.command.CommandStackEventListener = Class.extend(
/** @lends draw2d.command.CommandStackEventListener.prototype */
{

  NAME: "draw2d.command.CommandStackEventListener",

  /**
   * Creates a new Listener Object
   *
   */
  init: function init() {},

  /**
   *
   * Sent when an event occurs on the command stack. draw2d.command.CommandStackEvent.getDetail()
   * can be used to identify the type of event which has occurred.
   *
   * @template
   *
   * @param {draw2d.command.CommandStackEvent} event
   **/
  stackChanged: function stackChanged(event) {}

});

/***/ }),

/***/ "./src/command/CommandType.js":
/*!************************************!*\
  !*** ./src/command/CommandType.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * EditPolicies should determine an Figures editing capabilities.
 * It is possible to implement an Figure such that it handles all editing
 * responsibility.<br>
 * However, it is much more flexible and object-oriented to use
 * EditPolicies. Using policies, you can pick and choose the editing behavior for
 * an Figure without being bound to its class hierarchy. Code reuse is increased,
 * and code management is easier.
 *
 * @author Andreas Herz
 */

_packages2.default.command.CommandType = Class.extend(
/** @lends draw2d.command.CommandType.prototype */
{

  NAME: "draw2d.command.CommandType",

  /**
   * Create a new edit policy object
   *
   * @param {String} policy
   */
  init: function init(policy) {
    this.policy = policy;
  },

  /**
   * 
   * Return the String representation of the policy
   *
   * @returns {String}
   **/
  getPolicy: function getPolicy() {
    return this.policy;
  }
});

_packages2.default.command.CommandType.DELETE = "DELETE";
_packages2.default.command.CommandType.MOVE = "MOVE";
_packages2.default.command.CommandType.CONNECT = "CONNECT";
_packages2.default.command.CommandType.MOVE_BASEPOINT = "MOVE_BASEPOINT";
_packages2.default.command.CommandType.MOVE_VERTEX = "MOVE_VERTEX";
_packages2.default.command.CommandType.MOVE_VERTICES = "MOVE_VERTICES";
_packages2.default.command.CommandType.MOVE_GHOST_VERTEX = "MOVE_GHOST_VERTEX";
_packages2.default.command.CommandType.RESIZE = "RESIZE";
_packages2.default.command.CommandType.RESET = "RESET";
_packages2.default.command.CommandType.ROTATE = "ROTATE";

/***/ }),

/***/ "./src/command/CommandUngroup.js":
/*!***************************************!*\
  !*** ./src/command/CommandUngroup.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Command to ungroup a given group figures
 *
 * @extends draw2d.command.Command
 */

_packages2.default.command.CommandUngroup = _packages2.default.command.Command.extend(
/** @lends draw2d.command.CommandUngroup.prototype */
{

  NAME: "draw2d.command.CommandUngroup",

  /**
   * Create a group command for the given figure.
   *
   * @param {draw2d.Canvas} canvas the responsible canvas
   * @param {draw2d.util.ArrayList|draw2d.Selection} group the figures to group
   */
  init: function init(canvas, group) {
    this._super(_packages2.default.Configuration.i18n.command.ungroupShapes);
    if (group instanceof _packages2.default.Selection) {
      this.group = group.getAll().first();
    } else {
      this.group = group;
    }

    this.canvas = canvas;
    this.figures = this.group.getAssignedFigures().clone();
  },

  /**
   *
   * Returns [true] if the command can be execute and the execution of the
   * command modifies the model. e.g.: a CommandMove with [startX,startX] == [endX,endY] should
   * return false. The execution of this Command doesn't modify the model.
   *
   * @returns {Boolean} return try if the command modify the model or make any relevant changes
   **/
  canExecute: function canExecute() {
    return !this.figures.isEmpty();
  },

  /**
   *
   * Execute the command the first time
   *
   **/
  execute: function execute() {
    this.redo();
  },

  /**
   *
   * Undo the command
   *
   **/
  undo: function undo() {
    var _this = this;
    this.figures.each(function (i, figure) {
      _this.group.assignFigure(figure);
    });
    this.canvas.add(this.group);
    this.canvas.setCurrentSelection(this.group);
  },

  /**
   *
   * Redo the command after the user has undo this command
   *
   **/
  redo: function redo() {
    var _this = this;
    this.figures.each(function (i, figure) {
      _this.group.unassignFigure(figure);
    });

    this.canvas.setCurrentSelection(this.figures);
    this.canvas.remove(this.group);
  }
});

/***/ }),

/***/ "./src/css/contextmenu.css":
/*!*********************************!*\
  !*** ./src/css/contextmenu.css ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./contextmenu.css */ "./node_modules/css-loader/index.js!./src/css/contextmenu.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/decoration/connection/ArrowDecorator.js":
/*!*****************************************************!*\
  !*** ./src/decoration/connection/ArrowDecorator.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    var start = new draw2d.shape.node.Start();
 *    var end   = new draw2d.shape.node.End();
 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // Create a Connection and connect the Start and End node
 *    //
 *    var c = new draw2d.Connection();
 *
 *    // toggle from ManhattenRouter to DirectRouter to show the rotation of decorations
 *    c.setRouter(new draw2d.layout.connection.DirectRouter());
 *
 *    // Set the endpoint decorations for the connection
 *    //
 *    c.setSourceDecorator(new draw2d.decoration.connection.ArrowDecorator());
 *    c.setTargetDecorator(new draw2d.decoration.connection.ArrowDecorator());
 *
 *    // Connect the endpoints with the start and end port
 *    //
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *
 *    // and finally add the connection to the canvas
 *    canvas.add(c);
 *
 *
 * @author Andreas Herz
 * @param {Number} [width] the width of the arrow
 * @param {Number} [height] the height of the arrow
 * @extend draw2d.decoration.connection.Decorator
 */
_packages2.default.decoration.connection.ArrowDecorator = _packages2.default.decoration.connection.Decorator.extend(
/** @lends draw2d.decoration.connection.ArrowDecorator */
{
  NAME: "draw2d.decoration.connection.ArrowDecorator",

  init: function init(width, height) {
    this._super(width, height);
  },

  /**
   * Draws a filled arrow decoration.
   *
   *
   * ```
   *                       ---+ [length , width/2]
   *                -------   |
   * [0,0]  --------          |
   *    +---                  |==========================
   *        --------          |
   *                -------   |
   *                       ---+ [length ,-width/2]
   *
   * ```
   *
   * @param {RaphaelPaper} paper the raphael paper object for the paint operation
   * @returns {RaphaelPath}
   * @private
   **/
  paint: function paint(paper) {
    var st = paper.set();

    st.push(paper.path(["M0 0", "L", this.width, " ", -this.height / 2, "L", this.width, " ", this.height / 2, "L0 0"].join("")));

    st.attr({ fill: this.backgroundColor.rgba() });

    return st;
  }
});

/***/ }),

/***/ "./src/decoration/connection/BarDecorator.js":
/*!***************************************************!*\
  !*** ./src/decoration/connection/BarDecorator.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    var start = new draw2d.shape.node.Start();
 *    var end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // Create a Connection and connect the Start and End node
 *    //
 *    var c = new draw2d.Connection();
 *
 *    // toggle from ManhattenRouter to DirectRouter to show the rotation of decorations
 *    c.setRouter(new draw2d.layout.connection.DirectRouter());
 *
 *    // Set the endpoint decorations for the connection
 *    //
 *    c.setSourceDecorator(new draw2d.decoration.connection.BarDecorator());
 *    c.setTargetDecorator(new draw2d.decoration.connection.BarDecorator());
 *    // Connect the endpoints with the start and end port
 *    //
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *
 *    // and finally add the connection to the canvas
 *    canvas.add(c);
 *
 * @author Andreas Herz
 * @param {Number} [width] the width of the bar
 * @param {Number} [height] the height of the bar
 * @extend draw2d.decoration.connection.Decorator
 */
_packages2.default.decoration.connection.BarDecorator = _packages2.default.decoration.connection.Decorator.extend(
/** @lends draw2d.decoration.connection.BarDecorator */
{

  NAME: "draw2d.decoration.connection.BarDecorator",

  init: function init(width, height) {
    this._super(width, height);
  },

  /**
   * Draw a bar decoration.
   *
   * ```
   *
   *               | [length , width/2]
   *               |
   * [0,0]         |                          (Connection)
   *    +==========|==========================
   *               |
   *               |
   *               | [length ,-width/2]
   *
   * ```
   *
   * @param {RaphaelPaper} paper the raphael paper object for the paint operation
   * @returns {RaphaelPath}
   * @private
   **/
  paint: function paint(paper) {
    var st = paper.set();
    var path = ["M", this.width / 2, " ", -this.height / 2]; // Go to the top center..
    path.push("L", this.width / 2, " ", this.height / 2); // ...bottom center...

    st.push(paper.path(path.join("")));
    st.attr({ fill: this.backgroundColor.rgba() });
    return st;
  }
});

/***/ }),

/***/ "./src/decoration/connection/CircleDecorator.js":
/*!******************************************************!*\
  !*** ./src/decoration/connection/CircleDecorator.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    var start = new draw2d.shape.node.Start();
 *    var end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // Create a Connection and connect the Start and End node
 *    //
 *    var c = new draw2d.Connection();
 *
 *    // toggle from ManhattenRouter to DirectRouter to show the rotation of decorations
 *    c.setRouter(new draw2d.layout.connection.DirectRouter());
 *
 *    // Set the endpoint decorations for the connection
 *    //
 *    c.setSourceDecorator(new draw2d.decoration.connection.CircleDecorator());
 *    c.setTargetDecorator(new draw2d.decoration.connection.CircleDecorator());
 *    // Connect the endpoints with the start and end port
 *    //
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *
 *    // and finally add the connection to the canvas
 *    canvas.add(c);
 *
 * @author Andreas Herz
 * @param {Number} [width] the width of the arrow
 * @param {Number} [height] the height of the arrow
 * @extend draw2d.decoration.connection.Decorator
 */
_packages2.default.decoration.connection.CircleDecorator = _packages2.default.decoration.connection.Decorator.extend(
/** @lends draw2d.decoration.connection.CircleDecorator */
{

  NAME: "draw2d.decoration.connection.CircleDecorator",

  init: function init(width, height) {
    this._super(width, height);
  },

  /**
   * Draw a filled circle decoration.
   *
   * @param {RaphaelPaper} paper the raphael paper object for the paint operation
   * @returns {RaphaelPath}
   * @private
   **/
  paint: function paint(paper) {
    var st = paper.set();

    st.push(paper.circle(0, 0, this.width / 2));
    st.attr({ fill: this.backgroundColor.rgba() });

    return st;
  }
});

/***/ }),

/***/ "./src/decoration/connection/Decorator.js":
/*!************************************************!*\
  !*** ./src/decoration/connection/Decorator.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _Color = __webpack_require__(/*! ../../util/Color */ "./src/util/Color.js");

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Base class for any kind of Connection end/start decorations like arrows, bullets, circles, bars,...
 *
 * @author Andreas Herz
 */
_packages2.default.decoration.connection.Decorator = Class.extend(
/** @lends draw2d.decoration.connection.Decorator */
{

  NAME: "draw2d.decoration.connection.Decorator",

  init: function init(width, height) {

    if (typeof width === "undefined" || width < 1) {
      this.width = 20;
    } else {
      this.width = width;
    }

    if (typeof height === "undefined" || height < 1) {
      this.height = 15;
    } else {
      this.height = height;
    }
    this.parent = null;
    this.color = null; // null => use the color of the connection
    this.backgroundColor = new _Color2.default(250, 250, 250);
  },

  /**
   *
   * Paint the decoration for a connector. The Connector starts always in
   * [0,0] and ends in [x,0].
   * It is not necessary to consider any rotation of the connection. This will be done by the
   * framework.
   *
   * <pre>
   *               | -Y
   *               |
   *               |
   *  --------------+-----------------------------&gt; +X
   *               |
   *               |
   *               |
   *               V +Y
   *
   *
   * </pre>
   *
   * See in ArrowConnectionDecorator for example implementation.
   * @param {RaphaelPaper} paper
   * @private
   */
  paint: function paint(paper) {
    // do nothing per default
  },

  /**
   *
   * @param {draw2d.Connection} parent
   * @private
   */
  setParent: function setParent(parent) {
    this.parent = parent;
  },

  /**
   *
   * Set the stroke color for the decoration
   *
   * @param {draw2d.util.Color|String} c
   * @returns {this}
   */
  setColor: function setColor(c) {
    this.color = new _Color2.default(c);
    if (this.parent !== null) {
      this.parent.repaint();
    }
    return this;
  },

  /**
   * Get the line color of the decoration
   *
   * @returns {drawd.util.Color} the current line color of null if the Decoration should use the color of the host connection
   */
  getColor: function getColor() {
    return this.color;
  },

  /**
   *
   * Set the background color for the decoration
   *
   * @param {draw2d.util.Color|String} c
   * @returns {this}
   */
  setBackgroundColor: function setBackgroundColor(c) {
    this.backgroundColor = new _Color2.default(c);
    if (this.parent !== null) {
      this.parent.repaint();
    }

    return this;
  },

  /**
   * Returns the fill color
   *
   * @returns {draw2d.util.Color}
   */
  getBackgroundColor: function getBackgroundColor() {
    return this.backgroundColor;
  },

  /**
   *
   * Change the dimension of the decoration shape
   *
   * @param {Number} width  The new width of the decoration
   * @param {Number} height The new height of the decoration
   * @returns {this}
   **/
  setDimension: function setDimension(width, height) {
    this.width = width;
    this.height = height;

    return this;
  }
});

/***/ }),

/***/ "./src/decoration/connection/DiamondDecorator.js":
/*!*******************************************************!*\
  !*** ./src/decoration/connection/DiamondDecorator.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * @example
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    var start = new draw2d.shape.node.Start();
 *    var end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // Create a Connection and connect the Start and End node
 *    //
 *    var c = new draw2d.Connection();
 *
 *    // toggle from ManhattenRouter to DirectRouter to show the rotation of decorations
 *    c.setRouter(new draw2d.layout.connection.DirectRouter());
 *
 *    // Set the endpoint decorations for the connection
 *    //
 *    c.setSourceDecorator(new draw2d.decoration.connection.DiamondDecorator());
 *    c.setTargetDecorator(new draw2d.decoration.connection.DiamondDecorator());
 *    // Connect the endpoints with the start and end port
 *    //
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *
 *    // and finally add the connection to the canvas
 *    canvas.add(c);
 *
 *
 * @author Andreas Herz
 * @param {Number} [width] the width of the arrow
 * @param {Number} [height] the height of the arrow
 * @extend draw2d.decoration.connection.Decorator
 */

_packages2.default.decoration.connection.DiamondDecorator = _packages2.default.decoration.connection.Decorator.extend(
/** @lends draw2d.decoration.connection.DiamondDecorator */
{

  NAME: "draw2d.decoration.connection.DiamondDecorator",

  init: function init(width, height) {
    this._super(width, height);
  },

  /**
   * Draw a filled diamond decoration.
   *
   * It's not your work to rotate the arrow. The draw2d do this job for you.
   *
   * @param {RaphaelPaper} paper the raphael paper object for the paint operation
   * @returns {RaphaelPath}
   * @private
   **/
  paint: function paint(paper) {
    var st = paper.set();

    st.push(paper.path(["M", this.width / 2, " ", -this.height / 2, // Go to the top center..
    "L", this.width, " ", 0, // ...draw line to the right middle
    "L", this.width / 2, " ", this.height / 2, // ...bottom center...
    "L", 0, " ", 0, // ...left middle...
    "L", this.width / 2, " ", -this.height / 2, // and close the path
    "Z"].join("")));

    st.attr({ fill: this.backgroundColor.rgba() });
    return st;
  }
});

/***/ }),

/***/ "./src/geo/Line.js":
/*!*************************!*\
  !*** ./src/geo/Line.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Static util function to determine the minimal distance of point(px,py) on the line(x1,y1,x2,y2)
 *
 *
 * @returns {Number}
 * @static
 * @private
 * @param {Number} X1 x coordinate of the start point of the line
 * @param {Number} Y1 y coordinate of the start point of the line
 * @param {Number} X2 x coordinate of the end point of the line
 * @param {Number} Y2 y coordinate of the end point of the line
 * @param {Number} px x coordinate of the point to test
 * @param {Number} py y coordinate of the point to test
 **/
_packages2.default.geo.Line = {

  /**
   * Returns the relative position of the point on the line between [0..1]
   * The point "p" must be part of the line!!
   *
   * 0 => given point is on the start location
   * ..=> given point is in between
   * 1 => given point is at the end
   *
   * @returns {Number}
   */
  inverseLerp: function inverseLerp(X1, Y1, X2, Y2, px, py) {
    var nenner = Math.abs(X2 - X1);
    var zaehler = Math.abs(X2 - px);
    if (nenner === 0) {
      nenner = Math.abs(Y2 - Y1);
      zaehler = Math.abs(Y2 - py);
      if (nenner === 0) {
        return 1;
      }
    }

    return zaehler / nenner;
  },

  /**
   *
   * Returns the projection of the point onto the line.
   *
   * @param {Number} px the x coordinate of the test point
   * @param {Number} py the y coordinate of the test point
   * @returns {draw2d.geo.Point}
   **/
  pointProjection: function pointProjection(X1, Y1, X2, Y2, px, py) {
    var r = new _packages2.default.geo.Point(0, 0);
    if (X1 === X2 && Y1 === Y2) X1 -= 0.00001;

    var U = (px - X1) * (X2 - X1) + (py - Y1) * (Y2 - Y1);

    var Udenom = Math.pow(X2 - X1, 2) + Math.pow(Y2 - Y1, 2);

    U /= Udenom;

    r.x = X1 + U * (X2 - X1);
    r.y = Y1 + U * (Y2 - Y1);

    var minx = void 0,
        maxx = void 0,
        miny = void 0,
        maxy = void 0;

    minx = Math.min(X1, X2);
    maxx = Math.max(X1, X2);

    miny = Math.min(Y1, Y2);
    maxy = Math.max(Y1, Y2);

    var isValid = r.x >= minx && r.x <= maxx && r.y >= miny && r.y <= maxy;

    return isValid ? r : null;
  },

  distance: function distance(X1, Y1, X2, Y2, px, py) {
    // Adjust vectors relative to X1,Y1
    // X2,Y2 becomes relative vector from X1,Y1 to end of segment
    X2 -= X1;
    Y2 -= Y1;
    // px,py becomes relative vector from X1,Y1 to test point
    px -= X1;
    py -= Y1;
    var dotprod = px * X2 + py * Y2;
    var projlenSq = void 0;
    if (dotprod <= 0.0) {
      // px,py is on the side of X1,Y1 away from X2,Y2
      // distance to segment is length of px,py vector
      // "length of its (clipped) projection" is now 0.0
      projlenSq = 0.0;
    } else {
      // switch to backwards vectors relative to X2,Y2
      // X2,Y2 are already the negative of X1,Y1=>X2,Y2
      // to get px,py to be the negative of px,py=>X2,Y2
      // the dot product of two negated vectors is the same
      // as the dot product of the two normal vectors
      px = X2 - px;
      py = Y2 - py;
      dotprod = px * X2 + py * Y2;
      if (dotprod <= 0.0) {
        // px,py is on the side of X2,Y2 away from X1,Y1
        // distance to segment is length of (backwards) px,py vector
        // "length of its (clipped) projection" is now 0.0
        projlenSq = 0.0;
      } else {
        // px,py is between X1,Y1 and X2,Y2
        // dotprod is the length of the px,py vector
        // projected on the X2,Y2=>X1,Y1 vector times the
        // length of the X2,Y2=>X1,Y1 vector
        projlenSq = dotprod * dotprod / (X2 * X2 + Y2 * Y2);
      }
    }
    // Distance to line is now the length of the relative point
    // vector minus the length of its projection onto the line
    // (which is zero if the projection falls outside the range
    //  of the line segment).
    var lenSq = px * px + py * py - projlenSq;
    if (lenSq < 0) {
      lenSq = 0;
    }
    return Math.sqrt(lenSq);
  }
};

/***/ }),

/***/ "./src/geo/Point.js":
/*!**************************!*\
  !*** ./src/geo/Point.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Represents a point (x, y) in 2-dimensional space.
 *
 * @class
 */

_packages2.default.geo.Point = Class.extend(
/** @lends draw2d.geo.Point.prototype */
{

  NAME: "draw2d.geo.Point",

  /**
   * Creates a new Point object with the hands over coordinates.
   *
   * @param {Number|draw2d.geo.Point} x
   * @param {Number} y
   */
  init: function init(x, y) {
    if (x instanceof _packages2.default.geo.Point) {
      this.x = x.x;
      this.y = x.y;
    } else if (!isNaN(parseFloat(x.x)) && !isNaN(parseFloat(x.y))) {
      this.x = x.x;
      this.y = x.y;
    } else {
      this.x = x;
      this.y = y;
    }

    // limit for the maxi/minimum boundary of this rectangle
    // It is not possible that the rect leave the boundary if set.
    this.bx = null;
    this.by = null;
    this.bw = null;
    this.bh = null;
  },

  /**
   * 
   * Ensure the boundary of the rectangle. If set, the rectangle keeps always inside
   * the boundary. It is like a virtual fence.
   *
   * @returns {this}
   */
  setBoundary: function setBoundary(bx, by, bw, bh) {
    if (bx instanceof _packages2.default.geo.Rectangle) {
      this.bx = bx.x;
      this.by = bx.y;
      this.bw = bx.w;
      this.bh = bx.h;
    } else {
      this.bx = bx;
      this.by = by;
      this.bw = bw;
      this.bh = bh;
    }
    this.adjustBoundary();

    return this;
  },

  /**
   * 
   * @private
   * @returns {this}
   */
  adjustBoundary: function adjustBoundary() {
    if (this.bx === null) {
      return this;
    }
    this.x = Math.min(Math.max(this.bx, this.x), this.bw);
    this.y = Math.min(Math.max(this.by, this.y), this.bh);

    return this;
  },

  /**
   * 
   * Moves this Rectangle horizontally by dx and vertically by dy, then returns
   * this Rectangle for convenience.<br>
   * <br>
   * The method return the object itself. This allows you to do command chaining, where
   * you can perform multiple methods on the same elements.
   *
   * @param {Number} dx  Shift along X axis
   * @param {Number} dy  Shift along Y axis
   * @returns {this}
   **/
  translate: function translate(dx, dy) {
    this.x += dx;
    this.y += dy;
    this.adjustBoundary();

    return this;
  },

  /**
   * 
   * The X value of the point
   *
   * @since 0.1
   * @returns {Number} The x coordinate of the top left corner
   */
  getX: function getX() {
    return this.x;
  },

  /**
   * 
   * The y value of the point
   *
   * @returns {Number} The y coordinate of the top left corner
   */
  getY: function getY() {
    return this.y;
  },

  /**
   * 
   * Set the new X value of the point
   *
   * @param {Number} x the new x coordinate of the rect
   * @returns {this}
   */
  setX: function setX(x) {
    this.x = x;
    this.adjustBoundary();

    return this;
  },

  /**
   * 
   * Set the new Y value of the point
   *
   * @param {Number} y the new y coordinate of the rect
   * @returns {this}
   */
  setY: function setY(y) {
    this.y = y;
    this.adjustBoundary();

    return this;
  },

  /**
   * 
   * Set the new x/y coordinates of this point
   *
   * @param {Number|draw2d.geo.Point} x
   * @param {Number} [y]
   * @returns {this}
   */
  setPosition: function setPosition(x, y) {
    if (x instanceof _packages2.default.geo.Point) {
      this.x = x.x;
      this.y = x.y;
    } else {
      this.x = x;
      this.y = y;
    }
    this.adjustBoundary();

    return this;
  },

  /**
   * 
   * Calculates the relative position of the specified Point to this Point.
   *
   * @param {draw2d.geo.Point} p The reference Point
   * @returns {Number} NORTH, SOUTH, EAST, or WEST, as defined in {@link draw2d.geo.PositionConstants}
   */
  getPosition: function getPosition(p) {
    var dx = p.x - this.x;
    var dy = p.y - this.y;
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx < 0) return _packages2.default.geo.PositionConstants.WEST;
      return _packages2.default.geo.PositionConstants.EAST;
    }
    if (dy < 0) {
      return _packages2.default.geo.PositionConstants.NORTH;
    }
    return _packages2.default.geo.PositionConstants.SOUTH;
  },

  /**
   * 
   * Compares two points and return [true] if x and y are equals.
   *
   * @param {draw2d.geo.Point} p the point to compare with
   *
   * @returns {Boolean} True if the given p[x,y] has an exact match with the point
   */
  equals: function equals(p) {
    return this.x === p.x && this.y === p.y;
  },

  /**
   * 
   * Return the distance between this point and the hands over.
   *
   * @param {draw2d.geo.Point} other the point to use
   * @returns {Number} The distance to the given point
   */
  distance: function distance(other) {
    return Math.sqrt((this.x - other.x) * (this.x - other.x) + (this.y - other.y) * (this.y - other.y));
  },
  /* @deprecated */
  getDistance: function getDistance(other) {
    return this.distance(other);
  },

  /**
   * 
   * Return the length of the vector measured from [0,0]
   *
   * @returns {Number} The length of the vector [0,0][x,y]
   * @since 2.10.0
   */
  length: function length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },

  /**
   * 
   * Return a new Point translated with the x/y values of the hands over point.
   *
   * @param {draw2d.geo.Point|Number} x the x translation or the complete point to translate
   * @param {Number} [y] the y translation. Required if x is a simple number instead of a draw2d.geo.Point
   * @returns {draw2d.geo.Point} A instance of a translated point.
   */
  translated: function translated(x, y) {
    var other = new _packages2.default.geo.Point(x, y);
    return new _packages2.default.geo.Point(this.x + other.x, this.y + other.y);
  },

  /**
   * 
   * Scales this point with the handover factor
   *
   * @param {Number} factor the factor to scaled the point.
   * @returns {this}
   */
  scale: function scale(factor) {
    this.x *= factor;
    this.y *= factor;
    this.adjustBoundary();

    return this;
  },

  /**
   * 
   * Return a **new** Point scaled with the givben factor
   *
   * @param {Number} factor the factor to scaled the new point.
   * @returns {draw2d.geo.Point} The new translated point.
   */
  scaled: function scaled(factor) {
    return new _packages2.default.geo.Point(this.x * factor, this.y * factor);
  },

  /* @deprecated */
  getScaled: function getScaled(factor) {
    return this.scaled(factor);
  },

  /**
   * 
   * Return an objects with all important attributes for XML or JSON serialization
   *
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes() {
    return {
      x: this.x,
      y: this.y
    };
  },

  /**
   * 
   * Read all attributes from the serialized properties and transfer them into the shape.
   *
   * @param {Object} memento
   * @returns {this}
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this.x = memento.x;
    this.y = memento.y;

    return this;
  },

  /**
   * 
   * substract the given point and return the **new** point.
   *
   * @param that
   * @returns {draw2d.geo.Point}
   */
  subtract: function subtract(that) {
    return new _packages2.default.geo.Point(this.x - that.x, this.y - that.y);
  },

  dot: function dot(that) {
    return this.x * that.x + this.y * that.y;
  },

  cross: function cross(that) {
    return this.x * that.y - this.y * that.x;
  },

  lerp: function lerp(that, t) {
    return new _packages2.default.geo.Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
  },

  /**
   * 
   * Return a cloned point
   *
   * @returns {draw2d.geo.Point}
   */
  clone: function clone() {
    return new _packages2.default.geo.Point(this.x, this.y);
  }

});

/***/ }),

/***/ "./src/geo/PositionConstants.js":
/*!**************************************!*\
  !*** ./src/geo/PositionConstants.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Static values for point orientation.
 * 
 */
_packages2.default.geo.PositionConstants = {
  /**
   *
   */
  NORTH: 1,
  SOUTH: 4,
  WEST: 8,
  EAST: 16
};

/***/ }),

/***/ "./src/geo/Ray.js":
/*!************************!*\
  !*** ./src/geo/Ray.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Represents a vector within 2-dimensional Euclidean space.
 * 
 * @inheritable
 * @extends draw2d.geo.Point
 * @author Andreas Herz
 */
_packages2.default.geo.Ray = _packages2.default.geo.Point.extend(
/** @lends draw2d.geo.Ray.prototype */
{

    NAME: "draw2d.geo.Ray",

    /**
     * Creates a ray object.
     *
     * @param {Number} x
     * @param {Number} y
     */
    init: function init(x, y) {
        this._super(x, y);
    },

    isHorizontal: function isHorizontal() {
        return this.x != 0;
    },

    similarity: function similarity(otherRay) {
        return Math.abs(this.dot(otherRay));
    },

    getAveraged: function getAveraged(otherRay) {
        return new _packages2.default.geo.Ray((this.x + otherRay.x) / 2, (this.y + otherRay.y) / 2);
    }

});

/***/ }),

/***/ "./src/geo/Rectangle.js":
/*!******************************!*\
  !*** ./src/geo/Rectangle.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Represents a Rectangle(x, y, width, height).
 *
 * @author Andreas Herz
 * @extends draw2d.geo.Point
 */
_packages2.default.geo.Rectangle = _packages2.default.geo.Point.extend(
/** @lends draw2d.geo.Rectangle.prototype */
{

  NAME: "draw2d.geo.Rectangle",

  /**
   * Creates a new Point object with the hands over coordinates.
   * <br>
   * The constructor consumes almost any kind of rectangel definitions
   * like:
   *      let rect0 = new draw2d.geo.Rectangle({x:0,y:0,width:20,height:20});
   *      let rect1 = new draw2d.geo.Rectangle({x:0,y:0,w:20,h:20});
   *      let rect2 = new draw2d.geo.Rectangle($("#divid")[0].getBoundingClientRect());
   *      let rect3 = new draw2d.geo.Rectangle(rect1);
   *
   * The rectangle class is usefull for any kind of intersection, hitTest, contains,...calculation
   * or to set the bounding box of any shape.
   *
   * @param {Number|draw2d.geo.Rectangle} x
   * @param {Number} y
   * @param {Number} w
   * @param {Number} h
   */
  init: function init(x, y, w, h) {
    // try to consume any kind rectangle definitions
    //
    if (x instanceof _packages2.default.geo.Rectangle) {
      y = x.y;
      w = x.w;
      h = x.h;
      x = x.x;
    } else if (typeof x.x === "number" && typeof x.y === "number") {
      y = x.y;
      w = x.w | x.width;
      h = x.h | x.height;
      x = x.x;
    } else if (typeof x.top === "number" && typeof x.left === "number") {
      y = x.top;
      w = x.w | x.width;
      h = x.h | x.height;
      x = x.left;
    }
    this._super(x, y);
    this.w = w;
    this.h = h;
  },

  /**
   *
   * @private
   */
  adjustBoundary: function adjustBoundary() {
    if (this.bx === null) {
      return;
    }
    this.x = Math.min(Math.max(this.bx, this.x), this.bw - this.w);
    this.y = Math.min(Math.max(this.by, this.y), this.bh - this.h);
    this.w = Math.min(this.w, this.bw);
    this.h = Math.min(this.h, this.bh);
  },

  /**
   *
   * Resizes this Rectangle by the values supplied as input and returns this for
   * convenience. This Rectangle's width will become this.width + dw. This
   * Rectangle's height will become this.height + dh.
   * <br>
   * The method return the object itself. This allows you to do command chaining, where
   * you can perform multiple methods on the same elements.
   *
   *
   * @param {Number} dw  Amount by which width is to be resized
   * @param {Number} dh  Amount by which height is to be resized
   * @returns  {this}
   **/
  resize: function resize(dw, dh) {
    this.w += dw;
    this.h += dh;
    this.adjustBoundary();

    return this;
  },

  /**
   * Adds the specified padding to the rectangle's bounds. This Rectangle's width
   * will become this.width + dw. The Rectangle's height will become this.height + dh.
   * The top left corner moves -dw/2, -dh/2
   *
   * @param {Number} dw  Amount by which width is to be resized
   * @param {Number} dh  Amount by which height is to be resized
   * @returns  {this}
   **/
  scale: function scale(dw, dh) {
    this.w += dw;
    this.h += dh;
    this.x -= dw / 2;
    this.y -= dh / 2;
    this.adjustBoundary();

    return this;
  },

  /**
   * Translate the rectangle with the given x/y coordiante.
   *
   * @param {draw2d.geo.Point|Number} x the x translation or the complete point to translate
   * @param {Number} [y] the y translation. Required if x is a simple number instead of a draw2d.geo.Point
   *
   *
   * @since 5.6.0
   * @returns  {this}
   */
  translate: function translate(x, y) {
    var other = new _packages2.default.geo.Point(x, y);
    this.x += other.x;
    this.y += other.y;
    this.adjustBoundary();

    return this;
  },

  /**
   *
   * Returns a copy of the translated rectangle
   *
   * @param {draw2d.geo.Point|Number} x the x translation or the complete point to translate
   * @param {Number} [y] the y translation. Required if x is a simple number instead of a draw2d.geo.Point
   *
   * @returns {draw2d.geo.Rectangle} The new translated rectangle.
   * @since 5.6.0
   */
  translated: function translated(x, y) {
    var other = new _packages2.default.geo.Point(x, y);
    return new _packages2.default.geo.Rectangle(this.x + other.x, this.y + other.y, this.w, this.h);
  },

  /**
   * Sets the parameters of this Rectangle from the Rectangle passed in and
   * returns this for convenience.<br>
   * <br>
   * The method return the object itself. This allows you to do command chaining, where
   * you can perform multiple methods on the same elements.
   *
   * @param {draw2d.geo.Rectangle} Rectangle providing the bounding values
   * @returns  {this}
   */
  setBounds: function setBounds(rect) {
    this.setPosition(rect.x, rect.y);

    this.w = rect.w;
    this.h = rect.h;

    return this;
  },

  /**
   *
   * Returns <code>true</code> if this Rectangle's width or height is less than or
   * equal to 0.
   *
   * @returns {Boolean}
   */
  isEmpty: function isEmpty() {
    return this.w <= 0 || this.h <= 0;
  },

  /**
   *
   * The width of the dimension element.
   *
   * @returns {Number}
   **/
  getWidth: function getWidth() {
    return this.w;
  },

  /**
   *
   * Set the new width of the rectangle.
   *
   * @param {Number} w the new width of the rectangle
   * @returns  {this}
   */
  setWidth: function setWidth(w) {
    this.w = w;
    this.adjustBoundary();

    return this;
  },

  /**
   *
   * The height of the dimension element.
   *
   * @returns {Number}
   **/
  getHeight: function getHeight() {
    return this.h;
  },

  /**
   *
   * Set the new height of the rectangle.
   *
   * @param {Number} h the new height of the rectangle
   * @returns  {this}
   */
  setHeight: function setHeight(h) {
    this.h = h;
    this.adjustBoundary();

    return this;
  },

  /**
   *
   * The x coordinate of the left corner.
   *
   * @returns {Number}
   **/
  getLeft: function getLeft() {
    return this.x;
  },

  /**
   *
   * The x coordinate of the right corner.
   *
   * @returns {Number}
   **/
  getRight: function getRight() {
    return this.x + this.w;
  },

  /**
   *
   * The y coordinate of the top.
   *
   *@return {Number}
   **/
  getTop: function getTop() {
    return this.y;
  },

  /**
   *
   * The y coordinate of the bottom.
   *
   *@return {Number}
   **/
  getBottom: function getBottom() {
    return this.y + this.h;
  },

  /**
   *
   * The top left corner of the dimension object.
   *
   * @returns {draw2d.geo.Point} a new point objects which holds the coordinates
   **/
  getTopLeft: function getTopLeft() {
    return new _packages2.default.geo.Point(this.x, this.y);
  },

  /**
   *
   * The top center coordinate of the dimension object.
   *
   * @returns {draw2d.geo.Point} a new point objects which holds the coordinates
   **/
  getTopCenter: function getTopCenter() {
    return new _packages2.default.geo.Point(this.x + this.w / 2, this.y);
  },

  /**
   *
   * The top right corner of the dimension object.
   *
   * @returns {draw2d.geo.Point} a new point objects which holds the coordinates
   **/
  getTopRight: function getTopRight() {
    return new _packages2.default.geo.Point(this.x + this.w, this.y);
  },

  /**
   *
   * The center left  of the dimension object.
   *
   * @returns {draw2d.geo.Point} a new point objects which holds the coordinates
   **/
  getCenterLeft: function getCenterLeft() {
    return new _packages2.default.geo.Point(this.x, this.y + this.h / 2);
  },

  /**
   *
   * The bottom left corner of the dimension object.
   *
   * @returns {draw2d.geo.Point} a new point objects which holds the coordinates
   **/
  getBottomLeft: function getBottomLeft() {
    return new _packages2.default.geo.Point(this.x, this.y + this.h);
  },

  /**
   *
   * The bottom center coordinate of the dimension object.
   *
   * @returns {draw2d.geo.Point} a new point objects which holds the coordinates
   **/
  getBottomCenter: function getBottomCenter() {
    return new _packages2.default.geo.Point(this.x + this.w / 2, this.y + this.h);
  },

  /**
   *
   * The center of the dimension object
   *
   * @returns {draw2d.geo.Point} a new point which holds the center of the object
   **/
  getCenter: function getCenter() {
    return new _packages2.default.geo.Point(this.x + this.w / 2, this.y + this.h / 2);
  },

  /**
   *
   * Bottom right corner of the object
   *
   * @returns {draw2d.geo.Point} a new point which holds the bottom right corner
   **/
  getBottomRight: function getBottomRight() {
    return new _packages2.default.geo.Point(this.x + this.w, this.y + this.h);
  },

  /**
   *
   * Return all points of the rectangle as array. Starting at topLeft and the
   * clockwise.
   *
   * @returns {draw2d.util.ArrayList} the points starting at top/left and the clockwise
   */
  getVertices: function getVertices() {
    var result = new _packages2.default.util.ArrayList();
    // don't change the order. We expect always that the top left corner has index[0]
    // and goes clock wise
    //
    result.add(this.getTopLeft());
    result.add(this.getTopRight());
    result.add(this.getBottomRight());
    result.add(this.getBottomLeft());

    return result;
  },

  /**
   *
   * Return a new rectangle which fits into this rectangle. <b>ONLY</b> the x/y coordinates
   * will be changed. Not the dimension of the given rectangle.
   *
   * @param {draw2d.geo.Rectangle} rect the rectangle to adjust
   * @returns the new shifted rectangle
   */
  moveInside: function moveInside(rect) {
    var newRect = new _packages2.default.geo.Rectangle(rect.x, rect.y, rect.w, rect.h);
    // shift the coordinate right/down if coordinate not inside the rect
    //
    newRect.x = Math.max(newRect.x, this.x);
    newRect.y = Math.max(newRect.y, this.y);

    // ensure that the right border is inside this rect (if possible). 
    //
    if (newRect.w < this.w) {
      newRect.x = Math.min(newRect.x + newRect.w, this.x + this.w) - newRect.w;
    } else {
      newRect.x = this.x;
    }

    // ensure that the bottom is inside this rectangle
    //
    if (newRect.h < this.h) {
      newRect.y = Math.min(newRect.y + newRect.h, this.y + this.h) - newRect.h;
    } else {
      newRect.y = this.y;
    }

    return newRect;
  },

  /**
   *
   * Return the minimum distance of this rectangle to the given {@link draw2d.geo.Point} or
   * {link draw2d.geo.Rectangle}.
   *
   * @param {draw2d.geo.Point|draw2d.geo.Rectangle} pointOrRectangle the reference point/rectangle for the distance calculation
   */
  getDistance: function getDistance(pointOrRectangle) {
    var cx = this.x;
    var cy = this.y;
    var cw = this.w;
    var ch = this.h;

    var ox = pointOrRectangle.getX();
    var oy = pointOrRectangle.getY();
    var ow = 1;
    var oh = 1;

    if (pointOrRectangle instanceof _packages2.default.geo.Rectangle) {
      ow = pointOrRectangle.getWidth();
      oh = pointOrRectangle.getHeight();
    }
    var oct = 9;

    // Determin Octant
    //
    // 0 | 1 | 2
    // __|___|__
    // 7 | 9 | 3
    // __|___|__
    // 6 | 5 | 4

    if (cx + cw <= ox) {
      if (cy + ch <= oy) {
        oct = 0;
      } else if (cy >= oy + oh) {
        oct = 6;
      } else {
        oct = 7;
      }
    } else if (cx >= ox + ow) {
      if (cy + ch <= oy) {
        oct = 2;
      } else if (cy >= oy + oh) {
        oct = 4;
      } else {
        oct = 3;
      }
    } else if (cy + ch <= oy) {
      oct = 1;
    } else if (cy >= oy + oh) {
      oct = 5;
    } else {
      return 0;
    }

    // Determine Distance based on Quad
    //
    switch (oct) {
      case 0:
        cx = cx + cw - ox;
        cy = cy + ch - oy;
        return -(cx + cy);
      case 1:
        return -(cy + ch - oy);
      case 2:
        cx = ox + ow - cx;
        cy = cy + ch - oy;
        return -(cx + cy);
      case 3:
        return -(ox + ow - cx);
      case 4:
        cx = ox + ow - cx;
        cy = oy + oh - cy;
        return -(cx + cy);
      case 5:
        return -(oy + oh - cy);
      case 6:
        cx = cx + cw - ox;
        cy = oy + oh - cy;
        return -(cx + cy);
      case 7:
        return -(cx + cw - ox);
    }

    throw "Unknown data type of parameter for distance calculation in draw2d.geo.Rectangle.getDistance(..)";
  },

  /**
   *
   * Determin the octant of r2 in relation to this rectangle.
   * <pre>
   *
   *    0 | 1 | 2
   *    __|___|__
   *    7 | 8 | 3
   *    __|___|__
   *    6 | 5 | 4
   * </pre>
   *
   * @param {draw2d.geo.Rectangle} r2
   *
   */
  determineOctant: function determineOctant(r2) {
    var HISTERESE = 3; // Toleranz um diese vermieden wird, dass der Octant "8" zurckgegeben wird

    var ox = this.x + HISTERESE;
    var oy = this.y + HISTERESE;
    var ow = this.w - HISTERESE * 2;
    var oh = this.h - HISTERESE * 2;

    var cx = r2.x;
    var cy = r2.y;
    var cw = 2;
    var ch = 2;
    if (r2 instanceof _packages2.default.geo.Rectangle) {
      cw = r2.w;
      ch = r2.h;
    }

    var oct = 0;

    if (cx + cw <= ox) {
      if (cy + ch <= oy) {
        oct = 0;
      } else if (cy >= oy + oh) {
        oct = 6;
      } else {
        oct = 7;
      }
    } else if (cx >= ox + ow) {
      if (cy + ch <= oy) {
        oct = 2;
      } else if (cy >= oy + oh) {
        oct = 4;
      } else {
        oct = 3;
      }
    } else if (cy + ch <= oy) {
      oct = 1;
    } else if (cy >= oy + oh) {
      oct = 5;
    } else {
      oct = 8;
    }

    return oct;
  },

  /**
   *
   * Returns the direction the point <i>p</i> is in relation to the given rectangle.
   * Util method for inherit router implementations.
   *
   * <p>
   * Possible values:
   * <ul>
   *   <li>up -&gt; 0</li>
   *   <li>right -&gt; 1</li>
   *   <li>down -&gt; 2</li>
   *   <li>left -&gt; 3</li>
   * </ul>
   * <p>
   *
   * @param {draw2d.geo.Point} other the point in relation to the given rectangle
   *
   * @returns {Number} the direction from <i>r</i> to <i>p</i>
   */
  getDirection: function getDirection(other) {
    var current = this.getTopLeft();
    switch (this.determineOctant(other)) {
      case 0:
        if (current.x - other.x < current.y - other.y) return _packages2.default.geo.Rectangle.DIRECTION_UP;
        return _packages2.default.geo.Rectangle.DIRECTION_LEFT;
      case 1:
        return _packages2.default.geo.Rectangle.DIRECTION_UP;
      case 2:
        current = this.getTopRight();
        if (other.x - current.x < current.y - other.y) return _packages2.default.geo.Rectangle.DIRECTION_UP;
        return _packages2.default.geo.Rectangle.DIRECTION_RIGHT;
      case 3:
        return _packages2.default.geo.Rectangle.DIRECTION_RIGHT;
      case 4:
        current = this.getBottomRight();
        if (other.x - current.x < other.y - current.y) return _packages2.default.geo.Rectangle.DIRECTION_DOWN;
        return _packages2.default.geo.Rectangle.DIRECTION_RIGHT;
      case 5:
        return _packages2.default.geo.Rectangle.DIRECTION_DOWN;
      case 6:
        current = this.getBottomLeft();
        if (current.x - other.x < other.y - current.y) return _packages2.default.geo.Rectangle.DIRECTION_DOWN;
        return _packages2.default.geo.Rectangle.DIRECTION_LEFT;
      case 7:
        return _packages2.default.geo.Rectangle.DIRECTION_LEFT;
      case 8:
        if (other.y > this.y) {
          return _packages2.default.geo.Rectangle.DIRECTION_DOWN;
        }
        return _packages2.default.geo.Rectangle.DIRECTION_UP;

    }
    return _packages2.default.geo.Rectangle.DIRECTION_UP;
  },

  /**
   *
   * Compares two rectangle objects
   *
   * @param {draw2d.geo.Rectangle} o
   *
   * @returns {Boolean}
   **/
  equals: function equals(o) {
    return this.x == o.x && this.y == o.y && this.w == o.w && this.h == o.h;
  },

  /**
   *
   * Detect whenever the hands over coordinate is inside the rectangle.
   *
   * @param {Number/draw2d.geo.Point} iX
   * @param {Number} iY
   * @returns {Boolean}
   */
  hitTest: function hitTest(iX, iY) {
    if (iX instanceof _packages2.default.geo.Point) {
      iY = iX.y;
      iX = iX.x;
    }
    var iX2 = this.x + this.getWidth();
    var iY2 = this.y + this.getHeight();
    return iX >= this.x && iX <= iX2 && iY >= this.y && iY <= iY2;
  },

  /**
   *
   * return true if this rectangle inside the hand over rectangle
   *
   *
   * @param {draw2d.geo.Rectangle} rect
   * @returns {Boolean}
   */
  isInside: function isInside(rect) {
    return rect.hitTest(this.getTopLeft()) && rect.hitTest(this.getTopRight()) && rect.hitTest(this.getBottomLeft()) && rect.hitTest(this.getBottomRight());
  },

  /**
   *
   * return true if this rectangle contains the hand over rectangle.
   *
   *
   * @param {draw2d.geo.Rectangle} rect
   * @returns {Boolean}
   * @since 4.7.2
   */
  contains: function contains(rect) {
    return this.hitTest(rect.getTopLeft()) && this.hitTest(rect.getTopRight()) && this.hitTest(rect.getBottomLeft()) && this.hitTest(rect.getBottomRight());
  },

  /**
   *
   * checks whenever the rectangles has an intersection.
   *
   * @param {draw2d.geo.Rectangle} rect
   * @returns {Boolean}
   */
  intersects: function intersects(rect) {
    var x11 = rect.x,
        y11 = rect.y,
        x12 = rect.x + rect.w,
        y12 = rect.y + rect.h,
        x21 = this.x,
        y21 = this.y,
        x22 = this.x + this.w,
        y22 = this.y + this.h;

    var x_overlap = Math.max(0, Math.min(x12, x22) - Math.max(x11, x21));
    var y_overlap = Math.max(0, Math.min(y12, y22) - Math.max(y11, y21));

    return x_overlap * y_overlap !== 0;
  },

  /**
   * Merge this rectangle with the given one.
   *
   * @param {draw2d.geo.Rectangle} rect
   * @since 4.8.0
   * @returns  {this}
   */
  merge: function merge(rect) {
    var r = Math.max(rect.getRight(), this.getRight());
    var b = Math.max(rect.getBottom(), this.getBottom());

    this.setPosition(Math.min(this.x, rect.x), Math.min(this.y, rect.y));

    this.w = r - this.x;
    this.h = b - this.y;

    return this;
  },

  /**
   *
   * returns the intersection points with the given line if any exists
   *
   * @param {draw2d.geo.Point} start
   * @param {draw2d.geo.Point} end
   */
  intersectionWithLine: function intersectionWithLine(start, end) {
    var result = new _packages2.default.util.ArrayList();
    var v = this.getVertices();
    v.add(v.first());
    var p1 = v.first();
    var p2 = null;
    for (var i = 1; i < 5; i++) {
      p2 = v.get(i);
      p1 = _packages2.default.shape.basic.Line.intersection(start, end, p1, p2);
      if (p1 !== null) {
        result.add(p1);
      }
      p1 = p2;
    }
    return result;
  },

  /**
   *
   * Returns a copy of this rectangle
   *
   *
   * @returns {draw2d.geo.Rectangle}
   * @since 5.6.0
   */
  clone: function clone() {
    return new _packages2.default.geo.Rectangle(this.x, this.y, this.w, this.h);
  },

  /**
   *
   * converts the rectangle to JSON representation. required for the draw2d.io.Writer
   *
   * @returns {Object}
   */
  toJSON: function toJSON() {
    return {
      width: this.w,
      height: this.h,
      x: this.x,
      y: this.y
    };
  }

});

/**
 * ENUM for Direction
 */
_packages2.default.geo.Rectangle.DIRECTION_UP = 0;
_packages2.default.geo.Rectangle.DIRECTION_RIGHT = 1;
_packages2.default.geo.Rectangle.DIRECTION_DOWN = 2;
_packages2.default.geo.Rectangle.DIRECTION_LEFT = 3;

/***/ }),

/***/ "./src/geo/Util.js":
/*!*************************!*\
  !*** ./src/geo/Util.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Geometric utils functions used in ray, point and some routers.
 *
 * @author Andreas Herz
 */
_packages2.default.geo.Util = {

  /**
   *
   * @param start {draw2d.geo.Point} start point of a line
   * @param end  {draw2d.geo.Point} end point of a line
   * @param distanceFromStart {Number} distance from the start point to extrapolate a new point
   * @returns {{x: *, y: *}|*} a new point with the distance *distanceFromStart* from the start point
   */
  insetPoint: function insetPoint(start, end, distanceFromStart) {
    if (start.equals(end)) {
      return start;
    }
    var vx = start.x - end.x;
    var vy = start.y - end.y;
    var length = Math.sqrt(vx * vx + vy * vy);
    var localDistance = Math.min(length / 2, distanceFromStart);
    return {
      x: end.x + vx / length * (length - localDistance),
      y: end.y + vy / length * (length - localDistance)
    };
  }
};

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _raphaelExec = __webpack_require__(/*! lib/raphael.exec.js */ "./src/lib/raphael.exec.js");

var _raphaelExec2 = _interopRequireDefault(_raphaelExec);

var _ClassExec = __webpack_require__(/*! lib/Class.exec.js */ "./src/lib/Class.exec.js");

var _ClassExec2 = _interopRequireDefault(_ClassExec);

var _pathfindingExec = __webpack_require__(/*! lib/pathfinding.exec.js */ "./src/lib/pathfinding.exec.js");

var _pathfindingExec2 = _interopRequireDefault(_pathfindingExec);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = _packages2.default;

__webpack_require__(/*! ./util/raphael_ext */ "./src/util/raphael_ext.js");
__webpack_require__(/*! ./util/Polyfill */ "./src/util/Polyfill.js");
__webpack_require__(/*! ./util/Base64 */ "./src/util/Base64.js");
__webpack_require__(/*! ./util/Debug */ "./src/util/Debug.js");
// require('./util/Color');

__webpack_require__(/*! ./util/ArrayList */ "./src/util/ArrayList.js");
__webpack_require__(/*! ./util/SVGUtil */ "./src/util/SVGUtil.js");
//require('./util/JSONUtil');
//require('./util/UUID');
__webpack_require__(/*! ./util/spline/Spline */ "./src/util/spline/Spline.js");
__webpack_require__(/*! ./util/spline/CubicSpline */ "./src/util/spline/CubicSpline.js");
__webpack_require__(/*! ./util/spline/CatmullRomSpline */ "./src/util/spline/CatmullRomSpline.js");
__webpack_require__(/*! ./util/spline/BezierSpline */ "./src/util/spline/BezierSpline.js");
__webpack_require__(/*! ./geo/PositionConstants */ "./src/geo/PositionConstants.js");
__webpack_require__(/*! ./geo/Point */ "./src/geo/Point.js");
__webpack_require__(/*! ./geo/Rectangle */ "./src/geo/Rectangle.js");
__webpack_require__(/*! ./geo/Util */ "./src/geo/Util.js");
__webpack_require__(/*! ./geo/Ray */ "./src/geo/Ray.js");
__webpack_require__(/*! ./geo/Line */ "./src/geo/Line.js");
__webpack_require__(/*! ./command/CommandType */ "./src/command/CommandType.js");
__webpack_require__(/*! ./command/Command */ "./src/command/Command.js");
__webpack_require__(/*! ./command/CommandCollection */ "./src/command/CommandCollection.js");
__webpack_require__(/*! ./command/CommandStack */ "./src/command/CommandStack.js");
__webpack_require__(/*! ./command/CommandStackEvent */ "./src/command/CommandStackEvent.js");
__webpack_require__(/*! ./command/CommandStackEventListener */ "./src/command/CommandStackEventListener.js");
__webpack_require__(/*! ./command/CommandMove */ "./src/command/CommandMove.js");
__webpack_require__(/*! ./command/CommandAttr */ "./src/command/CommandAttr.js");
__webpack_require__(/*! ./command/CommandMoveLine */ "./src/command/CommandMoveLine.js");
__webpack_require__(/*! ./command/CommandMoveConnection */ "./src/command/CommandMoveConnection.js");
__webpack_require__(/*! ./command/CommandMoveVertex */ "./src/command/CommandMoveVertex.js");
__webpack_require__(/*! ./command/CommandMoveVertices */ "./src/command/CommandMoveVertices.js");
__webpack_require__(/*! ./command/CommandResize */ "./src/command/CommandResize.js");
__webpack_require__(/*! ./command/CommandRotate */ "./src/command/CommandRotate.js");
__webpack_require__(/*! ./command/CommandConnect */ "./src/command/CommandConnect.js");
__webpack_require__(/*! ./command/CommandReconnect */ "./src/command/CommandReconnect.js");
__webpack_require__(/*! ./command/CommandDelete */ "./src/command/CommandDelete.js");
__webpack_require__(/*! ./command/CommandDeleteGroup */ "./src/command/CommandDeleteGroup.js");
__webpack_require__(/*! ./command/CommandAdd */ "./src/command/CommandAdd.js");
__webpack_require__(/*! ./command/CommandGroup */ "./src/command/CommandGroup.js");
__webpack_require__(/*! ./command/CommandUngroup */ "./src/command/CommandUngroup.js");
__webpack_require__(/*! ./command/CommandAddVertex */ "./src/command/CommandAddVertex.js");
__webpack_require__(/*! ./command/CommandAssignFigure */ "./src/command/CommandAssignFigure.js");
__webpack_require__(/*! ./command/CommandBoundingBox */ "./src/command/CommandBoundingBox.js");
__webpack_require__(/*! ./command/CommandRemoveVertex */ "./src/command/CommandRemoveVertex.js");
__webpack_require__(/*! ./command/CommandReplaceVertices */ "./src/command/CommandReplaceVertices.js");
__webpack_require__(/*! ./layout/connection/ConnectionRouter */ "./src/layout/connection/ConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/DirectRouter */ "./src/layout/connection/DirectRouter.js");
__webpack_require__(/*! ./layout/connection/RubberbandRouter */ "./src/layout/connection/RubberbandRouter.js");
__webpack_require__(/*! ./layout/connection/VertexRouter */ "./src/layout/connection/VertexRouter.js");
__webpack_require__(/*! ./layout/connection/ManhattanConnectionRouter */ "./src/layout/connection/ManhattanConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/ManhattanBridgedConnectionRouter */ "./src/layout/connection/ManhattanBridgedConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/InteractiveManhattanConnectionRouter */ "./src/layout/connection/InteractiveManhattanConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/CircuitConnectionRouter */ "./src/layout/connection/CircuitConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/SplineConnectionRouter */ "./src/layout/connection/SplineConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/FanConnectionRouter */ "./src/layout/connection/FanConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/MazeConnectionRouter */ "./src/layout/connection/MazeConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/MuteableManhattanConnectionRouter */ "./src/layout/connection/MuteableManhattanConnectionRouter.js");
__webpack_require__(/*! ./layout/connection/SketchConnectionRouter */ "./src/layout/connection/SketchConnectionRouter.js");
__webpack_require__(/*! ./layout/mesh/MeshLayouter */ "./src/layout/mesh/MeshLayouter.js");
__webpack_require__(/*! ./layout/mesh/ExplodeLayouter */ "./src/layout/mesh/ExplodeLayouter.js");
__webpack_require__(/*! ./layout/mesh/ProposedMeshChange */ "./src/layout/mesh/ProposedMeshChange.js");
__webpack_require__(/*! ./layout/locator/Locator */ "./src/layout/locator/Locator.js");
__webpack_require__(/*! ./layout/locator/PortLocator */ "./src/layout/locator/PortLocator.js");
__webpack_require__(/*! ./layout/locator/DraggableLocator */ "./src/layout/locator/DraggableLocator.js");
__webpack_require__(/*! ./layout/locator/SmartDraggableLocator */ "./src/layout/locator/SmartDraggableLocator.js");
__webpack_require__(/*! ./layout/locator/XYAbsPortLocator */ "./src/layout/locator/XYAbsPortLocator.js");
__webpack_require__(/*! ./layout/locator/XYRelPortLocator */ "./src/layout/locator/XYRelPortLocator.js");
__webpack_require__(/*! ./layout/locator/InputPortLocator */ "./src/layout/locator/InputPortLocator.js");
__webpack_require__(/*! ./layout/locator/OutputPortLocator */ "./src/layout/locator/OutputPortLocator.js");
__webpack_require__(/*! ./layout/locator/ConnectionLocator */ "./src/layout/locator/ConnectionLocator.js");
__webpack_require__(/*! ./layout/locator/ManhattanMidpointLocator */ "./src/layout/locator/ManhattanMidpointLocator.js");
__webpack_require__(/*! ./layout/locator/PolylineMidpointLocator */ "./src/layout/locator/PolylineMidpointLocator.js");
__webpack_require__(/*! ./layout/locator/ParallelMidpointLocator */ "./src/layout/locator/ParallelMidpointLocator.js");
__webpack_require__(/*! ./layout/locator/TopLocator */ "./src/layout/locator/TopLocator.js");
__webpack_require__(/*! ./layout/locator/BottomLocator */ "./src/layout/locator/BottomLocator.js");
__webpack_require__(/*! ./layout/locator/LeftLocator */ "./src/layout/locator/LeftLocator.js");
__webpack_require__(/*! ./layout/locator/RightLocator */ "./src/layout/locator/RightLocator.js");
__webpack_require__(/*! ./layout/locator/CenterLocator */ "./src/layout/locator/CenterLocator.js");
__webpack_require__(/*! ./policy/EditPolicy */ "./src/policy/EditPolicy.js");
__webpack_require__(/*! ./policy/canvas/CanvasPolicy */ "./src/policy/canvas/CanvasPolicy.js");
__webpack_require__(/*! ./policy/canvas/ZoomPolicy */ "./src/policy/canvas/ZoomPolicy.js");
__webpack_require__(/*! ./policy/canvas/WheelZoomPolicy */ "./src/policy/canvas/WheelZoomPolicy.js");
__webpack_require__(/*! ./policy/canvas/KeyboardPolicy */ "./src/policy/canvas/KeyboardPolicy.js");
__webpack_require__(/*! ./policy/canvas/DefaultKeyboardPolicy */ "./src/policy/canvas/DefaultKeyboardPolicy.js");
__webpack_require__(/*! ./policy/canvas/ExtendedKeyboardPolicy */ "./src/policy/canvas/ExtendedKeyboardPolicy.js");
__webpack_require__(/*! ./policy/canvas/SelectionPolicy */ "./src/policy/canvas/SelectionPolicy.js");
__webpack_require__(/*! ./policy/canvas/SingleSelectionPolicy */ "./src/policy/canvas/SingleSelectionPolicy.js");
__webpack_require__(/*! ./policy/canvas/GhostMoveSelectionPolicy */ "./src/policy/canvas/GhostMoveSelectionPolicy.js");
__webpack_require__(/*! ./policy/canvas/PanningSelectionPolicy */ "./src/policy/canvas/PanningSelectionPolicy.js");
__webpack_require__(/*! ./policy/canvas/BoundingboxSelectionPolicy */ "./src/policy/canvas/BoundingboxSelectionPolicy.js");
__webpack_require__(/*! ./policy/canvas/ReadOnlySelectionPolicy */ "./src/policy/canvas/ReadOnlySelectionPolicy.js");
__webpack_require__(/*! ./policy/canvas/DecorationPolicy */ "./src/policy/canvas/DecorationPolicy.js");
__webpack_require__(/*! ./policy/canvas/FadeoutDecorationPolicy */ "./src/policy/canvas/FadeoutDecorationPolicy.js");
__webpack_require__(/*! ./policy/canvas/CoronaDecorationPolicy */ "./src/policy/canvas/CoronaDecorationPolicy.js");
__webpack_require__(/*! ./policy/canvas/SnapToEditPolicy */ "./src/policy/canvas/SnapToEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/ShowDimetricGridEditPolicy */ "./src/policy/canvas/ShowDimetricGridEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/SnapToDimetricGridEditPolicy */ "./src/policy/canvas/SnapToDimetricGridEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/ShowGridEditPolicy */ "./src/policy/canvas/ShowGridEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/SnapToGridEditPolicy */ "./src/policy/canvas/SnapToGridEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/ShowDotEditPolicy */ "./src/policy/canvas/ShowDotEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/ShowChessboardEditPolicy */ "./src/policy/canvas/ShowChessboardEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/SnapToGeometryEditPolicy */ "./src/policy/canvas/SnapToGeometryEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/SnapToVerticesEditPolicy */ "./src/policy/canvas/SnapToVerticesEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/SnapToInBetweenEditPolicy */ "./src/policy/canvas/SnapToInBetweenEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/SnapToCenterEditPolicy */ "./src/policy/canvas/SnapToCenterEditPolicy.js");
__webpack_require__(/*! ./policy/canvas/DropInterceptorPolicy */ "./src/policy/canvas/DropInterceptorPolicy.js");
__webpack_require__(/*! ./policy/connection/ConnectionCreatePolicy */ "./src/policy/connection/ConnectionCreatePolicy.js");
__webpack_require__(/*! ./policy/connection/ComposedConnectionCreatePolicy */ "./src/policy/connection/ComposedConnectionCreatePolicy.js");
__webpack_require__(/*! ./policy/connection/ClickConnectionCreatePolicy */ "./src/policy/connection/ClickConnectionCreatePolicy.js");
__webpack_require__(/*! ./policy/connection/OrthogonalConnectionCreatePolicy */ "./src/policy/connection/OrthogonalConnectionCreatePolicy.js");
__webpack_require__(/*! ./policy/connection/DragConnectionCreatePolicy */ "./src/policy/connection/DragConnectionCreatePolicy.js");
__webpack_require__(/*! ./policy/figure/FigureEditPolicy */ "./src/policy/figure/FigureEditPolicy.js");
__webpack_require__(/*! ./policy/figure/DragDropEditPolicy */ "./src/policy/figure/DragDropEditPolicy.js");
__webpack_require__(/*! ./policy/figure/RegionEditPolicy */ "./src/policy/figure/RegionEditPolicy.js");
__webpack_require__(/*! ./policy/figure/HorizontalEditPolicy */ "./src/policy/figure/HorizontalEditPolicy.js");
__webpack_require__(/*! ./policy/figure/VerticalEditPolicy */ "./src/policy/figure/VerticalEditPolicy.js");
__webpack_require__(/*! ./policy/figure/SelectionPolicy */ "./src/policy/figure/SelectionPolicy.js");
__webpack_require__(/*! ./policy/figure/SelectionFeedbackPolicy */ "./src/policy/figure/SelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/ResizeSelectionFeedbackPolicy */ "./src/policy/figure/ResizeSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/RectangleSelectionFeedbackPolicy */ "./src/policy/figure/RectangleSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/BigRectangleSelectionFeedbackPolicy */ "./src/policy/figure/BigRectangleSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/RoundRectangleSelectionFeedbackPolicy */ "./src/policy/figure/RoundRectangleSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/BusSelectionFeedbackPolicy */ "./src/policy/figure/BusSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/WidthSelectionFeedbackPolicy */ "./src/policy/figure/WidthSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/VBusSelectionFeedbackPolicy */ "./src/policy/figure/VBusSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/HBusSelectionFeedbackPolicy */ "./src/policy/figure/HBusSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/AntSelectionFeedbackPolicy */ "./src/policy/figure/AntSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/GlowSelectionFeedbackPolicy */ "./src/policy/figure/GlowSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/SlimSelectionFeedbackPolicy */ "./src/policy/figure/SlimSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/figure/VertexSelectionFeedbackPolicy */ "./src/policy/figure/VertexSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/line/LineSelectionFeedbackPolicy */ "./src/policy/line/LineSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/line/VertexSelectionFeedbackPolicy */ "./src/policy/line/VertexSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/line/OrthogonalSelectionFeedbackPolicy */ "./src/policy/line/OrthogonalSelectionFeedbackPolicy.js");
__webpack_require__(/*! ./policy/port/PortFeedbackPolicy */ "./src/policy/port/PortFeedbackPolicy.js");
__webpack_require__(/*! ./policy/port/ElasticStrapFeedbackPolicy */ "./src/policy/port/ElasticStrapFeedbackPolicy.js");
__webpack_require__(/*! ./policy/port/IntrusivePortsFeedbackPolicy */ "./src/policy/port/IntrusivePortsFeedbackPolicy.js");
__webpack_require__(/*! ./Configuration */ "./src/Configuration.js");
__webpack_require__(/*! ./HeadlessCanvas */ "./src/HeadlessCanvas.js");
__webpack_require__(/*! ./Canvas */ "./src/Canvas.js");
__webpack_require__(/*! ./Selection */ "./src/Selection.js");
__webpack_require__(/*! ./Figure */ "./src/Figure.js");
__webpack_require__(/*! ./shape/node/Node */ "./src/shape/node/Node.js");
__webpack_require__(/*! ./VectorFigure */ "./src/VectorFigure.js");
__webpack_require__(/*! ./shape/basic/Rectangle */ "./src/shape/basic/Rectangle.js");
__webpack_require__(/*! ./SetFigure */ "./src/SetFigure.js");
__webpack_require__(/*! ./SVGFigure */ "./src/SVGFigure.js");
__webpack_require__(/*! ./shape/node/Hub */ "./src/shape/node/Hub.js");
__webpack_require__(/*! ./shape/node/HorizontalBus */ "./src/shape/node/HorizontalBus.js");
__webpack_require__(/*! ./shape/node/VerticalBus */ "./src/shape/node/VerticalBus.js");
__webpack_require__(/*! ./shape/node/Fulcrum */ "./src/shape/node/Fulcrum.js");
__webpack_require__(/*! ./shape/basic/Arc */ "./src/shape/basic/Arc.js");
__webpack_require__(/*! ./shape/basic/Oval */ "./src/shape/basic/Oval.js");
__webpack_require__(/*! ./shape/basic/Circle */ "./src/shape/basic/Circle.js");
__webpack_require__(/*! ./shape/basic/Label */ "./src/shape/basic/Label.js");
__webpack_require__(/*! ./shape/basic/Text */ "./src/shape/basic/Text.js");
__webpack_require__(/*! ./shape/basic/Line */ "./src/shape/basic/Line.js");
__webpack_require__(/*! ./shape/basic/PolyLine */ "./src/shape/basic/PolyLine.js");
__webpack_require__(/*! ./shape/basic/Image */ "./src/shape/basic/Image.js");
__webpack_require__(/*! ./shape/basic/Polygon */ "./src/shape/basic/Polygon.js");
__webpack_require__(/*! ./shape/basic/Diamond */ "./src/shape/basic/Diamond.js");
__webpack_require__(/*! ./shape/dimetric/Rectangle */ "./src/shape/dimetric/Rectangle.js");
__webpack_require__(/*! ./shape/composite/Composite */ "./src/shape/composite/Composite.js");
__webpack_require__(/*! ./shape/composite/StrongComposite */ "./src/shape/composite/StrongComposite.js");
__webpack_require__(/*! ./shape/composite/Group */ "./src/shape/composite/Group.js");
__webpack_require__(/*! ./shape/composite/Jailhouse */ "./src/shape/composite/Jailhouse.js");
__webpack_require__(/*! ./shape/composite/WeakComposite */ "./src/shape/composite/WeakComposite.js");
__webpack_require__(/*! ./shape/composite/Raft */ "./src/shape/composite/Raft.js");
__webpack_require__(/*! ./Connection */ "./src/Connection.js");
__webpack_require__(/*! ./VectorFigure */ "./src/VectorFigure.js");
__webpack_require__(/*! ./ResizeHandle */ "./src/ResizeHandle.js");
__webpack_require__(/*! ./shape/basic/LineResizeHandle */ "./src/shape/basic/LineResizeHandle.js");
__webpack_require__(/*! ./shape/basic/LineStartResizeHandle */ "./src/shape/basic/LineStartResizeHandle.js");
__webpack_require__(/*! ./shape/basic/LineEndResizeHandle */ "./src/shape/basic/LineEndResizeHandle.js");
__webpack_require__(/*! ./shape/basic/VertexResizeHandle */ "./src/shape/basic/VertexResizeHandle.js");
__webpack_require__(/*! ./shape/basic/GhostVertexResizeHandle */ "./src/shape/basic/GhostVertexResizeHandle.js");
__webpack_require__(/*! ./Port */ "./src/Port.js");
__webpack_require__(/*! ./InputPort */ "./src/InputPort.js");
__webpack_require__(/*! ./OutputPort */ "./src/OutputPort.js");
__webpack_require__(/*! ./HybridPort */ "./src/HybridPort.js");
__webpack_require__(/*! ./layout/anchor/ConnectionAnchor */ "./src/layout/anchor/ConnectionAnchor.js");
__webpack_require__(/*! ./layout/anchor/ChopboxConnectionAnchor */ "./src/layout/anchor/ChopboxConnectionAnchor.js");
__webpack_require__(/*! ./layout/anchor/FanConnectionAnchor */ "./src/layout/anchor/FanConnectionAnchor.js");
__webpack_require__(/*! ./layout/anchor/ShortesPathConnectionAnchor */ "./src/layout/anchor/ShortesPathConnectionAnchor.js");
__webpack_require__(/*! ./layout/anchor/CenterEdgeConnectionAnchor */ "./src/layout/anchor/CenterEdgeConnectionAnchor.js");
__webpack_require__(/*! ./shape/arrow/CalligrapherArrowLeft */ "./src/shape/arrow/CalligrapherArrowLeft.js");
__webpack_require__(/*! ./shape/arrow/CalligrapherArrowDownLeft */ "./src/shape/arrow/CalligrapherArrowDownLeft.js");
__webpack_require__(/*! ./shape/node/Start */ "./src/shape/node/Start.js");
__webpack_require__(/*! ./shape/node/End */ "./src/shape/node/End.js");
__webpack_require__(/*! ./shape/node/Between */ "./src/shape/node/Between.js");
__webpack_require__(/*! ./shape/note/PostIt */ "./src/shape/note/PostIt.js");
__webpack_require__(/*! ./shape/flowchart/Document */ "./src/shape/flowchart/Document.js");
__webpack_require__(/*! ./shape/widget/Widget */ "./src/shape/widget/Widget.js");
__webpack_require__(/*! ./shape/widget/Slider */ "./src/shape/widget/Slider.js");
__webpack_require__(/*! ./shape/diagram/Diagram */ "./src/shape/diagram/Diagram.js");
__webpack_require__(/*! ./shape/diagram/Pie */ "./src/shape/diagram/Pie.js");
__webpack_require__(/*! ./shape/diagram/Sparkline */ "./src/shape/diagram/Sparkline.js");
__webpack_require__(/*! ./shape/analog/OpAmp */ "./src/shape/analog/OpAmp.js");
__webpack_require__(/*! ./shape/analog/ResistorBridge */ "./src/shape/analog/ResistorBridge.js");
__webpack_require__(/*! ./shape/analog/ResistorVertical */ "./src/shape/analog/ResistorVertical.js");
__webpack_require__(/*! ./shape/analog/VoltageSupplyHorizontal */ "./src/shape/analog/VoltageSupplyHorizontal.js");
__webpack_require__(/*! ./shape/analog/VoltageSupplyVertical */ "./src/shape/analog/VoltageSupplyVertical.js");
__webpack_require__(/*! ./shape/layout/Layout */ "./src/shape/layout/Layout.js");
__webpack_require__(/*! ./shape/layout/HorizontalLayout */ "./src/shape/layout/HorizontalLayout.js");
__webpack_require__(/*! ./shape/layout/VerticalLayout */ "./src/shape/layout/VerticalLayout.js");
__webpack_require__(/*! ./shape/layout/TableLayout */ "./src/shape/layout/TableLayout.js");
__webpack_require__(/*! ./shape/layout/FlexGridLayout */ "./src/shape/layout/FlexGridLayout.js");
__webpack_require__(/*! ./shape/layout/StackLayout */ "./src/shape/layout/StackLayout.js");
__webpack_require__(/*! ./shape/icon/Icon */ "./src/shape/icon/Icon.js");
__webpack_require__(/*! ./shape/icon/Thunder */ "./src/shape/icon/Thunder.js");
__webpack_require__(/*! ./shape/icon/Snow */ "./src/shape/icon/Snow.js");
__webpack_require__(/*! ./shape/icon/Hail */ "./src/shape/icon/Hail.js");
__webpack_require__(/*! ./shape/icon/Rain */ "./src/shape/icon/Rain.js");
__webpack_require__(/*! ./shape/icon/Cloudy */ "./src/shape/icon/Cloudy.js");
__webpack_require__(/*! ./shape/icon/Sun */ "./src/shape/icon/Sun.js");
__webpack_require__(/*! ./shape/icon/Undo */ "./src/shape/icon/Undo.js");
__webpack_require__(/*! ./shape/icon/Detour */ "./src/shape/icon/Detour.js");
__webpack_require__(/*! ./shape/icon/Merge */ "./src/shape/icon/Merge.js");
__webpack_require__(/*! ./shape/icon/Split */ "./src/shape/icon/Split.js");
__webpack_require__(/*! ./shape/icon/Fork */ "./src/shape/icon/Fork.js");
__webpack_require__(/*! ./shape/icon/ForkAlt */ "./src/shape/icon/ForkAlt.js");
__webpack_require__(/*! ./shape/icon/Exchange */ "./src/shape/icon/Exchange.js");
__webpack_require__(/*! ./shape/icon/Shuffle */ "./src/shape/icon/Shuffle.js");
__webpack_require__(/*! ./shape/icon/Refresh */ "./src/shape/icon/Refresh.js");
__webpack_require__(/*! ./shape/icon/Ccw */ "./src/shape/icon/Ccw.js");
__webpack_require__(/*! ./shape/icon/Acw */ "./src/shape/icon/Acw.js");
__webpack_require__(/*! ./shape/icon/Contract */ "./src/shape/icon/Contract.js");
__webpack_require__(/*! ./shape/icon/Expand */ "./src/shape/icon/Expand.js");
__webpack_require__(/*! ./shape/icon/Stop */ "./src/shape/icon/Stop.js");
__webpack_require__(/*! ./shape/icon/End */ "./src/shape/icon/End.js");
__webpack_require__(/*! ./shape/icon/Start */ "./src/shape/icon/Start.js");
__webpack_require__(/*! ./shape/icon/Ff */ "./src/shape/icon/Ff.js");
__webpack_require__(/*! ./shape/icon/Rw */ "./src/shape/icon/Rw.js");
__webpack_require__(/*! ./shape/icon/ArrowRight */ "./src/shape/icon/ArrowRight.js");
__webpack_require__(/*! ./shape/icon/ArrowLeft */ "./src/shape/icon/ArrowLeft.js");
__webpack_require__(/*! ./shape/icon/ArrowUp */ "./src/shape/icon/ArrowUp.js");
__webpack_require__(/*! ./shape/icon/ArrowDown */ "./src/shape/icon/ArrowDown.js");
__webpack_require__(/*! ./shape/icon/ArrowLeft2 */ "./src/shape/icon/ArrowLeft2.js");
__webpack_require__(/*! ./shape/icon/ArrowRight2 */ "./src/shape/icon/ArrowRight2.js");
__webpack_require__(/*! ./shape/icon/Smile2 */ "./src/shape/icon/Smile2.js");
__webpack_require__(/*! ./shape/icon/Smile */ "./src/shape/icon/Smile.js");
__webpack_require__(/*! ./shape/icon/Alarm */ "./src/shape/icon/Alarm.js");
__webpack_require__(/*! ./shape/icon/Clock */ "./src/shape/icon/Clock.js");
__webpack_require__(/*! ./shape/icon/StopWatch */ "./src/shape/icon/StopWatch.js");
__webpack_require__(/*! ./shape/icon/History */ "./src/shape/icon/History.js");
__webpack_require__(/*! ./shape/icon/Future */ "./src/shape/icon/Future.js");
__webpack_require__(/*! ./shape/icon/GlobeAlt2 */ "./src/shape/icon/GlobeAlt2.js");
__webpack_require__(/*! ./shape/icon/GlobeAlt */ "./src/shape/icon/GlobeAlt.js");
__webpack_require__(/*! ./shape/icon/Globe */ "./src/shape/icon/Globe.js");
__webpack_require__(/*! ./shape/icon/Warning */ "./src/shape/icon/Warning.js");
__webpack_require__(/*! ./shape/icon/Code */ "./src/shape/icon/Code.js");
__webpack_require__(/*! ./shape/icon/Pensil */ "./src/shape/icon/Pensil.js");
__webpack_require__(/*! ./shape/icon/Pen */ "./src/shape/icon/Pen.js");
__webpack_require__(/*! ./shape/icon/Plus */ "./src/shape/icon/Plus.js");
__webpack_require__(/*! ./shape/icon/Minus */ "./src/shape/icon/Minus.js");
__webpack_require__(/*! ./shape/icon/TShirt */ "./src/shape/icon/TShirt.js");
__webpack_require__(/*! ./shape/icon/Sticker */ "./src/shape/icon/Sticker.js");
__webpack_require__(/*! ./shape/icon/Page2 */ "./src/shape/icon/Page2.js");
__webpack_require__(/*! ./shape/icon/Page */ "./src/shape/icon/Page.js");
__webpack_require__(/*! ./shape/icon/Landscape1 */ "./src/shape/icon/Landscape1.js");
__webpack_require__(/*! ./shape/icon/Landscape2 */ "./src/shape/icon/Landscape2.js");
__webpack_require__(/*! ./shape/icon/Plugin */ "./src/shape/icon/Plugin.js");
__webpack_require__(/*! ./shape/icon/Bookmark */ "./src/shape/icon/Bookmark.js");
__webpack_require__(/*! ./shape/icon/Hammer */ "./src/shape/icon/Hammer.js");
__webpack_require__(/*! ./shape/icon/Users */ "./src/shape/icon/Users.js");
__webpack_require__(/*! ./shape/icon/User */ "./src/shape/icon/User.js");
__webpack_require__(/*! ./shape/icon/Customer */ "./src/shape/icon/Customer.js");
__webpack_require__(/*! ./shape/icon/Employee */ "./src/shape/icon/Employee.js");
__webpack_require__(/*! ./shape/icon/Anonymous */ "./src/shape/icon/Anonymous.js");
__webpack_require__(/*! ./shape/icon/Skull */ "./src/shape/icon/Skull.js");
__webpack_require__(/*! ./shape/icon/Mail */ "./src/shape/icon/Mail.js");
__webpack_require__(/*! ./shape/icon/Picture */ "./src/shape/icon/Picture.js");
__webpack_require__(/*! ./shape/icon/Bubble */ "./src/shape/icon/Bubble.js");
__webpack_require__(/*! ./shape/icon/CodeTalk */ "./src/shape/icon/CodeTalk.js");
__webpack_require__(/*! ./shape/icon/Talkq */ "./src/shape/icon/Talkq.js");
__webpack_require__(/*! ./shape/icon/Talke */ "./src/shape/icon/Talke.js");
__webpack_require__(/*! ./shape/icon/Home */ "./src/shape/icon/Home.js");
__webpack_require__(/*! ./shape/icon/Lock */ "./src/shape/icon/Lock.js");
__webpack_require__(/*! ./shape/icon/Clip */ "./src/shape/icon/Clip.js");
__webpack_require__(/*! ./shape/icon/Star */ "./src/shape/icon/Star.js");
__webpack_require__(/*! ./shape/icon/StarOff */ "./src/shape/icon/StarOff.js");
__webpack_require__(/*! ./shape/icon/Star2 */ "./src/shape/icon/Star2.js");
__webpack_require__(/*! ./shape/icon/Star2Off */ "./src/shape/icon/Star2Off.js");
__webpack_require__(/*! ./shape/icon/Star3 */ "./src/shape/icon/Star3.js");
__webpack_require__(/*! ./shape/icon/Star3Off */ "./src/shape/icon/Star3Off.js");
__webpack_require__(/*! ./shape/icon/Chat */ "./src/shape/icon/Chat.js");
__webpack_require__(/*! ./shape/icon/Quote */ "./src/shape/icon/Quote.js");
__webpack_require__(/*! ./shape/icon/Gear2 */ "./src/shape/icon/Gear2.js");
__webpack_require__(/*! ./shape/icon/Gear */ "./src/shape/icon/Gear.js");
__webpack_require__(/*! ./shape/icon/Wrench */ "./src/shape/icon/Wrench.js");
__webpack_require__(/*! ./shape/icon/Wrench2 */ "./src/shape/icon/Wrench2.js");
__webpack_require__(/*! ./shape/icon/Wrench3 */ "./src/shape/icon/Wrench3.js");
__webpack_require__(/*! ./shape/icon/ScrewDriver */ "./src/shape/icon/ScrewDriver.js");
__webpack_require__(/*! ./shape/icon/HammerAndScrewDriver */ "./src/shape/icon/HammerAndScrewDriver.js");
__webpack_require__(/*! ./shape/icon/Magic */ "./src/shape/icon/Magic.js");
__webpack_require__(/*! ./shape/icon/Download */ "./src/shape/icon/Download.js");
__webpack_require__(/*! ./shape/icon/View */ "./src/shape/icon/View.js");
__webpack_require__(/*! ./shape/icon/Noview */ "./src/shape/icon/Noview.js");
__webpack_require__(/*! ./shape/icon/Cloud */ "./src/shape/icon/Cloud.js");
__webpack_require__(/*! ./shape/icon/Cloud2 */ "./src/shape/icon/Cloud2.js");
__webpack_require__(/*! ./shape/icon/CloudDown */ "./src/shape/icon/CloudDown.js");
__webpack_require__(/*! ./shape/icon/CloudUp */ "./src/shape/icon/CloudUp.js");
__webpack_require__(/*! ./shape/icon/Location */ "./src/shape/icon/Location.js");
__webpack_require__(/*! ./shape/icon/Volume0 */ "./src/shape/icon/Volume0.js");
__webpack_require__(/*! ./shape/icon/Volume1 */ "./src/shape/icon/Volume1.js");
__webpack_require__(/*! ./shape/icon/Volume2 */ "./src/shape/icon/Volume2.js");
__webpack_require__(/*! ./shape/icon/Volume3 */ "./src/shape/icon/Volume3.js");
__webpack_require__(/*! ./shape/icon/Key */ "./src/shape/icon/Key.js");
__webpack_require__(/*! ./shape/icon/Ruler */ "./src/shape/icon/Ruler.js");
__webpack_require__(/*! ./shape/icon/Power */ "./src/shape/icon/Power.js");
__webpack_require__(/*! ./shape/icon/Unlock */ "./src/shape/icon/Unlock.js");
__webpack_require__(/*! ./shape/icon/Flag */ "./src/shape/icon/Flag.js");
__webpack_require__(/*! ./shape/icon/Tag */ "./src/shape/icon/Tag.js");
__webpack_require__(/*! ./shape/icon/Search */ "./src/shape/icon/Search.js");
__webpack_require__(/*! ./shape/icon/ZoomOut */ "./src/shape/icon/ZoomOut.js");
__webpack_require__(/*! ./shape/icon/ZoomIn */ "./src/shape/icon/ZoomIn.js");
__webpack_require__(/*! ./shape/icon/Cross */ "./src/shape/icon/Cross.js");
__webpack_require__(/*! ./shape/icon/Check */ "./src/shape/icon/Check.js");
__webpack_require__(/*! ./shape/icon/Settings */ "./src/shape/icon/Settings.js");
__webpack_require__(/*! ./shape/icon/SettingsAlt */ "./src/shape/icon/SettingsAlt.js");
__webpack_require__(/*! ./shape/icon/Feed */ "./src/shape/icon/Feed.js");
__webpack_require__(/*! ./shape/icon/Bug */ "./src/shape/icon/Bug.js");
__webpack_require__(/*! ./shape/icon/Link */ "./src/shape/icon/Link.js");
__webpack_require__(/*! ./shape/icon/Calendar */ "./src/shape/icon/Calendar.js");
__webpack_require__(/*! ./shape/icon/Picker */ "./src/shape/icon/Picker.js");
__webpack_require__(/*! ./shape/icon/No */ "./src/shape/icon/No.js");
__webpack_require__(/*! ./shape/icon/CommandLine */ "./src/shape/icon/CommandLine.js");
__webpack_require__(/*! ./shape/icon/Photo */ "./src/shape/icon/Photo.js");
__webpack_require__(/*! ./shape/icon/Printer */ "./src/shape/icon/Printer.js");
__webpack_require__(/*! ./shape/icon/Export */ "./src/shape/icon/Export.js");
__webpack_require__(/*! ./shape/icon/Import */ "./src/shape/icon/Import.js");
__webpack_require__(/*! ./shape/icon/Run */ "./src/shape/icon/Run.js");
__webpack_require__(/*! ./shape/icon/Magnet */ "./src/shape/icon/Magnet.js");
__webpack_require__(/*! ./shape/icon/NoMagnet */ "./src/shape/icon/NoMagnet.js");
__webpack_require__(/*! ./shape/icon/ReflectH */ "./src/shape/icon/ReflectH.js");
__webpack_require__(/*! ./shape/icon/ReflectV */ "./src/shape/icon/ReflectV.js");
__webpack_require__(/*! ./shape/icon/Resize2 */ "./src/shape/icon/Resize2.js");
__webpack_require__(/*! ./shape/icon/Rotate */ "./src/shape/icon/Rotate.js");
__webpack_require__(/*! ./shape/icon/Connect */ "./src/shape/icon/Connect.js");
__webpack_require__(/*! ./shape/icon/Disconnect */ "./src/shape/icon/Disconnect.js");
__webpack_require__(/*! ./shape/icon/Folder */ "./src/shape/icon/Folder.js");
__webpack_require__(/*! ./shape/icon/Man */ "./src/shape/icon/Man.js");
__webpack_require__(/*! ./shape/icon/Woman */ "./src/shape/icon/Woman.js");
__webpack_require__(/*! ./shape/icon/People */ "./src/shape/icon/People.js");
__webpack_require__(/*! ./shape/icon/Parent */ "./src/shape/icon/Parent.js");
__webpack_require__(/*! ./shape/icon/Notebook */ "./src/shape/icon/Notebook.js");
__webpack_require__(/*! ./shape/icon/Diagram */ "./src/shape/icon/Diagram.js");
__webpack_require__(/*! ./shape/icon/BarChart */ "./src/shape/icon/BarChart.js");
__webpack_require__(/*! ./shape/icon/PieChart */ "./src/shape/icon/PieChart.js");
__webpack_require__(/*! ./shape/icon/LineChart */ "./src/shape/icon/LineChart.js");
__webpack_require__(/*! ./shape/icon/Apps */ "./src/shape/icon/Apps.js");
__webpack_require__(/*! ./shape/icon/Locked */ "./src/shape/icon/Locked.js");
__webpack_require__(/*! ./shape/icon/Ppt */ "./src/shape/icon/Ppt.js");
__webpack_require__(/*! ./shape/icon/Lab */ "./src/shape/icon/Lab.js");
__webpack_require__(/*! ./shape/icon/Umbrella */ "./src/shape/icon/Umbrella.js");
__webpack_require__(/*! ./shape/icon/Dry */ "./src/shape/icon/Dry.js");
__webpack_require__(/*! ./shape/icon/Ipad */ "./src/shape/icon/Ipad.js");
__webpack_require__(/*! ./shape/icon/Iphone */ "./src/shape/icon/Iphone.js");
__webpack_require__(/*! ./shape/icon/Jigsaw */ "./src/shape/icon/Jigsaw.js");
__webpack_require__(/*! ./shape/icon/Lamp */ "./src/shape/icon/Lamp.js");
__webpack_require__(/*! ./shape/icon/Lamp_alt */ "./src/shape/icon/Lamp_alt.js");
__webpack_require__(/*! ./shape/icon/Video */ "./src/shape/icon/Video.js");
__webpack_require__(/*! ./shape/icon/Palm */ "./src/shape/icon/Palm.js");
__webpack_require__(/*! ./shape/icon/Fave */ "./src/shape/icon/Fave.js");
__webpack_require__(/*! ./shape/icon/Help */ "./src/shape/icon/Help.js");
__webpack_require__(/*! ./shape/icon/Crop */ "./src/shape/icon/Crop.js");
__webpack_require__(/*! ./shape/icon/BioHazard */ "./src/shape/icon/BioHazard.js");
__webpack_require__(/*! ./shape/icon/WheelChair */ "./src/shape/icon/WheelChair.js");
__webpack_require__(/*! ./shape/icon/Mic */ "./src/shape/icon/Mic.js");
__webpack_require__(/*! ./shape/icon/MicMute */ "./src/shape/icon/MicMute.js");
__webpack_require__(/*! ./shape/icon/IMac */ "./src/shape/icon/IMac.js");
__webpack_require__(/*! ./shape/icon/Pc */ "./src/shape/icon/Pc.js");
__webpack_require__(/*! ./shape/icon/Cube */ "./src/shape/icon/Cube.js");
__webpack_require__(/*! ./shape/icon/FullCube */ "./src/shape/icon/FullCube.js");
__webpack_require__(/*! ./shape/icon/Font */ "./src/shape/icon/Font.js");
__webpack_require__(/*! ./shape/icon/Trash */ "./src/shape/icon/Trash.js");
__webpack_require__(/*! ./shape/icon/NewWindow */ "./src/shape/icon/NewWindow.js");
__webpack_require__(/*! ./shape/icon/DockRight */ "./src/shape/icon/DockRight.js");
__webpack_require__(/*! ./shape/icon/DockLeft */ "./src/shape/icon/DockLeft.js");
__webpack_require__(/*! ./shape/icon/DockBottom */ "./src/shape/icon/DockBottom.js");
__webpack_require__(/*! ./shape/icon/DockTop */ "./src/shape/icon/DockTop.js");
__webpack_require__(/*! ./shape/icon/Pallete */ "./src/shape/icon/Pallete.js");
__webpack_require__(/*! ./shape/icon/Cart */ "./src/shape/icon/Cart.js");
__webpack_require__(/*! ./shape/icon/Glasses */ "./src/shape/icon/Glasses.js");
__webpack_require__(/*! ./shape/icon/Package */ "./src/shape/icon/Package.js");
__webpack_require__(/*! ./shape/icon/Book */ "./src/shape/icon/Book.js");
__webpack_require__(/*! ./shape/icon/Books */ "./src/shape/icon/Books.js");
__webpack_require__(/*! ./shape/icon/Icons */ "./src/shape/icon/Icons.js");
__webpack_require__(/*! ./shape/icon/List */ "./src/shape/icon/List.js");
__webpack_require__(/*! ./shape/icon/Db */ "./src/shape/icon/Db.js");
__webpack_require__(/*! ./shape/icon/Paper */ "./src/shape/icon/Paper.js");
__webpack_require__(/*! ./shape/icon/TakeOff */ "./src/shape/icon/TakeOff.js");
__webpack_require__(/*! ./shape/icon/Landing */ "./src/shape/icon/Landing.js");
__webpack_require__(/*! ./shape/icon/Plane */ "./src/shape/icon/Plane.js");
__webpack_require__(/*! ./shape/icon/Phone */ "./src/shape/icon/Phone.js");
__webpack_require__(/*! ./shape/icon/HangUp */ "./src/shape/icon/HangUp.js");
__webpack_require__(/*! ./shape/icon/SlideShare */ "./src/shape/icon/SlideShare.js");
__webpack_require__(/*! ./shape/icon/Twitter */ "./src/shape/icon/Twitter.js");
__webpack_require__(/*! ./shape/icon/TwitterBird */ "./src/shape/icon/TwitterBird.js");
__webpack_require__(/*! ./shape/icon/Skype */ "./src/shape/icon/Skype.js");
__webpack_require__(/*! ./shape/icon/Windows */ "./src/shape/icon/Windows.js");
__webpack_require__(/*! ./shape/icon/Apple */ "./src/shape/icon/Apple.js");
__webpack_require__(/*! ./shape/icon/Linux */ "./src/shape/icon/Linux.js");
__webpack_require__(/*! ./shape/icon/NodeJs */ "./src/shape/icon/NodeJs.js");
__webpack_require__(/*! ./shape/icon/JQuery */ "./src/shape/icon/JQuery.js");
__webpack_require__(/*! ./shape/icon/Sencha */ "./src/shape/icon/Sencha.js");
__webpack_require__(/*! ./shape/icon/Vim */ "./src/shape/icon/Vim.js");
__webpack_require__(/*! ./shape/icon/InkScape */ "./src/shape/icon/InkScape.js");
__webpack_require__(/*! ./shape/icon/Aumade */ "./src/shape/icon/Aumade.js");
__webpack_require__(/*! ./shape/icon/Firefox */ "./src/shape/icon/Firefox.js");
__webpack_require__(/*! ./shape/icon/Ie */ "./src/shape/icon/Ie.js");
__webpack_require__(/*! ./shape/icon/Ie9 */ "./src/shape/icon/Ie9.js");
__webpack_require__(/*! ./shape/icon/Opera */ "./src/shape/icon/Opera.js");
__webpack_require__(/*! ./shape/icon/Chrome */ "./src/shape/icon/Chrome.js");
__webpack_require__(/*! ./shape/icon/Safari */ "./src/shape/icon/Safari.js");
__webpack_require__(/*! ./shape/icon/LinkedIn */ "./src/shape/icon/LinkedIn.js");
__webpack_require__(/*! ./shape/icon/Flickr */ "./src/shape/icon/Flickr.js");
__webpack_require__(/*! ./shape/icon/GitHub */ "./src/shape/icon/GitHub.js");
__webpack_require__(/*! ./shape/icon/GitHubAlt */ "./src/shape/icon/GitHubAlt.js");
__webpack_require__(/*! ./shape/icon/Raphael */ "./src/shape/icon/Raphael.js");
__webpack_require__(/*! ./shape/icon/GRaphael */ "./src/shape/icon/GRaphael.js");
__webpack_require__(/*! ./shape/icon/Svg */ "./src/shape/icon/Svg.js");
__webpack_require__(/*! ./shape/icon/Usb */ "./src/shape/icon/Usb.js");
__webpack_require__(/*! ./shape/icon/Ethernet */ "./src/shape/icon/Ethernet.js");
__webpack_require__(/*! ./shape/pert/Activity */ "./src/shape/pert/Activity.js");
__webpack_require__(/*! ./shape/pert/Start */ "./src/shape/pert/Start.js");
__webpack_require__(/*! ./shape/state/Start */ "./src/shape/state/Start.js");
__webpack_require__(/*! ./shape/state/End */ "./src/shape/state/End.js");
__webpack_require__(/*! ./shape/state/State */ "./src/shape/state/State.js");
__webpack_require__(/*! ./shape/state/Connection */ "./src/shape/state/Connection.js");
__webpack_require__(/*! ./ui/LabelEditor */ "./src/ui/LabelEditor.js");
__webpack_require__(/*! ./ui/LabelInplaceEditor */ "./src/ui/LabelInplaceEditor.js");
__webpack_require__(/*! ./decoration/connection/Decorator */ "./src/decoration/connection/Decorator.js");
__webpack_require__(/*! ./decoration/connection/ArrowDecorator */ "./src/decoration/connection/ArrowDecorator.js");
__webpack_require__(/*! ./decoration/connection/DiamondDecorator */ "./src/decoration/connection/DiamondDecorator.js");
__webpack_require__(/*! ./decoration/connection/CircleDecorator */ "./src/decoration/connection/CircleDecorator.js");
__webpack_require__(/*! ./decoration/connection/BarDecorator */ "./src/decoration/connection/BarDecorator.js");
__webpack_require__(/*! ./io/Reader */ "./src/io/Reader.js");
__webpack_require__(/*! ./io/Writer */ "./src/io/Writer.js");
__webpack_require__(/*! ./io/svg/Writer */ "./src/io/svg/Writer.js");
__webpack_require__(/*! ./io/png/Writer */ "./src/io/png/Writer.js");
__webpack_require__(/*! ./io/json/Writer */ "./src/io/json/Writer.js");
__webpack_require__(/*! ./io/json/Reader */ "./src/io/json/Reader.js");

/***/ }),

/***/ "./src/io/Reader.js":
/*!**************************!*\
  !*** ./src/io/Reader.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Template class for general import of a document into the canvas.
 *
 * @author andreas Herz
 */
_packages2.default.io.Reader = Class.extend(
/** @lends draw2d.io.Reader */
{

  init: function init() {},

  /**
   *
   *
   * Restore the canvas from a given String.
   *
   * @param {draw2d.Canvas} canvas the canvas to restore
   * @param {Object} document the document to read
   *
   * @returns {draw2d.util.ArrayList} the added elements
   * @template
   */
  unmarshal: function unmarshal(canvas, document) {
    // do nothing. Inherit classes must implement this method
  }

});

/***/ }),

/***/ "./src/io/Writer.js":
/*!**************************!*\
  !*** ./src/io/Writer.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Serialize the canvas to an external format. This is only a template/interface class.
 * Inherit classes must implement the export format.
 *
 * @author Andreas Herz
 */
_packages2.default.io.Writer = Class.extend(
/** @lends draw2d.io.Writer */

{
    init: function init() {},

    /**
     * 
     * Export the content to the implemented data format. Inherit class implements
     * content specific writer.
     * <br>
     * <br>
     *
     * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
     * The parameter <b>resultCallback</b> is required and new. The method calls
     * the callback instead of return the result.
     *
     * @template
     * @since 2.10.1
     * @param {draw2d.Canvas} canvas
     * @param {Function} resultCallback the method to call on success. The first argument is the result object, the second the base64 content of a corresponding file
     * @returns {Object}
     *
     */
    marshal: function marshal(canvas, resultCallback) {
        // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
        // if any application not care about this changes.
        if (typeof resultCallback !== "function") {
            throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
        }

        resultCallback("", "");
    },

    /**
     * 
     * utility method to format a given XML string.
     *
     * @param xml
     * @returns {String}
     */
    formatXml: function formatXml(xml) {
        var formatted = '';
        var reg = new RegExp("(>)(<)(\/*)", "g");
        xml = xml.replace(reg, '$1\r\n$2$3');
        var pad = 0;
        xml.split('\r\n').forEach(function (node) {
            var indent = 0;
            if (node.match(new RegExp(".+<\/\w[^>]*>$"))) {
                indent = 0;
            } else if (node.match(new RegExp("^<\/\w"))) {
                if (pad != 0) {
                    pad -= 1;
                }
            } else if (node.match(new RegExp("^<\w[^>]*[^\/]>.*$"))) {
                indent = 1;
            } else {
                indent = 0;
            }

            var padding = '';
            for (var i = 0; i < pad; i++) {
                padding += '  ';
            }

            formatted += padding + node + '\r\n';
            pad += indent;
        });

        return formatted;
    }
});

/***/ }),

/***/ "./src/io/json/Reader.js":
/*!*******************************!*\
  !*** ./src/io/json/Reader.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Read a JSON data and import them into the canvas. The JSON must be generated with the
 * {@link draw2d.io.json.Writer}.
 *
 * @example
 *
 *     // Load a standard draw2d JSON object into the canvas
 *     //
 *     let jsonDocument =
 *         [
 *          {
 *             "type": "draw2d.shape.basic.Oval",
 *             "id": "5b4c74 b0-96d1-1aa3-7eca-bbeaed5fffd7",
 *             "x": 237,
 *             "y": 236,
 *             "width": 93,
 *             "height": 38
 *           },
 *           {
 *             "type": "draw2d.shape.basic.Rectangle",
 *             "id": "354fa3b9-a834-0221-2009-abc2d6bd852a",
 *             "x": 225,
 *             "y": 97,
 *             "width": 201,
 *             "height": 82,
 *             "radius": 2
 *           }
 *         ];
 *     // unmarshal the JSON document into the canvas
 *     // (load)
 *     let reader = new draw2d.io.json.Reader();
 *     reader.unmarshal(canvas, jsonDocument);
 *
 *
 * @author Andreas Herz
 * @extends draw2d.io.Reader
 */
_packages2.default.io.json.Reader = _packages2.default.io.Reader.extend(
/** @lends draw2d.io.json.Reader.prototype */
{
  NAME: "draw2d.io.json.Reader",

  init: function init() {
    this._super();
  },

  /**
   *
   *
   * Restore the canvas from a given JSON object.
   *
   * @param {draw2d.Canvas} canvas the canvas to restore
   * @param {Object|String} json the json object to load.
   */
  unmarshal: function unmarshal(canvas, json) {
    var _this = this;

    var result = new _packages2.default.util.ArrayList();

    if (typeof json === "string") {
      json = JSON.parse(json);
    }

    var node = null;
    json.forEach(function (element) {
      try {
        var o = _this.createFigureFromElement(element) || _this.createFigureFromType(element.type);
        var source = null;
        var target = null;
        for (var i in element) {
          var val = element[i];
          if (i === "source") {
            node = canvas.getFigure(val.node);
            if (node === null) {
              throw "Source figure with id '" + val.node + "' not found";
            }
            source = node.getPort(val.port);
            if (source === null) {
              throw "Unable to find source port '" + val.port + "' at figure '" + val.node + "' to unmarschal '" + element.type + "'";
            }
          } else if (i === "target") {
            node = canvas.getFigure(val.node);
            if (node === null) {
              throw "Target figure with id '" + val.node + "' not found";
            }
            target = node.getPort(val.port);
            if (target === null) {
              throw "Unable to find target port '" + val.port + "' at figure '" + val.node + "' to unmarschal '" + element.type + "'";
            }
          }
        }
        if (source !== null && target !== null) {
          // don't change the order or the source/target set.
          // TARGET must always be the second one because some applications needs the "source"
          // port in the "connect" event of the target.
          o.setSource(source);
          o.setTarget(target);
        }
        o.setPersistentAttributes(element);
        canvas.add(o);
        result.add(o);
      } catch (exc) {
        debug.error(element, "Unable to instantiate figure type '" + element.type + "' with id '" + element.id + "' during unmarshal by " + _this.NAME + ". Skipping figure..");
        debug.error(exc);
        debug.warn(element);
      }
    });

    // restore group assignment
    //
    json.forEach(function (element) {
      if (typeof element.composite !== "undefined") {
        var figure = canvas.getFigure(element.id);
        if (figure === null) {
          figure = canvas.getLine(element.id);
        }
        var group = canvas.getFigure(element.composite);
        group.assignFigure(figure);
      }
    });

    // recalculate all crossings and repaint the connections with
    // possible crossing decoration
    canvas.calculateConnectionIntersection();
    canvas.getLines().each(function (i, line) {
      line.svgPathString = null;
      line.repaint();
    });
    canvas.linesToRepaintAfterDragDrop = canvas.getLines().clone();

    canvas.showDecoration();

    return result;
  },

  /**
   *
   * Factory method to create an instance of the given element type.
   *
   * @param {String} type
   * @returns {draw2d.Figure}
   */
  createFigureFromType: function createFigureFromType(type) {
    return eval("new " + type + "()");
  },

  /**
   *
   * Factory method to create an instance of the given element.
   *
   * @param {Object} element
   * @returns {draw2d.Figure}
   */
  createFigureFromElement: function createFigureFromElement(element) {
    return null;
  }
});

/***/ }),

/***/ "./src/io/json/Writer.js":
/*!*******************************!*\
  !*** ./src/io/json/Writer.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Serialize the canvas document into a JSON object which can be read from the corresponding
 * {@link draw2d.io.json.Reader}.
 *
 *     // Create a JSON writer and convert it into a JSON-String representation.
 *     //
 *     var writer = new draw2d.io.json.Writer();
 *     writer.marshal(canvas, function(json){
 *        // convert the json object into string representation
 *        var jsonTxt = JSON.stringify(json,null,2);
 *     
 *        // insert the json string into a DIV for preview or post
 *        // it via ajax to the server....
 *        $("#json").text(jsonTxt);
 *     
 *     });
 *
 *
 *
 * @author Andreas Herz
 * @extends draw2d.io.Writer
 */

_packages2.default.io.json.Writer = _packages2.default.io.Writer.extend(
/** @lends draw2d.io.json.Writer */
{

  init: function init() {
    this._super();
  },

  /**
   *
   * Export the content to the implemented data format. Inherit class implements
   * content specific writer.
   * <br>
   * <br>
   *
   * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
   * The parameter <b>resultCallback</b> is required and new. The method calls
   * the callback instead of return the result.
   *
   * @param {draw2d.Canvas} canvas
   * @param {Function} resultCallback the method to call on success. The first argument is the result object, the second the base64 representation of the file content
   * @param {Object} resultCallback.json  the canvas document as JSON object
   * @param {String} resultCallback.base64  the canvas document as base encoded JSON
   */
  marshal: function marshal(canvas, resultCallback) {
    // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
    // if any application not care about this changes.
    if (typeof resultCallback !== "function") {
      throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
    }

    var result = [];

    canvas.getFigures().each(function (i, figure) {
      result.push(figure.getPersistentAttributes());
    });

    canvas.getLines().each(function (i, element) {
      result.push(element.getPersistentAttributes());
    });

    var base64Content = _packages2.default.util.Base64.encode(JSON.stringify(result, null, 2));

    resultCallback(result, base64Content);
  }
});

/***/ }),

/***/ "./src/io/png/Writer.js":
/*!******************************!*\
  !*** ./src/io/png/Writer.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canvg = __webpack_require__(/*! canvg-browser */ "./node_modules/canvg-browser/index.js");

/**
 * @class
 *
 * Converts the canvas document into a PNG Image.
 *
 * @example
 *    // example how to create a PNG image and set an
 *    // image src attribute.
 *    //
 *    var writer = new draw2d.io.png.Writer();
 *    writer.marshal(canvas, function(png){
 *        $("#preview").attr("src",png);
 *    });
 *
 * @author Andreas Herz
 * @extends draw2d.io.Writer
 */
_packages2.default.io.png.Writer = _packages2.default.io.Writer.extend(
/** @lends draw2d.io.png.Writer */
{

  init: function init() {
    this._super();
  },

  /**
   *
   * Export the content to a PNG image. The result can be set as <b>src="...."</b> because
   * the result is encoded as data source url <b>data:image/png;base64....</b>
   * <br>
   * <br>
   *
   * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
   * The parameter <b>resultCallback</b> is required and new. The method calls
   * the callback instead of return the result.
   *
   * @param {draw2d.Canvas} canvas
   * @param {Function} resultCallback the method to call on success. The first argument is the dataUrl, the second is the base64 formated png image
   * @param {String} resultCallback.img  The image as data source url <b>data:image/png;base64....</b>
   * @param {String} resultCallback.base64  the image encoded in base64
   * @param {draw2d.geo.Rectangle} cropBoundingBox optional cropping/clipping bounding box
   */
  marshal: function marshal(canvas, resultCallback, cropBoundingBox) {
    // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
    // if any application not care about this changes.
    if (typeof resultCallback !== "function") {
      throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
    }

    var svg = "";

    // the png.Writer can create Snapshots of a singel figure too.
    // Didn't work in IE <10
    // @status beta
    // @since 5.5.0
    if (canvas instanceof _packages2.default.Figure) {
      var origPos = canvas.getPosition();
      canvas.setPosition(1, 1);
      svg = "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" >" + canvas.shape.node.outerHTML + "</svg>";
      canvas.setPosition(origPos);
      canvas.initialWidth = canvas.getWidth() + 2;
      canvas.initialHeight = canvas.getHeight() + 2;
    }
    // create a snapshot of a complete canvas
    //
    else {
        canvas.hideDecoration();
        svg = canvas.getHtmlContainer().html().replace(/>\s+/g, ">").replace(/\s+</g, "<");

        // add missing namespace for images in SVG if missing
        // depends on raphaelJS version
        if (svg.indexOf("http://www.w3.org/1999/xlink") === -1) {
          svg = svg.replace("<svg ", "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" ");
        }
      }

    // required for IE9 support.
    // The following table contains ready-to-use conditions to detec IE Browser versions
    //
    // IE versions     Condition to check for
    // ------------------------------------------------------------
    // 10 or older     document.all
    // 9 or older      document.all && !window.atob
    // 8 or older      document.all && !document.addEventListener
    // 7 or older      document.all && !document.querySelector
    // 6 or older      document.all && !window.XMLHttpRequest
    // 5.x             document.all && !document.compatMode
    if (document.all) {
      svg = svg.replace(/xmlns=\"http:\/\/www\.w3\.org\/2000\/svg\"/, '');
    }

    var canvasDomNode = $('<canvas id="canvas_png_export_for_draw2d" style="display:none"></canvas>');
    $('body').append(canvasDomNode);
    var fullSizeCanvas = $("#canvas_png_export_for_draw2d")[0];
    fullSizeCanvas.width = canvas.initialWidth;
    fullSizeCanvas.height = canvas.initialHeight;

    canvg("canvas_png_export_for_draw2d", svg, {
      ignoreMouse: true,
      ignoreAnimation: true,
      renderCallback: function renderCallback() {
        try {
          if (canvas instanceof _packages2.default.Canvas) canvas.showDecoration();

          if (typeof cropBoundingBox !== "undefined") {
            var sourceX = cropBoundingBox.x;
            var sourceY = cropBoundingBox.y;
            var sourceWidth = cropBoundingBox.w;
            var sourceHeight = cropBoundingBox.h;

            var croppedCanvas = document.createElement('canvas');
            croppedCanvas.width = sourceWidth;
            croppedCanvas.height = sourceHeight;

            croppedCanvas.getContext("2d").drawImage(fullSizeCanvas, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, sourceWidth, sourceHeight);

            var dataUrl = croppedCanvas.toDataURL("image/png");
            var base64Image = dataUrl.replace("data:image/png;base64,", "");
            resultCallback(dataUrl, base64Image);
          } else {
            var img = fullSizeCanvas.toDataURL("image/png");
            resultCallback(img, img.replace("data:image/png;base64,", ""));
          }
        } finally {
          canvasDomNode.remove();
        }
      }
    });
  }
});

/***/ }),

/***/ "./src/io/svg/Writer.js":
/*!******************************!*\
  !*** ./src/io/svg/Writer.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Serialize the canvas document into a SVG document.
 *
 *     // Create a SVG writer and convert the canvas into a SVG document.
 *     //
 *     var writer = new draw2d.io.svg.Writer();
 *     writer.marshal(canvas, function(svg){
 *         // insert the svg string into a DIV for preview or post
 *         // it via ajax to the server....
 *         $("#svg").text(svg);
 *     });
 *
 *
 *
 * @author Andreas Herz
 * @extends draw2d.io.Writer
 */
_packages2.default.io.svg.Writer = _packages2.default.io.Writer.extend(
/** @lends draw2d.io.svg.Writer */
{
  init: function init() {
    this._super();
  },

  /**
   *
   * Export the content of the canvas into SVG. The SVG document can be loaded with Inkscape or any other SVG Editor.
   * <br>
   * <br>
   *
   * Method signature has been changed from version 2.10.1 to version 3.0.0.<br>
   * The parameter <b>resultCallback</b> is required and new. The method calls
   * the callback instead of return the result.
   *
   *
   * @param {draw2d.Canvas} canvas the canvas to marshal
   * @param {Function} callback the method to call on success. The first argument is the SVG document
   * @param {String} callback.svg  the SVG document
   * @param {String} callback.base64  the SVG document encoded in base64
   */
  marshal: function marshal(canvas, callback) {
    // I change the API signature from version 2.10.1 to 3.0.0. Throw an exception
    // if any application not care about this changes.
    if (typeof callback !== "function") {
      throw "Writer.marshal method signature has been change from version 2.10.1 to version 3.0.0. Please consult the API documentation about this issue.";
    }

    var s = canvas.getPrimarySelection();
    canvas.setCurrentSelection(null);
    var svg = canvas.getHtmlContainer().html().replace(/>\s+/g, ">").replace(/\s+</g, "<");
    svg = this.formatXml(svg);
    svg = svg.replace(/<desc>.*<\/desc>/g, "<desc>Create with draw2d JS graph library and RaphaelJS</desc>");

    canvas.setCurrentSelection(s);

    var base64Content = _packages2.default.util.Base64.encode(svg);
    callback(svg, base64Content);
  }
});

/***/ }),

/***/ "./src/layout/anchor/CenterEdgeConnectionAnchor.js":
/*!*********************************************************!*\
  !*** ./src/layout/anchor/CenterEdgeConnectionAnchor.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * The CenterEdgeConnectionAnchor's location is found by calculating the intersection of a
 * line drawn from the center point of its owner's box (the parent of the
 * connection port) to a reference point on that box. A Connection using the
 * ChopBoxAnchor will be oriented such that they point to their port owner's
 * center.
 *
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.layout.anchor.ConnectionAnchor
 */

_packages2.default.layout.anchor.CenterEdgeConnectionAnchor = _packages2.default.layout.anchor.ConnectionAnchor.extend(
/** @lends draw2d.layout.anchor.CenterEdgeConnectionAnchor.prototype */
{

  NAME: "draw2d.layout.anchor.CenterEdgeConnectionAnchor",

  /**
   *
   * @param {draw2d.Figure} [owner] the figure to use for the anchor calculation
   */
  init: function init(owner) {
    this._super(owner);
  },

  /**
   * 
   *
   * Returns the location where the Connection should be anchored in
   * absolute coordinates. The anchor may use the given reference
   * Point to calculate this location.
   *
   * @param {draw2d.geo.Point} ref The reference Point in absolute coordinates
   * @param {draw2d.Connection} [inquiringConnection] the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point} The anchor's location
   */
  getLocation: function getLocation(ref, inquiringConnection) {
    var r = this.getOwner().getParent().getBoundingBox();

    var dir = r.getDirection(ref);
    var center = r.getCenter();

    switch (dir) {
      case 0:
        center.y = r.y;
        break;
      case 1:
        center.x = r.x + r.w;
        break;
      case 2:
        center.y = r.y + r.h;
        break;
      case 3:
        center.x = r.x;
    }

    return center;
  },

  /**
   * Returns the bounds of this Anchor's owner. Subclasses can
   * override this method to adjust the box. Maybe you return the box
   * of the port parent (the parent figure)
   *
   * @returns {draw2d.geo.Rectangle} The bounds of this Anchor's owner
   */
  getBox: function getBox() {
    return this.getOwner().getParent().getBoundingBox();
  },

  /**
   * 
   *
   * Returns the bounds of this Anchor's owner. Subclasses can
   * override this method to adjust the box. Maybe you return the box
   * of the port parent (the parent figure)
   *
   * @param {draw2d.Connection} [inquiringConnection] the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point} The bounds of this Anchor's owner
   */
  getReferencePoint: function getReferencePoint(inquiringConnection) {
    return this.getBox().getCenter();
  }
});

/***/ }),

/***/ "./src/layout/anchor/ChopboxConnectionAnchor.js":
/*!******************************************************!*\
  !*** ./src/layout/anchor/ChopboxConnectionAnchor.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * The ChopboxAnchor's location is found by calculating the intersection of a
 * line drawn from the center point of its owner's box (the parent of the
 * connection port) to a reference point on that box. A Connection using the
 * ChopBoxAnchor will be oriented such that they point to their port owner's
 * center.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.layout.anchor.ConnectionAnchor
 */

_packages2.default.layout.anchor.ChopboxConnectionAnchor = _packages2.default.layout.anchor.ConnectionAnchor.extend(
/** @lends draw2d.layout.anchor.ChopboxConnectionAnchor.prototype */
{

  NAME: "draw2d.layout.anchor.ChopboxConnectionAnchor",

  /**
   *
   * @param {draw2d.Figure} owner the figure to use for the anchor calculation
   */
  init: function init(owner) {
    this._super(owner);
  },

  /**
   *
   *
   * Returns the location where the Connection should be anchored in
   * absolute coordinates. The anchor may use the given reference
   * Point to calculate this location.
   *
   * @param {draw2d.geo.Point} reference The reference Point in absolute coordinates
   * @param {draw2d.Connection} [inquiringConnection] the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point} The anchor's location
   */
  getLocation: function getLocation(reference, inquiringConnection) {
    var r = new _packages2.default.geo.Rectangle(0, 0);
    r.setBounds(this.getBox());
    r.translate(-1, -1);
    r.resize(1, 1);

    var center = r.getCenter();

    if (r.isEmpty() || reference.x === center.x && reference.y === center.y) {
      return center; // This avoids divide-by-zero
    }

    var dx = reference.x - center.x;
    var dy = reference.y - center.y;

    // r.width, r.height, dx, and dy are guaranteed to be non-zero.
    var scale = 0.5 / Math.max(Math.abs(dx) / r.w, Math.abs(dy) / r.h);

    dx *= scale;
    dy *= scale;
    center.translate(dx, dy);

    return center;
  },

  /**
   * Returns the bounds of this Anchor's owner. Subclasses can
   * override this method to adjust the box. Maybe you return the box
   * of the port parent (the parent figure)
   *
   * @returns {draw2d.geo.Rectangle} The bounds of this Anchor's owner
   */
  getBox: function getBox() {
    return this.getOwner().getParent().getBoundingBox();
  },

  /**
   *
   *
   * Returns the reference point for this anchor in absolute coordinates. This might be used
   * by another anchor to determine its own location.
   *
   * @param {draw2d.Connection} [inquiringConnection] the connection who ask for the location.
   * @returns {draw2d.geo.Point} The bounds of this Anchor's owner
   */
  getReferencePoint: function getReferencePoint(inquiringConnection) {
    return this.getBox().getCenter();
  }
});

/***/ }),

/***/ "./src/layout/anchor/ConnectionAnchor.js":
/*!***********************************************!*\
  !*** ./src/layout/anchor/ConnectionAnchor.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *  An object to which a {@link draw2d.Connection} will be anchored.
 *
 * @inheritable
 * @author Andreas Herz
 */

_packages2.default.layout.anchor.ConnectionAnchor = Class.extend(
/** @lends draw2d.layout.anchor.ConnectionAnchor.prototype */
{

  NAME: "draw2d.layout.anchor.ConnectionAnchor",

  /**
   *
   * @param {draw2d.Figure} owner the figure to use for the anchor calculation
   */
  init: function init(owner) {
    this.owner = owner;
  },

  /**
   * 
   * Returns the location where the Connection should be anchored in absolute coordinates.
   * The anchor may use the given reference Point to calculate this location.
   *
   * @param {draw2d.geo.Point} reference the opposite reference point
   * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point}
   */
  getLocation: function getLocation(reference, inquiringConnection) {
    // return the center of the owner/port.
    return this.getReferencePoint(inquiringConnection);
  },

  /**
   * 
   * Returns the Figure that contains this ConnectionAnchor.
   *
   * @returns {draw2d.Figure} The Figure that contains this ConnectionAnchor
   */
  getOwner: function getOwner() {
    return this.owner;
  },

  /**
   * 
   * Set the owner of the Anchor.
   *
   * @param {draw2d.Figure} owner the new owner of the anchor locator
   */
  setOwner: function setOwner(owner) {
    if (typeof owner === "undefined") {
      throw "Missing parameter for 'owner' in ConnectionAnchor.setOwner";
    }
    this.owner = owner;
  },

  /**
   * 
   * Returns the bounds of this Anchor's owner.  Subclasses can override this method
   * to adjust the box. Maybe you return the box of the port parent (the parent figure)
   *
   * @returns {draw2d.geo.Rectangle} The bounds of this Anchor's owner
   */
  getBox: function getBox() {
    return this.getOwner().getAbsoluteBounds();
  },

  /**
   * 
   * Returns the reference point for this anchor in absolute coordinates. This might be used
   * by another anchor to determine its own location.
   *
   * @param {draw2d.Connection} [inquiringConnection] the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point} The reference Point
   */
  getReferencePoint: function getReferencePoint(inquiringConnection) {
    return this.getOwner().getAbsolutePosition();
  }
});

/***/ }),

/***/ "./src/layout/anchor/FanConnectionAnchor.js":
/*!**************************************************!*\
  !*** ./src/layout/anchor/FanConnectionAnchor.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * The FanConnectionAnchor's location is found by calculating the intersection of a
 * line drawn from the center point of its owner's box (the parent of the
 * connection port) to a reference point on that box.
 * Additional the anchor resolves conflicts by spread the anchor if more than one
 * connection has the same reference point. <br>
 * In a case of a DirectRouter parallel connections are the result.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @since 4.6.0
 * @extends draw2d.layout.anchor.ConnectionAnchor
 */

_packages2.default.layout.anchor.FanConnectionAnchor = _packages2.default.layout.anchor.ConnectionAnchor.extend(
/** @lends draw2d.layout.anchor.FanConnectionAnchor.prototype */
{

  NAME: "draw2d.layout.anchor.FanConnectionAnchor",

  /**
   *
   * @param {draw2d.Figure} owner the figure to use for the anchor calculation
   * @param {Number} [separation] the separation or fan distance between the concurrent/conflicting anchors
   */
  init: function init(owner, separation) {
    this._super(owner);

    if (separation) {
      this.separation = parseInt(separation);
    } else {
      this.separation = 10;
    }
  },

  /**
   * 
   *
   * Returns the location where the Connection should be anchored in
   * absolute coordinates. The anchor may use the given reference
   * Point to calculate this location.
   *
   * @param {draw2d.geo.Point} reference The reference Point in absolute coordinates
   * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point} The anchor's location
   */
  getLocation: function getLocation(reference, inquiringConnection) {

    var r = new _packages2.default.geo.Rectangle(0, 0);
    r.setBounds(this.getBox());
    r.translate(-1, -1);
    r.resize(1, 1);

    var center = r.getCenter();

    if (r.isEmpty() || reference.x === center.x && reference.y === center.y) {
      return center; // This avoids divide-by-zero
    }

    // translate the center if required
    //
    var s = inquiringConnection.getSource();
    var t = inquiringConnection.getTarget();
    var lines = this.getOwner().getConnections().clone();
    lines.grep(function (other) {
      return other.getTarget() === t && other.getSource() === s || other.getTarget() === s && other.getSource() === t;
    });
    var index = lines.indexOf(inquiringConnection) + 1;
    var position = center.getPosition(reference);
    var ray = void 0;
    if (position === _packages2.default.geo.PositionConstants.SOUTH || position === _packages2.default.geo.PositionConstants.EAST) {
      ray = new _packages2.default.geo.Point(reference.x - center.x, reference.y - center.y);
    } else {
      ray = new _packages2.default.geo.Point(center.x - reference.x, center.y - reference.y);
    }
    var length = Math.sqrt(ray.x * ray.x + ray.y * ray.y);
    if (index <= 2) {
      length *= 1.5;
    }
    var xSeparation = this.separation * ray.x / length;
    var ySeparation = this.separation * ray.y / length;
    if (index % 2 === 0) {
      center = new _packages2.default.geo.Point(center.x + index / 2 * (-1 * ySeparation), center.y + index / 2 * xSeparation);
    } else {
      center = new _packages2.default.geo.Point(center.x + index / 2 * ySeparation, center.y + index / 2 * (-1 * xSeparation));
    }

    var intersections = this.getBox().intersectionWithLine(center, reference);
    // perfect - one intersection mean that the shifted center point is inside the bounding box and has only one intersection with it.
    //
    switch (intersections.getSize()) {
      case 0:
        // calculate the edge of the bounding box which is nearest to the reference point
        //
        var v = this.getBox().getVertices();
        var first = v.first();
        first.distance = reference.distance(first);
        return v.asArray().reduce(function (previous, current) {
          current.distance = reference.distance(current);
          return current.distance < previous.distance ? current : previous;
        });
      case 1:
        return intersections.get(0);
      case 2:
        // get the nearest of these points
        var p0 = intersections.get(0);
        var p1 = intersections.get(1);
        var p0diff = reference.distance(p0);
        var p1diff = reference.distance(p1);
        if (p0diff < p1diff) {
          return p0;
        }
        return p1;
    }

    // we have 0 or 2 intersections with the bounding box. This means the shifted
    // calculate the intersection if the new "center" with the bounding box of the
    // shape (if any exists)
  },

  /**
   * Returns the bounds of this Anchor's owner. Subclasses can
   * override this method to adjust the box. Maybe you return the box
   * of the port parent (the parent figure)
   *
   * @returns {draw2d.geo.Rectangle} The bounds of this Anchor's owner
   */
  getBox: function getBox() {
    return this.getOwner().getParent().getBoundingBox();
  },

  /**
   * 
   *
   * Returns the reference point for this anchor in absolute coordinates. This might be used
   * by another anchor to determine its own location.
   *
   * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point} The bounds of this Anchor's owner
   */
  getReferencePoint: function getReferencePoint(inquiringConnection) {
    return this.getBox().getCenter();
  }
});

/***/ }),

/***/ "./src/layout/anchor/ShortesPathConnectionAnchor.js":
/*!**********************************************************!*\
  !*** ./src/layout/anchor/ShortesPathConnectionAnchor.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * The ChopboxAnchor's location is found by calculating the intersection of a
 * line drawn from the center point of its owner's box (the parent of the
 * connection port) to a reference point on that box. A Connection using the
 * ChopBoxAnchor will be oriented such that they point to their port owner's
 * center.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.layout.anchor.ConnectionAnchor
 */

_packages2.default.layout.anchor.ShortesPathConnectionAnchor = _packages2.default.layout.anchor.ConnectionAnchor.extend(
/** @lends draw2d.layout.anchor.ShortesPathConnectionAnchor.prototype */
{

  NAME: "draw2d.layout.anchor.ShortesPathConnectionAnchor",

  /**
   *
   * @param {draw2d.Figure} [owner] the figure to use for the anchor calculation
   */
  init: function init(owner) {
    this._super(owner);
  },

  /**
   * 
   *
   * Returns the location where the Connection should be anchored in
   * absolute coordinates. The anchor may use the given reference
   * Point to calculate this location.
   *
   * @param {draw2d.geo.Point} ref The reference Point in absolute coordinates
   * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point} The anchor's location
   */
  getLocation: function getLocation(ref, inquiringConnection) {
    var r = this.getOwner().getParent().getBoundingBox();
    var center = r.getCenter();

    // check if we can calculate with a circle/line intersection
    //
    if (this.getOwner().getParent() instanceof _packages2.default.shape.basic.Oval) {
      var result = this.getOwner().getParent().intersectionWithLine(ref, center);
      if (result.getSize() === 1) {
        return result.get(0);
      }
    }

    /*    0 | 1 | 2
     *    __|___|__
     *    7 | 8 | 3
     *    __|___|__
     *    6 | 5 | 4
     */
    var octant = r.determineOctant(new _packages2.default.geo.Rectangle(ref.x, ref.y, 2, 2));

    switch (octant) {
      case 0:
        return r.getTopLeft();
      case 1:
        return new _packages2.default.geo.Point(ref.x, r.getTop());
      case 2:
        return r.getTopRight();
      case 3:
        return new _packages2.default.geo.Point(r.getRight(), ref.y);
      case 4:
        return r.getBottomRight();
      case 5:
        return new _packages2.default.geo.Point(ref.x, r.getBottom());
      case 6:
        return r.getBottomLeft();
      case 7:
        return new _packages2.default.geo.Point(r.getLeft(), ref.y);
    }

    return r.getTopLeft();
  },

  /**
   * Returns the bounds of this Anchor's owner. Subclasses can
   * override this method to adjust the box. Maybe you return the box
   * of the port parent (the parent figure)
   *
   * @returns {draw2d.geo.Rectangle} The bounds of this Anchor's owner
   */
  getBox: function getBox() {
    return this.getOwner().getParent().getBoundingBox();
  },

  /**
   * 
   *
   * Returns the bounds of this Anchor's owner. Subclasses can
   * override this method to adjust the box. Maybe you return the box
   * of the port parent (the parent figure)
   *
   * @param {draw2d.Connection} inquiringConnection the connection who ask for the location.
   *
   * @returns {draw2d.geo.Point} The bounds of this Anchor's owner
   */
  getReferencePoint: function getReferencePoint(inquiringConnection) {
    return this.getBox().getCenter();
  }
});

/***/ }),

/***/ "./src/layout/connection/CircuitConnectionRouter.js":
/*!**********************************************************!*\
  !*** ./src/layout/connection/CircuitConnectionRouter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Provides a {@link draw2d.Connection} with an orthogonal route between the Connection's source
 * and target anchors.
 * <br>
 * Additional a <b>bridge</b> is added to each connection which didn't have a common source or target
 * port.<br>
 * A <b>dot</b> is added at the crossing if the two connections have a common spurce or target port.
 *
 * <br>
 *
 * @example
 *
 *    let createConnection=function(){
 *       let con = new draw2d.Connection();
 *       con.setRouter(new draw2d.layout.connection.CircuitConnectionRouter());
 *       return con;
 *    };
 *
 *    // install a custom connection create policy
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *           createConnection: createConnection
 *    }));
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let f1 = new draw2d.shape.analog.OpAmp({x:10, y:10});
 *    let f2 = new draw2d.shape.analog.ResistorVertical({angle:90, height:20, x:300, y:150});
 *    let f3 = new draw2d.shape.analog.ResistorVertical({x:250, y:70});
 *    let f4 = new draw2d.shape.analog.ResistorVertical({x:10, y:90});
 *
 *    // ...add it to the canvas
 *    //
 *    canvas.add( f1);
 *    canvas.add( f2);
 *    canvas.add( f3);
 *    canvas.add( f4);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(f1.getOutputPort(0));
 *    c.setTarget(f2.getHybridPort(0));
 *    canvas.add(c);
 *
 *    // second Connection between the other resistors
 *    //
 *    c = createConnection();
 *    c.setSource(f3.getHybridPort(1));
 *    c.setTarget(f4.getHybridPort(0));
 *    canvas.add(c);
 *
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ManhattanConnectionRouter
 */

_packages2.default.layout.connection.CircuitConnectionRouter = _packages2.default.layout.connection.ManhattanConnectionRouter.extend(
/** @lends draw2d.layout.connection.CircuitConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.CircuitConnectionRouter",

  /**
   * Creates a new Router object.
   *
   */
  init: function init() {
    this._super();

    this.setBridgeRadius(4);
    this.setVertexRadius(2);

    // experimental
    this.abortRoutingOnFirstVertexNode = false;
  },

  /**
   * 
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  },

  /**
   * 
   * Callback method if the router has been removed from the connection. In the case of the CircuitRouter
   * all vertex nodes will be removed from the canvas.
   *
   * @param {draw2d.Connection} connection The related connection
   * @template
   * @since 2.7.2
   */
  onUninstall: function onUninstall(connection) {
    if (typeof connection.vertexNodes !== "undefined" && connection.vertexNodes !== null) {
      connection.vertexNodes.remove();
      connection.vertexNodes = null;
    }
  },

  /**
   * 
   * Set the radius of the vertex circle.
   *
   * @param {Number} radius
   */
  setVertexRadius: function setVertexRadius(radius) {
    this.vertexRadius = radius;

    return this;
  },
  /** deprecated
   * @private
   * **/
  setJunctionRadius: function setJunctionRadius(radius) {
    this.vertexRadius = radius;
  },

  /**
   * 
   * Set the radius or span of the bridge. A bridge will be drawn if two connections are crossing and didn't have any
   * common port.
   *
   * @param {Number} radius
   */
  setBridgeRadius: function setBridgeRadius(radius) {
    this.bridgeRadius = radius;
    this.bridge_LR = [" r", 0.5, -0.5, radius - radius / 2, -(radius - radius / 4), radius, -radius, radius + radius / 2, -(radius - radius / 4), radius * 2, "0 "].join(" ");
    this.bridge_RL = [" r", -0.5, -0.5, -(radius - radius / 2), -(radius - radius / 4), -radius, -radius, -(radius + radius / 2), -(radius - radius / 4), -radius * 2, "0 "].join(" ");

    return this;
  },

  /**
   * @inheritdoc
   */
  route: function route(conn, routingHints) {
    var _this = this;

    var fromPt = conn.getStartPoint();
    var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());

    var toPt = conn.getEndPoint();
    var toDir = conn.getTarget().getConnectionDirection(conn.getSource());

    // calculate the lines between the two points with the standard ManhattanRouter.
    //
    this._route(conn, toPt, toDir, fromPt, fromDir);

    // get the intersections to the other connections
    //
    var intersectionsASC = conn.getCanvas().getIntersection(conn).sort("x");
    var intersectionsDESC = intersectionsASC.clone().reverse();

    var intersectionForCalc = intersectionsASC;

    // add a ArrayList of all added vertex nodes to the connection
    //
    if (typeof conn.vertexNodes !== "undefined" && conn.vertexNodes !== null) {
      conn.vertexNodes.remove();
    }
    conn.vertexNodes = conn.canvas.paper.set();

    // ATTENTION: we cast all x/y coordinates to integer and add 0.5 to avoid subpixel rendering of
    //            the connection. The 1px or 2px lines look much clearer than before.
    //
    var ps = conn.getVertices();
    var p = ps.get(0);
    var path = ["M", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5];

    var oldP = p;
    var bridgeWidth = null;
    var bridgeCode = null;

    var lastVertexNode = null;

    for (var i = 1; i < ps.getSize(); i++) {
      p = ps.get(i);

      // line goes from right->left.
      if (oldP.x > p.x) {
        intersectionForCalc = intersectionsDESC;
        bridgeCode = this.bridge_RL;
        bridgeWidth = -this.bridgeRadius;
      }
      // line goes from left->right
      else {
          intersectionForCalc = intersectionsASC;
          bridgeCode = this.bridge_LR;
          bridgeWidth = this.bridgeRadius;
        }

      // add a bridge or a vertex node depending to the intersection connection
      //
      // bridge   => the connections didn't have a common port
      // vertex => the connections did have a common source or target port
      //
      intersectionForCalc.each(function (ii, interP) {
        if (_packages2.default.shape.basic.Line.hit(1, oldP.x, oldP.y, p.x, p.y, interP.x, interP.y) === true) {

          // It is a vertex node..
          //
          if (conn.sharingPorts(interP.other)) {
            var other = interP.other;
            var otherZ = other.getZOrder();
            var connZ = conn.getZOrder();
            if (connZ < otherZ) {
              var vertexNode = conn.canvas.paper.ellipse(interP.x, interP.y, _this.vertexRadius, _this.vertexRadius).attr({ fill: conn.lineColor.rgba() });
              conn.vertexNodes.push(vertexNode);
              // we found a vertex node. In this case an already existing connection did draw the connection.
              //
              if (_this.abortRoutingOnFirstVertexNode === true) {
                if (conn.getSource() === other.getSource() || conn.getSource() === other.getTarget()) {
                  path = ["M", (interP.x | 0) + 0.5, " ", (interP.y | 0) + 0.5];
                  if (lastVertexNode !== null) {
                    lastVertexNode.remove();
                    conn.vertexNodes.exclude(lastVerteNode);
                  }
                }
                lastVertexNode = vertexNode;
              }
            }
          }
          // ..or a bridge. We draw only horizontal bridges. Just a design decision
          //
          else if (p.y === interP.y) {
              path.push(" L", (interP.x - bridgeWidth | 0) + 0.5, " ", (interP.y | 0) + 0.5);
              path.push(bridgeCode);
            }
        }
      });

      path.push(" L", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
      oldP = p;
    }
    conn.svgPathString = path.join("");
  }
});

/***/ }),

/***/ "./src/layout/connection/ConnectionRouter.js":
/*!***************************************************!*\
  !*** ./src/layout/connection/ConnectionRouter.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Routes a {@link draw2d.Connection}, possibly using a constraint.
 *
 * @author Andreas Herz
 */

_packages2.default.layout.connection.ConnectionRouter = Class.extend(
/** @lends draw2d.layout.connection.ConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.ConnectionRouter",

  /**
   * Creates a new Router object
   */
  init: function init() {},

  /**
   *
   * Routes the Connection.
   *
   * @param {draw2d.Connection} connection The Connection to route
   * @param {Object} [routingHints] some helper attributes for the router
   * @param {Boolean} [routingHints.startMoved] is true if just the start location has moved
   * @param {Boolean} [routingHints.endMoved] is true if the destination location has changed
   * @param {draw2d.util.ArrayList} [routingHints.oldVertices] the vertices before the reroute has been triggered
   *
   * @template
   */
  route: function route(connection, routingHints) {
    throw "subclasses must implement the method [ConnectionRouter.route]";
  },

  _paint: function _paint(conn) {
    // calculate the path string for the SVG rendering
    // Important: to avoid subpixel error rendering we add 0.5 to each coordinate
    //            With this offset the canvas can paint the line on a "full pixel" instead
    //            of subpixel rendering.
    //    let adjust = val => (val| 0) +0.5
    var adjust = function adjust(val) {
      return val;
    };

    var ps = conn.getVertices();
    var p = ps.get(0);
    var radius = conn.getRadius();
    var path = ["M", adjust(p.x), " ", adjust(p.y)];
    var i = 1;
    var length = void 0,
        inset = void 0,
        p2 = void 0;
    if (radius > 0) {
      var lastP = p;
      length = ps.getSize() - 1;
      for (; i < length; i++) {
        p = ps.get(i);
        inset = _packages2.default.geo.Util.insetPoint(p, lastP, radius);
        path.push("L", adjust(inset.x), ",", adjust(inset.y));

        p2 = ps.get(i + 1);
        inset = _packages2.default.geo.Util.insetPoint(p, p2, radius);

        path.push("Q", p.x, ",", p.y, " ", adjust(inset.x), ", ", adjust(inset.y));
        lastP = p;
      }
      p = ps.get(i);
      path.push("L", adjust(p.x), ",", adjust(p.y));
    } else {
      length = ps.getSize();
      for (; i < length; i++) {
        p = ps.get(i);
        path.push("L", adjust(p.x), ",", adjust(p.y));
      }
    }
    conn.svgPathString = path.join("");
  },

  /**
   *
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.shape.basic.PolyLine} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {},

  /**
   *
   * Callback method if the router has been removed from the connection.
   *
   * @param {draw2d.shape.basic.PolyLine} connection The related connection
   * @template
   * @since 2.7.2
   */
  onUninstall: function onUninstall(connection) {},

  /**
   *
   * Callback method for the PolyLine or Connection to check if it possible to remove a vertex from
   * the list. The router can send an veto for this.
   * Per default it is not possible to remove any vertex from the PolyLine exceptional if any interactive
   * router is installed.
   *
   * @param {Number} index
   * @since 4.2.3
   */
  canRemoveVertexAt: function canRemoveVertexAt(index) {
    return false;
  },

  /**
   * Callback method for the PolyLine or Connection to verify that a segment is deletable.
   *
   * @param {Number} index
   * @returns {Boolean}
   * @since 4.2.3
   */
  canRemoveSegmentAt: function canRemoveSegmentAt(index) {
    return false;
  },

  /**
   *
   * Tweak or enrich the polyline persistence data with routing information
   *
   * @since 2.10.0
   * @param {draw2d.shape.basic.PolyLine} line
   * @param {Object} memento The memento data of the polyline
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes(line, memento) {
    return memento;
  },

  /**
   *
   * set the attributes for the polyline with routing information
   *
   * @since 2.10.0
   * @param {draw2d.shape.basic.Line} line
   * @param {Object} memento the JSON data to read
   */
  setPersistentAttributes: function setPersistentAttributes(line, memento) {},

  /**
   *
   *
   * The draw2d.Connection delegates the drag operation to the router. The router can
   * handle the different constraints of the connection.
   *
   * @param {draw2d.shape.basic.Line} line
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   */
  onDrag: function onDrag(line, dx, dy, dx2, dy2) {},

  /**
   *
   * Called by the connection if the vertices set outside.
   * This enforce the router to avoid full autoroute. E.g. InteractiveManhattanRouter
   *
   * @protected
   * @param {draw2d.shape.basic.Line} line
   */
  verticesSet: function verticesSet(line) {}

});

/***/ }),

/***/ "./src/layout/connection/DirectRouter.js":
/*!***********************************************!*\
  !*** ./src/layout/connection/DirectRouter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Router for direct connections between two ports. Beeline
 * <br>
 * <br>
 *
 * @example
 *
 *    let createConnection=function(){
 *       let con = new draw2d.Connection();
 *       con.setRouter(new draw2d.layout.connection.DirectRouter());
 *       return con;
 *    };
 *
 *    // install a custom connection create policy
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *           createConnection: createConnection
 *    }));
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let start = new draw2d.shape.node.Start();
 *    let end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */

_packages2.default.layout.connection.DirectRouter = _packages2.default.layout.connection.ConnectionRouter.extend(
/** @lends draw2d.layout.connection.DirectRouter.prototype */
{

  NAME: "draw2d.layout.connection.DirectRouter",

  /**
   * Creates a new Router object
   */
  init: function init() {
    this._super();
  },

  /**
   * 
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  },

  /**
   * 
   * Invalidates the given Connection
   */
  invalidate: function invalidate() {},

  /**
   * @inheritdoc
   */
  route: function route(connection, routingHints) {
    var start = connection.getStartPosition();
    var end = connection.getEndPosition();

    // required for hit tests
    //
    connection.addPoint(start);
    connection.addPoint(end);

    // calculate the path
    var path = ["M", start.x, " ", start.y];
    path.push("L", end.x, " ", end.y);

    connection.svgPathString = path.join("");
  }
});

/***/ }),

/***/ "./src/layout/connection/FanConnectionRouter.js":
/*!******************************************************!*\
  !*** ./src/layout/connection/FanConnectionRouter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Automatic router that spreads its  {@link draw2d.Connection Connections} in a fan-like fashion upon collision.
 *
 *
 * @example
 *
 *    let createConnection=function(){
 *       // return my special kind of connection
 *       let con = new draw2d.Connection({
 *         radius: 14,
 *         router: new draw2d.layout.connection.FanConnectionRouter()
 *       });
 *       return con;
 *    };
 *
 *    // install a custom connection create policy
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *           createConnection: createConnection
 *    }));
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let start = new draw2d.shape.node.Start();
 *    let end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 *    // second Connection
 *    //
 *    c = createConnection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 *    // third Connection
 *    //
 *    c = createConnection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.layout.connection.DirectRouter
 */

_packages2.default.layout.connection.FanConnectionRouter = _packages2.default.layout.connection.DirectRouter.extend(
/** @lends draw2d.layout.connection.FanConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.FanConnectionRouter",

  /**
   * Creates a new Router object.
   *
   */
  init: function init() {
    this._super();
  },

  /**
   * 
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  },

  /**
   * 
   * Layout the hands over connection in a manhattan like layout
   *
   * @param {draw2d.Connection}  conn
   * @param {draw2d.util.ArrayList} oldVertices old/existing vertices of the Connection
   * @param {Object} routingHints some helper attributes for the router
   * @param {Boolean} routingHints.startMoved is true if just the start location has moved
   * @param {Boolean} routingHints.destMoved is true if the destination location has changed
   */
  route: function route(conn, routingHints) {
    var lines = conn.getSource().getConnections().clone();
    lines.grep(function (other) {
      return other.getTarget() === conn.getTarget() || other.getSource() === conn.getTarget();
    });

    if (lines.getSize() > 1) {
      this.routeCollision(conn, lines.indexOf(conn));
    } else {
      this._super(conn, routingHints);
    }
  },

  /**
   * 
   * route the connection if connections overlap. Two connections overlap if the combination
   * of source and target anchors are equal.
   *
   * @param {draw2d.Connection} conn
   * @param {Number} index
   */
  routeCollision: function routeCollision(conn, index) {
    index = index + 1;
    var start = conn.getStartPoint();
    var end = conn.getEndPoint();

    var separation = 15;

    var midPoint = new _packages2.default.geo.Point((end.x + start.x) / 2, (end.y + start.y) / 2);
    var position = end.getPosition(start);
    var ray = void 0;
    if (position === _packages2.default.geo.PositionConstants.SOUTH || position === _packages2.default.geo.PositionConstants.EAST) {
      ray = new _packages2.default.geo.Point(end.x - start.x, end.y - start.y);
    } else {
      ray = new _packages2.default.geo.Point(start.x - end.x, start.y - end.y);
    }

    var length = Math.sqrt(ray.x * ray.x + ray.y * ray.y);

    var xSeparation = separation * ray.x / length;
    var ySeparation = separation * ray.y / length;

    var bendPoint = void 0;

    if (index % 2 === 0) {
      bendPoint = new _packages2.default.geo.Point(midPoint.x + index / 2 * (-1 * ySeparation), midPoint.y + index / 2 * xSeparation);
    } else {
      bendPoint = new _packages2.default.geo.Point(midPoint.x + index / 2 * ySeparation, midPoint.y + index / 2 * (-1 * xSeparation));
    }

    // required for hit tests
    conn.addPoint(start);
    conn.addPoint(bendPoint);
    conn.addPoint(end);

    // calculate the path string for the SVG rendering
    //
    this._paint(conn);
  }

});

/***/ }),

/***/ "./src/layout/connection/InteractiveManhattanConnectionRouter.js":
/*!***********************************************************************!*\
  !*** ./src/layout/connection/InteractiveManhattanConnectionRouter.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Route the connection in an Manhattan style and add resize handles to all vertex for interactive alignment of the
 * routing.
 *
 *
 * @example
 *
 *    let createConnection=function(){
 *       // return my special kind of connection
 *       let con = new draw2d.Connection({
 *         radius: 4,
 *         router: new draw2d.layout.connection.InteractiveManhattanConnectionRouter()
 *       });
 *       return con;
 *    };
 *
 *    // install a custom connection create policy
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *           createConnection: createConnection
 *    }));
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let start = new draw2d.shape.node.Start();
 *    let end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 *    // select the connection to show the selection handles
 *    //
 *    c.select();
 *
 *
 * @author Andreas Herz
 * @since 4.0.2
 * @extends  draw2d.layout.connection.ManhattanConnectionRouter
 */

_packages2.default.layout.connection.InteractiveManhattanConnectionRouter = _packages2.default.layout.connection.ManhattanConnectionRouter.extend(
/** @lends draw2d.layout.connection.InteractiveManhattanConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.InteractiveManhattanConnectionRouter",

  /**
   * Creates a new Router object.
   *
   */
  init: function init() {
    this._super();
  },

  onInstall: function onInstall(conn) {
    conn.installEditPolicy(new _packages2.default.policy.line.OrthogonalSelectionFeedbackPolicy());
    if (!conn._routingMetaData) {
      conn._routingMetaData = {
        routedByUserInteraction: false,
        fromDir: -1,
        toDir: -1
      };
    }
  },

  onUninstall: function onUninstall(conn) {
    delete conn._routingMetaData;
  },

  /**
   * @inheritDoc
   */
  route: function route(conn, routingHints) {
    if (!routingHints.oldVertices) {
      debugger;
    }
    if (routingHints.oldVertices.getSize() === 0 || conn._routingMetaData.routedByUserInteraction === false) {
      this._super(conn, routingHints);
      conn._routingMetaData.fromDir = conn.getSource().getConnectionDirection(conn.getTarget());
      conn._routingMetaData.toDir = conn.getTarget().getConnectionDirection(conn.getSource());
    } else {
      this.halfRoute(conn, routingHints);
      this._paint(conn);
    }
  },

  /**
   * 
   * The routing algorithm if the user has changed at least on of the vertices manually.
   * This kind of routing just align the start and end vertices to the new source/target port
   * location.
   * The vertices between keep untouched. Modification of this vertices are done by the
   * draw2d.policy.line.OrthogonalSelectionFeedbackPolicy
   *
   * @param {draw2d.Connection} conn the connection to route
   * @param {Object} routingHints some helper attributes for the router
   * @param {Boolean} routingHints.startMoved is true if just the start location has moved
   * @param {Boolean} routingHints.endMoved is true if the destination location has changed
   */
  halfRoute: function halfRoute(conn, routingHints) {
    var MINDIST = this.MINDIST;
    var max = Math.max;
    var min = Math.min;

    routingHints = routingHints || { oldVertices: new _packages2.default.util.ArrayList() };
    var oldVertices = routingHints.oldVertices;
    var vertexCount = oldVertices.getSize();

    var fromPt = conn.getStartPosition();
    var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());

    var toPt = conn.getEndPosition();
    var toDir = conn.getTarget().getConnectionDirection(conn.getSource());

    // the port orientation has been changed. This can happen if the node rotates. In this case
    // we must recalculate the routing.
    if (conn._routingMetaData.fromDir !== fromDir || conn._routingMetaData.toDir !== toDir) {
      conn._routingMetaData.routedByUserInteraction = false;
      this.route(conn, routingHints);
    }

    // TODO: detection for switch back to autoroute isn't good enough.
    //       Add more logic. e.g. if the fromDir!==1. This happens if
    //       The ports are at bottom and top.
    //       The code below covers only the classic workflow configuration left->right
    //
    //  go back to the default if no routing is possible anymore
    //
    if (fromDir === _packages2.default.geo.Rectangle.DIRECTION_RIGHT && toDir === _packages2.default.geo.Rectangle.DIRECTION_LEFT && fromPt.x > toPt.x && vertexCount <= 4) {

      conn._routingMetaData.routedByUserInteraction = false;
      this.route(conn, routingHints);
    }
    // it makes no sense to have just 2 vertices and manual routing for Manhattan-style routing
    else if (conn.getVertices().getSize() === 2 && conn._routingMetaData.routedByUserInteraction === true) {
        conn._routingMetaData.routedByUserInteraction = false;
        this.route(conn, routingHints);
      }

    // transfer the old vertices into the connection
    //
    oldVertices.each(function (i, vertex) {
      conn.addPoint(vertex);
    });

    // all points are adjusted with the drag&drop operation. There is no need to move
    // start/end points twice
    if (conn.isInDragDrop) {
      return;
    }

    // The SOURCE port (labeled with p0) has been moved/changed.
    //
    if (routingHints.startMoved || !fromPt.equals(oldVertices.get(0))) {
      var p1 = oldVertices.get(1);
      var p2 = oldVertices.get(2); // optional. Happens if the connection has just 2 points
      conn.setVertex(0, fromPt);
      switch (fromDir) {
        //          .
        //   p0     . p1
        //   x------+
        //          .
        //          .
        //
        case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
          conn.setVertex(1, max(fromPt.x + MINDIST, p1.x), fromPt.y); // p1
          if (p2) conn.setVertex(2, max(fromPt.x + MINDIST, p1.x), p2.y); // p2
          break;
        //   .
        //   . p1     p0
        //   +------x
        //   .
        //   .
        //
        case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
          conn.setVertex(1, min(fromPt.x - MINDIST, p1.x), fromPt.y); // p1
          if (p2) conn.setVertex(2, min(fromPt.x - MINDIST, p1.x), p2.y); // p2
          break;
        //     ...+....
        //     p1 |
        //        |
        //        |
        //     p0 x
        //
        case _packages2.default.geo.Rectangle.DIRECTION_UP:
          conn.setVertex(1, fromPt.x, min(fromPt.y - MINDIST, p1.y)); // p1
          if (p2) conn.setVertex(2, p2.x, min(fromPt.y - MINDIST, p1.y)); // p2
          break;
        //        x
        //     p0 |
        //        |
        //     p1 |
        //    ....+....
        //
        case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
          conn.setVertex(1, fromPt.x, max(fromPt.y + MINDIST, p1.y)); // p1
          if (p2) conn.setVertex(2, p2.x, max(fromPt.y + MINDIST, p1.y)); // p2
          break;
      }
    }
    //////////////////////////////////////////////////////////////////
    // the TARGET port (labeled with p0) has moved
    //
    if (routingHints.endMoved || !toPt.equals(oldVertices.get(vertexCount - 1))) {
      var _p = oldVertices.get(vertexCount - 2);
      var _p2 = oldVertices.get(vertexCount - 3); // optional
      conn.setVertex(vertexCount - 1, toPt); // p0

      switch (toDir) {
        //               .
        //      p0       . p1
        //    x----------+
        //               .
        //               .
        case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
          conn.setVertex(vertexCount - 2, max(toPt.x + MINDIST, _p.x), toPt.y); // p1
          if (_p2) conn.setVertex(vertexCount - 3, max(toPt.x + MINDIST, _p.x), _p2.y); // p2
          break;

        //    .
        //    .
        //    . p1         p0
        //    +----------x
        //    .
        //    .
        //
        case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
          conn.setVertex(vertexCount - 2, min(toPt.x - MINDIST, _p.x), toPt.y); // p1
          if (_p2) conn.setVertex(vertexCount - 3, min(toPt.x - MINDIST, _p.x), _p2.y); // p2
          break;

        //     ...+....
        //     p1 |
        //        |
        //        |
        //     p0 x
        //
        case _packages2.default.geo.Rectangle.DIRECTION_UP:
          conn.setVertex(vertexCount - 2, toPt.x, min(toPt.y - MINDIST, _p.y)); // p1
          if (_p2) conn.setVertex(vertexCount - 3, _p2.x, min(toPt.y - MINDIST, _p.y)); // p2
          break;

        //        +
        //     p0 |
        //        |
        //     p1 |
        //     ...+...
        //
        case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
          conn.setVertex(vertexCount - 2, toPt.x, max(toPt.y + MINDIST, _p.y)); // p1
          if (_p2) conn.setVertex(vertexCount - 3, _p2.x, max(toPt.y + MINDIST, _p.y)); // p2
          break;
      }
    }
  },

  /**
   * Callback method for the PolyLine or Connection to verify that a segment is deletable.
   * @param {draw2d.Connection} conn
   * @param {Number} index
   *
   * @returns {Boolean}
   * @since 4.2.3
   */
  canRemoveSegmentAt: function canRemoveSegmentAt(conn, index) {

    var segmentCount = conn.getVertices().getSize() - 1; // segmentCount is one less than vertex count

    // The first and last segment isn't deletable
    //
    if (index <= 0 || index + 1 >= segmentCount) {
      return false;
    }

    // a connection need at least three strokes
    //
    if (segmentCount < 4) {
      return false;
    }

    var fromPt = conn.getStartPosition();
    var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());

    var toPt = conn.getEndPosition();
    var toDir = conn.getTarget().getConnectionDirection(conn.getSource());

    if (segmentCount <= 5) {
      //     ___
      //    |   |      From
      //    | 1 |-----+
      //    |___|     |
      //              |
      //   +----------+
      //   |
      //   |    ___
      //   |   |   |
      //   +---| 2 |    To
      //       |___|
      // the connection needs at least 5 segments if the routing is like this
      //
      if (fromDir === _packages2.default.geo.Rectangle.DIRECTION_RIGHT && toDir === _packages2.default.geo.Rectangle.DIRECTION_LEFT && fromPt.x >= toPt.x) {
        return false;
      }

      //     ___
      //    |   |        To
      //    | 2 |-----+
      //    |___|     |
      //              |
      //   +----------+
      //   |
      //   |    ___
      //   |   |   |
      //   +---| 1 |    From
      //       |___|
      // the connection needs at least 5 segments if the routing is like this
      //
      if (fromDir == _packages2.default.geo.Rectangle.DIRECTION_LEFT & toDir == _packages2.default.geo.Rectangle.DIRECTION_RIGHT && fromPt.x <= toPt.x) {
        return false;
      }

      //                          ___
      //      +_______           |   |
      //      | from  |          | 2 |
      //     _+_      |          |___|
      //    |   |     |       To   +
      //    | 1 |     |____________|
      //    |___|
      // the connection needs at least 5 segments if the routing is like this
      //
      if (fromDir == _packages2.default.geo.Rectangle.DIRECTION_UP & toDir == _packages2.default.geo.Rectangle.DIRECTION_DOWN && fromPt.y <= toPt.y) {
        return false;
      }

      //                          ___
      //      +_______           |   |
      //      | to    |          | 1 |
      //     _+_      |          |___|
      //    |   |     |     from   +
      //    | 2 |     |____________|
      //    |___|
      // the connection needs at least 5 segments if the routing is like this
      //
      if (fromDir == _packages2.default.geo.Rectangle.DIRECTION_DOWN & toDir == _packages2.default.geo.Rectangle.DIRECTION_UP && fromPt.y >= toPt.y) {
        return false;
      }

      // unable to make the decision on the easy way. calculate the route again with an
      // temporary connection and check if the segment count of the new routed connection
      // allows a removal
      //
      var tmpConn = new _packages2.default.Connection();
      tmpConn.lineSegments = new _packages2.default.util.ArrayList();
      tmpConn.vertices = new _packages2.default.util.ArrayList();
      tmpConn.sourcePort = conn.sourcePort;
      tmpConn.targetPort = conn.targetPort;
      tmpConn._routingMetaData = { routedByUserInteraction: false, fromDir: -1, toDir: -1 };
      this.route(tmpConn, { oldVertices: new _packages2.default.util.ArrayList() });
      var curSegmentCount = conn.getVertices().getSize() - 1;
      var minSegmentCount = tmpConn.getVertices().getSize() - 1;
      if (curSegmentCount <= minSegmentCount) {
        return false;
      }
    }

    return true;
  },

  /**
   * 
   *
   * The draw2d.Connection delegates the drag operation to the router. The router can
   * handle the different constraints of the connection and just drag&drop a single segment
   * instead of the complete connection.
   *
   * @param {draw2d.shape.basic.Line} line the related line to handle
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   *
   * @since 6.1.0
   */
  onDrag: function onDrag(line, dx, dy, dx2, dy2) {
    var i = 0;
    // Connection is dragged by source and origin port movement
    // or MultiSelection in this case we drag the complete
    // connection
    if (line.draggedSegment === null) {
      var count = line.getVertices().getSize() - 1;
      for (i = 1; i < count; i++) {
        line.getVertex(i).translate(dx2, dy2);
      }
      return;
    }

    // don't drag start/end segments. This segments are bounded to the related
    // ports.
    if (line.draggedSegment.index === 0 || line.draggedSegment.index === line.getSegments().getSize() - 1) {
      return;
    }

    line._routingMetaData.routedByUserInteraction = true;

    var p0 = line.draggedSegment.start;
    var p1 = line.draggedSegment.end;
    i = line.draggedSegment.index;
    var lp0 = line.getVertices().first();
    var lp1 = line.getVertices().last();

    // horizontal segment movement
    //                              x Py
    //                              .
    //  P0                          .
    //  +---------------------------+ P1
    //  .
    //  .
    //  x Px
    //
    var distance = 0;
    if (p0.y === p1.y) {
      // ensure that the segment is the min distance away from the source/target port
      // (Px is endpoints of the connection and bounded to a port)
      if (i === 1) distance = p0.y - lp0.y;
      // (Py is endpoints of the connection and bounded to a port)
      if (i === line.getSegments().getSize() - 2) distance = p1.y - lp1.y;

      if (distance < 0 && dy2 > 0) {
        dy2 = Math.min(dy2, -distance - this.MINDIST);
      } else if (distance > 0 && dy2 < 0) {
        dy2 = -Math.min(-dy2, distance - this.MINDIST);
      }

      line.getVertex(i).translate(0, dy2);
      line.getVertex(i + 1).translate(0, dy2);
    }
    // vertical segment movement
    //
    else if (p0.x === p1.x) {
        // ensure that the segment is the min distance away from the source/target port
        //
        if (i === 1) {
          distance = p0.x - lp0.x;
          if (distance < 0 && dx2 > 0) {
            dx2 = Math.min(dx2, -distance - this.MINDIST);
          } else if (distance > 0 && dx2 < 0) {
            dx2 = -Math.min(-dx2, distance - this.MINDIST);
          }
        }

        // we need this additional test too. No "else if" because the special
        // case of "index===1". In this case the segment can be the last AND first
        // segment if the connection has only three segments at all.
        //
        if (i === line.getSegments().getSize() - 2) {
          distance = p1.x - lp1.x;
          if (distance < 0 && dx2 > 0) {
            dx2 = Math.min(dx2, -distance - this.MINDIST);
          } else if (distance > 0 && dx2 < 0) {
            dx2 = -Math.min(-dx2, distance - this.MINDIST);
          }
        }

        line.getVertex(i).translate(dx2, 0);
        line.getVertex(i + 1).translate(dx2, 0);
      }
  },

  /**
   * 
   * Called by the connection if the vertices set outside.
   * This enforce the router to avoid full autoroute. E.g. InteractiveManhattanRouter
   *
   * @protected
   */
  verticesSet: function verticesSet(conn) {
    conn._routingMetaData.routedByUserInteraction = true;
    if (conn.getSource() !== null && conn.getTarget() !== null) {
      conn._routingMetaData.fromDir = conn.getSource().getConnectionDirection(conn.getTarget());
      conn._routingMetaData.toDir = conn.getTarget().getConnectionDirection(conn.getSource());
    }
  },

  /**
   * 
   * Tweak or enrich the polyline persistence data with routing information
   *
   * @since 2.10.0
   * @param {draw2d.shape.basic.PolyLine} line
   * @param {Object} memento The memento data of the polyline
   *
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes(line, memento) {
    memento.vertex = [];

    line.getVertices().each(function (i, e) {
      memento.vertex.push({ x: e.x, y: e.y });
    });
    memento.routingMetaData = (0, _extend2.default)({}, line._routingMetaData);

    return memento;
  },

  /**
   * 
   * set the attributes for the polyline with routing information of the interactive manhattan router.
   *
   * @since 4..0.0
   * @param {Object} memento
   */
  setPersistentAttributes: function setPersistentAttributes(line, memento) {
    // restore the points from the JSON data and add them to the polyline
    //
    if (Array.isArray(memento.vertex)) {

      line.oldPoint = null;
      line.lineSegments = new _packages2.default.util.ArrayList();

      line.setVertices(memento.vertex);

      /*
       line.vertices     = new draw2d.util.ArrayList();
       $.each(memento.vertex, function(i,e){
       line.addPoint(e.x, e.y);
       });
       */
    }

    if (typeof memento.routingMetaData !== "undefined") {
      line._routingMetaData = (0, _extend2.default)({}, memento.routingMetaData);
    }
  }

});

/***/ }),

/***/ "./src/layout/connection/ManhattanBridgedConnectionRouter.js":
/*!*******************************************************************!*\
  !*** ./src/layout/connection/ManhattanBridgedConnectionRouter.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Provides a {@link draw2d.Connection} with an orthogonal route between the Connection's source
 * and target anchors.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ManhattanConnectionRouter
 */

_packages2.default.layout.connection.ManhattanBridgedConnectionRouter = _packages2.default.layout.connection.ManhattanConnectionRouter.extend(
/** @lends draw2d.layout.connection.ManhattanBridgedConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.ManhattanBridgedConnectionRouter",

  BRIDGE_HORIZONTAL_LR: " r 0 0 3 -4 7 -4 10 0 13 0 ", // Left to right
  BRIDGE_HORIZONTAL_RL: " r 0 0 -3 -4 -7 -4 -10 0 -13 0 ", // right to left

  /**
   * Creates a new Router object.
   *
   */
  init: function init() {
    this._super();
  },

  /**
   * 
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  },

  /**
   * @inheritdoc
   */
  route: function route(conn, routingHints) {
    var _this = this;

    var fromPt = conn.getStartPoint();
    var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());

    var toPt = conn.getEndPoint();
    var toDir = conn.getTarget().getConnectionDirection(conn.getSource());

    // calculate the lines between the two points.
    //
    this._route(conn, toPt, toDir, fromPt, fromDir);

    // calculate the path string for the SVG rendering
    //
    var intersectionsASC = conn.getCanvas().getIntersection(conn).sort("x");
    var intersectionsDESC = intersectionsASC.clone().reverse();

    var intersectionForCalc = intersectionsASC;

    // ATTENTION: we cast all x/y coordinates to int and add 0.5 to avoid subpixel rendering of
    //            the connection. The 1px or 2px lines look much clearer than before.
    //
    var ps = conn.getVertices();
    var p = ps.get(0);
    var path = ["M", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5];
    var oldP = p;

    var _loop = function _loop(i) {
      p = ps.get(i);

      // check for intersection and paint a bridge if required
      // line goes from left to right
      //
      var bridgeWidth = 5;
      var bridgeCode = _this.BRIDGE_HORIZONTAL_LR;

      // line goes from right->left. Inverse the bridge and the bridgeWidth
      //
      if (oldP.x > p.x) {
        intersectionForCalc = intersectionsDESC;
        bridgeCode = _this.BRIDGE_HORIZONTAL_RL;
        bridgeWidth = -bridgeWidth;
      }

      intersectionForCalc.each(function (ii, interP) {
        if (interP.justTouching === false && _packages2.default.shape.basic.Line.hit(1, oldP.x, oldP.y, p.x, p.y, interP.x, interP.y) === true) {
          // we draw only horizontal bridges. Just a design decision
          //
          if (p.y === interP.y) {
            path.push(" L", (interP.x - bridgeWidth | 0) + 0.5, " ", (interP.y | 0) + 0.5);
            path.push(bridgeCode);
          }
        }
      });

      path.push(" L", (p.x | 0) + 0.5, " ", (p.y | 0) + 0.5);
      oldP = p;
    };

    for (var i = 1; i < ps.getSize(); i++) {
      _loop(i);
    }
    conn.svgPathString = path.join("");
  }

});

/***/ }),

/***/ "./src/layout/connection/ManhattanConnectionRouter.js":
/*!************************************************************!*\
  !*** ./src/layout/connection/ManhattanConnectionRouter.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Provides a {@link draw2d.Connection} with an orthogonal route between the Connection's source
 * and target anchors.
 *
 *
 * @example
 *
 *    // Override the default connection type. This is used during drag&drop operations of ports.
 *    //
 *    let createConnection=function(sourcePort, targetPort){
 *       // return my special kind of connection
 *       let con = new draw2d.Connection();
 *       con.setRouter(new draw2d.layout.connection.ManhattanConnectionRouter());
 *       return con;
 *    };
 *
 *    // Install a special policy into the canvas to use my own implementation of connection
 *    // if we drag&drop a port
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *          createConnection: createConnection
 *    }));
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let start = new draw2d.shape.node.Start();
 *    let end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */

_packages2.default.layout.connection.ManhattanConnectionRouter = _packages2.default.layout.connection.ConnectionRouter.extend(
/** @lends draw2d.layout.connection.ManhattanConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.ManhattanConnectionRouter",

  MINDIST: 20,
  TOL: 0.1,
  TOLxTOL: 0.01,
  TOGGLE_DIST: 20,

  /**
   * Creates a new Router object.
   *
   */
  init: function init() {
    this._super();
  },

  /**
   *
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  },

  /**
   * @inheritdoc
   */
  route: function route(conn, routingHints) {
    var fromPt = conn.getStartPosition();
    var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());

    var toPt = conn.getEndPosition();
    var toDir = conn.getTarget().getConnectionDirection(conn.getSource());

    // calculate the lines between the two points.
    //
    this._route(conn, toPt, toDir, fromPt, fromDir);
    this._paint(conn);
  },

  /**
   *
   * Internal routing algorithm.
   *
   * @private
   * @param {draw2d.Connection} conn
   * @param {draw2d.geo.Point} fromPt
   * @param {Number} fromDir
   * @param {draw2d.geo.Point} toPt
   * @param {Number} toDir
   */
  _route: function _route(conn, fromPt, fromDir, toPt, toDir) {
    // fromPt is an x,y to start from.
    // fromDir is an angle that the first link must
    //
    var UP = _packages2.default.geo.Rectangle.DIRECTION_UP;
    var RIGHT = _packages2.default.geo.Rectangle.DIRECTION_RIGHT;
    var DOWN = _packages2.default.geo.Rectangle.DIRECTION_DOWN;
    var LEFT = _packages2.default.geo.Rectangle.DIRECTION_LEFT;

    var xDiff = fromPt.x - toPt.x;
    var yDiff = fromPt.y - toPt.y;
    var point = void 0;
    var dir = void 0;
    var pos = void 0;

    if (xDiff * xDiff < this.TOLxTOL && yDiff * yDiff < this.TOLxTOL) {
      conn.addPoint(new _packages2.default.geo.Point(toPt.x, toPt.y));
      return;
    }

    if (fromDir === LEFT) {
      if (xDiff > 0 && yDiff * yDiff < this.TOL && toDir === RIGHT) {
        point = toPt;
        dir = toDir;
      } else {
        if (xDiff < 0) {
          point = new _packages2.default.geo.Point(fromPt.x - this.MINDIST, fromPt.y);
        } else if (yDiff > 0 && toDir === DOWN || yDiff < 0 && toDir === UP) {
          point = new _packages2.default.geo.Point(toPt.x, fromPt.y);
        } else if (fromDir === toDir) {
          pos = Math.min(fromPt.x, toPt.x) - this.MINDIST;
          point = new _packages2.default.geo.Point(pos, fromPt.y);
        } else {
          point = new _packages2.default.geo.Point(fromPt.x - xDiff / 2, fromPt.y);
        }

        if (yDiff > 0) {
          dir = UP;
        } else {
          dir = DOWN;
        }
      }
    } else if (fromDir === RIGHT) {
      if (xDiff < 0 && yDiff * yDiff < this.TOL && toDir === LEFT) {
        point = toPt;
        dir = toDir;
      } else {
        if (xDiff > 0) {
          point = new _packages2.default.geo.Point(fromPt.x + this.MINDIST, fromPt.y);
        } else if (yDiff > 0 && toDir === DOWN || yDiff < 0 && toDir === UP) {
          point = new _packages2.default.geo.Point(toPt.x, fromPt.y);
        } else if (fromDir === toDir) {
          pos = Math.max(fromPt.x, toPt.x) + this.MINDIST;
          point = new _packages2.default.geo.Point(pos, fromPt.y);
        } else {
          point = new _packages2.default.geo.Point(fromPt.x - xDiff / 2, fromPt.y);
        }

        if (yDiff > 0) {
          dir = UP;
        } else {
          dir = DOWN;
        }
      }
    } else if (fromDir === DOWN) {
      if (xDiff * xDiff < this.TOL && yDiff < 0 && toDir === UP) {
        point = toPt;
        dir = toDir;
      } else {
        if (yDiff > 0) {
          point = new _packages2.default.geo.Point(fromPt.x, fromPt.y + this.MINDIST);
        } else if (xDiff > 0 && toDir === RIGHT || xDiff < 0 && toDir === LEFT) {
          point = new _packages2.default.geo.Point(fromPt.x, toPt.y);
        } else if (fromDir === toDir) {
          pos = Math.max(fromPt.y, toPt.y) + this.MINDIST;
          point = new _packages2.default.geo.Point(fromPt.x, pos);
        } else {
          point = new _packages2.default.geo.Point(fromPt.x, fromPt.y - yDiff / 2);
        }

        if (xDiff > 0) {
          dir = LEFT;
        } else {
          dir = RIGHT;
        }
      }
    } else if (fromDir === UP) {
      if (xDiff * xDiff < this.TOL && yDiff > 0 && toDir === DOWN) {
        point = toPt;
        dir = toDir;
      } else {
        if (yDiff < 0) {
          point = new _packages2.default.geo.Point(fromPt.x, fromPt.y - this.MINDIST);
        } else if (xDiff > 0 && toDir === RIGHT || xDiff < 0 && toDir === LEFT) {
          point = new _packages2.default.geo.Point(fromPt.x, toPt.y);
        } else if (fromDir === toDir) {
          pos = Math.min(fromPt.y, toPt.y) - this.MINDIST;
          point = new _packages2.default.geo.Point(fromPt.x, pos);
        } else {
          point = new _packages2.default.geo.Point(fromPt.x, fromPt.y - yDiff / 2);
        }

        if (xDiff > 0) {
          dir = LEFT;
        } else {
          dir = RIGHT;
        }
      }
    }
    this._route(conn, point, dir, toPt, toDir);
    conn.addPoint(fromPt);
  }

});

/***/ }),

/***/ "./src/layout/connection/MazeConnectionRouter.js":
/*!*******************************************************!*\
  !*** ./src/layout/connection/MazeConnectionRouter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * <b>BETA VERSION. Not for production!!!<br></b>
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */

var ROUTER_RECTS = null;

_packages2.default.layout.connection.MazeConnectionRouter = _packages2.default.layout.connection.ConnectionRouter.extend(
/** @lends draw2d.layout.connection.MazeConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.MazeConnectionRouter",

  /**
   * Creates a new Router object.
   *
   */
  init: function init() {
    this._super();

    this.useSpline = false;
    this.useSimplify = true;
    this.useSimplifyValue = 2;
    this.useDebug = false;
    this.useShift = 4;
    this.portOutletOffset = 15;

    //    	this.finder = new PF.AStarFinder();
    //      this.finder = new PF.AStarFinder({ allowDiagonal: true, dontCrossCorners: true});
    //      this.finder = new PF.AStarFinder({ allowDiagonal: false});
    //      this.finder = new PF.BiBreadthFirstFinder({ allowDiagonal: false});
    //      this.finder = new PF.BreadthFirstFinder({ allowDiagonal: false});
    this.finder = new PF.JumpPointFinder({ allowDiagonal: false, dontCrossCorners: true });
  },

  /**
   * 
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  },

  /**
   * @inheritdoc
   */
  route: function route(conn, routingHints) {
    var fromPt = conn.getStartPoint();
    var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());

    var toPt = conn.getEndPoint();
    var toDir = conn.getTarget().getConnectionDirection(conn.getSource());

    // calculate the lines between the two points.
    //
    this._route(conn, toPt, toDir, fromPt, fromDir);
    this._paint(conn);
  },

  /**
   * 
   * Internal routing algorithm.
   *     * <p>
   * Possible values:
   * <ul>
   *   <li>up -&gt; 0</li>
   *   <li>right -&gt; 1</li>
   *   <li>down -&gt; 2</li>
   *   <li>left -&gt; 3</li>
   * </ul>
   * <p>
    * @private
   * @param {draw2d.Connection} conn
   * @param {draw2d.geo.Point} fromPt
   * @param {Number} fromDir
   * @param {draw2d.geo.Point} toPt
   * @param {Number} toDir
   */
  _route: function _route(conn, fromPt, fromDir, toPt, toDir) {
    var shift = this.useShift;

    var oldToPt = toPt;
    var oldFromPt = fromPt;

    // move the points with an offset in the prefered routing direction of the ports
    // to avoid that the routed connection is sticking on one side of the figure.
    //
    fromPt = this.getAdjustedPoint(fromPt, fromDir, this.portOutletOffset);
    toPt = this.getAdjustedPoint(toPt, toDir, this.portOutletOffset);

    var grid = this.generateNoGoGrid(conn, fromPt, fromDir, toPt, toDir);

    // 4. Calculate the shortest path from source to target based on the grid
    //
    var path = this.finder.findPath(Math.max(fromPt.x) >> shift, Math.max(fromPt.y) >> shift, Math.max(toPt.x) >> shift, Math.max(0, toPt.y) >> shift, grid);

    // transfer the path from the grid based coordinates back to the real coordinates
    //
    path.forEach(function (e) {
      e.x = e[0] = e[0] << shift;
      e.y = e[1] = e[1] << shift;
    });

    // 5. paint the "no go" area in read if we are in debug mode
    //
    if (this.useDebug) {
      if (ROUTER_RECTS !== null) {
        ROUTER_RECTS.remove();
      }
      ROUTER_RECTS = conn.canvas.paper.set();

      for (var i = 0; i < grid.width; i++) {
        for (var j = 0; j < grid.height; j++) {
          if (!grid.isWalkableAt(i, j)) ROUTER_RECTS.push(conn.canvas.paper.rect(i << shift, j << shift, 1 << shift, 1 << shift).attr({
            "fill": "red",
            "opacity": "0.1"
          }));
        }
      }
      ROUTER_RECTS.push(conn.canvas.paper.rect(fromPt.x - 3, fromPt.y - 3, 6, 6).attr({
        "fill": "#ff0000",
        "opacity": "0.8"
      }));
      ROUTER_RECTS.push(conn.canvas.paper.rect(toPt.x - 3, toPt.y - 3, 6, 6).attr({
        "fill": "#ff0000",
        "opacity": "0.8"
      }));

      // paint the original calculated path without any simplification in BLUE
      path.forEach(function (e) {
        ROUTER_RECTS.push(conn.canvas.paper.rect(e.x - 3, e.y - 3, 6, 6).attr({ "fill": "#0000ff", "opacity": "0.8" }));
      });
      var p = path[0];
      var svgPathBefore = ["M", p.x, " ", p.y];
      for (var _i = 1; _i < path.length; _i++) {
        p = path[_i];
        svgPathBefore.push("L", p.x, " ", p.y);
      }
      svgPathBefore = svgPathBefore.join("");
      ROUTER_RECTS.push(conn.canvas.paper.path(svgPathBefore).attr({ "stroke": "#0000ff" }));
    }

    this.adjustPath(fromPt, path, fromDir);
    path.reverse();
    this.adjustPath(toPt, path, toDir);
    path.reverse();

    path.forEach(function (e) {
      e.x = e[0];
      e.y = e[1];
    });

    if (this.useSpline) {
      var _p = new _packages2.default.util.ArrayList();
      _p.add(oldFromPt);
      path.forEach(function (e) {
        _p.add(new _packages2.default.geo.Point(e[0], e[1]));
      });
      _p.add(oldToPt);

      if (this.useDebug) {
        path.forEach(function (e) {
          ROUTER_RECTS.push(conn.canvas.paper.rect(e.x - 3, e.y - 3, 6, 6).attr({ "fill": "#00ff00", "opacity": "0.8" }));
        });
        var pt = path[0];
        var _svgPathBefore = ["M", pt.x, " ", pt.y];
        for (var _i2 = 1; _i2 < path.length; _i2++) {
          pt = path[_i2];
          _svgPathBefore.push("L", pt.x, " ", pt.y);
        }
        _svgPathBefore = _svgPathBefore.join("");
        ROUTER_RECTS.push(conn.canvas.paper.path(_svgPathBefore).attr({ "stroke": "#00ff00" }));
      }

      this.spline = new _packages2.default.util.spline.CubicSpline();
      var splinePoints = this.spline.generate(_p, 8);

      if (this.useSimplify) {
        path = [];
        splinePoints.each(function (i, e) {
          path.push({ x: e.x, y: e.y });
        });
        path = this.simplify(path, this.useSimplifyValue, true);

        path.forEach(function (e) {
          conn.addPoint(e.x, e.y);
        });
      } else {
        splinePoints.each(function (i, e) {
          conn.addPoint(e);
        });
      }
    } else {
      if (this.useSimplify) {
        path = this.simplify(path, this.useSimplifyValue, true);
      }

      if (this.useDebug) {
        path.forEach(function (e) {
          ROUTER_RECTS.push(conn.canvas.paper.rect(e.x - 3, e.y - 3, 6, 6).attr({ "fill": "#00ff00", "opacity": "0.8" }));
        });
        var _p2 = path[0];
        var _svgPathBefore2 = ["M", _p2.x, " ", _p2.y];
        for (var _i3 = 1; _i3 < path.length; _i3++) {
          _p2 = path[_i3];
          _svgPathBefore2.push("L", _p2.x, " ", _p2.y);
        }
        _svgPathBefore2 = _svgPathBefore2.join("");
        ROUTER_RECTS.push(conn.canvas.paper.path(_svgPathBefore2).attr({ "stroke": "#00ff00" }));
      }

      conn.addPoint(oldFromPt);
      path.forEach(function (e) {
        conn.addPoint(e[0], e[1]);
      });
      conn.addPoint(oldToPt);
    }
  },

  /**
   * 
   * Generate a grid base no go map required for the path finding algorithm
   *
   * @param conn
   * @returns {PF.Grid}
   * @private
   */
  generateNoGoGrid: function generateNoGoGrid(conn, fromPt, fromDir, toPt, toDir) {
    var shift = this.useShift;
    var oneShift2 = (1 << shift) / 2;

    // 1. generate a map with all "no go" areas. The bounding box of the shapes defines
    //    the no go areas.
    //
    var canvasWidth = conn.getCanvas().paper.width >> shift;
    var canvasHeight = conn.getCanvas().paper.height >> shift;
    var grid = new PF.Grid(canvasWidth, canvasHeight);
    var figures = conn.getCanvas().getFigures();
    figures.each(function (i, e) {
      var box = e.getBoundingBox();
      // remove shapes which are hit by the input or output ports. It is not possible to route
      // out from a not walkable area
      if (box.hitTest(fromPt.x, fromPt.y) === true || box.hitTest(toPt.x, toPt.y)) {
        return;
      }

      var x = box.x >> shift;
      var y = box.y >> shift;
      if (x < 1 || y < 1) {
        return;
      }
      var r_orig = box.x + box.w + oneShift2 >> shift;
      var b_orig = box.y + box.h + oneShift2 >> shift;
      for (var _i4 = x; _i4 <= r_orig; _i4++) {
        for (var j = y; j <= b_orig; j++) {
          grid.setWalkableAt(_i4, j, false);
        }
      }
    });

    // 3. make the are walkable on the edge of the port side. Otherwise we a
    //    an enclosed area around the port if we are very close to another shape
    //
    var box = conn.getSource().getParent().getBoundingBox();
    if (toDir === 1 || toDir === 3) {
      var y = box.y >> shift;
      if (y > 0) {
        var b_orig = box.y + box.h;
        var i = toPt.x >> shift;

        for (var j = y - 1; j << shift <= b_orig; j++) {
          grid.setWalkableAt(i, j, true);
        }
      }
    } else {
      var x = box.x >> shift;
      if (x > 0) {
        var r_orig = box.x + box.w;
        var _j = toPt.x >> shift;
        for (var _i5 = x - 1; _i5 << shift <= r_orig; _i5++) {
          grid.setWalkableAt(_i5, _j, true);
        }
      }
    }

    box = conn.getTarget().getParent().getBoundingBox();
    if (fromDir === 1 || fromDir === 3) {
      var _y = box.y >> shift;
      if (_y > 0) {
        var _b_orig = box.y + box.h;
        var _i6 = fromPt.x >> shift;
        for (var _j2 = _y - 1; _j2 << shift <= _b_orig; _j2++) {
          grid.setWalkableAt(_i6, _j2, true);
        }
      }
    } else {
      var _x = box.x >> shift;
      if (_x > 0) {
        var _r_orig = box.x + box.w;
        var _j3 = fromPt.x >> shift;
        for (var _i7 = _x - 1; _i7 << shift <= _r_orig; _i7++) {
          grid.setWalkableAt(_i7, _j3, true);
        }
      }
    }

    return grid;
  },

  /**
   * 
   * move the point in the given direction with the given offset
   *
   * @param {draw2d.geo.Point} pt
   * @param {Number} direction
   * @param {Number} adjustment
   *
   * @returns {draw2d.geo.Point}
   */
  getAdjustedPoint: function getAdjustedPoint(pt, direction, adjustment) {

    switch (direction) {
      case _packages2.default.geo.Rectangle.DIRECTION_UP:
        return new _packages2.default.geo.Point(pt.x, pt.y - adjustment);
      case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
        return new _packages2.default.geo.Point(pt.x + adjustment, pt.y);
      case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
        return new _packages2.default.geo.Point(pt.x, pt.y + adjustment);
      case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
        return new _packages2.default.geo.Point(pt.x - adjustment, pt.y);
    }
  },

  adjustPath: function adjustPath(pt, path, direction) {
    var shift = this.useShift;
    var x = pt.x >> shift;
    var y = pt.y >> shift;
    path.forEach(function (e) {
      if (y === e[1] >> shift) {
        e[1] = pt.y;
      } else {
        return false;
      }
    });
    path.forEach(function (e) {
      if (x === e[0] >> shift) {
        e[0] = pt.x;
      } else {
        return false;
      }
    });
  },

  getSquareDistance: function getSquareDistance(p1, p2) {
    // square distance between 2 points

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
  },

  getSquareSegmentDistance: function getSquareSegmentDistance(p, p1, p2) {
    // square distance from a point to a segment

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y,
        t = void 0;

    if (dx !== 0 || dy !== 0) {

      t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

      if (t > 1) {
        x = p2.x;
        y = p2.y;
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
  },

  simplifyRadialDistance: function simplifyRadialDistance(points, sqTolerance) {
    // distance-based simplification

    var i = void 0,
        len = points.length,
        point = null,
        prevPoint = points[0],
        newPoints = [prevPoint];

    for (i = 1; i < len; i++) {
      point = points[i];

      if (this.getSquareDistance(point, prevPoint) > sqTolerance) {
        newPoints.push(point);
        prevPoint = point;
      }
    }

    if (prevPoint !== point) {
      newPoints.push(point);
    }

    return newPoints;
  },

  // simplification using optimized Douglas-Peucker algorithm with recursion elimination

  simplifyDouglasPeucker: function simplifyDouglasPeucker(points, sqTolerance) {

    var len = points.length,
        MarkerArray = (typeof Uint8Array === "undefined" ? "undefined" : _typeof(Uint8Array)) !== undefined + '' ? Uint8Array : Array,
        markers = new MarkerArray(len),
        first = 0,
        last = len - 1,
        i = void 0,
        maxSqDist = void 0,
        sqDist = void 0,
        index = void 0,
        firstStack = [],
        lastStack = [],
        newPoints = [];

    markers[first] = markers[last] = 1;

    while (last) {

      maxSqDist = 0;

      for (i = first + 1; i < last; i++) {
        sqDist = this.getSquareSegmentDistance(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }

      if (maxSqDist > sqTolerance) {
        markers[index] = 1;

        firstStack.push(first);
        lastStack.push(index);

        firstStack.push(index);
        lastStack.push(last);
      }

      first = firstStack.pop();
      last = lastStack.pop();
    }

    for (i = 0; i < len; i++) {
      if (markers[i]) {
        newPoints.push(points[i]);
      }
    }

    return newPoints;
  },

  simplify: function simplify(points, tolerance, highestQuality) {

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    if (!highestQuality) {
      points = this.simplifyRadialDistance(points, sqTolerance);
    }
    points = this.simplifyDouglasPeucker(points, sqTolerance);

    return points;
  }
});

/***/ }),

/***/ "./src/layout/connection/MuteableManhattanConnectionRouter.js":
/*!********************************************************************!*\
  !*** ./src/layout/connection/MuteableManhattanConnectionRouter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * JUST FOR RESEARCH AT THE MOMENT!!!!!!
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ManhattanConnectionRouter
 */

_packages2.default.layout.connection.MuteableManhattanConnectionRouter = _packages2.default.layout.connection.ManhattanConnectionRouter.extend(
/** @lends draw2d.layout.connection.MuteableManhattanConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.MuteableManhattanConnectionRouter",

  UP: new _packages2.default.geo.Ray(0, -1),
  DOWN: new _packages2.default.geo.Ray(0, 1),
  LEFT: new _packages2.default.geo.Ray(-1, 0),
  RIGHT: new _packages2.default.geo.Ray(1, 0),

  /**
   * Creates a new Router object.
   *
   */
  init: function init() {
    this._super();

    this.rowsUsed = {}; //new HashMap<Integer, Integer>();
    this.colsUsed = {}; //new HashMap<Integer, Integer>();
    this.constraints = {}; //new HashMap<Connection, Object>();
    this.reservedInfo = {}; //new HashMap<Connection, ReservedInfo>();
  },

  /**
   * @inheritdoc
   */
  route: function route(conn, routingHints) {
    this.rowsUsed = {}; //new HashMap<Integer, Integer>();
    this.colsUsed = {}; //new HashMap<Integer, Integer>();
    this.constraints = {}; //new HashMap<Connection, Object>();
    this.reservedInfo = {}; //new HashMap<Connection, ReservedInfo>();

    var canvas = conn.getCanvas();
    var i = void 0;

    var startPoint = conn.getStartPoint();
    var endPoint = conn.getEndPoint();

    var start = new _packages2.default.geo.Ray(startPoint);
    var end = new _packages2.default.geo.Ray(endPoint);
    var average = new _packages2.default.geo.Ray((start.x + end.x) / 2, (start.y + end.y) / 2);

    var direction = new _packages2.default.geo.Ray(end.x - start.x, end.y - start.y);
    var startNormal = this.getStartDirection(conn);
    var endNormal = this.getEndDirection(conn);

    var positions = new _packages2.default.util.ArrayList();
    var horizontal = startNormal.isHorizontal();

    if (horizontal) {
      positions.add(start.y);
    } else {
      positions.add(start.x);
    }

    horizontal = !horizontal;

    // dot product is zero if the vector orthogonal (90)
    if (startNormal.dot(endNormal) === 0) {
      if (startNormal.dot(direction) >= 0 && endNormal.dot(direction) <= 0) {
        // 0
      } else {

        // 2
        if (startNormal.dot(direction) < 0) i = startNormal.similarity(start.translated(startNormal.scaled(10)));else {
          if (horizontal) i = average.y;else i = average.x;
        }

        positions.add(i);
        horizontal = !horizontal;

        if (endNormal.dot(direction) > 0) {
          i = endNormal.similarity(end.translated(endNormal.scaled(10)));
        } else {
          if (horizontal) {
            i = average.y;
          } else {
            i = average.x;
          }
        }
        positions.add(i);
        horizontal = !horizontal;
      }
    } else {
      if (startNormal.dot(endNormal) > 0) {
        //1
        if (startNormal.dot(direction) >= 0) i = startNormal.similarity(start.translated(startNormal.scaled(10)));else i = endNormal.similarity(end.translated(endNormal.scaled(10)));
        positions.add(i);
        horizontal = !horizontal;
      } else {
        //3 or 1
        if (startNormal.dot(direction) < 0) {
          i = startNormal.similarity(start.translated(startNormal.scaled(10)));
          positions.add(i);
          horizontal = !horizontal;
        }

        // my tweak to route SCA wires starts
        if (this.isCycle(conn)) {
          if (horizontal) i = conn.getSource().getParent().getBoundingBox().getTop() - 10; // * index;
          else i = conn.getSource().getParent().getBoundingBox().getRight() + 10; // * index;
        } else {
          if (horizontal) {
            var j = average.y;

            var next = endNormal.similarity(end.translated(endNormal.scaled(10)));

            var trial = new _packages2.default.geo.Ray(positions.get(positions.getSize() - 1), j);
            var figure = this.findFirstFigureAtStraightLine(canvas, trial, this.LEFT, _packages2.default.util.ArrayList.EMPTY_LIST);

            while (figure != null && figure.getBoundingBox().x + figure.getBoundingBox().width > next) {
              j = figure.getBoundingBox().y + figure.getBoundingBox().height + 5;
              trial.y = j;
              figure = this.findFirstFigureAtStraightLine(canvas, trial, this.LEFT, _packages2.default.util.ArrayList.EMPTY_LIST);
            }

            i = j;
          } else {
            var _figure = this.findFirstFigureAtStraightLine(canvas, start, this.RIGHT, this.getExcludingFigures(conn));
            if (_figure == null) i = average.x;else {
              i = Math.min(average.x, start.translated(new _packages2.default.geo.Ray(3 * (_figure.getBoundingBox().x - start.x) / 4, 0)).x);
              i = Math.max(start.x, i);
            }
            i = this.adjust(conn, i);
          }
        }
        // my tweak to route SCA wires ends
        positions.add(i);
        horizontal = !horizontal;
      }
    }
    if (horizontal) positions.add(end.y);else positions.add(end.x);

    this.processPositions(start, end, positions, startNormal.isHorizontal(), conn);

    this._paint(conn);
  },

  /**
   *
   *
   * @param {draw2d.Connection} connection
   * @param {Number} r
   * @param {Number} n
   * @param {Number} x
   *
   * @private
   */
  getColumnNear: function getColumnNear(connection, r, n, x) {
    var min = Math.min(n, x);
    var max = Math.max(n, x);

    if (min > r) {
      max = min;
      min = r - (min - r);
    }
    if (max < r) {
      min = max;
      max = r + (r - max);
    }

    var proximity = 0;
    var direction = -1;
    if (r % 6 !== 0) {
      r = r - r % 6;
    }

    var i = void 0;
    while (proximity < r) {
      i = parseInt(r + proximity * direction);
      if (!(i in this.colsUsed)) {
        this.colsUsed[i] = i;
        this.reserveColumn(connection, i);
        return i;
      }

      if (i <= min) {
        return i + 6;
      }

      if (i >= max) {
        return i - 6;
      }

      if (direction === 1) {
        direction = -1;
      } else {
        direction = 1;
        proximity += 6;
      }
    }
    return r;
  },

  getRowNear: function getRowNear(connection, r, n, x) {
    var min = Math.min(n, x);
    var max = Math.max(n, x);

    if (min > r) {
      max = min;
      min = r - (min - r);
    }
    if (max < r) {
      min = max;
      max = r + (r - max);
    }

    var proximity = 0;
    var direction = -1;
    if (r % 6 !== 0) {
      r = r - r % 6;
    }

    var i = void 0;
    while (proximity < r) {
      i = parseInt(r + proximity * direction);
      if (!(i in this.rowsUsed)) {
        this.rowsUsed[i] = i;
        this.reserveRow(connection, i);
        return i;
      }
      if (i <= min) return i + 6;
      if (i >= max) return i - 6;
      if (direction === 1) direction = -1;else {
        direction = 1;
        proximity += 6;
      }
    }
    return r;
  },

  /**
   *   <li>up -&gt; 0</li>
   *   <li>right -&gt; 1</li>
   *   <li>down -&gt; 2</li>
   *   <li>left -&gt; 3</li>
   **/
  getEndDirection: function getEndDirection(conn) {
    var p = conn.getEndPoint();
    var rect = conn.getTarget().getParent().getBoundingBox();
    return this.getDirection(rect, p);
  },

  /**
   *   <li>up -&gt; 0</li>
   *   <li>right -&gt; 1</li>
   *   <li>down -&gt; 2</li>
   *   <li>left -&gt; 3</li>
   **/
  getStartDirection: function getStartDirection(conn) {
    var p = conn.getStartPoint();
    var rect = conn.getSource().getParent().getBoundingBox();
    return this.getDirection(rect, p);
  },

  /**
   * Returns the direction the point <i>p</i> is in relation to the given rectangle.
   * Possible values are LEFT (-1,0), RIGHT (1,0), UP (0,-1) and DOWN (0,1).
   *
   * @param r the rectangle
   * @param p the point
   * @returns the direction from <i>r</i> to <i>p</i>
   */
  getDirection: function getDirection(r, p) {
    var i = Math.abs(r.y - p.y);
    var distance = Math.abs(r.x - p.x);
    var direction = this.LEFT;

    if (i <= distance) {
      distance = i;
      direction = this.UP;
    }

    i = Math.abs(r.getBottom() - p.y);
    if (i <= distance) {
      distance = i;
      direction = this.DOWN;
    }

    i = Math.abs(r.getRight() - p.x);
    if (i < distance) {
      direction = this.RIGHT;
    }

    return direction;
  },

  processPositions: function processPositions( /*Ray*/start, /*Ray*/end, /*List*/positions, /*boolean*/horizontal, /*Connection*/conn) {
    this.removeReservedLines(conn);

    var pos = [];
    if (horizontal) pos.push(start.x);else pos.push(start.y);
    var i = void 0;
    for (i = 0; i < positions.getSize(); i++) {
      pos.push(positions.get(i));
    }

    if (horizontal === (positions.getSize() % 2 === 1)) {
      pos.push(end.x);
    } else {
      pos.push(end.y);
    }

    conn.addPoint(new _packages2.default.geo.Point(start.x, start.y));
    var p = void 0;
    var current = void 0,
        prev = void 0,
        min = void 0,
        max = void 0;
    var adjust = void 0;
    for (i = 2; i < pos.length - 1; i++) {
      horizontal = !horizontal;
      prev = pos[i - 1];
      current = pos[i];

      adjust = i !== pos.length - 2;
      if (horizontal) {
        if (adjust) {
          min = pos[i - 2];
          max = pos[i + 2];
          pos[i] = current = this.getRowNear(conn, current, min, max);
        }
        p = new _packages2.default.geo.Point(prev, current);
      } else {
        if (adjust) {
          min = pos[i - 2];
          max = pos[i + 2];
          pos[i] = current = this.getColumnNear(conn, current, min, max);
        }
        p = new _packages2.default.geo.Point(current, prev);
      }
      conn.addPoint(p);
    }
    conn.addPoint(new _packages2.default.geo.Point(end.x, end.y));
  },

  removeReservedLines: function removeReservedLines(connection) {
    var rInfo = this.reservedInfo[connection];
    if (typeof rInfo === "undefined" || rInfo === null) return;

    for (var i = 0; i < rInfo.reservedRows.getSize(); i++) {
      delete this.rowsUsed[rInfo.reservedRows.get(i)];
    }
    for (var _i = 0; _i < rInfo.reservedCols.getSize(); _i++) {
      delete this.colsUsed[rInfo.reservedCols.get(_i)];
    }
    delete this.reservedInfo[connection];
  },

  reserveColumn: function reserveColumn(connection, column) {
    var info = this.reservedInfo[connection];
    if (typeof info === "undefined" || info === null) {
      info = { reservedCols: new _packages2.default.util.ArrayList(), reservedRows: new _packages2.default.util.ArrayList() };
      this.reservedInfo[connection] = info;
    }
    info.reservedCols.add(column);
  },

  reserveRow: function reserveRow(connection, row) {
    var info = this.reservedInfo[connection];
    if (typeof info === "undefined" || info === null) {
      info = { reservedCols: new _packages2.default.util.ArrayList(), reservedRows: new _packages2.default.util.ArrayList() };
      this.reservedInfo[connection] = info;
    }
    info.reservedRows.add(row);
  },

  getConstraint: function getConstraint(connection) {
    return this.constraints[connection];
  },

  setConstraint: function setConstraint(connection, constraint) {
    this.constraints[connection] = constraint;
  },

  isCycle: function isCycle(conn) {
    var source = conn.getSource().getParent();
    var target = conn.getTarget().getParent();

    return source.id === target.id;
  },

  getExcludingFigures: function getExcludingFigures(conn) {
    var excluding = new _packages2.default.util.ArrayList();

    excluding.add(conn.getSource().getParent());
    excluding.add(conn.getTarget().getParent());

    return excluding;
  },

  findFirstFigureAtStraightLine: function findFirstFigureAtStraightLine(canvas, /*Ray*/start, /*Ray*/direction, /*List*/excluding) {
    var figure = null;

    var figures = canvas.getFigures();
    var _this = this;
    figures.each(function (i, child) {
      try {
        if (!excluding.contains(child)) {
          var rect = child.getBoundingBox();
          if (_this.LEFT.equals(direction)) {
            if (start.x > rect.x && start.y >= rect.y && start.y <= rect.y + rect.h) {
              if (figure === null || rect.x > figure.getBoundingBox().x) figure = child;
            }
          } else if (_this.RIGHT.equals(direction)) {
            if (start.x < rect.x + rect.w && start.y >= rect.y && start.y <= rect.y + rect.h) {
              if (figure == null || rect.x < figure.getBoundingBox().x) figure = child;
            }
          } else if (_this.UP.equals(direction)) {
            if (start.y > rect.y && start.x >= rect.x && start.x <= rect.x + rect.w) {
              if (figure === null || rect.y > figure.getBoundingBox().y) figure = child;
            }
          } else if (_this.DOWN.equals(direction)) {
            if (start.y < rect.y + rect.h && start.x >= rect.x && start.x <= rect.x + rect.w) {
              if (figure === null || rect.y < figure.getBoundingBox().y) figure = child;
            }
          }
        }
      } catch (exc) {
        console.log(exc);
        debugger;
      }
    });
    return figure;
  },

  adjust: function adjust(connection, col) {
    var column = col;

    var start = connection.getSource().getPosition();

    var connections = connection.getCanvas().getLines();
    connections.each(function (i, conn) {
      try {
        if (conn === connection) return;

        var end = conn.getTarget().getPosition();
        if (start.x < end.x && start.y === end.y) {
          if (conn.getVertices().getMidpoint().x <= col) column = conn.getVertices().getMidpoint().x - 5;
        }
      } catch (exc) {
        console.log(exc);
        debugger;
      }
    });
    return column;
  }

});

/***/ }),

/***/ "./src/layout/connection/RubberbandRouter.js":
/*!***************************************************!*\
  !*** ./src/layout/connection/RubberbandRouter.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Router for direct connections between two ports with a rubber band effect
 *
 *
 * @example
 *
 *    let RubberConnection= draw2d.Connection.extend({
 *        NAME: "RubberConnection",
 *
 *        init:function(attr, setter, getter)
 *        {
 *          this._super(extend({
 *              color: "#33691e",
 *              stroke:1,
 *              outlineStroke:0,
 *              outlineColor:null
 *          },attr),
 *          setter,
 *          getter);
 *
 *
 *          this.setRouter(new draw2d.layout.connection.RubberbandRouter());
 *        },
 *
 *        repaint:function(attributes)
 *        {
 *            if (this.repaintBlocked===true || this.shape === null){
 *                return;
 *            }
 *            attributes= attributes || {};
 *            // enrich the rendering with a "fill" attribute
 *            if(typeof attributes.fill === "undefined"){
 *            	   attributes.fill = "#aed581";
 *            }
 *            this._super(attributes);
 *       }
 *    });
 *
 *    let createConnection=function(){
 *       let con = new RubberConnection();
 *       return con;
 *    };
 *
 *    // install a custom connection create policy
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *           createConnection: createConnection
 *    }));
 *
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let start = new draw2d.shape.node.Start();
 *    let end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */
_packages2.default.layout.connection.RubberbandRouter = _packages2.default.layout.connection.ConnectionRouter.extend(
/** @lends draw2d.layout.connection.RubberbandRouter.prototype */
{

  NAME: "draw2d.layout.connection.RubberbandRouter",

  /**
   * Creates a new Router object
   *
   */
  init: function init() {
    this._super();
  },

  /**
   * 
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  },

  /**
   * 
   * Invalidates the given Connection
   */
  invalidate: function invalidate() {},

  /**
   * @inheritdoc
   */
  route: function route(connection, routingHints) {
    var thickness = 10;

    var start = connection.getStartPoint();
    var end = connection.getEndPoint();

    // 1. Calculate the vector AB by subtracting the coordinates of A from the coordinates of B.
    //    Let's say you get (u,v) as the vector components.
    //
    // 2. normalize the vector (u,v,) to a length of |1|
    //
    // 3. The vector (v,u) is AB rotated by 90 degrees counterclockwise. (Why? Look up "rotation matrix").
    //
    // 4. Add (v,u) to A to get C. Also add (v,u) to B to get D.

    var uv = end.subtract(start);
    var uv2 = uv.clone();
    var length = uv.length();

    var strength = 1 - Math.min(0.75, 1 / 500 * length);
    var first = start.lerp(end, 0.25 * strength); // go closer to the start point if the strength grows
    var second = start.lerp(end, 0.5);
    var third = start.lerp(end, 1 - 0.25 * strength); // go closer to the end point if the strengths grows

    thickness = Math.max(5, thickness * strength);

    uv.x = uv.x / length * thickness;
    uv.y = uv.y / length * thickness;

    uv2.x = uv2.x / length * (thickness * strength);
    uv2.y = uv2.y / length * (thickness * strength);

    // anchor points for the 180 arc at the start point of the connection
    //
    var start90 = new _packages2.default.geo.Point(-uv.y + start.x, uv.x + start.y);
    var start270 = new _packages2.default.geo.Point(uv.y + start.x, -uv.x + start.y);

    // anchor point in the first segment ( on the upside/downside) of the connection
    //
    var first90 = new _packages2.default.geo.Point(-uv2.y + first.x, uv2.x + first.y);
    var first270 = new _packages2.default.geo.Point(uv2.y + first.x, -uv2.x + first.y);

    // center upside/downside anchor point of the connection
    //
    var second90 = new _packages2.default.geo.Point(-uv2.y + second.x, uv2.x + second.y);
    var second270 = new _packages2.default.geo.Point(uv2.y + second.x, -uv2.x + second.y);

    // anchor point in the third segment of the connection
    //
    var third90 = new _packages2.default.geo.Point(-uv2.y + third.x, uv2.x + third.y);
    var third270 = new _packages2.default.geo.Point(uv2.y + third.x, -uv2.x + third.y);

    // anchor point for the 180 arc at the end
    //
    var end90 = new _packages2.default.geo.Point(-uv.y + end.x, uv.x + end.y);
    var end270 = new _packages2.default.geo.Point(uv.y + end.x, -uv.x + end.y);

    // required for hit tests
    //
    connection.addPoint(start);
    connection.addPoint(end);

    // calculate the path
    var path = ["M", start90.x, ",", start90.y];
    path.push("A", thickness, ",", thickness, "0 0 1 ", start270.x, ",", start270.y);
    path.push("C", start270.x, ",", start270.y, first270.x, ",", first270.y, second270.x, ",", second270.y);
    path.push("C", second270.x, ",", second270.y, third270.x, ",", third270.y, end270.x, ",", end270.y);
    path.push("A", thickness, ",", thickness, "0 0 1", end90.x, ",", end90.y);
    path.push("C", end90.x, ",", end90.y, third90.x, ",", third90.y, second90.x, ",", second90.y);
    path.push("C", second90.x, ",", second90.y, first90.x, ",", first90.y, start90.x, ",", start90.y);

    connection.svgPathString = path.join(" ");
  }
});

/***/ }),

/***/ "./src/layout/connection/SketchConnectionRouter.js":
/*!*********************************************************!*\
  !*** ./src/layout/connection/SketchConnectionRouter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Provide a router which routes the connection in a hand drawn manner.
 *
 * @example
 *
 *    let createConnection=function(){
 *       let con = new draw2d.Connection();
 *       con.setRouter(new draw2d.layout.connection.SketchConnectionRouter());
 *       return con;
 *    };
 *
 *    // install a custom connection create policy
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *           createConnection: createConnection
 *    }));
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let f1 = new draw2d.shape.analog.OpAmp({x:10, y:10});
 *    let f2 = new draw2d.shape.analog.ResistorVertical({angle:90, height:20, x:300, y:150});
 *
 *    // ...add it to the canvas
 *    //
 *    canvas.add( f1);
 *    canvas.add( f2);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(f1.getOutputPort(0));
 *    c.setTarget(f2.getHybridPort(0));
 *    canvas.add(c);
 *
 * @inheritable
 * @author Andreas Herz
 * @since 2.7.2
 * @extends  draw2d.layout.connection.MazeConnectionRouter
 */
_packages2.default.layout.connection.SketchConnectionRouter = _packages2.default.layout.connection.MazeConnectionRouter.extend(
/** @lends draw2d.layout.connection.SketchConnectionRouter.prototype */
{
  NAME: "draw2d.layout.connection.SketchConnectionRouter",

  /**
   * Creates a new Router object.
   *
   */
  init: function init() {
    this._super();

    this.useSpline = true;
    this.useShift = 5;
    this.useSimplifyValue = 0.2;
    this.finder = new PF.JumpPointFinder({ allowDiagonal: false, dontCrossCorners: true });
  },

  /**
   *
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  }
});

/***/ }),

/***/ "./src/layout/connection/SplineConnectionRouter.js":
/*!*********************************************************!*\
  !*** ./src/layout/connection/SplineConnectionRouter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A ManhattanConnectionRouter with an spline interpolation between the bend points.
 *
 * @example
 *
 *    let createConnection=function(){
 *       let con = new draw2d.Connection();
 *       con.setRouter(new draw2d.layout.connection.SplineConnectionRouter());
 *       return con;
 *    };
 *
 *    // install a custom connection create policy
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *           createConnection: createConnection
 *    }));
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let f1 = new draw2d.shape.analog.OpAmp({x:10, y:10});
 *    let f2 = new draw2d.shape.analog.ResistorVertical({angle:90, height:20, x:300, y:150});
 *
 *    // ...add it to the canvas
 *    //
 *    canvas.add( f1);
 *    canvas.add( f2);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(f1.getOutputPort(0));
 *    c.setTarget(f2.getHybridPort(0));
 *    canvas.add(c);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.layout.connection.ManhattanConnectionRouter
 */
_packages2.default.layout.connection.SplineConnectionRouter = _packages2.default.layout.connection.ManhattanConnectionRouter.extend(
/** @lends draw2d.layout.connection.SplineConnectionRouter.prototype */
{

  NAME: "draw2d.layout.connection.SplineConnectionRouter",

  /**
   * Creates a new Router object
   */
  init: function init() {
    this._super();

    //        this.spline = new draw2d.util.spline.CatmullRomSpline();
    this.spline = new _packages2.default.util.spline.CubicSpline();
    //        this.spline = new draw2d.util.spline.BezierSpline();

    this.MINDIST = 50;
  },

  /**
   *
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
  },

  /**
   * @inheritdoc
   */
  route: function route(conn, routingHints) {
    var i = void 0;
    var fromPt = conn.getStartPoint();
    var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());

    var toPt = conn.getEndPoint();
    var toDir = conn.getTarget().getConnectionDirection(conn.getSource());

    // calculate the manhatten bend points between start/end.
    //
    this._route(conn, toPt, toDir, fromPt, fromDir);

    var ps = conn.getVertices();

    conn.oldPoint = null;
    conn.lineSegments = new _packages2.default.util.ArrayList();
    conn.vertices = new _packages2.default.util.ArrayList();

    var splinePoints = this.spline.generate(ps, 8);
    splinePoints.each(function (i, e) {
      conn.addPoint(e);
    });

    // calculate the path string for the SVG rendering
    //
    ps = conn.getVertices();
    var length = ps.getSize();
    var p = ps.get(0);
    var path = ["M", p.x, " ", p.y];
    for (i = 1; i < length; i++) {
      p = ps.get(i);
      path.push("L", p.x, " ", p.y);
    }
    conn.svgPathString = path.join("");
  }
});

/***/ }),

/***/ "./src/layout/connection/VertexRouter.js":
/*!***********************************************!*\
  !*** ./src/layout/connection/VertexRouter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A Router with unlimited vertices.
 *
 *
 * @example
 *
 *    // Override the default connection type. This is used during drag&drop operations of ports.
 *    //
 *    let createConnection=function(){
 *       // return my special kind of connection
 *       let con = new draw2d.Connection();
 *       con.setRouter(new draw2d.layout.connection.VertexRouter());
 *       return con;
 *    };
 *
 *    // Install a special policy into the canvas to use my own implementation of connection
 *    // if we drag&drop a port
 *    //
 *    canvas.installEditPolicy(  new draw2d.policy.connection.DragConnectionCreatePolicy({
 *          createConnection: createConnection
 *    }));
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let start = new draw2d.shape.node.Start();
 *    let end   = new draw2d.shape.node.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,80);
 *
 *    // first Connection
 *    //
 *    let c = createConnection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends  draw2d.layout.connection.ConnectionRouter
 */
_packages2.default.layout.connection.VertexRouter = _packages2.default.layout.connection.ConnectionRouter.extend(
/** @lends draw2d.layout.connection.VertexRouter.prototype */
{

  NAME: "draw2d.layout.connection.VertexRouter",

  /**
   * Creates a new Router object
   *
   */
  init: function init() {
    this._super();
  },

  /**
   *
   * Callback method if the router has been assigned to a connection.
   *
   * @param {draw2d.Connection} connection The assigned connection
   * @template
   * @since 2.7.2
   */
  onInstall: function onInstall(connection) {
    connection.installEditPolicy(new _packages2.default.policy.line.VertexSelectionFeedbackPolicy());
  },

  /**
   *
   * Invalidates the given Connection
   */
  invalidate: function invalidate() {},

  /**
   * @inheritdoc
   */
  route: function route(connection, routingHints) {
    // reuse all existing vertex points
    //
    var count = routingHints.oldVertices.getSize();
    for (var i = 0; i < count; i++) {
      connection.addPoint(routingHints.oldVertices.get(i));
    }

    var ps = connection.getVertices();

    // respect the calculated anchor position if the start/end port has set any Anchor impl.
    var startAnchor = connection.getStartPosition(ps.get(1));
    var endAnchor = connection.getEndPosition(ps.get(ps.getSize() - 2));
    ps.first().setPosition(startAnchor);
    ps.last().setPosition(endAnchor);

    this._paint(connection);
  },

  /**
   *
   * Callback method for the PolyLine or Connection to check if it possible to remove a vertex from
   * the list. The router can send an veto for this.
   * Per default it is not possible to remove any vertex from the PolyLine exceptional if any interactive
   * router is installed.
   *
   * @param {draw2d.Connection} conn
   * @param {Number} index
   *
   * @since 4.2.3
   */
  canRemoveVertexAt: function canRemoveVertexAt(conn, index) {
    return false;
  },

  /**
   * Callback method for the PolyLine or Connection to verify that a segment is deletable.
   *
   * @param {draw2d.Connection} conn
   * @param {Number} index
   *
   * @returns {Boolean}
   * @since 4.2.3
   */
  canRemoveSegmentAt: function canRemoveSegmentAt(conn, index) {

    var segmentCount = conn.getVertices().getSize() - 1; // segmentCount is one less than vertex count

    // The first and last segment isn't deletable
    //
    if (index <= 0 || index >= segmentCount) {
      return false;
    }

    // a connection need at least one strokes
    //
    return segmentCount >= 2;
  },

  /**
   *
   * Tweak or enrich the polyline persistence data with routing information
   *
   * @since 2.10.0
   * @param {draw2d.shape.basic.PolyLine} line
   * @param {Object} memento The memento data of the polyline
   *
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes(line, memento) {
    memento.vertex = [];

    line.getVertices().each(function (i, e) {
      memento.vertex.push({ x: e.x, y: e.y });
    });

    return memento;
  },

  /**
   *
   * set the attributes for the polyline with routing information
   *
   * @since 2.10.0
   * @param {Object} memento
   */
  setPersistentAttributes: function setPersistentAttributes(line, memento) {
    // restore the points from the JSON data and add them to the polyline
    //
    if (Array.isArray(memento.vertex) && memento.vertex.length > 1) {

      line.oldPoint = null;
      line.lineSegments = new _packages2.default.util.ArrayList();

      line.setVertices(memento.vertex);
    }
  },

  /**
   *
   *
   * The draw2d.Connection delegates the drag operation to the router. The router can
   * handle the different constraints of the connection and just drag&drop a single segment
   * instead of the complete connection.
   *
   * @param {draw2d.shape.basic.Line} line the related line to handle
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   *
   * @since 6.1.0
   */
  onDrag: function onDrag(line, dx, dy, dx2, dy2) {
    var count = line.getVertices().getSize() - 1;
    for (var i = 1; i < count; i++) {
      line.getVertex(i).translate(dx2, dy2);
    }
  }

});

/***/ }),

/***/ "./src/layout/locator/BottomLocator.js":
/*!*********************************************!*\
  !*** ./src/layout/locator/BottomLocator.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A bottomLocator is used to place figures at the bottom of a parent shape.
 *
 *
 *
 * @example
 *
 *    // create a basic figure and add a Label/child via API call
 *    //
 *    let circle = new draw2d.shape.basic.Circle({
 *        x:100,
 *        y:50,
 *        diameter:100,
 *        stroke: 3,
 *        color:"#A63343",
 *        bgColor:"#E65159"
 *    });
 *
 *    circle.add(new draw2d.shape.basic.Label({text:"Bottom Label"}), new draw2d.layout.locator.BottomLocator());
 *    canvas.add( circle);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.BottomLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.BottomLocator.prototype */
{

  NAME: "draw2d.layout.locator.BottomLocator",

  /**
   *
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Relocates the given Figure.
   *
   * @param {Number} index child index of the target
   * @param {draw2d.Figure} target The figure to relocate
   **/
  relocate: function relocate(index, target) {
    var parent = target.getParent();
    var boundingBox = parent.getBoundingBox();
    // I made a wrong decision in the port handling: anchor point
    // is in the center and not topLeft. Now I must correct this flaw here, and there, and...
    // shit happens.
    var offset = parent instanceof _packages2.default.Port ? boundingBox.w / 2 : 0;

    var targetBoundingBox = target.getBoundingBox();
    if (target instanceof _packages2.default.Port) {
      target.setPosition(boundingBox.w / 2 - offset, boundingBox.h);
    } else {
      target.setPosition(boundingBox.w / 2 - targetBoundingBox.w / 2 - offset, 2 + boundingBox.h);
    }
  }
});

/***/ }),

/***/ "./src/layout/locator/CenterLocator.js":
/*!*********************************************!*\
  !*** ./src/layout/locator/CenterLocator.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A CenterLocator is used to place figures in the center of a parent shape.
 *
 *
 *
 * @example
 *
 *
 *    // create a basic figure and add a Label/child via API call
 *    //
 *    let circle = new draw2d.shape.basic.Circle({diameter:120});
 *    circle.setStroke(3);
 *    circle.setColor("#A63343");
 *    circle.setBackgroundColor("#E65159");
 *    circle.add(new draw2d.shape.basic.Label({text:"Center Label"}), new draw2d.layout.locator.CenterLocator());
 *    canvas.add( circle, 100,50);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.CenterLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.CenterLocator.prototype */
{

  NAME: "draw2d.layout.locator.CenterLocator",

  /**
   * Constructs a locator with associated parent.
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Relocates the given Figure.
   *
   * @param {Number} index child index of the target
   * @param {draw2d.Figure} target The figure to relocate
   **/
  relocate: function relocate(index, target) {
    var parent = target.getParent();
    var boundingBox = parent.getBoundingBox();

    // TODO: instanceof is always a HACK. ugly. Redirect the call to the figure instead of 
    // determine the position with a miracle.
    //
    if (target instanceof _packages2.default.Port) {
      target.setPosition(boundingBox.w / 2, boundingBox.h / 2);
    } else {
      var targetBoundingBox = target.getBoundingBox();
      target.setPosition((boundingBox.w / 2 - targetBoundingBox.w / 2 | 0) + 0.5, (boundingBox.h / 2 - targetBoundingBox.h / 2 | 0) + 0.5);
    }
  }
});

/***/ }),

/***/ "./src/layout/locator/ConnectionLocator.js":
/*!*************************************************!*\
  !*** ./src/layout/locator/ConnectionLocator.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Repositions a Figure attached to a Connection when the
 * Connection is moved. Provides for alignment at the start
 * (source), middle, or end (target) of the Connection.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.ConnectionLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.ConnectionLocator.prototype */
{

  NAME: "draw2d.layout.locator.ConnectionLocator",

  /**
   * Default constructor for a Locator which can layout a figure in context of a
   * {@link draw2d.Connector}
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  }

});

/***/ }),

/***/ "./src/layout/locator/DraggableLocator.js":
/*!************************************************!*\
  !*** ./src/layout/locator/DraggableLocator.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A DraggableLocator is used to place figures relative to the parent top left corner. It is
 * possible to move a child node via drag&drop.
 *
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.DraggableLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.DraggableLocator.prototype */
{

  NAME: "draw2d.layout.locator.DraggableLocator",

  /**
   * Constructs a locator with associated parent.
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  bind: function bind(parent, child) {
    // override the parent implementation to avoid
    // that the child is "!selectable" and "!draggable"

    // Don't redirect the selection handling to the parent
    // Using the DraggableLocator provides the ability to the children
    // that they are selectable and draggable. Remove the SelectionAdapter from the parent
    // assignment.
    child.setSelectionAdapter(function () {
      return child;
    });
  },

  unbind: function unbind(parent, child) {
    // use default
    child.setSelectionAdapter(null);
  }
});

/***/ }),

/***/ "./src/layout/locator/InputPortLocator.js":
/*!************************************************!*\
  !*** ./src/layout/locator/InputPortLocator.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Repositions a Figure attached to a Connection when the
 * Connection is moved. Provides for alignment at the start
 * (source), middle, or end (target) of the Connection.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.PortLocator
 */
_packages2.default.layout.locator.InputPortLocator = _packages2.default.layout.locator.PortLocator.extend(
/** @lends draw2d.layout.locator.InputPortLocator.prototype */
{

  NAME: "draw2d.layout.locator.InputPortLocator",

  /**
   * Default constructor for a Locator which can layout a port in context of a
   * {@link draw2d.shape.node.Node}
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Controls the location of an {@link draw2d.Figure}
   *
   * @param {Number} index port index of the figure
   * @param {draw2d.Figure} figure the figure to control
   *
   * @template
   **/
  relocate: function relocate(index, figure) {
    var node = figure.getParent();

    var dividerFactor = 1;
    var thisNAME = this.NAME;
    var portIndex = 1;
    node.getPorts().each(function (i, p) {
      portIndex = p === figure ? dividerFactor : portIndex;
      dividerFactor += p.getLocator().NAME === thisNAME ? 1 : 0;
    });
    this.applyConsiderRotation(figure, 0, node.getHeight() / dividerFactor * portIndex);
  }

});

/***/ }),

/***/ "./src/layout/locator/LeftLocator.js":
/*!*******************************************!*\
  !*** ./src/layout/locator/LeftLocator.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A LeftLocator is used to place figures to the left of a parent shape.
 *
 *
 *
 * @example
 *
 *    // create a basic figure and add a Label/child via API call
 *    //
 *    let start = new draw2d.shape.node.Start();
 *    start.add(new draw2d.shape.basic.Label({text:"Left Label"}), new draw2d.layout.locator.LeftLocator({
 *     margin:10  // distance to the parent shape
 *    }));
 *    canvas.add( start, 100,50);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.LeftLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.LeftLocator.prototype */
{

  NAME: "draw2d.layout.locator.LeftLocator",

  /**
   * Constructs a locator with associated parent.
   *
   * @param {Object} attr additional init attributes
   * @param {Object} setter key/value map of injected setter-methods
   * @param {Object} getter key/value map of injected getter-methods
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.margin = attr && "margin" in attr ? attr.margin : 5;
  },

  /**
   *
   * Relocates the given Figure.
   *
   * @param {Number} index child index of the target
   * @param {draw2d.Figure} target The figure to relocate
   **/
  relocate: function relocate(index, target) {
    var parent = target.getParent();
    var boundingBox = parent.getBoundingBox();

    // I made a wrong decision in the port handling: anchor point
    // is in the center and not topLeft. Now I must correct this flaw here, and there, and...
    // shit happens.
    var offset = parent instanceof _packages2.default.Port ? boundingBox.h / 2 : 0;

    if (target instanceof _packages2.default.Port) {
      target.setPosition(0, boundingBox.h / 2 - offset);
    } else {
      var targetBoundingBox = target.getBoundingBox();
      target.setPosition(-targetBoundingBox.w - this.margin, boundingBox.h / 2 - targetBoundingBox.h / 2 - offset);
    }
  }
});

/***/ }),

/***/ "./src/layout/locator/Locator.js":
/*!***************************************!*\
  !*** ./src/layout/locator/Locator.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

var _JSONUtil = __webpack_require__(/*! ../../util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @class
 *
 * Controls the location of an IFigure.
 *
 * @author Andreas Herz
 */
_packages2.default.layout.locator.Locator = Class.extend(
/** @lends draw2d.layout.locator.Locator.prototype */
{

  NAME: "draw2d.layout.locator.Locator",

  /**
   * Initial Constructor
   *
   * @param {Object} attr additional init attributes
   * @param {Object} setter key/value map of injected setter-methods
   * @param {Object} getter key/value map of injected getter-methods
   */
  init: function init(attr, setter, getter) {

    this.setterWhitelist = (0, _extend2.default)({}, setter);
    this.getterWhitelist = (0, _extend2.default)({}, getter);

    // propagate the attr to the new instance
    this.attr(attr);
  },

  /**
   *
   * Read or set locator attributes.<br>
   * When no value is given, reads specified attribute from the element.<br>
   * When value is given, sets the attribute to that value.
   * Multiple attributes can be set by passing an object with name-value pairs.
   *
   *
   *    // multiple attributes:
   *    locator.attr({
   *      x: 30,
   *      y: 40
   *    });
   *
   *    let data = locator.attr()
   *
   *
   * @param {String/Object} name
   * @param {Object} [value]
   * @since 5.0.1
   * @experimental
   * @returns {Object} either the requested attribute if this method used as getter or `this` if the method uses as setter
   **/
  attr: function attr(name, value) {
    var _this = this;

    // call of attr as setter method with {name1:val1, name2:val2 }  argument list
    //
    if ($.isPlainObject(name)) {
      for (var key in name) {
        var func = this.setterWhitelist[key];
        var param = name[key];
        if (func && param !== undefined) {
          func.call(this, param);
        }
      }
    } else if (typeof name === "string") {
      // call attr as getter
      //
      if (typeof value === "undefined") {
        var getter = this.getterWhitelist[name];
        if (typeof getter === "function") {
          return getter.call(this);
        }
        return; // undefined
      }

      // the value can be a function. In this case we must call the value().
      if (typeof value === "function") {
        value = value();
      }
      var setter = this.setterWhitelist[name];
      if (setter) {
        setter.call(this, value);
      }
    }
    // may it is a array of attributes used for the getter
    //
    else if (Array.isArray(name)) {
        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.keys(name).map(function (k) {
          return _defineProperty({}, k, _this.attr(k));
        }))));
      }
      // generic getter of all registered attributes
      else if (typeof name === "undefined") {
          var result = {};
          for (var _key in this.getterWhitelist) {
            result[_key] = this.getterWhitelist[_key].call(this);
          }
          return result;
        }

    return this;
  },

  /**
   *
   * Callback method if a child is bounded to a parent. This is
   * the perfect moment to prepare the child node with some basic
   * behaviour which are forced by the <code>Locator</code>
   *
   * @param {draw2d.Figure} figure
   * @param {draw2d.Figure} child
   * @returns {this}
   */
  bind: function bind(figure, child) {
    // default behaviour of an Locator. The child isn't draggable and
    // the locator defines the position of the child.
    //
    child.setDraggable(false);
    child.setSelectable(false);

    return this;
  },

  /**
   *
   * Callback method if a child is unbounded to the locator.
   *
   * @param {draw2d.Figure} figure
   * @param {draw2d.Figure} child
   * @returns {this}
   */
  unbind: function unbind(figure, child) {

    return this;
  },

  /**
   *
   * Controls the location of an I{@link draw2d.Figure}
   *
   * @param {Number} index child index of the figure
   * @param {draw2d.Figure} figure the figure to control
   *
   * @private
   **/
  relocate: function relocate(index, figure) {
    // just repaint the child to update the SVG related to the new location
    // of the parent.
    figure.repaint();
  },

  /**
   *
   * Return a clone of the locator object
   *
   * @returns {draw2d.layout.locator.Locator}
   */
  clone: function clone() {
    return eval("new " + this.NAME + "()");
  }
});

/***/ }),

/***/ "./src/layout/locator/ManhattanMidpointLocator.js":
/*!********************************************************!*\
  !*** ./src/layout/locator/ManhattanMidpointLocator.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A ManhattanMidpointLocator that is used to place figures at the midpoint of a Manhatten routed
 * connection. The midpoint is always in the center of an edge.
 *
 *
 *
 * @example
 *
 *    // create and add two Node which contains Ports (In and OUT)
 *    let start = new draw2d.shape.node.Start({x:50,y:50});
 *    let end   = new draw2d.shape.node.End({x:230,y:100});
 *
 *    canvas.add( start);
 *    canvas.add( end);
 *
 *    // Create a Connection and connect the Start and End node
 *    //
 *    let c = new draw2d.Connection();
 *    c.setSource(start.getOutputPort(0));
 *    c.setTarget(end.getInputPort(0));
 *    canvas.add(c);
 *
 *    // create a label which should attach to the connection
 *    //
 *    let label = new draw2d.shape.basic.Label({text:"I'm a Label"});
 *    label.setColor("#0d0d0d");
 *    label.setFontColor("#0d0d0d");
 *    label.setBackgroundColor("#f0f0f0");
 *
 *    // add the decoration to the connection with a ManhattanMidpointLocator.
 *    //
 *    c.add(label, new draw2d.layout.locator.ManhattanMidpointLocator());
 *
 * @author Andreas Herz
 * @extends draw2d.layout.locator.ConnectionLocator
 */
_packages2.default.layout.locator.ManhattanMidpointLocator = _packages2.default.layout.locator.ConnectionLocator.extend(
/** @lends draw2d.layout.locator.ManhattanMidpointLocator.prototype */
{

  NAME: "draw2d.layout.locator.ManhattanMidpointLocator",

  /**
   * Constructs a ManhattanMidpointLocator with associated Connection c.
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Relocates the given Figure always in the center of an edge.
   *
   * @param {Number} index child index of the target
   * @param {draw2d.Figure} target The figure to relocate
   **/
  relocate: function relocate(index, target) {
    var conn = target.getParent();
    var points = conn.getVertices();

    var segmentIndex = Math.floor((points.getSize() - 2) / 2);
    if (points.getSize() <= segmentIndex + 1) return;

    var p1 = points.get(segmentIndex);
    var p2 = points.get(segmentIndex + 1);

    target.setPosition((p2.x - p1.x) / 2 + p1.x - target.getWidth() / 2 | 0, (p2.y - p1.y) / 2 + p1.y - target.getHeight() / 2 | 0);
  }
});

/***/ }),

/***/ "./src/layout/locator/OutputPortLocator.js":
/*!*************************************************!*\
  !*** ./src/layout/locator/OutputPortLocator.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Repositions a Figure attached to a Connection when the
 * Connection is moved. Provides for alignment at the start
 * (source), middle, or end (target) of the Connection.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.PortLocator
 */
_packages2.default.layout.locator.OutputPortLocator = _packages2.default.layout.locator.PortLocator.extend(
/** @lends draw2d.layout.locator.OutputPortLocator.prototype */
{

  NAME: "draw2d.layout.locator.OutputPortLocator",

  /**
   * Default constructor for a Locator which can layout a port in context of a
   * {@link draw2d.shape.node.Node}
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Controls the location of an I{@link draw2d.Figure}
   *
   * @param {Number} index child index of the figure
   * @param {draw2d.Figure} figure the figure to control
   *
   * @template
   **/
  relocate: function relocate(index, figure) {
    var node = figure.getParent();
    var dividerFactor = 1;
    var thisNAME = this.NAME;
    var portIndex = 1;
    node.getPorts().each(function (i, p) {
      portIndex = p === figure ? dividerFactor : portIndex;
      dividerFactor += p.getLocator().NAME === thisNAME ? 1 : 0;
    });
    this.applyConsiderRotation(figure, node.getWidth(), node.getHeight() / dividerFactor * portIndex);
  }

});

/***/ }),

/***/ "./src/layout/locator/ParallelMidpointLocator.js":
/*!*******************************************************!*\
  !*** ./src/layout/locator/ParallelMidpointLocator.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A ParallelMidpointLocator that is used to place label at the midpoint of a  routed
 * connection. The midpoint is always in the center of an edge.
 * The label is aligned to the connection angle at the calculated conection segment.
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.ConnectionLocator
 * @since 4.4.4
 */
_packages2.default.layout.locator.ParallelMidpointLocator = _packages2.default.layout.locator.ConnectionLocator.extend(
/** @lends draw2d.layout.locator.ParallelMidpointLocator.prototype */
{

  NAME: "draw2d.layout.locator.ParallelMidpointLocator",

  /**
   * Constructs a ParallelMidpointLocator with optional padding to the connection.
   *
   * if the parameter <b>distance</b> is less than zero the label is
   * placed above of the connection. Else the label is below the connection.
   *
   * @param {Object} attr object with {distance: <NUMBER>>} distance of the label to the connection.
   */
  init: function init(attr, setter, getter) {
    this.distance = 0;

    this._super((0, _extend2.default)({
      distance: -5
    }, attr), (0, _extend2.default)({
      x: this.setDistance
    }, setter), (0, _extend2.default)({
      distance: this.getDistance
    }, getter));
  },

  /**
   * Set the distance to the connection
   *
   * @param {Number} distance the distance to the connection
   * @returns {this}
   */
  setDistance: function setDistance(distance) {
    this.distance = distance;
    return this;
  },

  /**
   * Returns the distance to the connection
   *
   * @returns {Number}
   */
  getDistance: function getDistance() {
    return this.distance;
  },

  /**
   *
   * Relocates the given Figure always in the center of an edge.
   *
   * @param {Number} index child index of the target
   * @param {draw2d.Figure} target The figure to relocate
   **/
  relocate: function relocate(index, target) {
    var conn = target.getParent();
    var points = conn.getVertices();

    var segmentIndex = Math.floor((points.getSize() - 2) / 2);
    if (points.getSize() <= segmentIndex + 1) {
      return;
    }

    var p1 = points.get(segmentIndex);
    var p2 = points.get(segmentIndex + 1);

    // calculate the distance of the label (above or below the connection)
    var distance = this.distance <= 0 ? this.distance - target.getHeight() : this.distance;

    // get the angle of the segment
    var nx = p1.x - p2.x;
    var ny = p1.y - p2.y;
    var length = Math.sqrt(nx * nx + ny * ny);
    var radian = -Math.asin(ny / length);
    var angle = 180 / Math.PI * radian;
    if (radian < 0) {
      if (p2.x < p1.x) {
        radian = Math.abs(radian) + Math.PI;
        angle = 360 - angle;
        distance = -distance - target.getHeight();
      } else {
        radian = Math.PI * 2 - Math.abs(radian);
        angle = 360 + angle;
      }
    } else {
      if (p2.x < p1.x) {
        radian = Math.PI - radian;
        angle = 360 - angle;
        distance = -distance - target.getHeight();
      }
    }

    var rotAnchor = this.rotate(length / 2 - target.getWidth() / 2, distance, 0, 0, radian);

    // rotate the x/y coordinate with the calculated angle around "p1"
    //
    var rotCenterOfLabel = this.rotate(0, 0, target.getWidth() / 2, target.getHeight() / 2, radian);

    target.setRotationAngle(angle);
    target.setPosition(rotAnchor.x - rotCenterOfLabel.x + p1.x, rotAnchor.y - rotCenterOfLabel.y + p1.y);
  },

  rotate: function rotate(x, y, xm, ym, radian) {
    var cos = Math.cos,
        sin = Math.sin;

    // Subtract midpoints, so that midpoint is translated to origin
    // and add it in the end again
    return {
      x: (x - xm) * cos(radian) - (y - ym) * sin(radian) + xm,
      y: (x - xm) * sin(radian) + (y - ym) * cos(radian) + ym
    };
  }

});

/***/ }),

/***/ "./src/layout/locator/PolylineMidpointLocator.js":
/*!*******************************************************!*\
  !*** ./src/layout/locator/PolylineMidpointLocator.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A PolylineMidpointLocator is used to place figures at the midpoint of a routed
 * connection. <br>
 * If the connection did have an odd count of points the figure is located in the center vertex of the polyline.<br>
 * On an even count of junction point, the figure will be center on the middle segment of the ploy line.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.ManhattanMidpointLocator
 */
_packages2.default.layout.locator.PolylineMidpointLocator = _packages2.default.layout.locator.ManhattanMidpointLocator.extend(
/** @lends draw2d.layout.locator.PolylineMidpointLocator.prototype */
{

  NAME: "draw2d.layout.locator.PolylineMidpointLocator",

  /**
   * Constructs a ManhattanMidpointLocator with associated Connection c.
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Relocates the given Figure.
   *
   * @param {Number} index child index of the target
   * @param {draw2d.Figure} target The figure to relocate
   **/
  relocate: function relocate(index, target) {
    var conn = target.getParent();
    var points = conn.getVertices();

    // it has an event count of points -> use the manhattan algorithm...this is working
    // well in this case
    if (points.getSize() % 2 === 0) {
      this._super(index, target);
    }
    // odd count of points. take the center point as fulcrum
    else {
        var index = Math.floor(points.getSize() / 2);
        var p1 = points.get(index);
        target.setPosition(p1.x - target.getWidth() / 2, p1.y - target.getHeight() / 2);
      }
  }
});

/***/ }),

/***/ "./src/layout/locator/PortLocator.js":
/*!*******************************************!*\
  !*** ./src/layout/locator/PortLocator.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * The port locator calculates the position of an port. All ports MUST have a locator
 * if you add them as child to a node.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.PortLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.PortLocator.prototype */
{

  NAME: "draw2d.layout.locator.PortLocator",

  /**
   * Default constructor for a Locator which can layout a port in context of a
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  applyConsiderRotation: function applyConsiderRotation(port, x, y) {
    var parent = port.getParent();

    // determine the width/height before manipulate the 
    // matrix of the shape
    var halfW = parent.getWidth() / 2;
    var halfH = parent.getHeight() / 2;

    var rotAngle = parent.getRotationAngle();
    var m = Raphael.matrix();
    m.rotate(rotAngle, halfW, halfH);
    if (rotAngle === 90 || rotAngle === 270) {
      var ratio = parent.getHeight() / parent.getWidth();
      m.scale(ratio, 1 / ratio, halfW, halfH);
    }

    port.setPosition(m.x(x, y), m.y(x, y));
  }
});

/***/ }),

/***/ "./src/layout/locator/RightLocator.js":
/*!********************************************!*\
  !*** ./src/layout/locator/RightLocator.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A RightLocator is used to place figures to the right of a parent shape.
 *
 *
 *
 * @example
 *
 *
 *    // create a basic figure and add a Label/child via API call
 *    //
 *    var end = new draw2d.shape.node.End();
 *    end.add(new draw2d.shape.basic.Label({text:"Right Label"}), new draw2d.layout.locator.RightLocator({
 *         margin: 10 // distance to the parent shape
 *    }));
 *    canvas.add( end, 50,50);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.RightLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.RightLocator.prototype */
{

  NAME: "draw2d.layout.locator.RightLocator",

  /**
   * Constructs a locator with associated parent.
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.margin = attr && "margin" in attr ? attr.margin : 5;
  },

  /**
   * 
   * Relocates the given Figure.
   *
   * @param {Number} index child index of the target
   * @param {draw2d.Figure} target The figure to relocate
   **/
  relocate: function relocate(index, target) {
    var parent = target.getParent();
    var boundingBox = parent.getBoundingBox();

    // I made a wrong decision in the port handling: anchor point
    // is in the center and not topLeft. Now I must correct this flaw here, and there, and...
    // shit happens.
    var offset = parent instanceof _packages2.default.Port ? boundingBox.h / 2 : 0;

    if (target instanceof _packages2.default.Port) {
      target.setPosition(boundingBox.w, boundingBox.h / 2 - offset);
    } else {
      var targetBoundingBox = target.getBoundingBox();
      target.setPosition(boundingBox.w + this.margin, boundingBox.h / 2 - targetBoundingBox.h / 2 - offset);
    }
  }
});

/***/ }),

/***/ "./src/layout/locator/SmartDraggableLocator.js":
/*!*****************************************************!*\
  !*** ./src/layout/locator/SmartDraggableLocator.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A DraggableLocator is used to place figures relative to the parent nearest corner. It is
 * possible to move a child node via drag&drop.
 *
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.SmartDraggableLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.SmartDraggableLocator.prototype */
{

  NAME: "draw2d.layout.locator.SmartDraggableLocator",

  /**
   * Constructs a locator with associated parent.
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    // description see "bind" method
    this.boundedCorners = {
      init: false,
      parent: 0,
      child: 0,
      dist: Number.MAX_SAFE_INTEGER,
      xOffset: 0,
      yOffset: 0
    };
  },

  bind: function bind(parent, child) {
    var _this = this;
    // determine the best corner of the parent/child node and stick to the calculated corner
    // In the example below it is R1.2 in combination with R2.0
    //
    //     0             1
    //      +-----------+
    //      |           |
    //      |    R1     |
    //      +-----------+
    //     3             2
    //
    //              0             1
    //               +-----------+
    //               |           |
    //               |    R2     |
    //               +-----------+
    //              3             2
    //
    var calcBoundingCorner = function calcBoundingCorner() {
      _this.boundedCorners = {
        init: false,
        parent: 0,
        child: 0,
        dist: Number.MAX_SAFE_INTEGER,
        xOffset: 0,
        yOffset: 0
      };
      var parentVertices = child.getParent().getBoundingBox().getVertices();
      var childVertices = child.getBoundingBox().getVertices();
      var i_parent = void 0,
          i_child = void 0;
      var p1 = void 0,
          p2 = void 0,
          distance = void 0;
      for (i_parent = 0; i_parent < parentVertices.getSize(); i_parent++) {
        for (i_child = 0; i_child < childVertices.getSize(); i_child++) {
          p1 = parentVertices.get(i_parent);
          p2 = childVertices.get(i_child);
          distance = Math.abs(p1.distance(p2));
          if (distance < _this.boundedCorners.dist) {
            _this.boundedCorners = {
              parent: i_parent,
              child: i_child,
              dist: distance,
              xOffset: p1.x - p2.x,
              yOffset: p1.y - p2.y
            };
          }
        }
      }
      _this.boundedCorners.init = true;
    };

    // override the parent implementation to avoid
    // that the child is "!selectable" and "!draggable"

    // Don't redirect the selection handling to the parent
    // Using the DraggableLocator provides the ability to the children
    // that they are selectable and draggable. Remove the SelectionAdapter from the parent
    // assignment.
    child.setSelectionAdapter(function () {
      return child;
    });

    child.getParent().on("added", calcBoundingCorner);
    child.on("dragend", calcBoundingCorner);
  },

  unbind: function unbind(parent, child) {
    // use default
    child.setSelectionAdapter(null);
  },

  /**
   * 
   * Controls the location of an I{@link draw2d.Figure}
   *
   * @param {Number} index child index of the figure
   * @param {draw2d.Figure} figure the figure to control
   *
   * @template
   **/
  relocate: function relocate(index, figure) {
    this._super(index, figure);
    if (this.boundedCorners.init === true) {
      var parentVertices = figure.getParent().getBoundingBox().getVertices();
      var childVertices = figure.getBoundingBox().getVertices();
      var p1 = parentVertices.get(this.boundedCorners.parent);
      var p2 = childVertices.get(this.boundedCorners.child);

      var xOffset = p1.x - p2.x;
      var yOffset = p1.y - p2.y;
      // restore the initial distance from the corner by adding the new offset
      // to the position of the child
      figure.translate(xOffset - this.boundedCorners.xOffset, yOffset - this.boundedCorners.yOffset);
    }
  }
});

/***/ }),

/***/ "./src/layout/locator/TopLocator.js":
/*!******************************************!*\
  !*** ./src/layout/locator/TopLocator.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A TopLocator  is used to place figures at the top/center of a parent shape.
 *
 *
 *
 * @example
 *
 *    // create a basic figure and add a Label/child via API call
 *    //
 *    let circle = new draw2d.shape.basic.Circle({
 *        x:100,
 *        y:70,
 *        diameter:80,
 *        stroke: 3,
 *        color:"#A63343",
 *        bgColor:"#E65159"
 *    });
 *
 *    circle.add(new draw2d.shape.basic.Label({text:"Top Label"}), new draw2d.layout.locator.TopLocator());
 *    canvas.add( circle);
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.Locator
 */
_packages2.default.layout.locator.TopLocator = _packages2.default.layout.locator.Locator.extend(
/** @lends draw2d.layout.locator.TopLocator.prototype */
{

  NAME: "draw2d.layout.locator.TopLocator",

  /**
   * Constructs a ManhattanMidpointLocator with associated Connection c.
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Relocates the given Figure.
   *
   * @param {Number} index child index of the target
   * @param {draw2d.Figure} target The figure to relocate
   **/
  relocate: function relocate(index, target) {
    var parent = target.getParent();
    var boundingBox = parent.getBoundingBox();

    // I made a wrong decision in the port handling: anchor point
    // is in the center and not topLeft. Now I must correct this flaw here, and there, and...
    // shit happens.
    var offset = parent instanceof _packages2.default.Port ? boundingBox.w / 2 : 0;

    var targetBoundingBox = target.getBoundingBox();
    if (target instanceof _packages2.default.Port) {
      target.setPosition(boundingBox.w / 2 - offset, 0);
    } else {
      target.setPosition(boundingBox.w / 2 - targetBoundingBox.w / 2 - offset, -(targetBoundingBox.h + 2));
    }
  }
});

/***/ }),

/***/ "./src/layout/locator/XYAbsPortLocator.js":
/*!************************************************!*\
  !*** ./src/layout/locator/XYAbsPortLocator.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Create a locator for fixed x/y coordinate position. The port in the example below is
 * always 20px below of the top border.
 *
 *
 * @example
 *
 *    var figure =  new draw2d.shape.basic.Rectangle({x:130,y:30,width:100,height:60});
 *    figure.createPort("input", new draw2d.layout.locator.XYAbsPortLocator(0,20));
 *
 *    canvas.add(figure);
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.PortLocator
 * @since 4.0.0
 */
_packages2.default.layout.locator.XYAbsPortLocator = _packages2.default.layout.locator.PortLocator.extend(
/** @lends draw2d.layout.locator.XYAbsPortLocator.prototype */
{

  NAME: "draw2d.layout.locator.XYAbsPortLocator",

  /**
   *
   * {@link draw2d.shape.node.Node}
   *
   * @param {Number} x the x coordinate of the port relative to the left of the parent
   * @param {Number} y the y coordinate of the port relative to the top of the parent
   */
  init: function init(attr, setter, getter) {
    this.x = 0;
    this.y = 0;

    this._super(attr, (0, _extend2.default)({
      x: this.setX,
      y: this.setY
    }, setter), (0, _extend2.default)({
      x: this.getX,
      y: this.getY
    }, getter));
  },

  /**
   * Set the X Offset for the Locator
   * @param {Number} x
   */
  setX: function setX(x) {
    this.x = x;
  },

  /**
   * Set the y-offset of the locator
   *
   * @param {Number} y
   */
  setY: function setY(y) {
    this.y = y;
  },

  /**
   * Get the X-Offset of the Locator
   *
   * @returns {Number}
   */
  getX: function getX() {
    return this.x;
  },

  /**
   * Returns the Y-Offset of the Locator
   *
   * @returns {Number}
   */
  getY: function getY() {
    return this.y;
  },

  /**
   *
   * Controls the location of an {@link draw2d.Figure}
   *
   * @param {Number} index child index of the figure
   * @param {draw2d.Figure} figure the figure to control
   *
   * @template
   **/
  relocate: function relocate(index, figure) {
    this.applyConsiderRotation(figure, this.x, this.y);
  }

});

/***/ }),

/***/ "./src/layout/locator/XYRelPortLocator.js":
/*!************************************************!*\
  !*** ./src/layout/locator/XYRelPortLocator.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Create a locator for a relative x/y coordinate position. The coordinates are named in percentage [0..100%]
 * relative to the top/left corner of the parent node.<br>
 * <br>
 * <br>
 * Resize the shape in the example to see what happens. The port top position is always 20% of the shape height.
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.basic.Rectangle({x:130,y:30,width:100,height:60});
 *    figure.createPort("input", new draw2d.layout.locator.XYRelPortLocator(0,20));
 *
 *    canvas.add(figure);
 *
 *
 * @author Andreas Herz
 * @extend draw2d.layout.locator.PortLocator
 * @since 4.0.0
 */
_packages2.default.layout.locator.XYRelPortLocator = _packages2.default.layout.locator.PortLocator.extend(
/** @lends draw2d.layout.locator.XYRelPortLocator.prototype */
{

  NAME: "draw2d.layout.locator.XYRelPortLocator",

  /**
   *
   *
   * @param {Number} xPercentage the x coordinate in percent of the port relative to the left of the parent
   * @param {Number} yPercentage the y coordinate in percent of the port relative to the top of the parent
   */
  init: function init(attr, setter, getter) {
    // legacy code handling
    // new draw2d.layout.locator.XYRelPortLocator(10,30)
    if (typeof attr === "number" && typeof setter === "number") {
      this.x = attr;
      this.y = setter;
      this._super();
    }
    // new constructor
    // new draw2d.layout.locator.XYRelPortLocator({x:10, y:30}})
    else {
        this.x = 0;
        this.y = 0;
        this._super(attr, (0, _extend2.default)({
          x: this.setX,
          y: this.setY
        }, setter), (0, _extend2.default)({
          x: this.getX,
          y: this.getY
        }, getter));
      }
  },

  /**
   * Set the X Offset for the Locator
   * @param {Number} x
   */
  setX: function setX(x) {
    this.x = x;
  },

  /**
   * Set the y-offset of the locator
   *
   * @param {Number} y
   */
  setY: function setY(y) {
    this.y = y;
  },

  /**
   * Get the X-Offset of the Locator
   *
   * @returns {Number}
   */
  getX: function getX() {
    return this.x;
  },

  /**
   * Returns the Y-Offset of the Locator
   *
   * @returns {Number}
   */
  getY: function getY() {
    return this.y;
  },

  /**
   *
   * Controls the location of an I{@link draw2d.Figure}
   *
   * @param {Number} index child index of the figure
   * @param {draw2d.Figure} figure the figure to control
   *
   * @template
   **/
  relocate: function relocate(index, figure) {
    var parent = figure.getParent();

    this.applyConsiderRotation(figure, parent.getWidth() / 100 * this.x, parent.getHeight() / 100 * this.y);
  }

});

/***/ }),

/***/ "./src/layout/mesh/ExplodeLayouter.js":
/*!********************************************!*\
  !*** ./src/layout/mesh/ExplodeLayouter.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.layout.mesh.ExplodeLayouter = _packages2.default.layout.mesh.MeshLayouter.extend(
/** @lends draw2d.layout.mesh.ExplodeLayouter.prototype */
{

  MIN_MARGIN: 40,

  /**
   * Creates a new layouter object.
   */
  init: function init() {},

  /**
   *
   * Return a changes list for an existing mesh/canvas to ensure that the element to insert 
   * did have enough space.
   * 
   * @param {draw2d.Canvas} canvas the canvas to use for the analytic
   * @param {draw2d.Figure} figure The figure to add to the exising canvas
   * @param {Number} x requested x-position for the figure
   * @param {Number} y requested y-position for the figure
   * 
   * 
   * @returns {draw2d.util.ArrayList} a list of changes to apply if the user want to insert he figure.
   */
  add: function add(canvas, figureToAdd) {
    // changes for the different octant areas
    var changes = [];
    changes[0] = { x: 0, y: 0 };
    changes[1] = { x: 0, y: 0 };
    changes[2] = { x: 0, y: 0 };
    changes[3] = { x: 0, y: 0 };
    changes[4] = { x: 0, y: 0 };
    changes[5] = { x: 0, y: 0 };
    changes[6] = { x: 0, y: 0 };
    changes[7] = { x: 0, y: 0 };
    changes[8] = { x: 0, y: 0 };

    var boundingBox = figureToAdd.getBoundingBox();

    var figures = canvas.getFigures();
    var figure = null;

    var dis = 0;
    var oct = 0;
    var currentOctChanges = null;
    var i = 0;
    for (i = 0; i < figures.getSize(); i++) {

      figure = figures.get(i);

      // calculate the distance of all corners in relation to the requested x/y coordinate
      //
      if (figure !== figureToAdd) {
        dis = figure.getBoundingBox().getDistance(boundingBox);
        // other figure is to close
        //
        if (dis < this.MIN_MARGIN) {
          // determine the octant of the figure
          oct = this.determineOctant(boundingBox, figure.getBoundingBox());

          // all other relevant segments must be arranged too!!
          //
          switch (oct) {
            case 2:
              changes[2].x = Math.max(changes[2].x, this.MIN_MARGIN - dis);
              changes[3].x = Math.max(changes[3].x, this.MIN_MARGIN - dis);
              changes[4].x = Math.max(changes[4].x, this.MIN_MARGIN - dis);
              break;
            case 3:
              changes[2].x = Math.max(changes[2].x, this.MIN_MARGIN - dis);
              changes[3].x = Math.max(changes[3].x, this.MIN_MARGIN - dis);
              changes[4].x = Math.max(changes[4].x, this.MIN_MARGIN - dis);
              break;
            case 4:
              changes[2].x = Math.max(changes[2].x, this.MIN_MARGIN - dis);
              changes[3].x = Math.max(changes[3].x, this.MIN_MARGIN - dis);
              changes[4].x = Math.max(changes[4].x, this.MIN_MARGIN - dis);
              changes[4].y = Math.max(changes[4].y, this.MIN_MARGIN - dis);
              changes[5].y = Math.max(changes[5].y, this.MIN_MARGIN - dis);
              changes[6].y = Math.max(changes[6].y, this.MIN_MARGIN - dis);
              break;
            case 5:
              changes[4].y = Math.max(changes[4].y, this.MIN_MARGIN - dis);
              changes[5].y = Math.max(changes[5].y, this.MIN_MARGIN - dis);
              changes[6].y = Math.max(changes[6].y, this.MIN_MARGIN - dis);
              break;
            case 6:
              changes[4].y = Math.max(changes[4].y, this.MIN_MARGIN - dis);
              changes[5].y = Math.max(changes[5].y, this.MIN_MARGIN - dis);
              changes[6].y = Math.max(changes[6].y, this.MIN_MARGIN - dis);
              break;
            case 8:
              // overlapping
              // we must determine the new distance with the border of the figures
              dis = boundingBox.getBottomRight().getDistance(figure.getBoundingBox().getTopLeft()) | 0;

              changes[2].x = Math.max(changes[2].x, this.MIN_MARGIN + dis);
              changes[3].x = Math.max(changes[3].x, this.MIN_MARGIN + dis);
              changes[4].x = Math.max(changes[4].x, this.MIN_MARGIN + dis);
              changes[4].y = Math.max(changes[4].y, this.MIN_MARGIN + dis);
              changes[5].y = Math.max(changes[5].y, this.MIN_MARGIN + dis);
              changes[6].y = Math.max(changes[6].y, this.MIN_MARGIN + dis);
              changes[8].x = Math.max(changes[8].x, this.MIN_MARGIN + dis);
            //        				changes[8].y =  Math.max(changes[8].y,this.MIN_MARGIN+dis);
          }
        }
      }
      // Falls die minimale Distance zu den Objecten kleiner 80 ist, muss ein layout erfolgen
    }

    // calculate the adjustment for each figure
    //
    var result = new _packages2.default.util.ArrayList();
    for (i = 0; i < figures.getSize(); i++) {
      figure = figures.get(i);
      if (figure !== figureToAdd) {
        oct = this.determineOctant(boundingBox, figure.getBoundingBox());
        currentOctChanges = changes[oct];
        if (currentOctChanges.x !== 0 || currentOctChanges.y !== 0) {
          result.add(new _packages2.default.layout.mesh.ProposedMeshChange(figure, currentOctChanges.x, currentOctChanges.y));
        }
      }
    }

    return result;
  },

  /**
   *
   * Determin Octant
  *
  *    0 | 1 | 2
  *    __|___|__
  *    7 | 8 | 3
   *    __|___|__
  *    6 | 5 | 4
   *
  * @returns {Number}
   */
  determineOctant: function determineOctant(r1, r2) {
    var ox = r1.x;
    var oy = r1.y;
    var ow = r1.w;
    var oh = r1.h;

    var cx = r2.x;
    var cy = r2.y;
    var cw = r2.w;
    var ch = r2.h;
    var oct = 0;

    if (cx + cw <= ox) {
      if (cy + ch <= oy) {
        oct = 0;
      } else if (cy >= oy + oh) {
        oct = 6;
      } else {
        oct = 7;
      }
    } else if (cx >= ox + ow) {
      if (cy + ch <= oy) {
        oct = 2;
      } else if (cy >= oy + oh) {
        oct = 4;
      } else {
        oct = 3;
      }
    } else if (cy + ch <= oy) {
      oct = 1;
    } else if (cy >= oy + oh) {
      oct = 5;
    } else {
      oct = 8;
    }

    return oct;
  }
});
/**
 * @class
 * Routes a {@link draw2d.Connection}, possibly using a constraint.
 *
 * @author Andreas Herz
 * @extend draw2d.layout.mesh.MeshLayouter
 */

/***/ }),

/***/ "./src/layout/mesh/MeshLayouter.js":
/*!*****************************************!*\
  !*** ./src/layout/mesh/MeshLayouter.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.layout.mesh.MeshLayouter = Class.extend(
/** @lends draw2d.layout.mesh.MeshLayouter.prototype */

{

  /**
   * Creates a new layouter object.
   */
  init: function init() {},

  /**
   * 
   * Return a changes list for an existing mesh/canvas to ensure that the element to insert
   * did have enough space.
   *
   * @param {draw2d.Canvas} canvas the canvas to use for the analytic
   * @param {draw2d.Figure} figure The figure to add to the exising canvas
   *
   *
   * @returns {draw2d.util.ArrayList} a list of changes to apply if the user want to insert he figure.
   */
  add: function add(canvas, figure) {
    return new _packages2.default.util.ArrayList();
  }
});
/**
 * @class
 * Layouter for a mesh or grid.
 *
 * @author Andreas Herz
 */

/***/ }),

/***/ "./src/layout/mesh/ProposedMeshChange.js":
/*!***********************************************!*\
  !*** ./src/layout/mesh/ProposedMeshChange.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.layout.mesh.ProposedMeshChange = Class.extend(
/** @lends draw2d.layout.mesh.ProposedMeshChange.prototype */

{

  /**
   * Creates change object.
   */
  init: function init(figure, x, y) {
    this.figure = figure;
    this.x = x;
    this.y = y;
  },

  /**
   *
   * Return the related figure.
   *
   * @returns {draw2d.Figure} the figure to the related change proposal
   */
  getFigure: function getFigure() {
    return this.figure;
  },

  /**
   *
   * The proposed x-coordinate.
   *
   * @returns {Number}
   */
  getX: function getX() {
    return this.x;
  },

  /**
   *
   * The proposed y-coordinate
   *
   * @returns {Number}
   */
  getY: function getY() {
    return this.y;
  }

});
/**
 * @class
 * Change proposal for grid/mesh layout changes.
 *
 * @author Andreas Herz
 */

/***/ }),

/***/ "./src/lib/Class.exec.js":
/*!*******************************!*\
  !*** ./src/lib/Class.exec.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./src/lib/Class.exec.js */ "./node_modules/raw-loader/index.js!./src/lib/Class.exec.js"));

/***/ }),

/***/ "./src/lib/jquery.autoresize.js":
/*!**************************************!*\
  !*** ./src/lib/jquery.autoresize.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * jQuery.fn.autoResize 1.14
 * --
 * https://github.com/padolsey/jQuery.fn.autoResize
 * --
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/wtfpl/COPYING for more details. */
(function ($) {

	var uid = 'ar' + +new Date(),
	    defaults = autoResize.defaults = {
		onResize: function onResize() {},
		onBeforeResize: function onBeforeResize() {
			return 123;
		},
		onAfterResize: function onAfterResize() {
			return 555;
		},
		animate: {
			duration: 200,
			complete: function complete() {}
		},
		extraSpace: 50,
		minHeight: 'original',
		maxHeight: 500,
		minWidth: 'original',
		maxWidth: 500
	};

	autoResize.cloneCSSProperties = ['lineHeight', 'textDecoration', 'letterSpacing', 'fontSize', 'fontFamily', 'fontStyle', 'fontWeight', 'textTransform', 'textAlign', 'direction', 'wordSpacing', 'fontSizeAdjust', 'paddingTop', 'paddingLeft', 'paddingBottom', 'paddingRight', 'width'];

	autoResize.cloneCSSValues = {
		position: 'absolute',
		top: -9999,
		left: -9999,
		opacity: 0,
		overflow: 'hidden'
	};

	autoResize.resizableFilterSelector = ['textarea:not(textarea.' + uid + ')', 'input:not(input[type])', 'input[type=text]', 'input[type=password]', 'input[type=email]', 'input[type=url]'].join(',');

	autoResize.AutoResizer = AutoResizer;

	$.fn.autoResize = autoResize;

	function autoResize(config) {
		this.filter(autoResize.resizableFilterSelector).each(function () {
			new AutoResizer($(this), config);
		});
		return this;
	}

	function AutoResizer(el, config) {

		if (el.data('AutoResizer')) {
			el.data('AutoResizer').destroy();
		}

		config = this.config = $.extend({}, autoResize.defaults, config);
		this.el = el;

		this.nodeName = el[0].nodeName.toLowerCase();

		this.originalHeight = el.height();
		this.previousScrollTop = null;

		this.value = el.val();

		if (config.maxWidth === 'original') config.maxWidth = el.width();
		if (config.minWidth === 'original') config.minWidth = el.width();
		if (config.maxHeight === 'original') config.maxHeight = el.height();
		if (config.minHeight === 'original') config.minHeight = el.height();

		if (this.nodeName === 'textarea') {
			el.css({
				resize: 'none',
				overflowY: 'hidden'
			});
		}

		el.data('AutoResizer', this);

		// Make sure onAfterResize is called upon animation completion
		config.animate.complete = function (f) {
			return function () {
				config.onAfterResize.call(el);
				return f.apply(this, arguments);
			};
		}(config.animate.complete);

		this.bind();
	}

	AutoResizer.prototype = {

		bind: function bind() {

			var check = $.proxy(function () {
				this.check();
				return true;
			}, this);

			this.unbind();

			this.el.bind('keyup.autoResize', check)
			//.bind('keydown.autoResize', check)
			.bind('change.autoResize', check).bind('paste.autoResize', function () {
				setTimeout(function () {
					check();
				}, 0);
			});

			if (!this.el.is(':hidden')) {
				this.check(null, true);
			}
		},

		unbind: function unbind() {
			this.el.unbind('.autoResize');
		},

		createClone: function createClone() {

			var el = this.el,
			    clone = this.nodeName === 'textarea' ? el.clone() : $('<span/>');

			this.clone = clone;

			$.each(autoResize.cloneCSSProperties, function (i, p) {
				clone[0].style[p] = el.css(p);
			});

			clone.removeAttr('name').removeAttr('id').addClass(uid).attr('tabIndex', -1).css(autoResize.cloneCSSValues);

			if (this.nodeName === 'textarea') {
				clone.height('auto');
			} else {
				clone.width('auto').css({
					whiteSpace: 'nowrap'
				});
			}
		},

		check: function check(e, immediate) {

			if (!this.clone) {
				this.createClone();
				this.injectClone();
			}

			var config = this.config,
			    clone = this.clone,
			    el = this.el,
			    value = el.val();

			// Do nothing if value hasn't changed
			if (value === this.prevValue) {
				return true;
			}
			this.prevValue = value;

			if (this.nodeName === 'input') {

				clone.text(value);

				// Calculate new width + whether to change
				var cloneWidth = clone.width(),
				    newWidth = cloneWidth + config.extraSpace >= config.minWidth ? cloneWidth + config.extraSpace : config.minWidth,
				    currentWidth = el.width();

				newWidth = Math.min(newWidth, config.maxWidth);

				if (newWidth < currentWidth && newWidth >= config.minWidth || newWidth >= config.minWidth && newWidth <= config.maxWidth) {

					config.onBeforeResize.call(el);
					config.onResize.call(el);

					el.scrollLeft(0);

					if (config.animate && !immediate) {
						el.stop(1, 1).animate({
							width: newWidth
						}, config.animate);
					} else {
						el.width(newWidth);
						config.onAfterResize.call(el);
					}
				}

				return;
			}

			// TEXTAREA

			clone.width(el.width()).height(0).val(value).scrollTop(10000);

			var scrollTop = clone[0].scrollTop;

			if (!value) {
				// empty textarea should be exactly minHeight
				scrollTop = config.minHeight;
				this.previousScrollTop = null; // reset state
			} else {
				// Don't do anything if scrollTop hasen't changed:
				if (this.previousScrollTop === scrollTop) {
					return;
				}

				this.previousScrollTop = scrollTop;

				if (scrollTop + config.extraSpace >= config.maxHeight) {
					el.css('overflowY', '');
					scrollTop = config.maxHeight;
					immediate = true;
				} else if (scrollTop + config.extraSpace <= config.minHeight) {
					// include extraSpace in calculations so the code works correctly
					// when there are few lines
					scrollTop = config.minHeight;
				} else {
					el.css('overflowY', 'hidden');
					scrollTop += config.extraSpace;
				}
			}

			config.onBeforeResize.call(el);
			config.onResize.call(el);

			// Either animate or directly apply height:
			if (config.animate && !immediate) {
				el.stop(1, 1).animate({
					height: scrollTop
				}, config.animate);
			} else {
				el.height(scrollTop);
				config.onAfterResize.call(el);
			}
		},

		destroy: function destroy() {
			this.unbind();
			this.el.removeData('AutoResizer');
			this.clone.remove();
			delete this.el;
			delete this.clone;
		},

		injectClone: function injectClone() {
			(autoResize.cloneContainer || (autoResize.cloneContainer = $('<arclones/>').appendTo('body'))).append(this.clone);
		}

	};
})(jQuery);

/***/ }),

/***/ "./src/lib/jquery.contextmenu.js":
/*!***************************************!*\
  !*** ./src/lib/jquery.contextmenu.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * jQuery contextMenu - Plugin for simple contextMenu handling
 *
 * Version: 1.6.5
 *
 * Authors: Rodney Rehm, Addy Osmani (patches for FF)
 * Web: http://medialize.github.com/jQuery-contextMenu/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *   GPL v3 http://opensource.org/licenses/GPL-3.0
 *
 */
(function ($, undefined) {

    // TODO: -
    // ARIA stuff: menuitem, menuitemcheckbox und menuitemradio
    // create <menu> structure if $.support[htmlCommand || htmlMenuitem] and !opt.disableNative

    // determine html5 compatibility
    $.support.htmlMenuitem = 'HTMLMenuItemElement' in window;
    $.support.htmlCommand = 'HTMLCommandElement' in window;
    $.support.eventSelectstart = "onselectstart" in document.documentElement;
    /* // should the need arise, test for css user-select
    $.support.cssUserSelect = (function(){
        var t = false,
            e = document.createElement('div');
    
        $.each('Moz|Webkit|Khtml|O|ms|Icab|'.split('|'), function(i, prefix) {
            var propCC = prefix + (prefix ? 'U' : 'u') + 'serSelect',
                prop = (prefix ? ('-' + prefix.toLowerCase() + '-') : '') + 'user-select';
    
            e.style.cssText = prop + ': text;';
            if (e.style[propCC] == 'text') {
                t = true;
                return false;
            }
    
            return true;
        });
    
        return t;
    })();
    */

    if (!$.ui || !$.ui.widget) {
        // duck punch $.cleanData like jQueryUI does to get that remove event
        // https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js#L16-24
        var _cleanData = $.cleanData;
        $.cleanData = function (elems) {
            for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                try {
                    $(elem).triggerHandler("remove");
                    // http://bugs.jquery.com/ticket/8235
                } catch (e) {}
            }
            _cleanData(elems);
        };
    }

    var // currently active contextMenu trigger
    $currentTrigger = null,

    // is contextMenu initialized with at least one menu?
    initialized = false,

    // window handle
    $win = $(window),

    // number of registered menus
    counter = 0,

    // mapping selector to namespace
    namespaces = {},

    // mapping namespace to options
    menus = {},

    // custom command type handlers
    types = {},

    // default values
    defaults = {
        // selector of contextMenu trigger
        selector: null,
        // where to append the menu to
        appendTo: null,
        // method to trigger context menu ["right", "left", "hover"]
        trigger: "right",
        // hide menu when mouse leaves trigger / menu elements
        autoHide: false,
        // ms to wait before showing a hover-triggered context menu
        delay: 200,
        // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu
        // as long as the trigger happened on one of the trigger-element's child nodes
        reposition: false,
        // determine position to show menu at
        determinePosition: function determinePosition($menu) {
            // position to the lower middle of the trigger element
            if ($.ui && $.ui.position) {
                // .position() is provided as a jQuery UI utility
                // (...and it won't work on hidden elements)
                $menu.css('display', 'block').position({
                    my: "center top",
                    at: "center bottom",
                    of: this,
                    offset: "0 5",
                    collision: "fit"
                }).css('display', 'none');
            } else {
                // determine contextMenu position
                var offset = this.offset();
                offset.top += this.outerHeight();
                offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
                $menu.css(offset);
            }
        },
        // position menu
        position: function position(opt, x, y) {
            var $this = this,
                offset;
            // determine contextMenu position
            if (!x && !y) {
                opt.determinePosition.call(this, opt.$menu);
                return;
            } else if (x === "maintain" && y === "maintain") {
                // x and y must not be changed (after re-show on command click)
                offset = opt.$menu.position();
            } else {
                // x and y are given (by mouse event)
                offset = { top: y, left: x };
            }

            // correct offset if viewport demands it
            var bottom = $win.scrollTop() + $win.height(),
                right = $win.scrollLeft() + $win.width(),
                height = opt.$menu.height(),
                width = opt.$menu.width();

            if (offset.top + height > bottom) {
                offset.top -= height;
            }

            if (offset.left + width > right) {
                offset.left -= width;
            }

            opt.$menu.css(offset);
        },
        // position the sub-menu
        positionSubmenu: function positionSubmenu($menu) {
            if ($.ui && $.ui.position) {
                // .position() is provided as a jQuery UI utility
                // (...and it won't work on hidden elements)
                $menu.css('display', 'block').position({
                    my: "left top",
                    at: "right top",
                    of: this,
                    collision: "flipfit fit"
                }).css('display', '');
            } else {
                // determine contextMenu position
                var offset = {
                    top: 0,
                    left: this.outerWidth()
                };
                $menu.css(offset);
            }
        },
        // offset to add to zIndex
        zIndex: 1,
        // show hide animation settings
        animation: {
            duration: 50,
            show: 'slideDown',
            hide: 'slideUp'
        },
        // events
        events: {
            show: $.noop,
            hide: $.noop
        },
        // default callback
        callback: null,
        // list of contextMenu items
        items: {}
    },

    // mouse position for hover activation
    hoveract = {
        timer: null,
        pageX: null,
        pageY: null
    },

    // determine zIndex
    zindex = function zindex($t) {
        var zin = 0,
            $tt = $t;

        while (true) {
            zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0);
            $tt = $tt.parent();
            if (!$tt || !$tt.length || "html body".indexOf($tt.prop('nodeName').toLowerCase()) > -1) {
                break;
            }
        }

        return zin;
    },

    // event handlers
    handle = {
        // abort anything
        abortevent: function abortevent(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        },

        // contextmenu show dispatcher
        contextmenu: function contextmenu(e) {
            var $this = $(this);

            // disable actual context-menu
            e.preventDefault();
            e.stopImmediatePropagation();

            // abort native-triggered events unless we're triggering on right click
            if (e.data.trigger != 'right' && e.originalEvent) {
                return;
            }

            // abort event if menu is visible for this trigger
            if ($this.hasClass('context-menu-active')) {
                return;
            }

            if (!$this.hasClass('context-menu-disabled')) {
                // theoretically need to fire a show event at <menu>
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus
                // var evt = jQuery.Event("show", { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this });
                // e.data.$menu.trigger(evt);

                $currentTrigger = $this;
                if (e.data.build) {
                    var built = e.data.build($currentTrigger, e);
                    // abort if build() returned false
                    if (built === false) {
                        return;
                    }

                    // dynamically build menu on invocation
                    e.data = $.extend(true, {}, defaults, e.data, built || {});

                    // abort if there are no items to display
                    if (!e.data.items || $.isEmptyObject(e.data.items)) {
                        // Note: jQuery captures and ignores errors from event handlers
                        if (window.console) {
                            (console.error || console.log)("No items specified to show in contextMenu");
                        }

                        throw new Error('No Items sepcified');
                    }

                    // backreference for custom command type creation
                    e.data.$trigger = $currentTrigger;

                    op.create(e.data);
                }
                // show menu
                op.show.call($this, e.data, e.pageX, e.pageY);
            }
        },
        // contextMenu left-click trigger
        click: function click(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            $(this).trigger($.Event("contextmenu", { data: e.data, pageX: e.pageX, pageY: e.pageY }));
        },
        // contextMenu right-click trigger
        mousedown: function mousedown(e) {
            // register mouse down
            var $this = $(this);

            // hide any previous menus
            if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
                $currentTrigger.data('contextMenu').$menu.trigger('contextmenu:hide');
            }

            // activate on right click
            if (e.button == 2) {
                $currentTrigger = $this.data('contextMenuActive', true);
            }
        },
        // contextMenu right-click trigger
        mouseup: function mouseup(e) {
            // show menu
            var $this = $(this);
            if ($this.data('contextMenuActive') && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass('context-menu-disabled')) {
                e.preventDefault();
                e.stopImmediatePropagation();
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", { data: e.data, pageX: e.pageX, pageY: e.pageY }));
            }

            $this.removeData('contextMenuActive');
        },
        // contextMenu hover trigger
        mouseenter: function mouseenter(e) {
            var $this = $(this),
                $related = $(e.relatedTarget),
                $document = $(document);

            // abort if we're coming from a menu
            if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                return;
            }

            // abort if a menu is shown
            if ($currentTrigger && $currentTrigger.length) {
                return;
            }

            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
            hoveract.data = e.data;
            $document.on('mousemove.contextMenuShow', handle.mousemove);
            hoveract.timer = setTimeout(function () {
                hoveract.timer = null;
                $document.off('mousemove.contextMenuShow');
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", { data: hoveract.data, pageX: hoveract.pageX, pageY: hoveract.pageY }));
            }, e.data.delay);
        },
        // contextMenu hover trigger
        mousemove: function mousemove(e) {
            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
        },
        // contextMenu hover trigger
        mouseleave: function mouseleave(e) {
            // abort if we're leaving for a menu
            var $related = $(e.relatedTarget);
            if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                return;
            }

            try {
                clearTimeout(hoveract.timer);
            } catch (e) {}

            hoveract.timer = null;
        },

        // click on layer to hide contextMenu
        layerClick: function layerClick(e) {
            var $this = $(this),
                root = $this.data('contextMenuRoot'),
                mouseup = false,
                button = e.button,
                x = e.pageX,
                y = e.pageY,
                target,
                offset,
                selectors;

            e.preventDefault();
            e.stopImmediatePropagation();

            setTimeout(function () {
                var $window, hideshow, possibleTarget;
                var triggerAction = root.trigger == 'left' && button === 0 || root.trigger == 'right' && button === 2;

                // find the element that would've been clicked, wasn't the layer in the way
                if (document.elementFromPoint) {
                    root.$layer.hide();
                    target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());
                    root.$layer.show();
                }

                if (root.reposition && triggerAction) {
                    if (document.elementFromPoint) {
                        if (root.$trigger.is(target) || root.$trigger.has(target).length) {
                            root.position.call(root.$trigger, root, x, y);
                            return;
                        }
                    } else {
                        offset = root.$trigger.offset();
                        $window = $(window);
                        // while this looks kinda awful, it's the best way to avoid
                        // unnecessarily calculating any positions
                        offset.top += $window.scrollTop();
                        if (offset.top <= e.pageY) {
                            offset.left += $window.scrollLeft();
                            if (offset.left <= e.pageX) {
                                offset.bottom = offset.top + root.$trigger.outerHeight();
                                if (offset.bottom >= e.pageY) {
                                    offset.right = offset.left + root.$trigger.outerWidth();
                                    if (offset.right >= e.pageX) {
                                        // reposition
                                        root.position.call(root.$trigger, root, x, y);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                if (target && triggerAction) {
                    root.$trigger.one('contextmenu:hidden', function () {
                        $(target).contextMenu({ x: x, y: y });
                    });
                }

                root.$menu.trigger('contextmenu:hide');
            }, 50);
        },
        // key handled :hover
        keyStop: function keyStop(e, opt) {
            if (!opt.isInput) {
                e.preventDefault();
            }

            e.stopPropagation();
        },
        key: function key(e) {
            var opt = $currentTrigger.data('contextMenu') || {};

            switch (e.keyCode) {
                case 9:
                case 38:
                    // up
                    handle.keyStop(e, opt);
                    // if keyCode is [38 (up)] or [9 (tab) with shift]
                    if (opt.isInput) {
                        if (e.keyCode == 9 && e.shiftKey) {
                            e.preventDefault();
                            opt.$selected && opt.$selected.find('input, textarea, select').blur();
                            opt.$menu.trigger('prevcommand');
                            return;
                        } else if (e.keyCode == 38 && opt.$selected.find('input, textarea, select').prop('type') == 'checkbox') {
                            // checkboxes don't capture this key
                            e.preventDefault();
                            return;
                        }
                    } else if (e.keyCode != 9 || e.shiftKey) {
                        opt.$menu.trigger('prevcommand');
                        return;
                    }
                // omitting break;

                // case 9: // tab - reached through omitted break;
                case 40:
                    // down
                    handle.keyStop(e, opt);
                    if (opt.isInput) {
                        if (e.keyCode == 9) {
                            e.preventDefault();
                            opt.$selected && opt.$selected.find('input, textarea, select').blur();
                            opt.$menu.trigger('nextcommand');
                            return;
                        } else if (e.keyCode == 40 && opt.$selected.find('input, textarea, select').prop('type') == 'checkbox') {
                            // checkboxes don't capture this key
                            e.preventDefault();
                            return;
                        }
                    } else {
                        opt.$menu.trigger('nextcommand');
                        return;
                    }
                    break;

                case 37:
                    // left
                    handle.keyStop(e, opt);
                    if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                        break;
                    }

                    if (!opt.$selected.parent().hasClass('context-menu-root')) {
                        var $parent = opt.$selected.parent().parent();
                        opt.$selected.trigger('contextmenu:blur');
                        opt.$selected = $parent;
                        return;
                    }
                    break;

                case 39:
                    // right
                    handle.keyStop(e, opt);
                    if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                        break;
                    }

                    var itemdata = opt.$selected.data('contextMenu') || {};
                    if (itemdata.$menu && opt.$selected.hasClass('context-menu-submenu')) {
                        opt.$selected = null;
                        itemdata.$selected = null;
                        itemdata.$menu.trigger('nextcommand');
                        return;
                    }
                    break;

                case 35: // end
                case 36:
                    // home
                    if (opt.$selected && opt.$selected.find('input, textarea, select').length) {
                        return;
                    } else {
                        (opt.$selected && opt.$selected.parent() || opt.$menu).children(':not(.disabled, .not-selectable)')[e.keyCode == 36 ? 'first' : 'last']().trigger('contextmenu:focus');
                        e.preventDefault();
                        return;
                    }
                    break;

                case 13:
                    // enter
                    handle.keyStop(e, opt);
                    if (opt.isInput) {
                        if (opt.$selected && !opt.$selected.is('textarea, select')) {
                            e.preventDefault();
                            return;
                        }
                        break;
                    }
                    opt.$selected && opt.$selected.trigger('mouseup');
                    return;

                case 32: // space
                case 33: // page up
                case 34:
                    // page down
                    // prevent browser from scrolling down while menu is visible
                    handle.keyStop(e, opt);
                    return;

                case 27:
                    // esc
                    handle.keyStop(e, opt);
                    opt.$menu.trigger('contextmenu:hide');
                    return;

                default:
                    // 0-9, a-z
                    var k = String.fromCharCode(e.keyCode).toUpperCase();
                    if (opt.accesskeys[k]) {
                        // according to the specs accesskeys must be invoked immediately
                        opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu ? 'contextmenu:focus' : 'mouseup');
                        return;
                    }
                    break;
            }
            // pass event to selected item,
            // stop propagation to avoid endless recursion
            e.stopPropagation();
            opt.$selected && opt.$selected.trigger(e);
        },

        // select previous possible command in menu
        prevItem: function prevItem(e) {
            e.stopPropagation();
            var opt = $(this).data('contextMenu') || {};

            // obtain currently selected menu
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data('contextMenu') || {};
                opt.$selected = $s;
            }

            var $children = opt.$menu.children(),
                $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(),
                $round = $prev;

            // skip disabled
            while ($prev.hasClass('disabled') || $prev.hasClass('not-selectable')) {
                if ($prev.prev().length) {
                    $prev = $prev.prev();
                } else {
                    $prev = $children.last();
                }
                if ($prev.is($round)) {
                    // break endless loop
                    return;
                }
            }

            // leave current
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }

            // activate next
            handle.itemMouseenter.call($prev.get(0), e);

            // focus input
            var $input = $prev.find('input, textarea, select');
            if ($input.length) {
                $input.focus();
            }
        },
        // select next possible command in menu
        nextItem: function nextItem(e) {
            e.stopPropagation();
            var opt = $(this).data('contextMenu') || {};

            // obtain currently selected menu
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data('contextMenu') || {};
                opt.$selected = $s;
            }

            var $children = opt.$menu.children(),
                $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(),
                $round = $next;

            // skip disabled
            while ($next.hasClass('disabled') || $next.hasClass('not-selectable')) {
                if ($next.next().length) {
                    $next = $next.next();
                } else {
                    $next = $children.first();
                }
                if ($next.is($round)) {
                    // break endless loop
                    return;
                }
            }

            // leave current
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }

            // activate next
            handle.itemMouseenter.call($next.get(0), e);

            // focus input
            var $input = $next.find('input, textarea, select');
            if ($input.length) {
                $input.focus();
            }
        },

        // flag that we're inside an input so the key handler can act accordingly
        focusInput: function focusInput(e) {
            var $this = $(this).closest('.context-menu-item'),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.$selected = opt.$selected = $this;
            root.isInput = opt.isInput = true;
        },
        // flag that we're inside an input so the key handler can act accordingly
        blurInput: function blurInput(e) {
            var $this = $(this).closest('.context-menu-item'),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.isInput = opt.isInput = false;
        },

        // :hover on menu
        menuMouseenter: function menuMouseenter(e) {
            var root = $(this).data().contextMenuRoot;
            if (root) root.hovering = true;
        },
        // :hover on menu
        menuMouseleave: function menuMouseleave(e) {
            var root = $(this).data().contextMenuRoot;
            if (root && root.$layer && root.$layer.is(e.relatedTarget)) {
                root.hovering = false;
            }
        },

        // :hover done manually so key handling is possible
        itemMouseenter: function itemMouseenter(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            if (!root) return;

            root.hovering = true;

            // abort if we're re-entering
            if (e && root.$layer && root.$layer.is(e.relatedTarget)) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }

            // make sure only one item is selected
            (opt.$menu ? opt : root).$menu.children('.hover').trigger('contextmenu:blur');

            if ($this.hasClass('disabled') || $this.hasClass('not-selectable')) {
                opt.$selected = null;
                return;
            }

            $this.trigger('contextmenu:focus');
        },
        // :hover done manually so key handling is possible
        itemMouseleave: function itemMouseleave(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            if (root && root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {
                root.$selected && root.$selected.trigger('contextmenu:blur');
                e.preventDefault();
                e.stopImmediatePropagation();
                root.$selected = opt.$selected = opt.$node;
                return;
            }

            $this.trigger('contextmenu:blur');
        },
        // contextMenu item click
        itemClick: function itemClick(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot,
                key = data.contextMenuKey,
                callback;

            // abort if the key is unknown or disabled or is a menu
            if (!opt.items[key] || $this.is('.disabled, .context-menu-submenu, .context-menu-separator, .not-selectable')) {
                return;
            }

            e.preventDefault();
            e.stopImmediatePropagation();

            if ($.isFunction(root.callbacks[key]) && Object.prototype.hasOwnProperty.call(root.callbacks, key)) {
                // item-specific callback
                callback = root.callbacks[key];
            } else if ($.isFunction(root.callback)) {
                // default callback
                callback = root.callback;
            } else {
                // no callback, no action
                return;
            }

            // hide menu if callback doesn't stop that
            if (callback.call(root.$trigger, key, root) !== false) {
                root.$menu.trigger('contextmenu:hide');
            } else if (root.$menu.parent().length) {
                op.update.call(root.$trigger, root);
            }
        },
        // ignore click events on input elements
        inputClick: function inputClick(e) {
            e.stopImmediatePropagation();
        },

        // hide <menu>
        hideMenu: function hideMenu(e, data) {
            var root = $(this).data('contextMenuRoot');
            op.hide.call(root.$trigger, root, data && data.force);
        },
        // focus <command>
        focusItem: function focusItem(e) {
            e.stopPropagation();
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            $this.addClass('hover').siblings('.hover').trigger('contextmenu:blur');

            // remember selected
            opt.$selected = root.$selected = $this;

            // position sub-menu - do after show so dumb $.ui.position can keep up
            if (opt.$node) {
                root.positionSubmenu.call(opt.$node, opt.$menu);
            }
        },
        // blur <command>
        blurItem: function blurItem(e) {
            e.stopPropagation();
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu;

            $this.removeClass('hover');
            if (opt) opt.$selected = null;
        }
    },

    // operations
    op = {
        show: function show(opt, x, y) {
            var $trigger = $(this),
                offset,
                css = {};

            // hide any open menus
            $('#context-menu-layer').trigger('mousedown');

            // backreference for callbacks
            opt.$trigger = $trigger;

            // show event
            if (opt.events.show.call($trigger, opt) === false) {
                $currentTrigger = null;
                return;
            }

            // create or update context menu
            op.update.call($trigger, opt);

            // position menu
            opt.position.call($trigger, opt, x, y);

            // make sure we're in front
            if (opt.zIndex) {
                css.zIndex = zindex($trigger) + opt.zIndex;
            }

            // add layer
            op.layer.call(opt.$menu, opt, css.zIndex);

            // adjust sub-menu zIndexes
            opt.$menu.find('ul').css('zIndex', css.zIndex + 1);

            // position and show context menu
            opt.$menu.css(css)[opt.animation.show](opt.animation.duration, function () {
                $trigger.trigger('contextmenu:visible');
            });
            // make options available and set state
            $trigger.data('contextMenu', opt).addClass("context-menu-active");

            // register key handler
            $(document).off('keydown.contextMenu').on('keydown.contextMenu', handle.key);
            // register autoHide handler
            if (opt.autoHide) {
                // mouse position handler
                $(document).on('mousemove.contextMenuAutoHide', function (e) {
                    // need to capture the offset on mousemove,
                    // since the page might've been scrolled since activation
                    var pos = $trigger.offset();
                    pos.right = pos.left + $trigger.outerWidth();
                    pos.bottom = pos.top + $trigger.outerHeight();

                    if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {
                        // if mouse in menu...
                        opt.$menu.trigger('contextmenu:hide');
                    }
                });
            }
        },
        hide: function hide(opt, force) {
            var $trigger = $(this);
            if (!opt) {
                opt = $trigger.data('contextMenu') || {};
            }

            // hide event
            if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
                return;
            }

            // remove options and revert state
            $trigger.removeData('contextMenu').removeClass("context-menu-active");

            if (opt.$layer) {
                // keep layer for a bit so the contextmenu event can be aborted properly by opera
                setTimeout(function ($layer) {
                    return function () {
                        $layer.remove();
                    };
                }(opt.$layer), 10);

                try {
                    delete opt.$layer;
                } catch (e) {
                    opt.$layer = null;
                }
            }

            // remove handle
            $currentTrigger = null;
            // remove selected
            opt.$menu.find('.hover').trigger('contextmenu:blur');
            opt.$selected = null;
            // unregister key and mouse handlers
            //$(document).off('.contextMenuAutoHide keydown.contextMenu'); // http://bugs.jquery.com/ticket/10705
            $(document).off('.contextMenuAutoHide').off('keydown.contextMenu');
            // hide menu
            opt.$menu && opt.$menu[opt.animation.hide](opt.animation.duration, function () {
                // tear down dynamically built menu after animation is completed.
                if (opt.build) {
                    opt.$menu.remove();
                    $.each(opt, function (key, value) {
                        switch (key) {
                            case 'ns':
                            case 'selector':
                            case 'build':
                            case 'trigger':
                                return true;

                            default:
                                opt[key] = undefined;
                                try {
                                    delete opt[key];
                                } catch (e) {}
                                return true;
                        }
                    });
                }

                setTimeout(function () {
                    $trigger.trigger('contextmenu:hidden');
                }, 10);
            });
        },
        create: function create(opt, root) {
            if (root === undefined) {
                root = opt;
            }
            // create contextMenu
            opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || "").data({
                'contextMenu': opt,
                'contextMenuRoot': root
            });

            $.each(['callbacks', 'commands', 'inputs'], function (i, k) {
                opt[k] = {};
                if (!root[k]) {
                    root[k] = {};
                }
            });

            root.accesskeys || (root.accesskeys = {});

            // create contextMenu items
            $.each(opt.items, function (key, item) {
                var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ""),
                    $label = null,
                    $input = null;

                // iOS needs to see a click-event bound to an element to actually
                // have the TouchEvents infrastructure trigger the click event
                $t.on('click', $.noop);

                if (typeof item !== "string") {
                    item.$node = $t.data({
                        'contextMenu': opt,
                        'contextMenuRoot': root,
                        'contextMenuKey': key
                    });
                }

                // register accesskey
                // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that
                if (item.accesskey) {
                    var aks = splitAccesskey(item.accesskey);
                    for (var i = 0, ak; ak = aks[i]; i++) {
                        if (!root.accesskeys[ak]) {
                            root.accesskeys[ak] = item;
                            item._name = item.name.replace(new RegExp('(' + ak + ')', 'i'), '<span class="context-menu-accesskey">$1</span>');
                            break;
                        }
                    }
                }

                if (typeof item == "string") {
                    $t.addClass('context-menu-separator not-selectable');
                } else if (item.type && types[item.type]) {
                    // run custom type handler
                    types[item.type].call($t, item, opt, root);
                    // register commands
                    $.each([opt, root], function (i, k) {
                        k.commands[key] = item;
                        if ($.isFunction(item.callback)) {
                            k.callbacks[key] = item.callback;
                        }
                    });
                } else {
                    // add label for input
                    if (item.type == 'html') {
                        $t.addClass('context-menu-html not-selectable');
                    } else if (item.type) {
                        $label = $('<label></label>').appendTo($t);
                        $('<span></span>').html(item._name || item.name).appendTo($label);
                        $t.addClass('context-menu-input');
                        opt.hasTypes = true;
                        $.each([opt, root], function (i, k) {
                            k.commands[key] = item;
                            k.inputs[key] = item;
                        });
                    } else if (item.items) {
                        item.type = 'sub';
                    }

                    switch (item.type) {
                        case 'text':
                            $input = $('<input type="text" value="1" name="" value="">').attr('name', 'context-menu-input-' + key).val(item.value || "").appendTo($label);
                            break;

                        case 'textarea':
                            $input = $('<textarea name=""></textarea>').attr('name', 'context-menu-input-' + key).val(item.value || "").appendTo($label);

                            if (item.height) {
                                $input.height(item.height);
                            }
                            break;

                        case 'checkbox':
                            $input = $('<input type="checkbox" value="1" name="" value="">').attr('name', 'context-menu-input-' + key).val(item.value || "").prop("checked", !!item.selected).prependTo($label);
                            break;

                        case 'radio':
                            $input = $('<input type="radio" value="1" name="" value="">').attr('name', 'context-menu-input-' + item.radio).val(item.value || "").prop("checked", !!item.selected).prependTo($label);
                            break;

                        case 'select':
                            $input = $('<select name="">').attr('name', 'context-menu-input-' + key).appendTo($label);
                            if (item.options) {
                                $.each(item.options, function (value, text) {
                                    $('<option></option>').val(value).text(text).appendTo($input);
                                });
                                $input.val(item.selected);
                            }
                            break;

                        case 'sub':
                            // FIXME: shouldn't this .html() be a .text()?
                            $('<span></span>').html(item._name || item.name).appendTo($t);
                            item.appendTo = item.$node;
                            op.create(item, root);
                            $t.data('contextMenu', item).addClass('context-menu-submenu');
                            item.callback = null;
                            break;

                        case 'html':
                            $(item.html).appendTo($t);
                            break;

                        default:
                            $.each([opt, root], function (i, k) {
                                k.commands[key] = item;
                                if ($.isFunction(item.callback)) {
                                    k.callbacks[key] = item.callback;
                                }
                            });
                            // FIXME: shouldn't this .html() be a .text()?
                            $('<span></span>').html(item._name || item.name || "").appendTo($t);
                            break;
                    }

                    // disable key listener in <input>
                    if (item.type && item.type != 'sub' && item.type != 'html') {
                        $input.on('focus', handle.focusInput).on('blur', handle.blurInput);

                        if (item.events) {
                            $input.on(item.events, opt);
                        }
                    }

                    // add icons
                    if (item.icon) {
                        $t.addClass("icon icon-" + item.icon);
                    }
                }

                // cache contained elements
                if (typeof item !== "string") {
                    item.$input = $input;
                    item.$label = $label;
                }

                // attach item to menu
                $t.appendTo(opt.$menu);

                // Disable text selection
                if (!opt.hasTypes && $.support.eventSelectstart) {
                    // browsers support user-select: none,
                    // IE has a special event for text-selection
                    // browsers supporting neither will not be preventing text-selection
                    $t.on('selectstart.disableTextSelect', handle.abortevent);
                }
            });
            // attach contextMenu to <body> (to bypass any possible overflow:hidden issues on parents of the trigger element)
            if (!opt.$node) {
                opt.$menu.css('display', 'none').addClass('context-menu-root');
            }
            opt.$menu.appendTo(opt.appendTo || document.body);
        },
        resize: function resize($menu, nested) {
            // determine widths of submenus, as CSS won't grow them automatically
            // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100;
            // kinda sucks hard...

            // determine width of absolutely positioned element
            $menu.css({ position: 'absolute', display: 'block' });
            // don't apply yet, because that would break nested elements' widths
            // add a pixel to circumvent word-break issue in IE9 - #80
            $menu.data('width', Math.ceil($menu.width()) + 1);
            // reset styles so they allow nested elements to grow/shrink naturally
            $menu.css({
                position: 'static',
                minWidth: '0px',
                maxWidth: '100000px'
            });
            // identify width of nested menus
            $menu.find('> li > ul').each(function () {
                op.resize($(this), true);
            });
            // reset and apply changes in the end because nested
            // elements' widths wouldn't be calculatable otherwise
            if (!nested) {
                $menu.find('ul').andSelf().css({
                    position: '',
                    display: '',
                    minWidth: '',
                    maxWidth: ''
                }).width(function () {
                    return $(this).data('width');
                });
            }
        },
        update: function update(opt, root) {
            var $trigger = this;
            if (root === undefined) {
                root = opt;
                op.resize(opt.$menu);
            }
            // re-check disabled for each item
            opt.$menu.children().each(function () {
                var $item = $(this),
                    key = $item.data('contextMenuKey'),
                    item = opt.items[key],
                    disabled = item === undefined || typeof item === "string" || $.isFunction(item.disabled) && item.disabled.call($trigger, key, root) || item.disabled === true;

                // dis- / enable item
                $item[disabled ? 'addClass' : 'removeClass']('disabled');

                if (item && item.type) {
                    // dis- / enable input elements
                    $item.find('input, select, textarea').prop('disabled', disabled);

                    // update input states
                    switch (item.type) {
                        case 'text':
                        case 'textarea':
                            item.$input.val(item.value || "");
                            break;

                        case 'checkbox':
                        case 'radio':
                            item.$input.val(item.value || "").prop('checked', !!item.selected);
                            break;

                        case 'select':
                            item.$input.val(item.selected || "");
                            break;
                    }
                }

                if (item && item.$menu) {
                    // update sub-menu
                    op.update.call($trigger, item, root);
                }
            });
        },
        layer: function layer(opt, zIndex) {
            // add transparent layer for click area
            // filter and background for Internet Explorer, Issue #23
            var $layer = opt.$layer = $('<div id="context-menu-layer" style="position:fixed; z-index:' + zIndex + '; top:0; left:0; opacity: 0; filter: alpha(opacity=0); background-color: #000;"></div>').css({ height: $win.height(), width: $win.width(), display: 'block' }).data('contextMenuRoot', opt).insertBefore(this).on('contextmenu', handle.abortevent).on('mousedown', handle.layerClick);

            // IE6 doesn't know position:fixed;
            if (!$.support.fixedPosition) {
                $layer.css({
                    'position': 'absolute',
                    'height': $(document).height()
                });
            }

            return $layer;
        }
    };

    // split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key
    function splitAccesskey(val) {
        var t = val.split(/\s+/),
            keys = [];

        for (var i = 0, k; k = t[i]; i++) {
            k = k[0].toUpperCase(); // first character only
            // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it.
            // a map to look up already used access keys would be nice
            keys.push(k);
        }

        return keys;
    }

    // handle contextMenu triggers
    $.fn.contextMenu = function (operation) {
        if (operation === undefined) {
            this.first().trigger('contextmenu');
        } else if (operation.x && operation.y) {
            this.first().trigger($.Event("contextmenu", { pageX: operation.x, pageY: operation.y }));
        } else if (operation === "hide") {
            var $menu = this.data('contextMenu').$menu;
            $menu && $menu.trigger('contextmenu:hide');
        } else if (operation === "destroy") {
            $.contextMenu("destroy", { context: this });
        } else if ($.isPlainObject(operation)) {
            operation.context = this;
            $.contextMenu("create", operation);
        } else if (operation) {
            this.removeClass('context-menu-disabled');
        } else if (!operation) {
            this.addClass('context-menu-disabled');
        }

        return this;
    };

    // manage contextMenu instances
    $.contextMenu = function (operation, options) {
        if (typeof operation != 'string') {
            options = operation;
            operation = 'create';
        }

        if (typeof options == 'string') {
            options = { selector: options };
        } else if (options === undefined) {
            options = {};
        }

        // merge with default options
        var o = $.extend(true, {}, defaults, options || {});
        var $document = $(document);
        var $context = $document;
        var _hasContext = false;

        if (!o.context || !o.context.length) {
            o.context = document;
        } else {
            // you never know what they throw at you...
            $context = $(o.context).first();
            o.context = $context.get(0);
            _hasContext = o.context !== document;
        }

        switch (operation) {
            case 'create':
                // no selector no joy
                if (!o.selector) {
                    throw new Error('No selector specified');
                }
                // make sure internal classes are not bound to
                if (o.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
                    throw new Error('Cannot bind to selector "' + o.selector + '" as it contains a reserved className');
                }
                if (!o.build && (!o.items || $.isEmptyObject(o.items))) {
                    throw new Error('No Items sepcified');
                }
                counter++;
                o.ns = '.contextMenu' + counter;
                if (!_hasContext) {
                    namespaces[o.selector] = o.ns;
                }
                menus[o.ns] = o;

                // default to right click
                if (!o.trigger) {
                    o.trigger = 'right';
                }

                if (!initialized) {
                    // make sure item click is registered first
                    $document.on({
                        'contextmenu:hide.contextMenu': handle.hideMenu,
                        'prevcommand.contextMenu': handle.prevItem,
                        'nextcommand.contextMenu': handle.nextItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.menuMouseenter,
                        'mouseleave.contextMenu': handle.menuMouseleave
                    }, '.context-menu-list').on('mouseup.contextMenu', '.context-menu-input', handle.inputClick).on({
                        'mouseup.contextMenu': handle.itemClick,
                        'contextmenu:focus.contextMenu': handle.focusItem,
                        'contextmenu:blur.contextMenu': handle.blurItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.itemMouseenter,
                        'mouseleave.contextMenu': handle.itemMouseleave
                    }, '.context-menu-item');

                    initialized = true;
                }

                // engage native contextmenu event
                $context.on('contextmenu' + o.ns, o.selector, o, handle.contextmenu);

                if (_hasContext) {
                    // add remove hook, just in case
                    $context.on('remove' + o.ns, function () {
                        $(this).contextMenu("destroy");
                    });
                }

                switch (o.trigger) {
                    case 'hover':
                        $context.on('mouseenter' + o.ns, o.selector, o, handle.mouseenter).on('mouseleave' + o.ns, o.selector, o, handle.mouseleave);
                        break;

                    case 'left':
                        $context.on('click' + o.ns, o.selector, o, handle.click);
                        break;
                    /*
                    default:
                        // http://www.quirksmode.org/dom/events/contextmenu.html
                        $document
                            .on('mousedown' + o.ns, o.selector, o, handle.mousedown)
                            .on('mouseup' + o.ns, o.selector, o, handle.mouseup);
                        break;
                    */
                }

                // create menu
                if (!o.build) {
                    op.create(o);
                }
                break;

            case 'destroy':
                var $visibleMenu;
                if (_hasContext) {
                    // get proper options
                    var context = o.context;
                    $.each(menus, function (ns, o) {
                        if (o.context !== context) {
                            return true;
                        }

                        $visibleMenu = $('.context-menu-list').filter(':visible');
                        if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {
                            $visibleMenu.trigger('contextmenu:hide', { force: true });
                        }

                        try {
                            if (menus[o.ns].$menu) {
                                menus[o.ns].$menu.remove();
                            }

                            delete menus[o.ns];
                        } catch (e) {
                            menus[o.ns] = null;
                        }

                        $(o.context).off(o.ns);

                        return true;
                    });
                } else if (!o.selector) {
                    $document.off('.contextMenu .contextMenuAutoHide');
                    $.each(menus, function (ns, o) {
                        $(o.context).off(o.ns);
                    });

                    namespaces = {};
                    menus = {};
                    counter = 0;
                    initialized = false;

                    $('#context-menu-layer, .context-menu-list').remove();
                } else if (namespaces[o.selector]) {
                    $visibleMenu = $('.context-menu-list').filter(':visible');
                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {
                        $visibleMenu.trigger('contextmenu:hide', { force: true });
                    }

                    try {
                        if (menus[namespaces[o.selector]].$menu) {
                            menus[namespaces[o.selector]].$menu.remove();
                        }

                        delete menus[namespaces[o.selector]];
                    } catch (e) {
                        menus[namespaces[o.selector]] = null;
                    }

                    $document.off(namespaces[o.selector]);
                }
                break;

            case 'html5':
                // if <command> or <menuitem> are not handled by the browser,
                // or options was a bool true,
                // initialize $.contextMenu for them
                if (!$.support.htmlCommand && !$.support.htmlMenuitem || typeof options == "boolean" && options) {
                    $('menu[type="context"]').each(function () {
                        if (this.id) {
                            $.contextMenu({
                                selector: '[contextmenu=' + this.id + ']',
                                items: $.contextMenu.fromMenu(this)
                            });
                        }
                    }).css('display', 'none');
                }
                break;

            default:
                throw new Error('Unknown operation "' + operation + '"');
        }

        return this;
    };

    // import values into <input> commands
    $.contextMenu.setInputValues = function (opt, data) {
        if (data === undefined) {
            data = {};
        }

        $.each(opt.inputs, function (key, item) {
            switch (item.type) {
                case 'text':
                case 'textarea':
                    item.value = data[key] || "";
                    break;

                case 'checkbox':
                    item.selected = data[key] ? true : false;
                    break;

                case 'radio':
                    item.selected = (data[item.radio] || "") == item.value ? true : false;
                    break;

                case 'select':
                    item.selected = data[key] || "";
                    break;
            }
        });
    };

    // export values from <input> commands
    $.contextMenu.getInputValues = function (opt, data) {
        if (data === undefined) {
            data = {};
        }

        $.each(opt.inputs, function (key, item) {
            switch (item.type) {
                case 'text':
                case 'textarea':
                case 'select':
                    data[key] = item.$input.val();
                    break;

                case 'checkbox':
                    data[key] = item.$input.prop('checked');
                    break;

                case 'radio':
                    if (item.$input.prop('checked')) {
                        data[item.radio] = item.value;
                    }
                    break;
            }
        });

        return data;
    };

    // find <label for="xyz">
    function inputLabel(node) {
        return node.id && $('label[for="' + node.id + '"]').val() || node.name;
    }

    // convert <menu> to items object
    function menuChildren(items, $children, counter) {
        if (!counter) {
            counter = 0;
        }

        $children.each(function () {
            var $node = $(this),
                node = this,
                nodeName = this.nodeName.toLowerCase(),
                label,
                item;

            // extract <label><input>
            if (nodeName == 'label' && $node.find('input, textarea, select').length) {
                label = $node.text();
                $node = $node.children().first();
                node = $node.get(0);
                nodeName = node.nodeName.toLowerCase();
            }

            /*
             * <menu> accepts flow-content as children. that means <embed>, <canvas> and such are valid menu items.
             * Not being the sadistic kind, $.contextMenu only accepts:
             * <command>, <menuitem>, <hr>, <span>, <p> <input [text, radio, checkbox]>, <textarea>, <select> and of course <menu>.
             * Everything else will be imported as an html node, which is not interfaced with contextMenu.
             */

            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command
            switch (nodeName) {
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element
                case 'menu':
                    item = { name: $node.attr('label'), items: {} };
                    counter = menuChildren(item.items, $node.children(), counter);
                    break;

                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command
                case 'a':
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command
                case 'button':
                    item = {
                        name: $node.text(),
                        disabled: !!$node.attr('disabled'),
                        callback: function () {
                            return function () {
                                $node.click();
                            };
                        }()
                    };
                    break;

                // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command

                case 'menuitem':
                case 'command':
                    switch ($node.attr('type')) {
                        case undefined:
                        case 'command':
                        case 'menuitem':
                            item = {
                                name: $node.attr('label'),
                                disabled: !!$node.attr('disabled'),
                                callback: function () {
                                    return function () {
                                        $node.click();
                                    };
                                }()
                            };
                            break;

                        case 'checkbox':
                            item = {
                                type: 'checkbox',
                                disabled: !!$node.attr('disabled'),
                                name: $node.attr('label'),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        case 'radio':
                            item = {
                                type: 'radio',
                                disabled: !!$node.attr('disabled'),
                                name: $node.attr('label'),
                                radio: $node.attr('radiogroup'),
                                value: $node.attr('id'),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        default:
                            item = undefined;
                    }
                    break;

                case 'hr':
                    item = '-------';
                    break;

                case 'input':
                    switch ($node.attr('type')) {
                        case 'text':
                            item = {
                                type: 'text',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                value: $node.val()
                            };
                            break;

                        case 'checkbox':
                            item = {
                                type: 'checkbox',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        case 'radio':
                            item = {
                                type: 'radio',
                                name: label || inputLabel(node),
                                disabled: !!$node.attr('disabled'),
                                radio: !!$node.attr('name'),
                                value: $node.val(),
                                selected: !!$node.attr('checked')
                            };
                            break;

                        default:
                            item = undefined;
                            break;
                    }
                    break;

                case 'select':
                    item = {
                        type: 'select',
                        name: label || inputLabel(node),
                        disabled: !!$node.attr('disabled'),
                        selected: $node.val(),
                        options: {}
                    };
                    $node.children().each(function () {
                        item.options[this.value] = $(this).text();
                    });
                    break;

                case 'textarea':
                    item = {
                        type: 'textarea',
                        name: label || inputLabel(node),
                        disabled: !!$node.attr('disabled'),
                        value: $node.val()
                    };
                    break;

                case 'label':
                    break;

                default:
                    item = { type: 'html', html: $node.clone(true) };
                    break;
            }

            if (item) {
                counter++;
                items['key' + counter] = item;
            }
        });

        return counter;
    }

    // convert html5 menu
    $.contextMenu.fromMenu = function (element) {
        var $this = $(element),
            items = {};

        menuChildren(items, $this.children());

        return items;
    };

    // make defaults accessible
    $.contextMenu.defaults = defaults;
    $.contextMenu.types = types;
    // export internal functions - undocumented, for hacking only!
    $.contextMenu.handle = handle;
    $.contextMenu.op = op;
    $.contextMenu.menus = menus;
})(jQuery);

/***/ }),

/***/ "./src/lib/pathfinding.exec.js":
/*!*************************************!*\
  !*** ./src/lib/pathfinding.exec.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./src/lib/pathfinding.exec.js */ "./node_modules/raw-loader/index.js!./src/lib/pathfinding.exec.js"));

/***/ }),

/***/ "./src/lib/raphael.exec.js":
/*!*********************************!*\
  !*** ./src/lib/raphael.exec.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./src/lib/raphael.exec.js */ "./node_modules/raw-loader/index.js!./src/lib/raphael.exec.js"));

/***/ }),

/***/ "./src/packages.js":
/*!*************************!*\
  !*** ./src/packages.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 *
 * @private
 */
/**
 * Primary package containing general interfaces and implementation classes.
 * @namespace draw2d */
exports.default = {
  /**
   * Types representing or manipulating geometric values, such as Points, Rectangles, etc.
   * @namespace draw2d.geo
   * */
  geo: {},

  /** 
   * Contains classes to load and save Draw2D files into, or from, a Canvas.
   * @namespace draw2d.io 
   **/
  io: {
    /** @namespace draw2d.io.json
     * */
    json: {},
    /** @namespace draw2d.io.png */
    png: {},
    /** @namespace draw2d.io.svg */
    svg: {}
  },

  /** @namespace draw2d.util */
  util: {
    /** @namespace draw2d.util.spline */
    spline: {}
  },

  /**
   * This package contains EditPolicy implementations for all used elements. A *EditPolicy*
   * is a pluggable contribution implementing a portion of an element behavior. Editpolicies contribute to the
   * overall editing behavior of an EditPart.
   *
   * Editing behavior is defined as one or more of the following:
   *  - Selection handling
   *  - Routing
   *  - Feedback management
   *  - Delegation and Forwarding of commands
   *  - Drag&Drop behaviour
   *
   * @namespace draw2d.policy
   * */
  policy: {
    /**
     * Editpolicies for selection handling, highlighting, background rendering, snapTo behaviour.
     *
     * @namespace draw2d.policy.canvas
     * */
    canvas: {},
    /** 
     * Policies for Connection creation. Like 'ClickPolicy'...creates a connection if you click into the canvas. 
     * @namespace draw2d.policy.connection 
     **/
    connection: {},
    /** @namespace draw2d.policy.line */
    line: {},
    /** @namespace draw2d.policy.port */
    port: {},
    /** 
     * Selection decorations for figures. Movement contrains. Width limitation,...
     * @namespace draw2d.policy.figure 
     **/
    figure: {}
  },

  /** 
   * Contains all predefined visual shapes of Draw2D
   *  
   * @namespace draw2d.shape 
   **/
  shape: {
    /** 
     * @namespace draw2d.shape.basic 
     **/
    basic: {},
    /** @namespace draw2d.shape.dimetric */
    dimetric: {},
    /** @namespace draw2d.shape.composite */
    composite: {},
    /** @namespace draw2d.shape.arrow */
    arrow: {},
    /** @namespace draw2d.shape.node */
    node: {},
    /** @namespace draw2d.shape.note */
    note: {},
    /** @namespace draw2d.shape.diagram */
    diagram: {},
    /** @namespace draw2d.shape.flowchart */
    flowchart: {},
    /** @namespace draw2d.shape.analog */
    analog: {},
    /** @namespace draw2d.shape.icon */
    icon: {},
    /** @namespace draw2d.shape.layout */
    layout: {},
    /** @namespace draw2d.shape.pert */
    pert: {},
    /** @namespace draw2d.shape.state */
    state: {},
    /** @namespace draw2d.shape.widget */
    widget: {}
  },

  /** 
   * The command is what eventually changes the model. Figures are asked for a command for a given request. Commands also help 
   * determine if the interaction is possible. If there is no command, or it is not executable, the UI will indicate that the 
   * interaction is not allowed. 
   * 
   * All commands (move, drag&drop, insert, remove,....) are stored on top of a CommandStack and available for undo and redo.
   * An `draw2d.Canvas` has a single command stack. **Commands must be executed using the command stack rather than directly calling execute.**
   * 
   * @namespace draw2d.command 
   **/
  command: {},

  /** @namespace draw2d.decoration */
  decoration: {
    /** @namespace draw2d.decoration.connection */
    connection: {}
  },

  /** @namespace draw2d.layout */
  layout: {
    /** @namespace draw2d.layout.connection
     *  @memberof draw2d.layout
     * */
    connection: {},
    /** @namespace draw2d.layout.anchor */
    anchor: {},
    /** @namespace draw2d.layout.mesh */
    mesh: {},
    /** @namespace draw2d.layout.locator */
    locator: {}
  },

  /** @namespace draw2d.ui */
  ui: {},

  isTouchDevice:
  //Detect iPhone
  navigator.platform.indexOf("iPhone") != -1 ||
  //Detect iPod
  navigator.platform.indexOf("iPod") != -1 ||
  //Detect iPad
  navigator.platform.indexOf("iPad") != -1

};
module.exports = exports["default"];

/***/ }),

/***/ "./src/policy/EditPolicy.js":
/*!**********************************!*\
  !*** ./src/policy/EditPolicy.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A plugable contribution implementing a portion of an behavior.
 *
 *
 * EditPolicies should determine an Canvas or figure editing capabilities. It is possible to implement
 * an figure such that it handles all editing responsibility. However, it is much more flexible
 * and object-oriented to use EditPolicies. Using policies, you can pick and choose the editing
 * behavior for an figure/canvas without being bound to its class hierarchy. Code management is easier.
 *
 *
 * This interface is not intended to be implemented by clients. Clients should inherit from {@link draw2d.policy.figure.SelectionFeedbackPolicy}
 * or {@link draw2d.policy.canvas.SelectionPolicy}.
 *
 * @author Andreas Herz
 */
_packages2.default.policy.EditPolicy = Class.extend(
/** @lends draw2d.policy.EditPolicy.prototype */
{

  NAME: "draw2d.policy.EditPolicy",

  /**
   *
   */
  init: function init(attr, setter, getter) {
    this.setterWhitelist = (0, _extend2.default)({}, setter);

    this.getterWhitelist = (0, _extend2.default)({}, getter);

    this.attr(attr);
  },

  /**
   * 
   * Read or set object attributes.<br>
   * When no value is given, reads specified attribute from the element.<br>
   * When value is given, sets the attribute to that value.
   * Multiple attributes can be set by passing an object with name-value pairs.
   *
   * @param {String/Object} name
   * @param {Object} [value]
   * @since 5.3.2
   * @returns {Object}
   **/
  attr: function attr(name, value) {
    // call of attr as setter method with {name1:val1, name2:val2 }  argument list
    //
    if ($.isPlainObject(name)) {
      for (var _key in name) {
        var func = this.setterWhitelist[_key];
        // call the assigned method if given
        if (func) {
          func.call(this, name[_key]);
        }
        // maby the ussser adds a function as property to the attr call
        // e.g.:
        // {
        //     doIt: function(){}
        // }
        //
        // in this case we assign the method to this object and wrap it with "this" as context
        // a very, very simple method to replace default implemenations of the object
        else if (typeof name[_key] === "function") {
            this[_key] = name[_key].bind(this);
          }
      }
    } else if (typeof name === "string") {
      // call attr as getter
      //
      if (typeof value === "undefined") {
        var getter = this.getterWhitelist[name];
        if (typeof getter === "function") {
          return getter.call(this);
        }
        return; // undefined
      }
      // call attr as simple setter with (key , value)
      //

      // the value can be a function. In this case we must call the value().
      if (typeof value === "function") {
        value = value();
      }
      var setter = this.setterWhitelist[name];
      if (setter) {
        setter.call(this, value);
      }
    }
    // generic getter of all registered attributes
    else if (typeof name === "undefined") {
        var result = {};
        for (key in this.getterWhitelist) {
          result[key] = this.getterWhitelist[key].call(this);
        }
        return result;
      }

    return this;
  },

  /**
   * 
   * Called by the host if the policy has been installed.
   *
   * @param {draw2d.Canvas|draw2d.Figure} host
   */
  onInstall: function onInstall(host) {},

  /**
   * 
   * Called by the host if the policy has been uninstalled.
   *
   * @param {draw2d.Canvas|draw2d.Figure} host
   */
  onUninstall: function onUninstall(host) {}
});

/***/ }),

/***/ "./src/policy/canvas/BoundingboxSelectionPolicy.js":
/*!*********************************************************!*\
  !*** ./src/policy/canvas/BoundingboxSelectionPolicy.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SelectionPolicy
 */
_packages2.default.policy.canvas.BoundingboxSelectionPolicy = _packages2.default.policy.canvas.SingleSelectionPolicy.extend(
/** @lends draw2d.policy.canvas.BoundingboxSelectionPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.BoundingboxSelectionPolicy",

  /**
   * Creates a new selection policy for a canvas.
   */
  init: function init() {
    this.isInsideMode = function (rect1, rect2) {
      return rect1.isInside(rect2);
    };
    this.intersectsMode = function (rect1, rect2) {
      return rect1.intersects(rect2);
    };

    this.decision = this.isInsideMode;

    this._super();

    this.boundingBoxFigure1 = null;
    this.boundingBoxFigure2 = null;
    this.x = 0;
    this.y = 0;

    // falls ein Port getroffen wird, dann darf keine BoundingBox gezeichnet werden.
    //
    this.canDrawBoundingBox = false;
  },

  /**
   * @inheritdoc
   */
  select: function select(canvas, figure) {
    var _this = this;

    if (canvas.getSelection().contains(figure)) {
      return; // nothing to to
    }

    var oldSelection = canvas.getSelection().getPrimary();

    if (figure !== null) {
      figure.select(true); // primary selection
    }

    if (oldSelection !== figure) {
      canvas.getSelection().setPrimary(figure);

      // inform all selection listeners about the new selection.
      //
      canvas.fireEvent("select", { figure: figure, selection: canvas.getSelection() });
    }

    // adding connections to the selection of the source and target port part of the current selection
    //
    var selection = canvas.getSelection();
    canvas.getLines().each(function (i, line) {
      if (line instanceof _packages2.default.Connection) {
        if (selection.contains(line.getSource().getRoot()) && selection.contains(line.getTarget().getRoot())) {
          _this.select(canvas, line, false);
        }
      }
    });
  },

  /**
   * 
   * Set the selection handling mode to <b>intersection</b> or to <b>isInside</b>.
   * <ul>
   *   <li>true = intersection, shapes must only touch the selection bounding box </li>
   *   <li>false = isInside, shapes must complete inside the selection bounding box (default)</li>
   * </ul>
   *
   * @param {Boolean} useIntersectionMode set true if the selection handle should use the alternative selection approach
   * @since 4.9.0
   */
  setDecisionMode: function setDecisionMode(useIntersectionMode) {
    if (useIntersectionMode === true) {
      this.decision = this.intersectsMode;
    } else {
      this.decision = this.isInsideMode;
    }

    return this;
  },

  /**
   * 
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    var _this2 = this;

    try {
      this.x = x;
      this.y = y;

      var currentSelection = canvas.getSelection().getAll();

      // COPY_PARENT
      // this code part is copied from the parent implementation. The main problem is, that
      // the sequence of unselect/select of elements is broken if we call the base implementation
      // in this case wrong  events are fired if we select a figure if already a figure is selected!
      // WRONG: selectNewFigure -> unselectOldFigure
      // RIGHT: unselectOldFigure -> selectNewFigure
      // To ensure this I must copy the parent code and postbound the event propagation
      //
      this.mouseMovedDuringMouseDown = false;
      var canDragStart = true;

      this.canDrawBoundingBox = false;

      var figure = canvas.getBestFigure(x, y);

      // may the figure is assigned to a composite. In this case the composite can
      // override the event receiver
      while (figure !== null) {
        var delegated = figure.getSelectionAdapter()();
        if (delegated === figure) {
          break;
        }
        figure = delegated;
      }

      // ignore ports since version 6.1.0. This is handled by the ConnectionCreatePolicy
      //
      if (figure instanceof _packages2.default.Port) {
        return; // silently
      }

      if (figure !== null && figure.isSelectable() === false && figure.isDraggable() === false) {
        figure = null;
      }

      this.canDrawBoundingBox = true;

      if (figure !== null && figure.isDraggable()) {
        canDragStart = figure.onDragStart(x - figure.getAbsoluteX(), y - figure.getAbsoluteY(), shiftKey, ctrlKey);
        // Element send a veto about the drag&drop operation
        this.mouseDraggingElement = canDragStart === false ? null : figure;
      }

      this.mouseDownElement = figure;

      if (this.mouseDownElement !== null) {
        this.mouseDownElement.fireEvent("mousedown", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
      }

      // we click on an element which are not part of the current selection
      // => reset the "old" current selection if we didn't press the shift key
      if (shiftKey === false) {
        if (this.mouseDownElement !== null && this.mouseDownElement.isResizeHandle === false && !currentSelection.contains(this.mouseDownElement)) {
          currentSelection.each(function (i, figure) {
            _this2.unselect(canvas, figure);
          });
        }
      }

      if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
        this.select(canvas, figure);

        // its a line
        if (figure instanceof _packages2.default.shape.basic.Line) {
          // you can move a line with Drag&Drop...but not a connection.
          // A Connection is fixed linked with the corresponding ports.
          //
          if (!(figure instanceof _packages2.default.Connection)) {
            canvas.draggingLineCommand = figure.createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.MOVE));
            if (canvas.draggingLineCommand !== null) {
              canvas.draggingLine = figure;
            }
          }
        } else if (canDragStart === false) {
          figure.unselect();
        }
      }
      // END_COPY FROM PARENT


      // inform all figures that they have a new ox/oy position for the relative
      // drag/drop operation
      if (this.mouseDownElement !== null && this.mouseDownElement.isResizeHandle === false) {
        currentSelection = canvas.getSelection().getAll();
        currentSelection.each(function (i, figure) {
          var fakeDragX = 1;
          var fakeDragY = 1;

          var handleRect = figure.getHandleBBox();
          if (handleRect !== null) {
            handleRect.translate(figure.getAbsolutePosition().scale(-1));
            fakeDragX = handleRect.x + 1;
            fakeDragY = handleRect.y + 1;
          }

          var canDragStart = figure.onDragStart(fakeDragX, fakeDragY, shiftKey, ctrlKey, true /*fakeFlag*/);
          // its a line
          if (figure instanceof _packages2.default.shape.basic.Line) {
            // no special handling
          } else if (canDragStart === false) {
            _this2.unselect(canvas, figure);
          }
        });
      }
    } catch (exc) {
      console.log(exc);
      throw exc;
    }
  },

  /**
   * 
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    // don't drag a selection box if we drag&drop a port
    //
    if (this.canDrawBoundingBox === false) {
      return;
    }

    try {
      this._super(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey);

      if (this.mouseDraggingElement === null && this.mouseDownElement === null && this.boundingBoxFigure1 === null) {
        this.boundingBoxFigure1 = new _packages2.default.shape.basic.Rectangle({
          width: 1,
          height: 1,
          x: this.x,
          y: this.y,
          bgColor: "#d4d1d4",
          alpha: 0.1
        });
        this.boundingBoxFigure1.setCanvas(canvas);

        this.boundingBoxFigure2 = new _packages2.default.shape.basic.Rectangle({
          width: 1,
          height: 1,
          x: this.x,
          y: this.y,
          dash: "--..",
          stroke: 0.5,
          color: "#37a8ff",
          bgColor: null
        });
        this.boundingBoxFigure2.setCanvas(canvas);
      }
      var abs = Math.abs;
      if (this.boundingBoxFigure1 !== null) {
        this.boundingBoxFigure1.setDimension(abs(dx), abs(dy));
        this.boundingBoxFigure1.setPosition(this.x + Math.min(0, dx), this.y + Math.min(0, dy));
        this.boundingBoxFigure2.setDimension(abs(dx), abs(dy));
        this.boundingBoxFigure2.setPosition(this.x + Math.min(0, dx), this.y + Math.min(0, dy));
      }
    } catch (exc) {
      console.log(exc);
    }
  },

  /**
   * 
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseUp: function onMouseUp(canvas, x, y, shiftKey, ctrlKey) {
    var _this3 = this;

    try {
      // delete the current selection if you have clicked in the empty
      // canvas.
      if (this.mouseDownElement === null) {
        canvas.getSelection().getAll().each(function (i, figure) {
          _this3.unselect(canvas, figure);
        });
      } else if (this.mouseDownElement instanceof _packages2.default.ResizeHandle || this.mouseDownElement instanceof _packages2.default.shape.basic.LineResizeHandle) {}
      // Do nothing
      // A click on a resize handle didn't change the selection of the canvas
      //

      // delete the current selection if you click on another figure than the current
      // selection and you didn't drag the complete selection.
      else if (this.mouseDownElement !== null && this.mouseMovedDuringMouseDown === false) {
          var sel = canvas.getSelection().getAll();
          if (!sel.contains(this.mouseDownElement)) {
            canvas.getSelection().getAll().each(function (i, figure) {
              _this3.unselect(canvas, figure);
            });
          }
        }
      this._super(canvas, x, y, shiftKey, ctrlKey);

      if (this.boundingBoxFigure1 !== null) {
        // retrieve all figures which are inside the bounding box and select all of them
        //
        var selectionRect = this.boundingBoxFigure1.getBoundingBox();
        canvas.getFigures().each(function (i, figure) {
          if (figure.isSelectable() === true && _this3.decision(figure.getBoundingBox(), selectionRect)) {
            var fakeDragX = 1;
            var fakeDragY = 1;

            var handleRect = figure.getHandleBBox();
            if (handleRect !== null) {
              handleRect.translate(figure.getAbsolutePosition().scale(-1));
              fakeDragX = handleRect.x + 1;
              fakeDragY = handleRect.y + 1;
            }
            var canDragStart = figure.onDragStart(fakeDragX, fakeDragY, shiftKey, ctrlKey);
            if (canDragStart === true) {
              _this3.select(canvas, figure);
            }
          }
        });

        this.boundingBoxFigure1.setCanvas(null);
        this.boundingBoxFigure1 = null;
        this.boundingBoxFigure2.setCanvas(null);
        this.boundingBoxFigure2 = null;
      }
    } catch (exc) {
      console.log(exc);
      debugger;
    }
  }

});

/***/ }),

/***/ "./src/policy/canvas/CanvasPolicy.js":
/*!*******************************************!*\
  !*** ./src/policy/canvas/CanvasPolicy.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _Color = __webpack_require__(/*! ../../util/Color */ "./src/util/Color.js");

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.EditPolicy
 */
_packages2.default.policy.canvas.CanvasPolicy = _packages2.default.policy.EditPolicy.extend(
/** @lends draw2d.policy.canvas.CanvasPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.CanvasPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this.canvas = null;
    this._super(attr, setter, getter);
  },

  /**
   *
   * Called if the policy is installed into the canvas.
   *
   * @param {draw2d.Canvas} canvas
   */
  onInstall: function onInstall(canvas) {
    this.canvas = canvas;
  },

  /**
   *
   * Called if the policy is deinstalled from the canvas
   *
   * @param {draw2d.Canvas} canvas
   */
  onUninstall: function onUninstall(canvas) {
    this.canvas = null;
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onMouseMove: function onMouseMove(canvas, x, y, shiftKey, ctrlKey) {},

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {},

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {},

  /**
   *
   *
   * @param {draw2d.Canvas} canvas the shape below the mouse or null
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseUp: function onMouseUp(canvas, x, y, shiftKey, ctrlKey) {},

  /**
   *
   * Called if the user press the right mouse in the canvas.
   *
   * @param {draw2d.Figure|draw2d.shape.basic.Line} figure the figure below the mouse
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @since 4.4.0
   */
  onRightMouseDown: function onRightMouseDown(figure, x, y, shiftKey, ctrlKey) {},

  /**
   *
   * Called by the canvas if the user click on a figure.
   *
   * @param {draw2d.Figure} figure the figure under the click event. Can be null
   * @param {Number} mouseX the x coordinate of the mouse during the click event
   * @param {Number} mouseY the y coordinate of the mouse during the click event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @since 3.0.0
   *
   * @template
   */
  onClick: function onClick(figure, mouseX, mouseY, shiftKey, ctrlKey) {},

  /**
   *
   * Called by the canvas if the user double click on a figure.
   *
   * @param {draw2d.Figure} figure the figure under the double click event. Can be null
   * @param {Number} mouseX the x coordinate of the mouse during the click event
   * @param {Number} mouseY the y coordinate of the mouse during the click event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @since 4.1.0
   *
   * @template
   */
  onDoubleClick: function onDoubleClick(figure, mouseX, mouseY, shiftKey, ctrlKey) {},

  /**
   *
   * called if the user uses the mouse wheel.
   *
   *
   * @param {Number} wheelDelta
   * @param {Number} x the x coordinate of the event
   * @param {Number} y the y coordinate of the event
   * @param shiftKey
   * @param ctrlKey
   * @since 5.8.0
   * @template
   *
   * @returns {Boolean} return <b>false</b> to preven tthe default event operation (e.g. scrolling)
   */
  onMouseWheel: function onMouseWheel(wheelDelta, x, y, shiftKey, ctrlKey) {
    // return "false" to prevent the default event operation
    return true;
  },

  /**
   *
   * Helper method to make an monochrome GIF image WxH pixels big, first create a properly sized array: let pixels = new Array(W*H);.
   * Then, for each pixel X,Y that should be opaque, store a 1 at the proper location: pixels[X+Y*W] = 1;.
   * Finally, create the image: let my_gif = createGif(W, H, pixels, color);
   * "0" pixels are transparent.
   * The <b>color</b> defines the foreground color.
   *
   * Now, you can specify this image as the SRC attribute of an IMG tag: document.write("<IMG SRC=\"" + my_gif + "\">");
   * or for the canvas as background-image css attribute.
   *
   *
   * @param w
   * @param h
   * @param d
   * @param color
   * @returns {String}
   *
   * @private
   */
  createMonochromGif: function createMonochromGif(w, h, d, color) {
    color = new _Color2.default(color);
    var r = String.fromCharCode(w % 256) + String.fromCharCode(w / 256) + String.fromCharCode(h % 256) + String.fromCharCode(h / 256);

    var gif = 'GIF89a' + r + '\xf0\0\0\xff\xff\xff' + String.fromCharCode(color.red) + String.fromCharCode(color.green) + String.fromCharCode(color.blue) + '!\xF9\x04\x01\0\0\0,\0\0\0\0' + r + '\0\x02';

    // help method to generate uncompressed in memory GIF data structure without the usage of a canvas or any other
    // heavy weight stuff.
    var b = {
      bit: 1,
      byte_: 0,
      data: '',

      writeBit: function writeBit(b) {
        if (b) this.byte_ |= this.bit;
        this.bit <<= 1;
        if (this.bit === 256) {
          this.bit = 1;
          this.data += String.fromCharCode(this.byte_);
          this.byte_ = 0;
        }
      },

      get: function get() {
        var result = "";
        var data = this.data;
        if (this.bit !== 1) {
          data += String.fromCharCode(this.byte_);
        }
        for (var i = 0; i < data.length + 1; i += 255) {
          var chunklen = data.length - i;
          if (chunklen < 0) chunklen = 0;
          if (chunklen > 255) chunklen = 255;
          result += String.fromCharCode(chunklen) + data.substring(i, i + 255);
        }
        return result + "\0";
      }
    };

    for (var y = 0; y < h; y++) {
      for (var x = 0; x < w; x++) {
        b.writeBit(d[x + w * y]);
        b.writeBit(0);
        b.writeBit(0);
        b.writeBit(0);
        b.writeBit(0);
        b.writeBit(1);
      }
    }
    gif += b.get() + ';';

    return 'data:image/gif;base64,' + _packages2.default.util.Base64.encode(gif);
  }

});

/***/ }),

/***/ "./src/policy/canvas/CoronaDecorationPolicy.js":
/*!*****************************************************!*\
  !*** ./src/policy/canvas/CoronaDecorationPolicy.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * This decorations hides draw2d.Ports which are to far from the current cursor position.
 * This makes the canvas more clean if you have a lot of nodes on it.<br>
 * You didn't see a bunch of ports.
 *
 *
 * @example
 *
 *      // install the policy to the canvas
 *
 *      // add some demo figure to the canvas
 *      canvas.add(new draw2d.shape.node.Start({x: 10,  y: 30}));
 *      canvas.add(new draw2d.shape.node.End({x: 90,  y: 90}));
 *      canvas.add(new draw2d.shape.node.Between({ x: 310, y: 30}));
 *
 *      canvas.add(new draw2d.shape.basic.Label({text:"move the mouse and you see that ports are hidden if the mouse far from it"}),5,5);
 *
 *      canvas.installEditPolicy(new draw2d.policy.canvas.CoronaDecorationPolicy());
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.DecorationPolicy
 */
_packages2.default.policy.canvas.CoronaDecorationPolicy = _packages2.default.policy.canvas.DecorationPolicy.extend(
/** @lends draw2d.policy.canvas.CoronaDecorationPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.CoronaDecorationPolicy",

  /**
   *
   */
  init: function init(attr, setter, getter) {

    this.startDragX = 0;
    this.startDragY = 0;
    this.diameterToBeFullVisible = 0;
    this.diameterToBeVisible = 0;
    this.sumDiameter = 0;

    this._super((0, _extend2.default)({ diameterToBeVisible: 200, diameterToBeFullVisible: 20 }, attr), (0, _extend2.default)({
      diameterToBeVisible: this.setDiameterToBeVisible,
      diameterToBeFullVisible: this.setDiameterToBeFullVisible
    }, setter), (0, _extend2.default)({
      diameterToBeVisible: this.getDiameterToBeVisible,
      diameterToBeFullVisible: this.getDiameterToBeFullVisible
    }, getter));
  },

  setDiameterToBeVisible: function setDiameterToBeVisible(diameter) {
    this.diameterToBeVisible = diameter;
    this.sumDiameter = this.diameterToBeFullVisible + this.diameterToBeVisible;
  },

  getDiameterToBeVisible: function getDiameterToBeVisible() {
    return this.diameterToBeVisible;
  },

  setDiameterToBeFullVisible: function setDiameterToBeFullVisible(diameter) {
    this.diameterToBeFullVisible = diameter;
    this.sumDiameter = this.diameterToBeFullVisible + this.diameterToBeVisible;
  },

  getDiameterToBeFullVisible: function getDiameterToBeFullVisible() {
    return this.diameterToBeFullVisible;
  },

  /**
   * @inheritdoc
   */
  onInstall: function onInstall(canvas) {
    this._super(canvas);
    canvas.getFigures().each(function (i, figure) {
      figure.getPorts().each(function (i, p) {
        return p.setAlpha(0.0);
      });
    });
  },

  /**
   * @inheritdoc
   */
  onUninstall: function onUninstall(canvas) {
    this._super(canvas);

    canvas.getFigures().each(function (i, figure) {
      figure.getPorts().each(function (i, p) {
        if (p.__origAlpha) {
          p.setAlpha(p.__origAlpha);
          delete p.__origAlpha;
        }
      });
    });
  },

  /**
   * @inheritdoc
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    this.startDragX = x;
    this.startDragY = y;
  },

  /**
   * @inheritdoc
   */
  onMouseMove: function onMouseMove(canvas, x, y, shiftKey, ctrlKey) {
    this.updatePorts(canvas, x, y);
  },

  /**
   * @inheritdoc
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    this.updatePorts(canvas, this.startDragX + dx, this.startDragY + dy);
  },

  /**
   * 
   * Update all ports with the new calculated opacity in relation to the distance to the current
   * mouse position
   *
   * @param canvas
   * @param x
   * @param y
   * @private
   */
  updatePorts: function updatePorts(canvas, x, y) {
    var _this = this;

    canvas.getFigures().each(function (i, figure) {
      if (figure instanceof _packages2.default.shape.node.Node) {
        if (figure.isVisible() === true && figure.hitTest(x, y, _this.sumDiameter) === true) {
          figure.getPorts().each(function (i, p) {
            if (p.isVisible() === false) {
              p.__origAlpha = figure.getAlpha();
            }
            var dist = figure.getBoundingBox().getDistance(new _packages2.default.geo.Point(x, y));
            var alpha = 1 - 100 / (_this.diameterToBeVisible - _this.diameterToBeFullVisible) * dist / 100.0;
            p.setAlpha(alpha);
          });
        } else {
          figure.getPorts().each(function (i, p) {
            p.setAlpha(0.0);
          });
        }
      }
    });
  }

});

/***/ }),

/***/ "./src/policy/canvas/DecorationPolicy.js":
/*!***********************************************!*\
  !*** ./src/policy/canvas/DecorationPolicy.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * The base class for any canvas decoration like grid, chessboard, graph paper or
 * other.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
_packages2.default.policy.canvas.DecorationPolicy = _packages2.default.policy.canvas.CanvasPolicy.extend(
/** @lends draw2d.policy.canvas.DecorationPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.DecorationPolicy",

  /**
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  }

});

/***/ }),

/***/ "./src/policy/canvas/DefaultKeyboardPolicy.js":
/*!****************************************************!*\
  !*** ./src/policy/canvas/DefaultKeyboardPolicy.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Standard keyboard policy. This is the standard installed keyboard policy.
 * <br>
 * <br>
 * Keyboard commands
 * <ul>
 *    <li>DEL    - delete selection</li>
 * </ul>
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.KeyboardPolicy
 */
_packages2.default.policy.canvas.DefaultKeyboardPolicy = _packages2.default.policy.canvas.KeyboardPolicy.extend(
/** @lends draw2d.policy.canvas.DefaultKeyboardPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.DefaultKeyboardPolicy",

  /**
   */
  init: function init() {
    this._super();
  },

  /**
   * 
   * Callback if the user press a key.<br>
   * This implementation checks only if the <b>DEL</b> has been pressed and creates an
   * CommandDelete if this happens.
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {Number} keyCode the pressed key
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onKeyDown: function onKeyDown(canvas, keyCode, shiftKey, ctrlKey) {
    //
    if (keyCode === 46 && canvas.getPrimarySelection() !== null) {
      // create a single undo/redo transaction if the user delete more than one element. 
      // This happens with command stack transactions.
      //
      canvas.getCommandStack().startTransaction(_packages2.default.Configuration.i18n.command.deleteShape);
      var selection = canvas.getSelection();
      selection.each(function (index, figure) {
        // don't delete a connection if the source or target figure is part of the selection.
        // In this case the connection is deleted by the DeleteCommand itself and it is not allowed to
        // delete a figure twice.
        //
        if (figure instanceof _packages2.default.Connection) {
          if (selection.contains(figure.getSource(), true)) {
            return;
          }
          if (selection.contains(figure.getTarget(), true)) {
            return;
          }
        }
        var cmd = figure.createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.DELETE));
        if (cmd !== null) {
          canvas.getCommandStack().execute(cmd);
        }
      });
      // execute all single commands at once.
      canvas.getCommandStack().commitTransaction();
    } else {
      this._super(canvas, keyCode, shiftKey, ctrlKey);
    }
  }
});

/***/ }),

/***/ "./src/policy/canvas/DropInterceptorPolicy.js":
/*!****************************************************!*\
  !*** ./src/policy/canvas/DropInterceptorPolicy.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Drop interceptors are basically event handlers from which you can return a value
 * that tells draw2d to abort what it is that it was doing.<br>
 * <br>
 * Interceptors can be registered via the registerEditPolicy method on the draw2d canvas just like any other
 * edit policies.<br>
 * <br>
 * The <b>delegateTarget</b> method is responsible for all drop event especially to all connection and port handling.
 *
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 * @since 5.0.0
 */
_packages2.default.policy.canvas.DropInterceptorPolicy = _packages2.default.policy.canvas.CanvasPolicy.extend(
/** @lends draw2d.policy.canvas.DropInterceptorPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.DropInterceptorPolicy",

  /**
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Called if the user want connect a port with any kind draw2d.Figure.<br>
   * Return a non <b>null</b> value if the interceptor accept the connect event.<br>
   * <br>
   * It is possible to delegate the drop event to another figure if the policy
   * returns another figure. This is useful if a figure want to accept a port
   * drop event and delegates this drop event to another port.<br>
   *
   *
   * @param {draw2d.Figure} connectInquirer the figure who wants connect
   * @param {draw2d.Figure} connectIntent the potential connect target
   *
   * @returns {draw2d.Figure} the calculated connect intent or <b>null</b> if the interceptor uses the veto right
   */
  delegateTarget: function delegateTarget(connectInquirer, connectIntent) {
    // a composite accept any kind of figures exceptional ports
    //
    if (!(connectInquirer instanceof _packages2.default.Port) && connectIntent instanceof _packages2.default.shape.composite.StrongComposite) {
      return connectIntent;
    }

    // Ports accepts only Ports from the same semanticGroup as DropTarget
    //
    if (connectIntent instanceof _packages2.default.Port && connectInquirer instanceof _packages2.default.Port) {
      if (connectIntent.getSemanticGroup() !== connectInquirer.getSemanticGroup()) {
        return null;
      }
    }

    // Ports accepts only Ports as DropTarget
    //
    if (!(connectIntent instanceof _packages2.default.Port) || !(connectInquirer instanceof _packages2.default.Port)) {
      return null;
    }

    // consider the max possible connections for this port
    //
    if (connectIntent.getConnections().getSize() >= connectIntent.getMaxFanOut()) {
      return null;
    }

    // It is not allowed to connect two output ports
    if (connectInquirer instanceof _packages2.default.OutputPort && connectIntent instanceof _packages2.default.OutputPort) {
      return null;
    }

    // It is not allowed to connect two input ports
    if (connectInquirer instanceof _packages2.default.InputPort && connectIntent instanceof _packages2.default.InputPort) {
      return null;
    }

    // It is not possible to create a loop back connection at the moment.
    // Reason: no connection router implemented for this case
    if (connectInquirer instanceof _packages2.default.Port && connectIntent instanceof _packages2.default.Port) {
      if (connectInquirer.getParent() === connectIntent.getParent()) {
        return null;
      }
    }

    // redirect the dragEnter handling to the hybrid port
    //
    if (connectInquirer instanceof _packages2.default.Port && connectIntent instanceof _packages2.default.shape.node.Hub) {
      return connectIntent.getHybridPort(0);
    }

    // return the connectTarget determined by the framework or delegate it to another
    // figure.
    return connectIntent;
  }

});

/***/ }),

/***/ "./src/policy/canvas/ExtendedKeyboardPolicy.js":
/*!*****************************************************!*\
  !*** ./src/policy/canvas/ExtendedKeyboardPolicy.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Extended keyboard policy to <b>delete</b> and <b>group</b> figures in the canvas.
 * <br>
 * Keyboard commands
 * <ul>
 *    <li>DEL    - delete selection</li>
 *    <li>Ctrl+G - group/ungroup selection</li>
 *    <li>Ctrl+B - send current selection in the background (toBack)</li>
 *    <li>Ctrl+F - send current selection in the foreground (toFront)</li>
 * </ul>
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.KeyboardPolicy
 */
_packages2.default.policy.canvas.ExtendedKeyboardPolicy = _packages2.default.policy.canvas.KeyboardPolicy.extend(
/** @lends draw2d.policy.canvas.ExtendedKeyboardPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.ExtendedKeyboardPolicy",

  /**
   */
  init: function init() {
    this._super();
  },

  /**
   * 
   * Callback if the user press a key
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {Number} keyCode the pressed key
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onKeyDown: function onKeyDown(canvas, keyCode, shiftKey, ctrlKey) {
    if (canvas.getPrimarySelection() !== null && ctrlKey === true) {
      switch (keyCode) {

        case 71:
          // G
          if (canvas.getPrimarySelection() instanceof _packages2.default.shape.composite.Group && canvas.getSelection().getSize() === 1) {
            canvas.getCommandStack().execute(new _packages2.default.command.CommandUngroup(canvas, canvas.getPrimarySelection()));
          } else {
            canvas.getCommandStack().execute(new _packages2.default.command.CommandGroup(canvas, canvas.getSelection()));
          }
          break;
        case 66:
          // B
          canvas.getPrimarySelection().toBack();
          break;
        case 70:
          // F
          canvas.getPrimarySelection().toFront();
      }
    } else {
      this._super(canvas, keyCode, shiftKey, ctrlKey);
    }
  }

});

/***/ }),

/***/ "./src/policy/canvas/FadeoutDecorationPolicy.js":
/*!******************************************************!*\
  !*** ./src/policy/canvas/FadeoutDecorationPolicy.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Install this edit policy in a canvas if you want fadeout all decorations like ports, resize handles
 * if the user didn't move the mouse. This is good for a clean representation of your diagram.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.DecorationPolicy
 */
_packages2.default.policy.canvas.FadeoutDecorationPolicy = _packages2.default.policy.canvas.DecorationPolicy.extend(
/** @lends draw2d.policy.canvas.FadeoutDecorationPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.FadeoutDecorationPolicy",

  DEFAULT_FADEOUT_DURATION: 60,
  DEFAULT_ALPHA_DECREMENT: 0.05,

  /**
   * Creates a new fade out policy. Don't forget to install them into the canvas.
   *
   */
  init: function init() {
    this._super();
    this.alpha = 1.0;
    this.alphaDec = this.DEFAULT_ALPHA_DECREMENT;
    this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
    this.portDragging = false;
  },

  /**
   * @inheritDoc
   **/
  onInstall: function onInstall(canvas) {
    this._super(canvas);
    this.timerId = window.setInterval(this.onTimer.bind(this), 50);

    // initial hide all decorations after install of this policy
    //
    this.hidePortsCounter = 1;
    this.alpha = 0.1;
  },

  /**
   * @inheritDoc
   **/
  onUninstall: function onUninstall(canvas) {
    window.clearInterval(this.timerId);
    this.canvas.getAllPorts().each(function (i, port) {
      port.setAlpha(1.0);
    });

    this._super(canvas);
  },

  /**
   *
   *
   * Timerfucntion to show/hide the related ports
   * @private
   **/
  onTimer: function onTimer() {
    this.hidePortsCounter--;
    var _this = this;
    if (this.hidePortsCounter <= 0 && this.alpha > 0) {
      this.alpha = Math.max(0, this.alpha - this.alphaDec);

      this.canvas.getAllPorts().each(function (i, port) {
        port.setAlpha(_this.alpha);
      });

      this.canvas.getSelection().getAll().each(function (i, figure) {
        figure.selectionHandles.each(function (i, handle) {
          handle.setAlpha(_this.alpha);
        });
      });
    } else if (this.hidePortsCounter > 0 && this.alpha !== 1.0) {
      this.alpha = 1; // Math.min(1,this.alpha+0.1);
      this.alphaDec = this.DEFAULT_ALPHA_DECREMENT;
      this.duringHide = false;
      this.canvas.getAllPorts().each(function (i, port) {
        port.setAlpha(_this.alpha);
      });
      this.canvas.getSelection().getAll().each(function (i, figure) {
        figure.selectionHandles.each(function (i, handle) {
          handle.setAlpha(_this.alpha);
        });
      });
    }
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
    this.portDragging = canvas.getBestFigure(x, y) instanceof _packages2.default.Port;
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseMove: function onMouseMove(canvas, x, y, shiftKey, ctrlKey) {
    this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
    this.portDragging = false;
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    if (this.portDragging === false) {
      this.hidePortsCounter = 0;
      this.alphaDec = 0.1;
      this.onTimer();
    }
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseUp: function onMouseUp(figure, x, y, shiftKey, ctrlKey) {
    this.hidePortsCounter = this.DEFAULT_FADEOUT_DURATION;
    this.portDragging = false;
  }

});

/***/ }),

/***/ "./src/policy/canvas/GhostMoveSelectionPolicy.js":
/*!*******************************************************!*\
  !*** ./src/policy/canvas/GhostMoveSelectionPolicy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A drag&Drop feedback handler for the canvas. The policy didn't move the
 * shapes in real time rather it shows a ghost rectangle as feedback. <br>
 * <br>
 * The shapes are updated after the drag&drop operation.
 *
 *
 *
 * @example
 *
 *      // install the policy to the canvas
 *      canvas.installEditPolicy(new draw2d.policy.canvas.GhostMoveSelectionPolicy());
 *
 *      // add some demo figure to the canvas
 *      canvas.add(new draw2d.shape.basic.Circle({diameter: 50, x: 10,  y: 30}));
 *      canvas.add(new draw2d.shape.basic.Circle({diameter: 30, x: 90,  y: 50}));
 *      canvas.add(new draw2d.shape.basic.Circle({diameter: 60, x: 110, y: 30}));
 *
 *      canvas.add(new draw2d.shape.basic.Label({text:"move the circle to see the drag&drop feedback"}),5,5);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SingleSelectionPolicy
 */
_packages2.default.policy.canvas.GhostMoveSelectionPolicy = _packages2.default.policy.canvas.SingleSelectionPolicy.extend(
/** @lends draw2d.policy.canvas.GhostMoveSelectionPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.GhostMoveSelectionPolicy",

  /**
   */
  init: function init() {
    this.clone = null;
    this.ghostRectangle1 = null;
    this.ghostRectangle2 = null;

    this._super();
  },

  /**
   * @inheritdoc
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    this.mouseMovedDuringMouseDown = true;
    if (this.mouseDraggingElement !== null) {

      // if the figure not part of the selection it must be a ResizeHandle...
      var sel = canvas.getSelection().getAll();
      if (!sel.contains(this.mouseDraggingElement)) {
        this.mouseDraggingElement.onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey);
      }
      // it is a normal draw2d.Figure
      else {
          // create the ghost handles for the figure to move and update the position
          //
          if (this.ghostRectangle1 === null) {
            this.ghostRectangle1 = new _packages2.default.shape.basic.Rectangle(); // new API with version 5.0.0
            // old API
            this.ghostRectangle1.setBackgroundColor("#303030");
            this.ghostRectangle1.setAlpha(0.1);

            this.ghostRectangle2 = new _packages2.default.shape.basic.Rectangle();
            this.ghostRectangle2.setDashArray("- ");
            this.ghostRectangle2.setStroke(1);
            this.ghostRectangle2.setColor("#5497DC");
            this.ghostRectangle2.setBackgroundColor(null);

            this.ghostRectangle1.setBoundingBox(this.mouseDraggingElement.getBoundingBox());
            this.ghostRectangle2.setBoundingBox(this.mouseDraggingElement.getBoundingBox());

            this.ghostRectangle1.setCanvas(canvas);
            this.ghostRectangle1.toFront();

            this.ghostRectangle2.setCanvas(canvas);
            this.ghostRectangle2.toFront();

            this.clone = this.mouseDraggingElement.clone();
            if (this.clone instanceof _packages2.default.shape.node.Node) {
              this.clone.resetPorts();
            }
            this.clone.setCanvas(canvas);
            this.clone.getShapeElement();
            this.clone.setAlpha(0.4);
            this.clone.repaint();
          } else {
            this.ghostRectangle1.translate(dx2, dy2);
            this.ghostRectangle2.translate(dx2, dy2);
            this.clone.translate(dx2, dy2);
          }

          sel.each(function (i, figure) {
            // store the new location in a tmp var.
            figure._newPos = new _packages2.default.geo.Point(figure.ox + dx, figure.oy + dy);

            // don't move the figure. This will be done in the MouseUp event
            //figure.onDrag(dx, dy, dx2, dy2);
          });
        }

      var p = canvas.fromDocumentToCanvasCoordinate(canvas.mouseDownX + dx / canvas.zoomFactor, canvas.mouseDownY + dy / canvas.zoomFactor);
      var target = canvas.getBestFigure(p.x, p.y, this.mouseDraggingElement);

      if (target !== canvas.currentDropTarget) {
        if (canvas.currentDropTarget !== null) {
          canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
          canvas.currentDropTarget.fireEvent("dragLeave", { draggingElement: this.draggingElement });
          canvas.currentDropTarget = null;
        }
        if (target !== null) {
          canvas.currentDropTarget = target.delegateTarget(this.mouseDraggingElement);
          // inform all listener that the element has accept a dropEnter event
          if (canvas.currentDropTarget !== null) {
            canvas.currentDropTarget.onDragEnter(this.mouseDraggingElement); // legacy
            canvas.currentDropTarget.fireEvent("dragEnter", { draggingElement: this.draggingElement });
          }
        }
      }
    }
    // Connection didn't support panning at the moment. There is no special reason for that. Just an interaction
    // decision.
    //
    else if (this.mouseDownElement !== null && !(this.mouseDownElement instanceof _packages2.default.Connection)) {
        if (this.mouseDownElement.panningDelegate !== null) {
          this.mouseDownElement.panningDelegate.fireEvent("panning", {
            dx: dx,
            dy: dy,
            dx2: dx2,
            dy2: dy2,
            shiftKey: shiftKey,
            ctrlKey: ctrlKey
          });
          this.mouseDownElement.panningDelegate.onPanning(dx, dy, dx2, dy2, shiftKey, ctrlKey);
        } else {
          this.mouseDownElement.fireEvent("panning", {
            dx: dx,
            dy: dy,
            dx2: dx2,
            dy2: dy2,
            shiftKey: shiftKey,
            ctrlKey: ctrlKey
          });
          this.mouseDownElement.onPanning(dx, dy, dx2, dy2, shiftKey, ctrlKey);
        }
      }
  },

  /**
   * @inheritdoc
   */
  onMouseUp: function onMouseUp(canvas, x, y, shiftKey, ctrlKey) {

    if (this.ghostRectangle1 !== null) {
      this.ghostRectangle1.setCanvas(null);
      this.ghostRectangle1 = null;
      this.ghostRectangle2.setCanvas(null);
      this.ghostRectangle2 = null;
      this.clone.setCanvas(null);
      this.clone = null;
    }

    if (this.mouseDraggingElement !== null) {
      var redrawConnection = new _packages2.default.util.ArrayList();
      if (this.mouseDraggingElement instanceof _packages2.default.shape.node.Node) {
        canvas.lineIntersections.each(function (i, inter) {
          if (!redrawConnection.contains(inter.line)) redrawConnection.add(inter.line);
          if (!redrawConnection.contains(inter.other)) redrawConnection.add(inter.other);
        });
      }

      // start CommandStack transaction
      // Trigger an update of the connections if we have move a draw2d.shape.node.Node figure.
      // (only "nodes" can have ports and connections)
      //
      canvas.getCommandStack().startTransaction();

      var sel = canvas.getSelection().getAll();
      // We move a resize handle...
      //
      if (!sel.contains(this.mouseDraggingElement)) {
        this.mouseDraggingElement.onDragEnd(x, y, shiftKey, ctrlKey);
      }
      // ... or a real figure.
      //
      else {
          canvas.getSelection().getAll().each(function (i, figure) {
            // set position and cleanup tmp variable
            if (figure._newPos) {
              figure.setPosition(figure._newPos);
              delete figure._newPos;
            }
            // done
            figure.onDragEnd(x, y, shiftKey, ctrlKey);
          });
        }

      // May we drop the figure onto another shape..handle this here
      //
      if (canvas.currentDropTarget !== null && !this.mouseDraggingElement.isResizeHandle) {
        this.mouseDraggingElement.onDrop(canvas.currentDropTarget, x, y, shiftKey, ctrlKey);
        canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
        canvas.currentDropTarget.onCatch(this.mouseDraggingElement, x, y, shiftKey, ctrlKey);
        canvas.currentDropTarget = null;
      }

      // end command stack trans
      canvas.getCommandStack().commitTransaction();

      if (this.mouseDraggingElement instanceof _packages2.default.shape.node.Node) {
        canvas.lineIntersections.each(function (i, inter) {
          if (!redrawConnection.contains(inter.line)) redrawConnection.add(inter.line);
          if (!redrawConnection.contains(inter.other)) redrawConnection.add(inter.other);
        });
        redrawConnection.each(function (i, line) {
          line.svgPathString = null;
          line.repaint();
        });
      }

      this.mouseDraggingElement = null;
    }

    // Reset the current selection if the user click in the blank canvas.
    // Don't reset the selection if the user is panning the canvas
    //
    if (this.mouseDownElement === null && this.mouseMovedDuringMouseDown === false) {
      this.select(canvas, null);
    }

    this.mouseDownElement = null;
    this.mouseMovedDuringMouseDown = false;
  }
});

/***/ }),

/***/ "./src/policy/canvas/KeyboardPolicy.js":
/*!*********************************************!*\
  !*** ./src/policy/canvas/KeyboardPolicy.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Default interface for keyboard interaction with the canvas.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
_packages2.default.policy.canvas.KeyboardPolicy = _packages2.default.policy.canvas.CanvasPolicy.extend(
/** @lends draw2d.policy.canvas.KeyboardPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.KeyboardPolicy",

  /**
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Callback if the user release a key
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {Number} keyCode the pressed key
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onKeyUp: function onKeyUp(canvas, keyCode, shiftKey, ctrlKey) {
    // do nothing per default
  },

  /**
   * 
   * Callback if the user press a key down
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {Number} keyCode the pressed key
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onKeyDown: function onKeyDown(canvas, keyCode, shiftKey, ctrlKey) {
    // do nothing per default
  }

});

/***/ }),

/***/ "./src/policy/canvas/PanningSelectionPolicy.js":
/*!*****************************************************!*\
  !*** ./src/policy/canvas/PanningSelectionPolicy.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SingleSelectionPolicy
 */
_packages2.default.policy.canvas.PanningSelectionPolicy = _packages2.default.policy.canvas.SingleSelectionPolicy.extend(
/** @lends draw2d.policy.canvas.PanningSelectionPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.PanningSelectionPolicy",

  /**
   * Creates a new Router object
   */
  init: function init() {
    this._super();
  },

  /**
   * 
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    this._super(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey);

    if (this.mouseDraggingElement === null && this.mouseDownElement === null) {

      // check if we are dragging a port. This isn't reported by the selection handler anymore
      //
      var p = canvas.fromDocumentToCanvasCoordinate(canvas.mouseDownX + dx / canvas.zoomFactor, canvas.mouseDownY + dy / canvas.zoomFactor);
      var figure = canvas.getBestFigure(p.x, p.y);

      if (figure === null) {
        var area = canvas.getScrollArea();
        area.scrollTop(area.scrollTop() - dy2);
        area.scrollLeft(area.scrollLeft() - dx2);
      }
    }
  }
});

/***/ }),

/***/ "./src/policy/canvas/ReadOnlySelectionPolicy.js":
/*!******************************************************!*\
  !*** ./src/policy/canvas/ReadOnlySelectionPolicy.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SelectionPolicy
 */
_packages2.default.policy.canvas.ReadOnlySelectionPolicy = _packages2.default.policy.canvas.SelectionPolicy.extend(
/** @lends draw2d.policy.canvas.ReadOnlySelectionPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.ReadOnlySelectionPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Called by the host if the policy has been installed.
   *
   * @param {draw2d.Canvas/draw2d.Canvas} canvas
   */
  onInstall: function onInstall(canvas) {
    this._super(canvas);
    canvas.getAllPorts().each(function (i, port) {
      port.setVisible(false);
    });
  },

  /**
   * 
   * Called by the host if the policy has been uninstalled.
   *
   * @param {draw2d.Canvas} canvas
   */
  onUninstall: function onUninstall(canvas) {
    canvas.getAllPorts().each(function (i, port) {
      port.setVisible(true);
    });

    this._super(canvas);
  },

  /**
   * 
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    var area = canvas.getScrollArea();
    area.scrollTop(area.scrollTop() - dy2);
    area.scrollLeft(area.scrollLeft() - dx2);
  }
});

/***/ }),

/***/ "./src/policy/canvas/SelectionPolicy.js":
/*!**********************************************!*\
  !*** ./src/policy/canvas/SelectionPolicy.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
_packages2.default.policy.canvas.SelectionPolicy = _packages2.default.policy.canvas.CanvasPolicy.extend(
/** @lends draw2d.policy.canvas.SelectionPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SelectionPolicy",

  /**
   * Creates a new selection policy
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Selects the given figure within the canvas. The policy must unselect already selected
   * figures or show any decorations.
   *
   * @param {draw2d.Canvas} canvas
   * @param {draw2d.Figure} figure
   *
   */
  select: function select(canvas, figure) {},

  /**
   *
   * Unselect the given figure in the canvas and remove all resize handles
   *
   * @param {draw2d.Canvas} canvas
   * @param {draw2d.Figure} figure
   */
  unselect: function unselect(canvas, figure) {
    canvas.getSelection().remove(figure);

    figure.unselect();

    // @since 6.1.42
    canvas.fireEvent("unselect", { figure: figure });
  }
});

/***/ }),

/***/ "./src/policy/canvas/ShowChessboardEditPolicy.js":
/*!*******************************************************!*\
  !*** ./src/policy/canvas/ShowChessboardEditPolicy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Just to paint a grid in the background of a canvas.
 *
 *
 * @example
 *
 *    canvas.installEditPolicy(new draw2d.policy.canvas.ShowChessboardEditPolicy());
 *    let shape =  new draw2d.shape.basic.Text({text:"This is a simple text in a canvas with chessboard background."});
 *
 *    canvas.add(shape,40,10);
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.DecorationPolicy
 */
_packages2.default.policy.canvas.ShowChessboardEditPolicy = _packages2.default.policy.canvas.DecorationPolicy.extend(
/** @lends draw2d.policy.canvas.ShowChessboardEditPolicy.prototype */
{
  NAME: "draw2d.policy.canvas.ShowChessboardEditPolicy",

  GRID_COLOR: "#e0e0e0",
  GRID_WIDTH: 20,

  /**
   * Creates a new constraint policy for snap to grid
   *
   * @param {Number} grid the grid width of the canvas
   */
  init: function init(grid) {
    this._super();
    if (grid) {
      this.grid = grid;
    } else {
      this.grid = this.GRID_WIDTH;
    }
  },

  onInstall: function onInstall(canvas) {
    var _this = this;

    this._super(canvas);

    this.oldBg = this.canvas.html.css("background");
    this.setGrid(1 / canvas.getZoom());
    this.onZoomCallback = function (emitterFigure, zoomData) {
      _this.setGrid(1 / zoomData.value);
    };
    canvas.on("zoom", this.onZoomCallback);
  },

  onUninstall: function onUninstall(canvas) {
    this._super(canvas);
    $(canvas.paper.canvas).css({ "background": this.oldBg });
    canvas.off(this.onZoomCallback);
  },

  /**
   * Activate the grid and set the CSS properties for the SVG canvas
   * @private
   */
  setGrid: function setGrid(zoom) {

    var gridColor = this.GRID_COLOR;

    var background = "linear-gradient(45deg, " + gridColor + " 25%, transparent 25%, transparent 75%, " + gridColor + " 75%, " + gridColor + " 100%),\n" + ("linear-gradient(45deg, " + gridColor + " 25%, transparent 25%, transparent 75%, " + gridColor + " 75%, " + gridColor + " 100%)");
    var backgroundSize = this.grid * 2 * zoom + "px " + this.grid * 2 * zoom + "px";
    var backgroundPosition = "0 0, " + this.grid * zoom + "px " + this.grid * zoom + "px";

    $(this.canvas.paper.canvas).css({
      "background": background,
      "background-size": backgroundSize,
      "background-position": backgroundPosition
    });
  }
});

/***/ }),

/***/ "./src/policy/canvas/ShowDimetricGridEditPolicy.js":
/*!*********************************************************!*\
  !*** ./src/policy/canvas/ShowDimetricGridEditPolicy.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A canvas decoration which paints a dimetric in the background.
 * <br>
 * <br>
 *
 * @example
 *
 *    canvas.installEditPolicy(new draw2d.policy.canvas.ShowDimetricGridEditPolicy());
 *    let shape =  new draw2d.shape.basic.Text({text:"This is a simple text in a canvas with grid background."});
 *
 *    canvas.add(shape,40,10);
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.DecorationPolicy
 */
_packages2.default.policy.canvas.ShowDimetricGridEditPolicy = _packages2.default.policy.canvas.DecorationPolicy.extend(
/** @lends draw2d.policy.canvas.ShowDimetricGridEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.ShowDimetricGridEditPolicy",

  GRID_COLOR: "#f0f0f0",
  GRID_WIDTH: 30,

  /**
   * Creates a new constraint policy for snap to grid
   *
   * @param {Number} [grid] the grid width of the canvas
   */
  init: function init(grid) {
    this.color = new _packages2.default.util.Color(this.GRID_COLOR);
    this.zoom = 1;
    this.shapes = null;

    this._super();

    if (typeof grid === "number") {
      this.grid = grid;
    } else {
      this.grid = this.GRID_WIDTH;
    }
  },

  onInstall: function onInstall(canvas) {
    this._super(canvas);
    this.zoom = canvas.getZoom();
    this.setGrid(this.grid);
  },

  onUninstall: function onUninstall(canvas) {
    this._super(canvas);
    if (this.shapes !== null) {
      this.shapes.remove();
    }
  },

  /**
   * 
   * Set the grid color
   *
   * @param {draw2d.util.Color|String} color a color object or the CSS string declaration for a color
   * @since 5.0.3
   */
  setGridColor: function setGridColor(color) {
    this.color = new _packages2.default.util.Color(color);
    this.setGrid(this.grid);
  },

  /**
   * 
   * Set a new grid width/height
   *
   * @param {Number} grid
   * @since 5.0.3
   */
  setGrid: function setGrid(grid) {
    this.grid = grid;

    if (this.canvas != null) {
      if (this.shapes !== null) {
        this.shapes.remove();
      }

      var r = this.canvas.paper;
      var d = this.grid,
          i = void 0;
      var w = r.width;
      var h = r.height;
      var props = { stroke: this.color.rgba() };

      var max = Math.sqrt(w * w + h * h);
      var angle26 = Math.atan(.5);
      var angle153 = Math.PI - angle26;
      var cos30 = Math.cos(angle26);
      var sin30 = Math.sin(angle26);
      var cos150 = Math.cos(angle153);
      var sin150 = Math.sin(angle153);

      r.setStart();
      // horizontal
      for (i = 0; i <= w; i += d * 2) {
        r.path([["M", i, 0], ["L", i + cos30 * max, sin30 * max]]).attr(props);
        r.path([["M", i, 0], ["L", i + cos150 * max, sin150 * max]]).attr(props);
      }
      for (i = d; i <= h; i += d) {
        r.path([["M", 0, i], ["L", cos30 * max, i + sin30 * max]]).attr(props);
        r.path([["M", w, i], ["L", w + cos150 * max, i + sin150 * max]]).attr(props);
      }
      // vertical
      this.shapes = r.setFinish();

      this.shapes.toBack();
    }
  }

});

/***/ }),

/***/ "./src/policy/canvas/ShowDotEditPolicy.js":
/*!************************************************!*\
  !*** ./src/policy/canvas/ShowDotEditPolicy.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Paint a dotted pattern in the background of the canvas.
 *
 *
 * @example
 *
 *    canvas.installEditPolicy(new draw2d.policy.canvas.ShowDotEditPolicy());
 *    let shape =  new draw2d.shape.basic.Text({text:"This is a simple text in a canvas with dotted background."});
 *
 *    canvas.add(shape,40,10);
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.DecorationPolicy
 * @since 4.0.1
 */

_packages2.default.policy.canvas.ShowDotEditPolicy = _packages2.default.policy.canvas.DecorationPolicy.extend(
/** @lends draw2d.policy.canvas.ShowDotEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.ShowDotEditPolicy",

  DOT_COLOR: "#999999",
  DOT_RADIUS: 1,
  DOT_DISTANCE: 20,

  /**
   * show a dot grid in the canvas for decoration.
   *
   * @param {Number} [dotDistance] the distance or grid width between the dots.
   * @param {Number} [dotRadius] the radius of the dots.
   * @param {draw2d.util.Color|String} [dotColor] the color for the dots.
   */
  init: function init(dotDistance, dotRadius, dotColor) {
    var _this = this;

    this._super();

    this.dotDistance = dotDistance ? dotDistance : this.DOT_DISTANCE;
    this.dotRadius = dotRadius ? dotRadius : this.DOT_RADIUS;
    this.dotColor = new _packages2.default.util.Color(dotColor ? dotColor : this.DOT_COLOR);
    this.onZoomCallback = function (emitterFigure, zoomData) {
      _this.setGrid(1 / zoomData.value);
    };
  },

  onInstall: function onInstall(canvas) {
    this._super(canvas);

    this.oldBg = this.canvas.html.css("background");
    this.setGrid(1 / canvas.getZoom());
    canvas.on("zoom", this.onZoomCallback);
  },

  onUninstall: function onUninstall(canvas) {
    this._super(canvas);
    $(canvas.paper.canvas).css({ "background": this.oldBg });
    canvas.off(this.onZoomCallback);
  },

  /**
   * @private
   * @param {Number} zoom 
   */
  setGrid: function setGrid(zoom) {
    var bgColor = "#FFFFFF";
    var dotColor = this.dotColor.rgba();

    var background = "linear-gradient(90deg, " + bgColor + " " + (this.dotDistance - this.dotRadius) * zoom + "px, transparent 1%) center, linear-gradient(" + bgColor + " " + (this.dotDistance - this.dotRadius) * zoom + "px, transparent 1%) center, " + dotColor;
    var backgroundSize = this.dotDistance * zoom + "px " + this.dotDistance * zoom + "px";

    $(this.canvas.paper.canvas).css({
      "background": background,
      "background-size": backgroundSize
    });
  }
});

/***/ }),

/***/ "./src/policy/canvas/ShowGridEditPolicy.js":
/*!*************************************************!*\
  !*** ./src/policy/canvas/ShowGridEditPolicy.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A cavas decoration which paints a grid in the background.
 * <br>
 * <br>
 *
 * @example
 *
 *    canvas.installEditPolicy(new draw2d.policy.canvas.ShowGridEditPolicy());
 *    let shape =  new draw2d.shape.basic.Text({text:"This is a simple text in a canvas with grid background."});
 *
 *    canvas.add(shape,40,10);
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.DecorationPolicy
 */
_packages2.default.policy.canvas.ShowGridEditPolicy = _packages2.default.policy.canvas.DecorationPolicy.extend(
/** @lends draw2d.policy.canvas.ShowGridEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.ShowGridEditPolicy",

  GRID_COLOR: "#f0f0f0",
  GRID_WIDTH: 20,
  GRID_STOKE: 1,

  /**
   * Creates a new constraint policy for snap to grid
   *
   * @param {Number} [grid] the grid width of the canvas
   */
  init: function init(gridDistance, gridStroke, gridColor) {
    var _this = this;

    this.gridWidth = gridDistance || this.GRID_WIDTH;
    this.gridStroke = gridStroke || this.GRID_STOKE;
    this.gridColor = new _packages2.default.util.Color(gridColor || this.GRID_COLOR);
    this._super();
    this.onZoomCallback = function (emitterFigure, zoomData) {
      _this.setGrid(1 / zoomData.value);
    };
  },

  /**
   *
   * Set the grid color
   *
   * @param {draw2d.util.Color|String} color a color object or the CSS string declaration for a color
   * @since 5.0.3
   */
  setGridColor: function setGridColor(color) {
    this.gridColor = new _packages2.default.util.Color(color);
    this.setGrid(1 / this.canvas.getZoom());
  },

  onInstall: function onInstall(canvas) {
    this._super(canvas);

    this.oldBg = this.canvas.html.css("background");
    this.setGrid(1 / canvas.getZoom());
    canvas.on("zoom", this.onZoomCallback);
  },

  onUninstall: function onUninstall(canvas) {
    this._super(canvas);

    $(canvas.paper.canvas).css({ "background": this.oldBg });
    canvas.off(this.onZoomCallback);
  },

  /**
   * @private
   * @param {Number} zoom 
   */
  setGrid: function setGrid(zoom) {
    var bgColor = "#FFFFFF";
    var color = this.gridColor.rgba();

    var background = " linear-gradient(to right,  " + color + " " + this.gridStroke + "px, transparent " + this.gridStroke + "px),\n      linear-gradient(to bottom, " + color + " " + this.gridStroke + "px, " + bgColor + "  " + this.gridStroke + "px)";
    var backgroundSize = this.gridWidth * zoom + "px " + this.gridWidth * zoom + "px";

    $(this.canvas.paper.canvas).css({
      "background": background,
      "background-size": backgroundSize
    });
  }
});

/***/ }),

/***/ "./src/policy/canvas/SingleSelectionPolicy.js":
/*!****************************************************!*\
  !*** ./src/policy/canvas/SingleSelectionPolicy.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.SelectionPolicy
 */
_packages2.default.policy.canvas.SingleSelectionPolicy = _packages2.default.policy.canvas.SelectionPolicy.extend(
/** @lends draw2d.policy.canvas.SingleSelectionPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SingleSelectionPolicy",

  /**
   * Creates a new Router object
   */
  init: function init() {
    this._super();
    this.mouseMovedDuringMouseDown = false;
    this.mouseDraggingElement = null;
    this.mouseDownElement = null;
  },

  /**
   * @inheritdoc
   */
  select: function select(canvas, figure) {
    if (canvas.getSelection().contains(figure)) {
      return; // nothing to to
    }

    var oldSelection = canvas.getSelection().getPrimary();
    if (canvas.getSelection().getPrimary() !== null) {
      this.unselect(canvas, canvas.getSelection().getPrimary());
    }

    if (figure !== null) {
      figure.select(true); // primary selection
    }

    canvas.getSelection().setPrimary(figure);

    // inform all selection listeners about the new selection.
    //
    if (oldSelection !== figure) {
      canvas.fireEvent("select", { figure: figure, selection: canvas.getSelection() });
    }
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
    this.mouseMovedDuringMouseDown = false;
    var canDragStart = true;

    // ignore ports since version 6.1.0. This is handled by the ConnectionCreatePolicy
    //
    var figure = canvas.getBestFigure(x, y);

    // may the figure is assigned to a composite. In this case the composite can
    // override the event receiver
    while (figure !== null) {
      var delegate = figure.getSelectionAdapter()();
      if (delegate === figure) {
        break;
      }
      figure = delegate;
    }

    // ignore ports since version 6.1.0. This is handled by the ConnectionCreatePolicy
    //
    if (figure instanceof _packages2.default.Port) {
      return; // silently
    }

    if (figure !== null && figure.isDraggable()) {
      canDragStart = figure.onDragStart(x - figure.getAbsoluteX(), y - figure.getAbsoluteY(), shiftKey, ctrlKey);
      // Element send a veto about the drag&drop operation
      this.mouseDraggingElement = canDragStart === false ? null : figure;
    }

    this.mouseDownElement = figure;
    if (this.mouseDownElement !== null) {
      this.mouseDownElement.fireEvent("mousedown", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
    }

    if (figure !== canvas.getSelection().getPrimary() && figure !== null && figure.isSelectable() === true) {
      this.select(canvas, figure);

      // it's a line
      if (figure instanceof _packages2.default.shape.basic.Line) {
        // you can move a line with Drag&Drop...but not a connection.
        // A Connection is fixed linked with the corresponding ports.
        //
        if (!(figure instanceof _packages2.default.Connection)) {
          canvas.draggingLineCommand = figure.createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.MOVE));
          if (canvas.draggingLineCommand !== null) {
            canvas.draggingLine = figure;
          }
        }
      } else if (canDragStart === false) {
        figure.unselect();
      }
    }
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} dx The x diff between start of dragging and this event
   * @param {Number} dy The y diff between start of dragging and this event
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {

    this.mouseMovedDuringMouseDown = true;
    if (this.mouseDraggingElement !== null) {

      // mouseDraggingElement be a ResizeHandle...in this case it is not part of the selection
      //
      var sel = canvas.getSelection();
      if (!sel.contains(this.mouseDraggingElement)) {
        this.mouseDraggingElement.onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey);
      } else {
        sel.each(function (i, figure) {
          figure.onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey);
        });
      }

      var p = canvas.fromDocumentToCanvasCoordinate(canvas.mouseDownX + dx / canvas.zoomFactor, canvas.mouseDownY + dy / canvas.zoomFactor);
      var target = canvas.getBestFigure(p.x, p.y, this.mouseDraggingElement);

      if (target !== canvas.currentDropTarget) {
        if (canvas.currentDropTarget !== null) {
          canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
          canvas.currentDropTarget.fireEvent("dragLeave", { draggingElement: this.mouseDraggingElement });
          canvas.currentDropTarget = null;
        }
        if (target !== null) {
          canvas.currentDropTarget = target.delegateTarget(this.mouseDraggingElement);
          // inform all listener that the element has accept the dragEnter event
          //
          if (canvas.currentDropTarget !== null) {
            canvas.currentDropTarget.onDragEnter(this.mouseDraggingElement); // legacy
            canvas.currentDropTarget.fireEvent("dragEnter", { draggingElement: this.mouseDraggingElement });
          }
        }
      }
    }
    // Connection didn't support panning at the moment. There is no special reason for that. Just an interaction
    // decision.
    //
    else if (this.mouseDownElement !== null && !(this.mouseDownElement instanceof _packages2.default.Connection)) {
        if (this.mouseDownElement.panningDelegate !== null) {
          this.mouseDownElement.panningDelegate.fireEvent("panning", {
            dx: dx,
            dy: dy,
            dx2: dx2,
            dy2: dy2,
            shiftKey: shiftKey,
            ctrlKey: ctrlKey
          });
          this.mouseDownElement.panningDelegate.onPanning(dx, dy, dx2, dy2, shiftKey, ctrlKey);
        } else {
          this.mouseDownElement.fireEvent("panning", {
            dx: dx,
            dy: dy,
            dx2: dx2,
            dy2: dy2,
            shiftKey: shiftKey,
            ctrlKey: ctrlKey
          });
          this.mouseDownElement.onPanning(dx, dy, dx2, dy2, shiftKey, ctrlKey);
        }
      }
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas the related Canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseUp: function onMouseUp(canvas, x, y, shiftKey, ctrlKey) {
    if (this.mouseDraggingElement !== null) {
      var redrawConnection = new _packages2.default.util.ArrayList();
      if (this.mouseDraggingElement instanceof _packages2.default.shape.node.Node) {
        // TODO: don't add the connections with to check if a repaint is required
        //       may a moved connection didn't have an intersection with the named lines.
        //       in this case a redraw is useless
        canvas.lineIntersections.each(function (i, inter) {
          if (!redrawConnection.contains(inter.line)) redrawConnection.add(inter.line);
          if (!redrawConnection.contains(inter.other)) redrawConnection.add(inter.other);
        });
      }

      // start CommandStack transaction
      canvas.getCommandStack().startTransaction();

      var sel = canvas.getSelection().getAll();
      if (!sel.contains(this.mouseDraggingElement)) {
        this.mouseDraggingElement.onDragEnd(x, y, shiftKey, ctrlKey);
      } else {
        canvas.getSelection().getAll().each(function (i, figure) {
          figure.onDragEnd(x, y, shiftKey, ctrlKey);
        });
      }

      if (canvas.currentDropTarget !== null && !this.mouseDraggingElement.isResizeHandle) {
        this.mouseDraggingElement.onDrop(canvas.currentDropTarget, x, y, shiftKey, ctrlKey);
        canvas.currentDropTarget.onDragLeave(this.mouseDraggingElement);
        canvas.currentDropTarget.fireEvent("dragLeave", { draggingElement: this.mouseDraggingElement });
        canvas.currentDropTarget.onCatch(this.mouseDraggingElement, x, y, shiftKey, ctrlKey);
        canvas.currentDropTarget = null;
      }

      // end command stack trans
      canvas.getCommandStack().commitTransaction();

      if (this.mouseDraggingElement instanceof _packages2.default.shape.node.Node) {
        canvas.lineIntersections.each(function (i, inter) {
          if (!redrawConnection.contains(inter.line)) redrawConnection.add(inter.line);
          if (!redrawConnection.contains(inter.other)) redrawConnection.add(inter.other);
        });
        redrawConnection.each(function (i, line) {
          line.svgPathString = null;
          line.repaint();
        });
      }

      this.mouseDraggingElement = null;
    }
    // Connection didn't support panning at the moment. There is no special reason for that. Just an interaction
    // decision.
    //
    else if (this.mouseDownElement !== null && !(this.mouseDownElement instanceof _packages2.default.Connection)) {
        if (this.mouseDownElement.panningDelegate !== null) {
          this.mouseDownElement.panningDelegate.fireEvent("panningEnd");
          this.mouseDownElement.panningDelegate.onPanningEnd();
        } else {
          this.mouseDownElement.fireEvent("panningEnd");
          this.mouseDownElement.onPanningEnd();
        }
      }

    // Reset the current selection if the user click in the blank canvas.
    // Don't reset the selection if the user pan the canvas
    //
    if (this.mouseDownElement === null && this.mouseMovedDuringMouseDown === false) {
      this.select(canvas, null);
    }

    if (this.mouseDownElement !== null) {
      this.mouseDownElement.fireEvent("mouseup", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
    }

    this.mouseDownElement = null;
    this.mouseMovedDuringMouseDown = false;
  },

  /**
   *
   * Called by the canvas if the user click on a figure.
   *
   * @param {draw2d.Figure} figure the figure under the click event. Can be null
   * @param {Number} mouseX the x coordinate of the mouse during the click event
   * @param {Number} mouseY the y coordinate of the mouse during the click event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @since 3.0.0
   */
  onClick: function onClick(figure, mouseX, mouseY, shiftKey, ctrlKey) {
    if (figure !== null) {
      figure.fireEvent("click", {
        figure: figure,
        x: mouseX,
        y: mouseY,
        relX: mouseX - figure.getAbsoluteX(),
        relY: mouseY - figure.getAbsoluteY(),
        shiftKey: shiftKey,
        ctrlKey: ctrlKey
      });

      figure.onClick();
    }
  },

  /**
   *
   * Called by the canvas if the user double click on a figure.
   *
   * @param {draw2d.Figure} figure the figure under the double click event. Can be null
   * @param {Number} mouseX the x coordinate of the mouse during the click event
   * @param {Number} mouseY the y coordinate of the mouse during the click event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @since 4.1.0
   */
  onDoubleClick: function onDoubleClick(figure, mouseX, mouseY, shiftKey, ctrlKey) {
    if (figure !== null) {
      figure.fireEvent("dblclick", { x: mouseX, y: mouseY, shiftKey: shiftKey, ctrlKey: ctrlKey });
      figure.onDoubleClick();
    }
  }

});

/***/ }),

/***/ "./src/policy/canvas/SnapToCenterEditPolicy.js":
/*!*****************************************************!*\
  !*** ./src/policy/canvas/SnapToCenterEditPolicy.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Snapping is based on the existing children of a container. When snapping a shape,
 * the center of the bounding box will snap to the center of other figures of the given canvas.
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.SnapToEditPolicy
 * @since 5.6.4
 */
_packages2.default.policy.canvas.SnapToCenterEditPolicy = _packages2.default.policy.canvas.SnapToEditPolicy.extend(
/** @lends draw2d.policy.canvas.SnapToCenterEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SnapToCenterEditPolicy",

  SNAP_THRESHOLD: 5,
  FADEOUT_DURATION: 500,

  /**
   * Creates a new constraint policy for snap to geometry
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.centers = null;

    this.horizontalGuideLines = null;
    this.verticalGuideLines = null;
  },

  /**
   *
   *
   * @param {draw2d.Figure} figure the shape below the mouse or null
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseUp: function onMouseUp(figure, x, y, shiftKey, ctrlKey) {
    this.centers = null;
    this.hideHorizontalGuides(false);
    this.hideVerticalGuides(false);
  },

  /**
   *
   * Adjust the coordinates to the canvas neighbours
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Figure} figure the figure to snap
   * @param {draw2d.geo.Point} modifiedPos the already modified position of the figure (e.g. from an another Policy)
   * @param {draw2d.geo.Point} originalPos the original requested position of the figure
   *
   * @returns {draw2d.geo.Point} the constraint position of the figure
   */
  snap: function snap(canvas, figure, modifiedPos, originalPos) {
    // do nothing for resize handles
    if (figure instanceof _packages2.default.ResizeHandle) {
      return modifiedPos;
    }

    // do nothing for lines
    if (figure instanceof _packages2.default.shape.basic.Line) {
      return modifiedPos;
    }

    var allowXChanges = modifiedPos.x === originalPos.x;
    var allowYChanges = modifiedPos.y === originalPos.y;

    var inputBounds = new _packages2.default.geo.Rectangle(modifiedPos.x, modifiedPos.y, figure.getWidth(), figure.getHeight());
    var inputCenter = inputBounds.getCenter();

    modifiedPos = modifiedPos.clone();

    if (allowXChanges === true) {
      var horizontal = this.snapHorizontal(inputCenter);

      // Show a horizontal line if the snapper has modified the inputPoint
      //
      if (horizontal.snapped) {
        // show the snap lines..
        this.showHorizontalGuides(figure, horizontal);

        // and snap the x coordinate
        modifiedPos.y += horizontal.diff;
      } else {
        this.hideHorizontalGuides(true);
      }
    } else {
      this.hideHorizontalGuides(true);
    }

    if (allowYChanges === true) {
      var vertical = this.snapVertical(inputCenter);

      // Show a vertical guides if the snapper has modified the inputPoint
      //
      if (vertical.snapped) {
        // show the snap lines..
        this.showVerticalGuides(figure, vertical);

        // and snap the x coordinate
        modifiedPos.x += vertical.diff;
      } else {
        this.hideVerticalGuides(true);
      }
    } else {
      this.hideVerticalGuides(true);
    }

    return modifiedPos;
  },

  snapVertical: function snapVertical(center) {
    var _this = this;
    if (this.centers === null) {
      this.populateCenters();
    }

    var result = {
      point: center,
      snapped: false,
      diff: 0
    };

    var candidates = [];
    this.centers.forEach(function (point) {
      if (Math.abs(point.x - center.x) < _this.SNAP_THRESHOLD) {
        candidates.push(point);
      }
    });

    // we can abort if we didn't find an intersection on the right hand side
    if (candidates.length === 0) {
      return result;
    }

    // sort the intersection point and get the closest point to the tested inputPoint
    // In this case it is the point with the greatest X coordinate
    //
    candidates.sort(function (a, b) {
      return a.x - b.x;
    });

    var diff = candidates[0].x - center.x;
    var snappedPoint = center.clone();
    snappedPoint.x += diff;
    return { snapped: true, diff: diff, point: candidates[0], snappedPoint: snappedPoint };
  },

  snapHorizontal: function snapHorizontal(center) {
    var _this = this;
    if (this.centers === null) {
      this.populateCenters();
    }

    var result = {
      point: center,
      snapped: false,
      diff: 0
    };

    var candidates = [];
    this.centers.forEach(function (point) {
      if (Math.abs(point.y - center.y) < _this.SNAP_THRESHOLD) {
        candidates.push(point);
      }
    });

    // we can abort if we didn't find an intersection on the right hand side
    if (candidates.length === 0) {
      return result;
    }

    // sort the intersection point and get the closest point to the tested inputPoint
    // In this case it is the point with the greatest X coordinate
    //
    candidates.sort(function (a, b) {
      return a.y - b.y;
    });

    var diff = candidates[0].y - center.y;
    var snappedPoint = center.clone();
    snappedPoint.y += diff;
    return { snapped: true, diff: diff, point: candidates[0], snappedPoint: snappedPoint };
  },

  populateCenters: function populateCenters() {
    var selection = this.canvas.getSelection().getAll(true);
    var centers = this.centers = [];

    var figures = this.canvas.getFigures();
    figures.each(function (index, figure) {
      if (!selection.contains(figure)) {
        centers.push(figure.getBoundingBox().getCenter());
      }
    });
  },

  showHorizontalGuides: function showHorizontalGuides(causedFigure, constraint) {
    if (this.horizontalGuideLines !== null) {
      this.horizontalGuideLines.stop();
      this.horizontalGuideLines.remove();
    }

    var start = constraint.point;
    var end = constraint.snappedPoint;

    this.canvas.paper.setStart();

    // horizontal lines
    //
    this.canvas.paper.path("M " + start.x + " " + ((start.y | 0) + 0.5) + " L " + end.x + " " + ((end.y | 0) + 0.5)).attr({
      "stroke": this.lineColor.rgba(),
      "stroke-width": 1
    });

    this.horizontalGuideLines = this.canvas.paper.setFinish();
    this.horizontalGuideLines.toFront();
  },

  /**
   *
   * Hide the horizontal snapping guides
   *
   * @param {Boolean} fast
   */
  hideHorizontalGuides: function hideHorizontalGuides(fast) {
    var _this2 = this;

    if (this.horizontalGuideLines === null) {
      return;
    }
    if (fast === true) {
      if (this.horizontalGuideLines !== null) {
        this.horizontalGuideLines.remove();
        this.horizontalGuideLines = null;
      }
    } else {
      this.horizontalGuideLines.animate({ opacity: 0.1 }, this.FADEOUT_DURATION, function () {
        if (_this2.horizontalGuideLines !== null) {
          _this2.horizontalGuideLines.remove();
          _this2.horizontalGuideLines = null;
        }
      });
    }
  },

  showVerticalGuides: function showVerticalGuides(causedFigure, constraint) {
    if (this.verticalGuideLines !== null) {
      this.verticalGuideLines.stop();
      this.verticalGuideLines.remove();
    }

    var start = constraint.point;
    var end = constraint.snappedPoint;

    this.canvas.paper.setStart();

    // horizontal lines
    //
    this.canvas.paper.path("M " + ((start.x | 0) + 0.5) + " " + start.y + " L " + ((end.x | 0) + 0.5) + " " + end.y).attr({
      "stroke": this.lineColor.rgba(),
      "stroke-width": 1
    });

    this.verticalGuideLines = this.canvas.paper.setFinish();
    this.verticalGuideLines.toFront();
  },

  /**
   *
   * Hide the horizontal snaping guides
   *
   * @param soft
   */
  hideVerticalGuides: function hideVerticalGuides(fast) {
    var _this3 = this;

    if (this.verticalGuideLines === null) {
      return;
    }
    if (fast === true) {
      if (this.verticalGuideLines !== null) {
        this.verticalGuideLines.remove();
        this.verticalGuideLines = null;
      }
    } else {
      this.verticalGuideLines.animate({ opacity: 0.1 }, this.FADEOUT_DURATION, function () {
        if (_this3.verticalGuideLines !== null) {
          _this3.verticalGuideLines.remove();
          _this3.verticalGuideLines = null;
        }
      });
    }
  }
});

/***/ }),

/***/ "./src/policy/canvas/SnapToDimetricGridEditPolicy.js":
/*!***********************************************************!*\
  !*** ./src/policy/canvas/SnapToDimetricGridEditPolicy.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A helper used to perform snapping to a grid, which is specified on the canvas via the various
 * properties defined in this class.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.ShowDimetricGridEditPolicy
 */
_packages2.default.policy.canvas.SnapToDimetricGridEditPolicy = _packages2.default.policy.canvas.ShowDimetricGridEditPolicy.extend(
/** @lends draw2d.policy.canvas.SnapToDimetricGridEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SnapToDimetricGridEditPolicy",

  /**
   * Creates a new constraint policy for snap to grid
   *
   * @param {Number} grid the grid width of the canvas
   */
  init: function init(grid) {
    this._super(grid);
  },

  /**
   *
   * Applies a snapping correction to the given result.
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Figure} figure the figure to snap
   * @param {draw2d.geo.Point} modifiedPos the already modified position of the figure (e.g. from an another Policy)
   * @param {draw2d.geo.Point} originalPos the original requested position of the figure
   * @since 2.3.0
   */
  snap: function snap(canvas, figure, modifiedPos, originalPos) {
    // do nothing for lines
    if (figure instanceof _packages2.default.shape.basic.Line) {
      return modifiedPos;
    }

    var snapPoint = figure.getSnapToGridAnchor();

    modifiedPos.x = modifiedPos.x + snapPoint.x;
    modifiedPos.y = modifiedPos.y + snapPoint.y;

    var g = this.grid / 5;

    modifiedPos.x = g * Math.floor((modifiedPos.x + g / 2.0) / g);
    modifiedPos.y = g * Math.floor((modifiedPos.y + g / 2.0) / g);

    modifiedPos.x = modifiedPos.x - snapPoint.x;
    modifiedPos.y = modifiedPos.y - snapPoint.y;

    return modifiedPos;
  }
});

/***/ }),

/***/ "./src/policy/canvas/SnapToEditPolicy.js":
/*!***********************************************!*\
  !*** ./src/policy/canvas/SnapToEditPolicy.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.SnapToHelper = {};

_packages2.default.SnapToHelper.NORTH = 1;
_packages2.default.SnapToHelper.SOUTH = 4;
_packages2.default.SnapToHelper.WEST = 8;
_packages2.default.SnapToHelper.EAST = 16;
_packages2.default.SnapToHelper.CENTER_H = 32;
_packages2.default.SnapToHelper.CENTER_V = 642;

_packages2.default.SnapToHelper.NORTH_EAST = _packages2.default.SnapToHelper.NORTH | _packages2.default.SnapToHelper.EAST;
_packages2.default.SnapToHelper.NORTH_WEST = _packages2.default.SnapToHelper.NORTH | _packages2.default.SnapToHelper.WEST;
_packages2.default.SnapToHelper.SOUTH_EAST = _packages2.default.SnapToHelper.SOUTH | _packages2.default.SnapToHelper.EAST;
_packages2.default.SnapToHelper.SOUTH_WEST = _packages2.default.SnapToHelper.SOUTH | _packages2.default.SnapToHelper.WEST;
_packages2.default.SnapToHelper.NORTH_SOUTH = _packages2.default.SnapToHelper.NORTH | _packages2.default.SnapToHelper.SOUTH;
_packages2.default.SnapToHelper.EAST_WEST = _packages2.default.SnapToHelper.EAST | _packages2.default.SnapToHelper.WEST;
_packages2.default.SnapToHelper.NSEW = _packages2.default.SnapToHelper.NORTH_SOUTH | _packages2.default.SnapToHelper.EAST_WEST;

/**
 * @class
 *
 * A helper used by Tools for snapping certain mouse interactions.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.CanvasPolicy
 */
_packages2.default.policy.canvas.SnapToEditPolicy = _packages2.default.policy.canvas.CanvasPolicy.extend(
/** @lends draw2d.policy.canvas.SnapToEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SnapToEditPolicy",

  /**
   * Creates a new constraint policy for snap to grid
   *
   */
  init: function init(attr, setter, getter) {
    this.lineColor = null;

    this._super((0, _extend2.default)({
      lineColor: "#51C1FC"
    }, attr), (0, _extend2.default)({
      // @attr {draw2d.util.Color} color the line color of the snapTo lines */
      lineColor: this.setLineColor
    }, setter), (0, _extend2.default)({
      lineColor: this.getLineColor
    }, getter));
  },

  /**
   *
   * Set the color of the snap line.
   *
   *     // Alternatively you can use the attr method:
   *     policy.attr({
   *       lineColor: color
   *     });
   *
   * @param {draw2d.util.Color|String} color The new color of the line.
   **/
  setLineColor: function setLineColor(color) {
    this.lineColor = new _packages2.default.util.Color(color);
    return this;
  },

  /**
   *
   * Return the current paint color.
   *
   * @returns {draw2d.util.Color} The paint color of the line.
   * @since 5.6.1
   **/
  getLineColor: function getLineColor() {
    return this.lineColor;
  },

  /**
   *
   * Adjust the coordinates to the given constraint of the policy.
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Figure} figure the figure to snap
   * @param {draw2d.geo.Point} modifiedPos the already modified position of the figure (e.g. from an another Policy)
   * @param {draw2d.geo.Point} originalPos the original requested position of the figure
   */
  snap: function snap(canvas, figure, modifiedPos, originalPos) {
    return modifiedPos;
  }
});

/***/ }),

/***/ "./src/policy/canvas/SnapToGeometryEditPolicy.js":
/*!*******************************************************!*\
  !*** ./src/policy/canvas/SnapToGeometryEditPolicy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Snapping is based on the existing children of a container. When snapping a shape,
 * the edges of the bounding box will snap to edges of other rectangles generated
 * from the children of the given canvas.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.SnapToEditPolicy
 */
_packages2.default.policy.canvas.SnapToGeometryEditPolicy = _packages2.default.policy.canvas.SnapToEditPolicy.extend(
/** @lends draw2d.policy.canvas.SnapToGeometryEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SnapToGeometryEditPolicy",

  SNAP_THRESHOLD: 3,
  FADEOUT_DURATION: 300,

  /**
   * Creates a new constraint policy for snap to geometry
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.rows = null;
    this.cols = null;
    this.vline = null;
    this.hline = null;
  },

  /**
   * 
   *
   * @param {draw2d.Figure} figure the shape below the mouse or null
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseUp: function onMouseUp(figure, x, y, shiftKey, ctrlKey) {
    this.rows = null;
    this.cols = null;
    this.hideVerticalLine();
    this.hideHorizontalLine();
  },

  /**
   * 
   * Adjust the coordinates to the canvas neighbours
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Figure} figure the figure to snap
   * @param {draw2d.geo.Point} modifiedPos the already modified position of the figure (e.g. from an another Policy)
   * @param {draw2d.geo.Point} originalPos the original requested position of the figure
   *
   * @returns {draw2d.geo.Point} the constraint position of the figure
   */
  snap: function snap(canvas, figure, modifiedPos, originalPos) {
    // do nothing for lines
    if (figure instanceof _packages2.default.shape.basic.Line) {
      return modifiedPos;
    }

    var result = void 0;
    var allowXChanges = modifiedPos.x === originalPos.x;
    var allowYChanges = modifiedPos.y === originalPos.y;

    // Coordinates already snapped to an x/y coordinate.
    // Don't change them and in this case no further calculation is requried.
    //
    if (!allowXChanges && !allowYChanges) {
      return modifiedPos;
    }

    if (figure instanceof _packages2.default.ResizeHandle) {
      var snapPoint = figure.getSnapToGridAnchor();
      modifiedPos.x += snapPoint.x;
      modifiedPos.y += snapPoint.y;

      var snapDirections = figure.getSnapToDirection();
      result = this.snapPoint(snapDirections, modifiedPos);

      // Show a vertical line if the snapper has modified the inputPoint
      //
      if (allowXChanges && snapDirections & _packages2.default.SnapToHelper.EAST_WEST && !(result.edge & _packages2.default.SnapToHelper.EAST_WEST)) {
        this.showVerticalLine(figure, _packages2.default.SnapToHelper.WEST, result.point.x);
      } else {
        this.hideVerticalLine();
      }

      // Show a horizontal line if the snapper has modified the inputPoint
      //
      if (allowYChanges && snapDirections & _packages2.default.SnapToHelper.NORTH_SOUTH && !(result.edge & _packages2.default.SnapToHelper.NORTH_SOUTH)) {
        this.showHorizontalLine(figure, _packages2.default.SnapToHelper.NORTH, result.point.y);
      } else {
        this.hideHorizontalLine();
      }

      // restore the original pos coordinate if x or y coordinate already snapped to any axis
      // or subtract the added snapOffset
      //
      result.point.x = allowXChanges ? result.point.x - snapPoint.x : modifiedPos.x;
      result.point.y = allowYChanges ? result.point.y - snapPoint.y : modifiedPos.y;

      return result.point;
    }

    // The user drag&drop a normal figure
    var inputBounds = new _packages2.default.geo.Rectangle(modifiedPos.x, modifiedPos.y, figure.getWidth(), figure.getHeight());

    result = this.snapRectangle(inputBounds);

    if (!allowXChanges) {
      result.bounds.x = modifiedPos.x;
    }

    if (!allowYChanges) {
      result.bounds.y = modifiedPos.y;
    }

    // Show a vertical line if the snapper has modified the inputPoint
    //
    if (allowXChanges && !(result.edge & _packages2.default.SnapToHelper.WEST)) {
      this.showVerticalLine(figure, _packages2.default.SnapToHelper.WEST, result.bounds.x);
    } else if (allowXChanges && !(result.edge & _packages2.default.SnapToHelper.EAST)) {
      this.showVerticalLine(figure, _packages2.default.SnapToHelper.EAST, result.bounds.x + result.bounds.getWidth());
    } else {
      this.hideVerticalLine();
    }

    // Show a horizontal line if the snapper has modified the inputPoint
    //
    if (allowYChanges && !(result.edge & _packages2.default.SnapToHelper.NORTH)) {
      this.showHorizontalLine(figure, _packages2.default.SnapToHelper.NORTH, result.bounds.y);
    } else if (allowYChanges && !(result.edge & _packages2.default.SnapToHelper.SOUTH)) {
      this.showHorizontalLine(figure, _packages2.default.SnapToHelper.SOUTH, result.bounds.y + result.bounds.getHeight());
    } else {
      this.hideHorizontalLine();
    }

    return result.bounds.getTopLeft();
  },

  /**
   * 
   * calculates the snapped position of the rectangle.
   *
   * @param {draw2d.geo.Rectangle} inputBounds
   *
   * @returns {Object}
   */
  snapRectangle: function snapRectangle(inputBounds) {
    var resultBounds = inputBounds.clone();

    var topLeft = this.snapPoint(_packages2.default.SnapToHelper.NORTH_WEST, inputBounds.getTopLeft());
    resultBounds.x = topLeft.point.x;
    resultBounds.y = topLeft.point.y;

    var bottomRight = this.snapPoint(_packages2.default.SnapToHelper.SOUTH_EAST, inputBounds.getBottomRight());

    // The first test (topLeft) has not modified the point. so we can modify them with the bottomRight adjustment
    //
    if (topLeft.edge & _packages2.default.SnapToHelper.WEST) {
      resultBounds.x = bottomRight.point.x - inputBounds.getWidth();
    }

    // The first test (topLeft) has not modified the point. so we can modify them with the bottomRight adjustment
    //
    if (topLeft.edge & _packages2.default.SnapToHelper.NORTH) {
      resultBounds.y = bottomRight.point.y - inputBounds.getHeight();
    }

    return { edge: topLeft.edge | bottomRight.edge, bounds: resultBounds };
  },

  snapPoint: function snapPoint( /*:int*/snapOrientation, /*:draw2d.Point*/inputPoint) {
    var resultPoint = inputPoint.clone();

    if (this.rows === null || this.cols === null) this.populateRowsAndCols();

    if ((snapOrientation & _packages2.default.SnapToHelper.EAST) !== 0) {
      var rightCorrection = this.getCorrectionFor(this.cols, inputPoint.x + 1, 1);
      if (rightCorrection !== this.SNAP_THRESHOLD) {
        snapOrientation &= ~_packages2.default.SnapToHelper.EAST;
        resultPoint.x += rightCorrection;
      }
    }

    if ((snapOrientation & _packages2.default.SnapToHelper.WEST) !== 0) {
      var leftCorrection = this.getCorrectionFor(this.cols, inputPoint.x, -1);
      if (leftCorrection !== this.SNAP_THRESHOLD) {
        snapOrientation &= ~_packages2.default.SnapToHelper.WEST;
        resultPoint.x += leftCorrection;
      }
    }

    if ((snapOrientation & _packages2.default.SnapToHelper.SOUTH) !== 0) {
      var bottomCorrection = this.getCorrectionFor(this.rows, inputPoint.y + 1, 1);
      if (bottomCorrection !== this.SNAP_THRESHOLD) {
        snapOrientation &= ~_packages2.default.SnapToHelper.SOUTH;
        resultPoint.y += bottomCorrection;
      }
    }

    if ((snapOrientation & _packages2.default.SnapToHelper.NORTH) !== 0) {
      var topCorrection = this.getCorrectionFor(this.rows, inputPoint.y, -1);
      if (topCorrection !== this.SNAP_THRESHOLD) {
        snapOrientation &= ~_packages2.default.SnapToHelper.NORTH;
        resultPoint.y += topCorrection;
      }
    }

    return { edge: snapOrientation, point: resultPoint };
  },

  populateRowsAndCols: function populateRowsAndCols() {
    var selection = this.canvas.getSelection();
    this.rows = [];
    this.cols = [];

    var figures = this.canvas.getFigures();
    for (var i = 0; i < figures.getSize(); i++) {
      var figure = figures.get(i);
      if (!selection.contains(figure, true)) {
        var bounds = figure.getBoundingBox();
        this.cols.push({ type: -1, location: bounds.x });
        this.cols.push({ type: 0, location: bounds.x + (bounds.w - 1) / 2 });
        this.cols.push({ type: 1, location: bounds.getRight() + 1 });
        this.rows.push({ type: -1, location: bounds.y });
        this.rows.push({ type: 0, location: bounds.y + (bounds.h - 1) / 2 });
        this.rows.push({ type: 1, location: bounds.getBottom() + 1 });
      }
    }

    // TODO: remove duplicate entries in the rows/cols array
  },

  getCorrectionFor: function getCorrectionFor( /*:Array*/entries, /*:double*/value, /*:int*/side) {
    var resultMag = this.SNAP_THRESHOLD;
    var result = this.SNAP_THRESHOLD;

    for (var i = 0; i < entries.length; i++) {
      var entry = entries[i];
      var magnitude = void 0;

      if (entry.type === -1 && side !== 0) {
        magnitude = Math.abs(value - entry.location);
        if (magnitude < resultMag) {
          resultMag = magnitude;
          result = entry.location - value;
        }
      } else if (entry.type === 0 && side === 0) {
        magnitude = Math.abs(value - entry.location);
        if (magnitude < resultMag) {
          resultMag = magnitude;
          result = entry.location - value;
        }
      } else if (entry.type === 1 && side !== 0) {
        magnitude = Math.abs(value - entry.location);
        if (magnitude < resultMag) {
          resultMag = magnitude;
          result = entry.location - value;
        }
      }
    }
    return result;
  },

  showVerticalLine: function showVerticalLine(causedFigure, edge, x) {
    if (this.vline != null) {
      this.vline.stop();
      this.vline.remove();
    }

    var figures = this.canvas.getFigures().clone();
    figures.removeAll(this.canvas.getSelection().getAll(true));
    figures.map(function (figure) {
      return figure.getBoundingBox();
    });
    figures.grep(function (bbox) {
      return Math.abs(bbox.x - x) <= 1 || Math.abs(bbox.getRight() - x) <= 1;
    });

    // return silently if no figure bounding box is left
    //
    if (figures.getSize() === 0) {
      return;
    }

    // figure to align is above the current shape
    //
    var causedBox = causedFigure.getBoundingBox();
    var causedCenter = causedBox.getCenter();
    figures.sort(function (a, b) {
      var d_a = a.getCenter().distance(causedCenter);
      var d_b = b.getCenter().distance(causedCenter);
      return d_a - d_b;
    });
    var fromY = 0;
    var maxLength = this.canvas.getHeight() * Math.max(1, this.canvas.getZoom());
    var yLength = maxLength;
    var snappedBox = figures.get(0);
    if (causedBox.y < snappedBox.y) {
      fromY = causedBox.y;
      yLength = snappedBox.getBottom() - causedBox.y;
    } else {
      fromY = snappedBox.y;
      yLength = causedBox.getBottom() - snappedBox.y;
    }

    x = (x | 0) + 0.5; // force a .5 number to avoid subpixel rendering. Blurry lines...
    this.canvas.paper.setStart();
    this.canvas.paper.path("M " + x + " 0 l 0 " + maxLength).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });
    this.canvas.paper.path("M " + x + " " + fromY + " l 0 " + yLength).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.vline = this.canvas.paper.setFinish();
    this.vline.toBack();
  },

  hideVerticalLine: function hideVerticalLine() {
    var _this = this;

    if (this.vline == null) {
      return;
    }
    this.vline.animate({ opacity: 0.1 }, this.FADEOUT_DURATION, function () {
      if (_this.vline !== null) {
        _this.vline.remove();
        _this.vline = null;
      }
    });
  },

  showHorizontalLine: function showHorizontalLine(causedFigure, edge, y) {
    if (this.hline != null) {
      this.hline.stop();
      this.hline.remove();
    }

    var figures = this.canvas.getFigures().clone();
    figures.removeAll(this.canvas.getSelection().getAll(true));
    figures.map(function (figure) {
      return figure.getBoundingBox();
    });
    figures.grep(function (bbox) {
      return Math.abs(bbox.y - y) <= 1 || Math.abs(bbox.getBottom() - y) <= 1;
    });

    // return silently if no figure bounding box is left
    //
    if (figures.getSize() === 0) {
      return;
    }

    // figure to align is above the current shape
    //
    var causedBox = causedFigure.getBoundingBox();
    var causedCenter = causedBox.getCenter();
    figures.sort(function (a, b) {
      var d_a = a.getCenter().distance(causedCenter);
      var d_b = b.getCenter().distance(causedCenter);
      return d_a - d_b;
    });
    var fromX = 0;
    var maxLength = void 0;
    var xLength = maxLength = this.canvas.getWidth() * Math.max(1, this.canvas.getZoom());
    var snappedBox = figures.get(0);
    if (causedBox.x < snappedBox.x) {
      fromX = causedBox.x;
      xLength = snappedBox.getRight() - causedBox.x;
    } else {
      fromX = snappedBox.x;
      xLength = causedBox.getRight() - snappedBox.x;
    }

    y = (y | 0) + 0.5; // force a .5 number to avoid subpixel rendering. Blurry lines...

    this.canvas.paper.setStart();
    this.canvas.paper.path("M 0 " + y + " l " + maxLength + " 0").attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });
    this.canvas.paper.path("M " + fromX + " " + y + " l " + xLength + " 0").attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.hline = this.canvas.paper.setFinish();
    this.hline.toBack();
  },

  hideHorizontalLine: function hideHorizontalLine() {
    var _this2 = this;

    if (this.hline === null) {
      return; //silently
    }
    this.hline.animate({ opacity: 0.1 }, this.FADEOUT_DURATION, function () {
      if (_this2.hline !== null) {
        _this2.hline.remove();
        _this2.hline = null;
      }
    });
  }

});

/***/ }),

/***/ "./src/policy/canvas/SnapToGridEditPolicy.js":
/*!***************************************************!*\
  !*** ./src/policy/canvas/SnapToGridEditPolicy.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A helper used to perform snapping to a grid, which is specified on the canvas via the various
 * properties defined in this class.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.ShowGridEditPolicy
 */
_packages2.default.policy.canvas.SnapToGridEditPolicy = _packages2.default.policy.canvas.SnapToEditPolicy.extend(
/** @lends draw2d.policy.canvas.SnapToGridEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SnapToGridEditPolicy",

  /**
   * Creates a new constraint policy for snap to grid
   *
   * @param {Number} grid the grid width of the canvas
   */
  init: function init(grid, showGrid) {
    this._super();
    this.grid = grid || 20;

    // Default Value for "showGrid=true"
    if (typeof showGrid === "undefined" || showGrid === true) {
      this.renderer = new _packages2.default.policy.canvas.ShowGridEditPolicy(this.grid);
    }
  },

  onInstall: function onInstall(canvas) {
    this._super(canvas);
    if (this.renderer) this.renderer.onInstall(canvas);
  },

  onUninstall: function onUninstall(canvas) {
    this._super(canvas);
    if (this.renderer) this.renderer.onUninstall(canvas);
  },

  /**
   *
   * Set a new grid width/height
   *
   * @param {Number} grid
   * @since 5.0.3
   */
  setGrid: function setGrid(grid) {
    this.grid = grid;
    if (this.renderer) this.renderer.setGrid(grid);
  },

  /**
  *
  * Applies a snapping correction to the given result.
  *
  * @param {draw2d.Canvas} canvas the related canvas
  * @param {draw2d.Figure} figure the figure to snap
  * @param {draw2d.geo.Point} modifiedPos the already modified position of the figure (e.g. from an another Policy)
  * @param {draw2d.geo.Point} originalPos the original requested position of the figure
  * @since 2.3.0
  */
  snap: function snap(canvas, figure, modifiedPos, originalPos) {
    // do nothing for lines
    if (figure instanceof _packages2.default.shape.basic.Line) {
      return modifiedPos;
    }

    var snapPoint = figure.getSnapToGridAnchor();

    modifiedPos.x = modifiedPos.x + snapPoint.x;
    modifiedPos.y = modifiedPos.y + snapPoint.y;

    modifiedPos.x = this.grid * Math.floor((modifiedPos.x + this.grid / 2.0) / this.grid);
    modifiedPos.y = this.grid * Math.floor((modifiedPos.y + this.grid / 2.0) / this.grid);

    modifiedPos.x = modifiedPos.x - snapPoint.x;
    modifiedPos.y = modifiedPos.y - snapPoint.y;

    return modifiedPos;
  }
});

/***/ }),

/***/ "./src/policy/canvas/SnapToInBetweenEditPolicy.js":
/*!********************************************************!*\
  !*** ./src/policy/canvas/SnapToInBetweenEditPolicy.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Snapping is based on the existing children of a container. When snapping a shape,
 * the edges of the bounding box will snap to edges of other rectangles generated
 * from the children of the given canvas.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.SnapToEditPolicy
 * @since 5.6.4
 */
_packages2.default.policy.canvas.SnapToInBetweenEditPolicy = _packages2.default.policy.canvas.SnapToEditPolicy.extend(
/** @lends draw2d.policy.canvas.SnapToInBetweenEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SnapToInBetweenEditPolicy",

  SNAP_THRESHOLD: 5,
  FADEOUT_DURATION: 500,

  /**
   * Creates a new constraint policy for snap to geometry
   *
   */
  init: function init(attr, setter, getter) {

    this._super(attr, setter, getter);

    this.bounds = null;

    this.horizontalGuideLines = null;
    this.verticalGuideLines = null;
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onMouseUp: function onMouseUp(figure, x, y, shiftKey, ctrlKey) {
    this.bounds = null;
    this.hideHorizontalGuides(false);
    this.hideVerticalGuides(false);
  },

  /**
   *
   * Adjust the coordinates to the canvas neighbours
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Figure} figure the figure to snap
   * @param {draw2d.geo.Point} modifiedPos the already modified position of the figure (e.g. from an another Policy)
   * @param {draw2d.geo.Point} originalPos the original requested position of the figure
   *
   * @returns {draw2d.geo.Point} the constraint position of the figure
   */
  snap: function snap(canvas, figure, modifiedPos, originalPos) {
    // do nothing for resize handles
    if (figure instanceof _packages2.default.ResizeHandle) {
      return modifiedPos;
    }
    // do nothing for lines
    if (figure instanceof _packages2.default.shape.basic.Line) {
      return modifiedPos;
    }

    var allowXChanges = modifiedPos.x === originalPos.x;
    var allowYChanges = modifiedPos.y === originalPos.y;

    var inputBounds = new _packages2.default.geo.Rectangle(modifiedPos.x, modifiedPos.y, figure.getWidth(), figure.getHeight());

    modifiedPos = modifiedPos.clone();

    if (allowXChanges === true) {
      var horizontal = this.snapHorizontal(inputBounds);

      // Show a horizontal line if the snapper has modified the inputPoint
      //
      if (horizontal.snapped) {
        // show the snap lines..
        this.showHorizontalGuides(figure, horizontal);

        // and snap the x coordinate
        modifiedPos.x += horizontal.diff;
      } else {
        this.hideHorizontalGuides(true);
      }
    } else {
      this.hideHorizontalGuides(true);
    }

    if (allowYChanges === true) {
      var vertical = this.snapVertical(inputBounds);

      // Show a vertical guides if the snapper has modified the inputPoint
      //
      if (vertical.snapped) {
        // show the snap lines..
        this.showVerticalGuides(figure, vertical);

        // and snap the x coordinate
        modifiedPos.y += vertical.diff;
      } else {
        this.hideVerticalGuides(true);
      }
    } else {
      this.hideVerticalGuides(true);
    }

    return modifiedPos;
  },

  snapHorizontal: function snapHorizontal(boundingBox) {
    var center = boundingBox.getCenter();
    if (this.bounds === null) this.populateBounds();

    var result = {
      point: center,
      snapped: false,
      snappedBox: boundingBox.clone()
    };

    var intersectionPoint = null;

    // Calculate the intersections points p(i) of all left side edges of the bounding boxes
    // and the ray from the center of the drag&drop object to the left edge of the canva
    //
    // BBox of          Drag&Drop
    // any Figure       Figure
    //
    // ....+           ........
    //     |           .      .
    // .   |p(i)       .      .
    // .   X<------------->+  .
    // .   |           .      .
    // ....+           .      .
    //                 ........
    //
    //
    var leftIntersections = [];
    var leftInputPoint = center.clone();
    leftInputPoint.x = 0;
    this.bounds.forEach(function (bbox, index) {
      intersectionPoint = _packages2.default.shape.basic.Line.intersection(bbox.getTopRight(), bbox.getBottomRight(), center, leftInputPoint);
      if (intersectionPoint !== null) {
        intersectionPoint.causedBBox = bbox;
        leftIntersections.push(intersectionPoint);
      }
    });
    // we can abort if we didn't find an intersection on the left hand side
    if (leftIntersections.length === 0) {
      return result;
    }

    // sort the intersection point and get the closest point to the tested inputPoint
    // In this case it is the point with the greates X coordinate
    //
    leftIntersections.sort(function (a, b) {
      return b.x - a.x;
    });

    // Calculate the intersections points p(i) of all right hand side edges of the
    // bounding boxes and the ray from the center of the drag&drop object to the
    // left edge of the canvas
    //
    //                 Drag&Drop             bbox of any
    //                 Figure                figure
    //
    //                 ........
    //                 .      .
    //                 .      .             ...........
    //                 .   +<-------------->X         |
    //                 .      .         p(i)|         |
    //                 .      .             |         |
    //                 ........             |         |
    //                                      ...........
    //
    var rightIntersections = [];
    var rightInputPoint = center.clone();
    rightInputPoint.x = Number.MAX_SAFE_INTEGER;
    this.bounds.forEach(function (bbox, index) {
      intersectionPoint = _packages2.default.shape.basic.Line.intersection(bbox.getTopLeft(), bbox.getBottomLeft(), center, rightInputPoint);
      if (intersectionPoint !== null) {
        intersectionPoint.causedBBox = bbox;
        rightIntersections.push(intersectionPoint);
      }
    });
    // we can abort if we didn't find an intersection on the right hand side
    if (rightIntersections.length === 0) {
      return result;
    }

    // sort the intersection point and get the closest point to the tested inputPoint
    // In this case it is the point with the greates X coordinate
    //
    rightIntersections.sort(function (a, b) {
      return a.x - b.x;
    });

    // Snap the point (S) between the two founded intersections
    // p(i1) and p(i2)
    //
    // BBox FigureA     Drag&Drop           BBox of FigureB
    //                  Figure
    //
    // ....+           ........
    //     |           .      .
    // .   |p(i1)      .   S  .             ...........
    // .   X<------------->X<-------------->X         |
    // .   |           .      .        p(i2)|         |
    // ....+           .      .             |         |
    //                 ........             |         |
    //                                      ...........
    //
    var snappedRect = boundingBox.clone();
    var diff = (leftIntersections[0].x + rightIntersections[0].x) / 2 - center.x;

    snappedRect.x += diff;

    return {
      snapped: Math.abs(diff) < this.SNAP_THRESHOLD,
      snappedRect: snappedRect,
      diff: diff,
      leftSide: leftIntersections[0],
      rightSide: rightIntersections[0]
    };
  },

  snapVertical: function snapVertical(boundingBox) {
    var center = boundingBox.getCenter();

    if (this.bounds === null) {
      this.populateBounds();
    }

    var result = {
      point: center,
      snapped: false,
      snappedBox: boundingBox.clone()
    };

    var intersectionPoint = null;

    // Calculate the intersections points p(i) of all left side edges of the bounding boxes
    // and the ray from the center of the drag&drop object to the left edge of the canva
    //
    // BBox of          Drag&Drop
    // any Figure       Figure
    //
    // ....+           ........
    //     |           .      .
    // .   |p(i)       .      .
    // .   X<------------->+  .
    // .   |           .      .
    // ....+           .      .
    //                 ........
    //
    //
    var topIntersections = [];
    var topInputPoint = center.clone();
    topInputPoint.y = 0;
    this.bounds.forEach(function (bbox) {
      intersectionPoint = _packages2.default.shape.basic.Line.intersection(bbox.getBottomLeft(), bbox.getBottomRight(), center, topInputPoint);
      if (intersectionPoint !== null) {
        intersectionPoint.causedBBox = bbox;
        topIntersections.push(intersectionPoint);
      }
    });
    // we can abort if we didn't find an intersection on the left hand side
    if (topIntersections.length === 0) {
      return result;
    }

    // sort the intersection point and get the closest point to the tested inputPoint
    // In this case it is the point with the greates X coordinate
    //
    topIntersections.sort(function (a, b) {
      return b.y - a.y;
    });

    // Calculate the intersections points p(i) of all right hand side edges of the
    // bounding boxes and the ray from the center of the drag&drop object to the
    // left edge of the canvas
    //
    //                 Drag&Drop             bbox of any
    //                 Figure                figure
    //
    //                 ........
    //                 .      .
    //                 .      .             ...........
    //                 .   +<-------------->X         |
    //                 .      .         p(i)|         |
    //                 .      .             |         |
    //                 ........             |         |
    //                                      ...........
    //
    var bottomIntersections = [];
    var bottomInputPoint = center.clone();
    bottomInputPoint.y = Number.MAX_SAFE_INTEGER;
    this.bounds.forEach(function (bbox) {
      intersectionPoint = _packages2.default.shape.basic.Line.intersection(bbox.getTopLeft(), bbox.getTopRight(), center, bottomInputPoint);
      if (intersectionPoint !== null) {
        intersectionPoint.causedBBox = bbox;
        bottomIntersections.push(intersectionPoint);
      }
    });
    // we can abort if we didn't find an intersection on the right hand side
    if (bottomIntersections.length === 0) {
      return result;
    }

    // sort the intersection point and get the closest point to the tested inputPoint
    // In this case it is the point with the greates X coordinate
    //
    bottomIntersections.sort(function (a, b) {
      return a.y - b.y;
    });

    // Snap the point (S) between the two founded intersections
    // p(i1) and p(i2)
    //
    // BBox FigureA     Drag&Drop           BBox of FigureB
    //                  Figure
    //
    // ....+           ........
    //     |           .      .
    // .   |p(i1)      .   S  .             ...........
    // .   X<------------->X<-------------->X         |
    // .   |           .      .        p(i2)|         |
    // ....+           .      .             |         |
    //                 ........             |         |
    //                                      ...........
    //
    var snappedRect = boundingBox.clone();
    var diff = (topIntersections[0].y + bottomIntersections[0].y) / 2 - center.y;

    snappedRect.y += diff;

    return {
      snapped: Math.abs(diff) < this.SNAP_THRESHOLD,
      snappedRect: snappedRect,
      diff: diff,
      topSide: topIntersections[0],
      bottomSide: bottomIntersections[0]
    };
  },

  populateBounds: function populateBounds() {
    var selection = this.canvas.getSelection().getAll(true);
    var bounds = this.bounds = [];

    var figures = this.canvas.getFigures();
    figures.each(function (index, figure) {
      if (!selection.contains(figure)) {
        bounds.push(figure.getBoundingBox());
      }
    });
  },

  showHorizontalGuides: function showHorizontalGuides(causedFigure, constraint) {
    if (this.horizontalGuideLines != null) {
      this.horizontalGuideLines.stop();
      this.horizontalGuideLines.remove();
    }

    var snapTopLeft = constraint.snappedRect.getTopLeft();
    var snapTopRight = constraint.snappedRect.getTopRight();
    var y = (Math.min(constraint.leftSide.causedBBox.getTopRight().y, Math.min(constraint.rightSide.causedBBox.y, causedFigure.getY())) - 50 | 0) + 0.5;

    this.canvas.paper.setStart();

    // Vertical lines from left to the right order
    //
    this.canvas.paper.path("M " + ((constraint.leftSide.x | 0) + 0.5) + " " + y + " L " + ((constraint.leftSide.x | 0) + 0.5) + " " + constraint.leftSide.y).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });

    this.canvas.paper.path("M " + ((snapTopLeft.x | 0) + 0.5) + " " + y + " L " + ((snapTopLeft.x | 0) + 0.5) + " " + snapTopLeft.y).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });

    this.canvas.paper.path("M " + ((snapTopRight.x | 0) + 0.5) + " " + y + " L " + ((snapTopRight.x | 0) + 0.5) + " " + snapTopRight.y).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });

    this.canvas.paper.path("M " + ((constraint.rightSide.x | 0) + 0.5) + " " + y + " L " + ((constraint.rightSide.x | 0) + 0.5) + " " + constraint.rightSide.y).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });

    // horizontal lines
    //
    this.canvas.paper.path("M " + constraint.leftSide.x + " " + (y + 5) + " L " + snapTopLeft.x + " " + (y + 5)).attr({
      "stroke": this.lineColor.rgba(),
      "stroke-width": 1
    });
    this.canvas.paper.path("M " + constraint.rightSide.x + " " + (y + 5) + " L " + snapTopRight.x + " " + (y + 5)).attr({
      "stroke": this.lineColor.rgba(),
      "stroke-width": 1
    });

    // 4 arrow heads starting on the left side and add one by one
    //
    this.canvas.paper.path(" M " + (constraint.leftSide.x + 5) + " " + y + " L " + constraint.leftSide.x + " " + (y + 5) + " L " + (constraint.leftSide.x + 5) + " " + (y + 10)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.canvas.paper.path(" M " + (snapTopLeft.x - 5) + " " + y + " L " + snapTopLeft.x + " " + (y + 5) + " L " + (snapTopLeft.x - 5) + " " + (y + 10)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.canvas.paper.path(" M " + (snapTopRight.x + 5) + " " + y + " L " + snapTopRight.x + " " + (y + 5) + " L " + (snapTopRight.x + 5) + " " + (y + 10)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.canvas.paper.path(" M " + (constraint.rightSide.x - 5) + " " + y + " L " + constraint.rightSide.x + " " + (y + 5) + " L " + (constraint.rightSide.x - 5) + " " + (y + 10)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.horizontalGuideLines = this.canvas.paper.setFinish();
    this.horizontalGuideLines.toFront();
  },

  /**
   *
   * Hide the horizontal snaping guides
   *
   * @param {Boolean} fast
   */
  hideHorizontalGuides: function hideHorizontalGuides(fast) {
    var _this = this;

    if (this.horizontalGuideLines == null) {
      return;
    }

    if (fast === true) {
      if (this.horizontalGuideLines !== null) {
        this.horizontalGuideLines.remove();
        this.horizontalGuideLines = null;
      }
    } else {
      this.horizontalGuideLines.animate({ opacity: 0.1 }, this.FADEOUT_DURATION, function () {
        if (_this.horizontalGuideLines !== null) {
          _this.horizontalGuideLines.remove();
          _this.horizontalGuideLines = null;
        }
      });
    }
  },

  showVerticalGuides: function showVerticalGuides(causedFigure, constraint) {
    if (this.verticalGuideLines != null) {
      this.verticalGuideLines.stop();
      this.verticalGuideLines.remove();
    }

    var snapTopRight = constraint.snappedRect.getTopRight();
    var snapBottomRight = constraint.snappedRect.getBottomRight();
    var x = (Math.max(constraint.topSide.causedBBox.getRight(), Math.max(constraint.bottomSide.causedBBox.getRight(), causedFigure.getX())) + 40 | 0) + 0.5;

    this.canvas.paper.setStart();

    // Vertical lines from left to the right order
    //
    this.canvas.paper.path("M " + x + " " + ((constraint.topSide.y | 0) + 0.5) + " L " + ((constraint.topSide.x | 0) + 0.5) + " " + ((constraint.topSide.y | 0) + 0.5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });
    this.canvas.paper.path("M " + x + " " + ((snapTopRight.y | 0) + 0.5) + " L " + ((snapTopRight.x | 0) + 0.5) + " " + ((snapTopRight.y | 0) + 0.5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });
    this.canvas.paper.path("M " + x + " " + ((snapBottomRight.y | 0) + 0.5) + " L " + ((snapBottomRight.x | 0) + 0.5) + " " + ((snapBottomRight.y | 0) + 0.5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });
    this.canvas.paper.path("M " + x + " " + ((constraint.bottomSide.y | 0) + 0.5) + " L " + ((constraint.bottomSide.x | 0) + 0.5) + " " + ((constraint.bottomSide.y | 0) + 0.5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });

    // horizontal lines
    //
    this.canvas.paper.path("M " + (x - 5) + " " + ((constraint.topSide.y | 0) + 0.5) + " L " + (x - 5) + " " + ((snapTopRight.y | 0) + 0.5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });
    this.canvas.paper.path("M " + (x - 5) + " " + ((constraint.bottomSide.y | 0) + 0.5) + " L " + (x - 5) + " " + ((snapBottomRight.y | 0) + 0.5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    // 4 arrow heads starting on the left side and add one by one
    //
    this.canvas.paper.path(" M " + (x - 10) + " " + (constraint.topSide.y + 5) + " L " + (x - 5) + " " + constraint.topSide.y + " L " + x + " " + (constraint.topSide.y + 5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.canvas.paper.path(" M " + (x - 10) + " " + (snapTopRight.y - 5) + " L " + (x - 5) + " " + snapTopRight.y + " L " + x + " " + (snapTopRight.y - 5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.canvas.paper.path(" M " + (x - 10) + " " + (snapBottomRight.y + 5) + " L " + (x - 5) + " " + snapBottomRight.y + " L " + x + " " + (snapBottomRight.y + 5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.canvas.paper.path(" M " + (x - 10) + " " + (constraint.bottomSide.y - 5) + " L " + (x - 5) + " " + constraint.bottomSide.y + " L " + x + " " + (constraint.bottomSide.y - 5)).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.verticalGuideLines = this.canvas.paper.setFinish();
    this.verticalGuideLines.toFront();
  },

  hideVerticalGuides: function hideVerticalGuides() {
    var _this2 = this;

    if (this.verticalGuideLines == null) {
      return; //silently
    }

    this.verticalGuideLines.animate({ opacity: 0.1 }, this.FADEOUT_DURATION, function () {
      if (_this2.verticalGuideLines !== null) {
        _this2.verticalGuideLines.remove();
        _this2.verticalGuideLines = null;
      }
    });
  }

});

/***/ }),

/***/ "./src/policy/canvas/SnapToVerticesEditPolicy.js":
/*!*******************************************************!*\
  !*** ./src/policy/canvas/SnapToVerticesEditPolicy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Snapping is based on the existing children of a container. When snapping a shape,
 * the edges of the bounding box will snap to edges of other rectangles generated
 * from the children of the given canvas.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.SnapToEditPolicy
 */
_packages2.default.policy.canvas.SnapToVerticesEditPolicy = _packages2.default.policy.canvas.SnapToEditPolicy.extend(
/** @lends draw2d.policy.canvas.SnapToVerticesEditPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.SnapToVerticesEditPolicy",

  SNAP_THRESHOLD: 3,
  FADEOUT_DURATION: 300,

  /**
   * Creates a new constraint policy for snap to geometry
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.constraints = null;
    this.vline = null;
    this.hline = null;
  },

  /**
   * 
   *
   * @param {draw2d.Figure} figure the shape below the mouse or null
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onMouseUp: function onMouseUp(figure, x, y, shiftKey, ctrlKey) {
    this.constraints = null;
    this.hideVerticalLine();
    this.hideHorizontalLine();
  },

  /**
   * 
   * Adjust the coordinates to the canvas neighbours
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Figure} figure the figure to snap
   * @param {draw2d.geo.Point} modifiedPos the already modified position of the figure (e.g. from an another Policy)
   * @param {draw2d.geo.Point} originalPos the original requested position of the figure
   *
   * @returns {draw2d.geo.Point} the constraint position of the figure
   */
  snap: function snap(canvas, figure, modifiedPos, originalPos) {
    // can only handle PolyLies at the moment
    //
    if (!(figure instanceof _packages2.default.shape.basic.VertexResizeHandle)) {
      return modifiedPos;
    }

    var allowXChanges = modifiedPos.x === originalPos.x;
    var allowYChanges = modifiedPos.y === originalPos.y;

    // Coordinates already snapped to an x/y coordinate.
    // Don't change them and in this case no further calculation is required.
    //
    if (!allowXChanges && !allowYChanges) {
      return modifiedPos;
    }

    var result = modifiedPos.clone();
    var correction = this.getCorrectionFor(figure, originalPos);

    if (allowXChanges && correction.vertical.x !== Number.MAX_SAFE_INTEGER) {
      result.x = correction.vertical.x;
      this.showVerticalLine(originalPos, correction.vertical);
    } else {
      this.hideVerticalLine();
    }

    if (allowYChanges && correction.horizontal.y !== Number.MAX_SAFE_INTEGER) {
      result.y = correction.horizontal.y;
      this.showHorizontalLine(originalPos, correction.horizontal);
    } else {
      this.hideHorizontalLine();
    }

    return result;
  },

  getCorrectionFor: function getCorrectionFor(vertexResizeHandle, point) {
    var _this = this;
    if (this.constraints === null) {
      this.constraints = [];

      var lines = this.canvas.getLines();
      lines.each(function (i, line) {
        line.getVertices().each(function (ii, vertex) {
          if (vertexResizeHandle.index !== ii || vertexResizeHandle.owner !== line) _this.constraints.push(vertex);
        });
      });
    }

    var SNAP = this.SNAP_THRESHOLD;
    var vertical = { x: Number.MAX_SAFE_INTEGER, y: Number.MAX_SAFE_INTEGER, diffy: Number.MAX_SAFE_INTEGER };
    var horizontal = { x: Number.MAX_SAFE_INTEGER, y: Number.MAX_SAFE_INTEGER, diffx: Number.MAX_SAFE_INTEGER };
    var diffx, diffy;

    for (var i = 0; i < this.constraints.length; i++) {
      var entry = this.constraints[i];

      diffx = Math.abs(point.x - entry.x);
      diffy = Math.abs(point.y - entry.y);
      // we found a possible candidate for the vertical snap line
      //
      if (diffx < SNAP) {
        if (diffy < vertical.diffy) {
          vertical = { x: entry.x, y: entry.y, diffy: diffy };
        }
      }

      if (diffy < SNAP) {
        if (diffx < horizontal.diffx) {
          horizontal = { x: entry.x, y: entry.y, diffx: diffx };
        }
      }
    }
    return { vertical: vertical, horizontal: horizontal };
  },

  showVerticalLine: function showVerticalLine(originalPos, snappedPos) {
    if (this.vline != null) {
      this.vline.stop();
      this.vline.remove();
    }

    var maxLength = this.canvas.getHeight();
    var x = (snappedPos.x | 0) + 0.5; // force a .5 number to avoid subpixel rendering. Blurry lines...
    this.canvas.paper.setStart();
    this.canvas.paper.path("M " + x + " 0 l 0 " + maxLength).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });
    this.canvas.paper.path("M " + x + " " + originalPos.y + " L " + x + " " + snappedPos.y).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.vline = this.canvas.paper.setFinish();
    this.vline.toBack();
  },

  hideVerticalLine: function hideVerticalLine() {
    var _this2 = this;

    if (this.vline == null) {
      return;
    }
    this.vline.animate({ opacity: 0.1 }, this.FADEOUT_DURATION, function () {
      if (_this2.vline !== null) {
        _this2.vline.remove();
        _this2.vline = null;
      }
    });
  },

  showHorizontalLine: function showHorizontalLine(originalPos, snappedPos) {
    if (this.hline != null) {
      this.hline.stop();
      this.hline.remove();
    }

    var maxLength = this.canvas.getWidth();
    var y = (snappedPos.y | 0) + 0.5; // force a .5 number to avoid subpixel rendering. Blurry lines...

    this.canvas.paper.setStart();
    this.canvas.paper.path("M 0 " + y + " l " + maxLength + " 0").attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1, "stroke-dasharray": ". " });
    this.canvas.paper.path("M " + originalPos.x + " " + y + " L " + snappedPos.x + " " + y).attr({ "stroke": this.lineColor.rgba(), "stroke-width": 1 });

    this.hline = this.canvas.paper.setFinish();
    this.hline.toBack();
  },

  hideHorizontalLine: function hideHorizontalLine() {
    var _this3 = this;

    if (this.hline === null) {
      return; //silently
    }
    this.hline.animate({ opacity: 0.1 }, this.FADEOUT_DURATION, function () {
      if (_this3.hline !== null) {
        _this3.hline.remove();
        _this3.hline = null;
      }
    });
  }

});

/***/ }),

/***/ "./src/policy/canvas/WheelZoomPolicy.js":
/*!**********************************************!*\
  !*** ./src/policy/canvas/WheelZoomPolicy.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _shifty = __webpack_require__(/*! shifty */ "./node_modules/shifty/dist/shifty.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Zoom support for a canvas. Use the mouse wheel and the shift key to zoom in/out.
 *
 *
 * @example
 *
 *    canvas.installEditPolicy(new draw2d.policy.canvas.WheelZoomPolicy());
 *    let shape =  new draw2d.shape.basic.Text({text:"Use the mouse wheel + SHIFT to zoom"});
 *
 *    canvas.add(shape,40,10);
 *
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 * @since 5.8.0
 */
_packages2.default.policy.canvas.WheelZoomPolicy = _packages2.default.policy.canvas.ZoomPolicy.extend(
/** @lends draw2d.policy.canvas.WheelZoomPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.WheelZoomPolicy",

  /**
   */
  init: function init() {
    var _this = this;

    this._super();

    this.center = null;
    this.debouncedZoomedCallback = this._debounce(function () {
      var canvas = _this.canvas;
      if (canvas !== null) {
        canvas.fireEvent("zoomed", { value: canvas.zoomFactor });
      }
      _this.center = null;
    }, 200);
  },

  onInstall: function onInstall(canvas) {
    this._super(canvas);
    canvas.setZoom(1);
    canvas.__wheelZoom = 1;
  },

  onUninstall: function onUninstall(canvas) {
    this._super(canvas);

    // cleanup the canvas object and remove custom properties
    //
    delete canvas.__wheelZoom;
  },

  /**
   *
   * called if the user uses the mouse wheel.
   *
   *
   * @param wheelDelta
   * @param {Number} x the x coordinate of the event
   * @param {Number} y the y coordinate of the event
   * @param shiftKey
   * @param ctrlKey
   * @since 5.8.0
   * @template
   * @returns {Boolean} return <b>false</b> to preven tthe default event operation (e.g. scrolling)
   */
  onMouseWheel: function onMouseWheel(wheelDelta, x, y, shiftKey, ctrlKey) {
    // mouse wheel is only supported if the user presses the shift key.
    // normally the canvas scrolls during mouseWheel usage.
    //
    if (shiftKey === false) {
      return true;
    }

    wheelDelta = wheelDelta / 1024;

    var newZoom = (Math.min(5, Math.max(0.1, this.canvas.zoomFactor + wheelDelta)) * 10000 | 0) / 10000;
    if (this.center === null) {
      var client = this.canvas.fromCanvasToDocumentCoordinate(x, y);

      this.center = {
        x: x,
        y: y,
        clientX: client.x,
        clientY: client.y
      };
    }
    this._zoom(newZoom, this.center);
    this.debouncedZoomedCallback();

    return false;
  },

  /**
   *
   * Set the new zoom level of the canvas.
   *
   * @param zoomFactor
   * @param animated
   */
  setZoom: function setZoom(zoomFactor, animated) {
    var _this2 = this;

    // determine the center of the current canvas. We try to keep the
    // current center during zoom operation
    //
    var scrollTop = this.canvas.getScrollTop();
    var scrollLeft = this.canvas.getScrollLeft();
    var scrollWidth = this.canvas.getScrollArea().width();
    var scrollHeight = this.canvas.getScrollArea().height();
    var centerY = scrollTop + scrollHeight / 2 * this.canvas.zoomFactor;
    var centerX = scrollLeft + scrollWidth / 2 * this.canvas.zoomFactor;

    if (animated) {
      var myTweenable = new _shifty.Tweenable();
      myTweenable.tween({
        from: { 'x': this.canvas.zoomFactor },
        to: { 'x': zoomFactor },
        duration: 300,
        easing: "easeOutSine",
        step: function step(params) {
          _this2._zoom(params.x, centerX, centerY);
        },
        finish: function finish(state) {
          _this2.debouncedZoomedCallback();
        }
      });
    } else {
      this._zoom(zoomFactor, { x: centerX, y: centerY });
      this.debouncedZoomedCallback();
    }
  },

  /**
   *
   *
   * @param {Number} zoom
   * @param {draw2d.geo.Point} center
   * @private
   */
  _zoom: function _zoom(zoom, center) {
    var canvas = this.canvas;

    if (zoom === canvas.zoomFactor) {
      return;
    }

    canvas.zoomFactor = zoom;

    canvas.paper.setViewBox(0, 0, canvas.initialWidth, canvas.initialHeight);
    // Change the width and the height attributes manually through DOM
    // unfortunately the raphaelJS 'setSize' method changes the viewBox as well and this is unwanted in this case
    //
    canvas.html.find("svg").attr({
      'width': canvas.initialWidth / zoom,
      'height': canvas.initialHeight / zoom
    });

    // try to keep the document position to the given client position
    //
    if (center.clientX) {
      var coordsAfter = canvas.fromCanvasToDocumentCoordinate(center.x, center.y);
      canvas.scrollTo(this.canvas.getScrollTop() - (center.clientY - coordsAfter.y), canvas.getScrollLeft() - (center.clientX - coordsAfter.x));
    }

    canvas.fireEvent("zoom", { value: canvas.zoomFactor });
  },

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _debounce: function _debounce(func, wait, immediate) {
    var _this3 = this,
        _arguments = arguments;

    var timeout = void 0;
    return function () {
      var context = _this3,
          args = _arguments;
      var later = function later() {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  }
});

/***/ }),

/***/ "./src/policy/canvas/ZoomPolicy.js":
/*!*****************************************!*\
  !*** ./src/policy/canvas/ZoomPolicy.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _shifty = __webpack_require__(/*! shifty */ "./node_modules/shifty/dist/shifty.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Generic zoom policy installable into a canvas object.
 * This is the legacy implementation of the very first zooming in
 * Draw2D. You can use this implementation if you want backward compatible.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.canvas.CanvasPolicy
 * @since 5.8.0
 */
_packages2.default.policy.canvas.ZoomPolicy = _packages2.default.policy.canvas.CanvasPolicy.extend(
/** @lends draw2d.policy.canvas.ZoomPolicy.prototype */
{

  NAME: "draw2d.policy.canvas.ZoomPolicy",

  /**
   */
  init: function init() {
    this._super();
  },

  onInstall: function onInstall(canvas) {
    this._super(canvas);
    canvas.setZoom(1);
  },

  onUninstall: function onUninstall(canvas) {
    this._super(canvas);
  },

  /** 
   * Set the new zoom factor for the canvas. The value must be between [0.01..10]
   *
   *     // you can register an eventhandler to listen to the zoom factor of the canvas.
   *    //
   *     canvas.on("zoom", function(emitterFigure, zoomData){
   *         alert("canvas zoomed to:"+zoomData.factor);
   *     });
   *
   * @param {Number} zoomFactor new zoom factor.
   * @param {Boolean} [animated] set it to true for smooth zoom in/out
   **/
  setZoom: function setZoom(zoomFactor, animated) {
    var canvas = this.canvas;

    var _zoom = function _zoom(z) {
      canvas.zoomFactor = Math.min(Math.max(0.01, z), 10);

      var viewBoxWidth = canvas.initialWidth * canvas.zoomFactor | 0;
      var viewBoxHeight = canvas.initialHeight * canvas.zoomFactor | 0;

      canvas.paper.setViewBox(0, 0, viewBoxWidth, viewBoxHeight);

      canvas.fireEvent("zoom", { value: canvas.zoomFactor });
    };

    if (animated) {
      var myTweenable = new _shifty.Tweenable();
      myTweenable.tween({
        from: { 'x': canvas.zoomFactor },
        to: { 'x': zoomFactor },
        duration: 300,
        easing: "easeOutSine",
        step: function step(params) {
          return _zoom(params.x);
        },
        finish: function finish(state) {
          return canvas.fireEvent("zoomed", { value: canvas.zoomFactor });
        }
      });
    } else {
      _zoom(zoomFactor);
      canvas.fireEvent("zoomed", { value: canvas.zoomFactor });
    }
  }
});

/***/ }),

/***/ "./src/policy/connection/ClickConnectionCreatePolicy.js":
/*!**************************************************************!*\
  !*** ./src/policy/connection/ClickConnectionCreatePolicy.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.policy.connection.ClickConnectionCreatePolicy = _packages2.default.policy.connection.ConnectionCreatePolicy.extend(
/** @lends draw2d.policy.connection.ClickConnectionCreatePolicy.prototype */
{

    NAME: "draw2d.policy.connection.ClickConnectionCreatePolicy",

    /**
     *
     * Creates a new connection create policy instance
     */
    init: function init(attr, setter, getter) {
        this._super(attr, setter, getter);

        this.port1 = null;
        this.beeline = null;
        this.pulse = null;
        this.tempConnection = null;

        this.vertices = [];
    },

    /**
     * 
     * Called by the canvas if the user click on a figure.
     *
     * @param {draw2d.Figure} the figure under the click event. Can be null
     * @param {Number} x the x coordinate of the mouse during the click event
     * @param {Number} y the y coordinate of the mouse during the click event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @since 6.1.0
     */
    onClick: function onClick(figure, x, y, shiftKey, ctrlKey) {
        var _this = this;
        var port = figure;

        if (port === null && this.port1 === null) {
            return;
        }

        // nothing found at all
        //
        if (port === null) {
            this.vertices.push(new _packages2.default.geo.Point(x, y));
            this.beeline.setStartPosition(x, y);
            this.tempConnection.setVertices(this.vertices);
            if (this.pulse !== null) {
                this.pulse.remove();
                this.pulse = null;
            }
            this.ripple(x, y, 0);
            return;
        }

        //just consider ports
        //
        if (!(port instanceof _packages2.default.Port)) {
            return;
        }

        // start connection create by selection the start port
        //
        if (this.port1 === null) {
            var canvas = port.getCanvas();
            this.port1 = port;
            this.vertices.push(port.getAbsolutePosition());
            this.beeline = new _packages2.default.shape.basic.Line({
                start: this.port1.getAbsolutePosition(),
                end: this.port1.getAbsolutePosition(),
                dasharray: "- ",
                color: "#2C70FF"
            });

            this.beeline.hide = function () {
                _this.beeline.setCanvas(null);
            };

            this.beeline.show = function (canvas) {
                _this.beeline.setCanvas(canvas);
                _this.beeline.shape.toFront();
            };
            this.beeline.show(canvas);

            this.tempConnection = new _packages2.default.shape.basic.PolyLine({
                start: this.port1.getAbsolutePosition(),
                end: this.port1.getAbsolutePosition(),
                stroke: 2,
                color: "#2C70FF"
            });

            this.tempConnection.hide = function () {
                _this.tempConnection.setCanvas(null);
            };

            this.tempConnection.show = function (canvas) {
                _this.tempConnection.setCanvas(canvas);
                _this.tempConnection.shape.toFront();
            };
            this.tempConnection.show(canvas);
            this.tempConnection.setVertices([this.port1.getAbsolutePosition(), this.port1.getAbsolutePosition()]);

            var a = function a() {
                _this.tempConnection.shape.animate({ "stroke-width": 2 }, 800, b);
            };
            var b = function b() {
                _this.tempConnection.shape.animate({ "stroke-width": 1 }, 800, a);
            };
            a();

            var pos = port.getAbsolutePosition();
            this.pulse = this.ripple(pos.x, pos.y, 1);
            return;
        }

        var possibleTarget = port.delegateTarget(this.port1);

        if (!(possibleTarget instanceof _packages2.default.Port)) {
            return; // silently
        }

        var request = new _packages2.default.command.CommandType(_packages2.default.command.CommandType.CONNECT);
        request.source = this.port1;
        request.target = port;

        var command = null;
        if (this.port1 instanceof _packages2.default.InputPort) {
            command = this.port1.createCommand(request);
        } else {
            command = port.createCommand(request);
        }

        if (command !== null) {
            this.vertices.push(port.getPosition());
            command.setConnection(this.createConnection());
            figure.getCanvas().getCommandStack().execute(command);
            this.beeline.hide();
            this.tempConnection.hide();
            if (this.pulse !== null) {
                this.pulse.remove();
                this.pulse = null;
            }
            this.beeline = null;
            this.port1 = null;
            this.vertices = [];
        }
    },

    /**
     * 
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseMove: function onMouseMove(canvas, x, y, shiftKey, ctrlKey) {
        if (this.beeline !== null) {
            this.beeline.setEndPosition(x, y);
        }
    },

    /**
     * 
     * Callback if the user press a key down
     *
     * @param {draw2d.Canvas} canvas the related canvas
     * @param {Number} keyCode the pressed key
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     **/
    onKeyDown: function onKeyDown(canvas, keyCode, shiftKey, ctrlKey) {
        var KEYCODE_ENTER = 13;
        var KEYCODE_ESC = 27;
        if (keyCode === KEYCODE_ESC && this.beeline !== null) {
            this.beeline.hide();
            this.tempConnection.hide();
            this.beeline = null;
            this.port1 = null;
            this.vertices = [];
            if (this.pulse != null) {
                this.pulse.remove();
                this.pulse = null;
            }
        }
    },

    createConnection: function createConnection() {
        var connection = this._super();
        if (this.vertices.length === 2) {
            connection.setRouter(new _packages2.default.layout.connection.DirectRouter());
        } else {
            connection.setRouter(new _packages2.default.layout.connection.VertexRouter());
            connection.setVertices(this.vertices);
        }
        connection.setRadius(10);
        return connection;
    }

});
/**
 * @class
 *
 * The ClickConnectionCreatePolicy can be installed into the canvas to override the
 * default connection crate behaviour. Normally you can create connections by drag&drop a port.
 *
 * With this policy you can route the connection during creation.
 *
 * Creates a connection by clicking on a port.
 * <ul>
 *  <li> click on the first port</li>
 *  <li> click within the canvas to add additional vertices</li>
 *  <li> click on the target port to draw the connection</li>
 *  <li> press ESC to abort the operation (didn't work within this JSDoc)</li>
 * </ul>
 * <br>
 * <br>
 * <b>The generated connections didn't have any orthogonal constraints nor any other restrictions or guidance.</b>
 * <br>
 * <br>
 *
 *
 *
 * @example
 *
 *    // Override the default connection creation.
 *    //
 *    canvas.installEditPolicy( new draw2d.policy.connection.ClickConnectionCreatePolicy());
 *
 *    // create and add two Node which contains Ports (In and OUT)
 *    //
 *    var start = new draw2d.shape.node.Start({x:50, y:50});
 *    var endNode   = new draw2d.shape.node.End({x:200, y:70});
 *
 *    // add the two nodes to the canvas
 *    //
 *    canvas.add( start);
 *    canvas.add( endNode);
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.connection.ConnectionCreatePolicy
 * @since 6.1.0
 */

/***/ }),

/***/ "./src/policy/connection/ComposedConnectionCreatePolicy.js":
/*!*****************************************************************!*\
  !*** ./src/policy/connection/ComposedConnectionCreatePolicy.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.policy.connection.ComposedConnectionCreatePolicy = _packages2.default.policy.connection.ConnectionCreatePolicy.extend(
/** @lends draw2d.policy.connection.ComposedConnectionCreatePolicy.prototype */
{

    NAME: "draw2d.policy.connection.ComposedConnectionCreatePolicy",

    /**
     *
     * Creates a new connection create policy instance
     *
     * @param {array} policies the policies to use
     */
    init: function init(policies) {
        this.policies = policies;
        this._super();
    },

    onMouseDown: function onMouseDown() {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onMouseDown.apply(p, _arg);
        });
    },
    onMouseDrag: function onMouseDrag() {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onMouseDrag.apply(p, _arg);
        });
    },

    onMouseUp: function onMouseUp() {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onMouseUp.apply(p, _arg);
        });
    },

    onClick: function onClick() {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onClick.apply(p, _arg);
        });
    },
    onMouseMove: function onMouseMove() {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onMouseMove.apply(p, _arg);
        });
    },

    /**
     * @inheritDoc
     **/
    onKeyUp: function onKeyUp(canvas, keyCode, shiftKey, ctrlKey) {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onKeyUp.apply(p, _arg);
        });
    },

    /**
     * @inheritDoc
     **/
    onKeyDown: function onKeyDown(canvas, keyCode, shiftKey, ctrlKey) {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onKeyDown.apply(p, _arg);
        });
    },

    /**
     * 
     * Called if the policy is installed into the canvas.
     *
     * @param {draw2d.Canvas} canvas
     */
    onInstall: function onInstall(canvas) {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onInstall.apply(p, _arg);
        });
    },

    /**
     * 
     * Called if the policy is deinstalled from the canvas
     *
     * @param {draw2d.Canvas} canvas
     */
    onUninstall: function onUninstall(canvas) {
        var _arg = arguments;
        this.policies.forEach(function (p) {
            p.onUninstall.apply(p, _arg);
        });
    }

});
/**
 * @class
 * A composed connection create policy. Use this to install more than one
 * ConnectionCreatePolicy into the canvas. Normally it is not allowed to install
 * more than one policy from the same type.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.connection.ConnectionCreatePolicy
 */

/***/ }),

/***/ "./src/policy/connection/ConnectionCreatePolicy.js":
/*!*********************************************************!*\
  !*** ./src/policy/connection/ConnectionCreatePolicy.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.policy.connection.ConnectionCreatePolicy = _packages2.default.policy.canvas.KeyboardPolicy.extend(
/** @lends draw2d.policy.connection.ConnectionCreatePolicy.prototype */
{

    NAME: "draw2d.policy.connection.ConnectionCreatePolicy",

    /**
     *
     * Creates a new connection create policy instance
     */
    init: function init(attr, setter, getter) {
        this._super(attr, setter, getter);
    },

    /**
     * 
     * Factory method to create the connection to insert.
     *
     * @returns {draw2d.Connection}
     * @template
     */
    createConnection: function createConnection() {
        return new _packages2.default.Connection({
            router: new _packages2.default.layout.connection.DirectRouter()
        });
    },

    ripple: function ripple(x, y, type) {
        switch (type) {
            case 0:
                var circle = this.canvas.paper.circle(x, y, 3, 3).attr({ fill: null, stroke: "#d0d0ff" });
                var anim = Raphael.animation({ transform: "s6", opacity: 0.0, "stroke-width": 3 }, 500, "linear", function () {
                    circle.remove();
                });
                circle.animate(anim);
                // return an emmpty raphael.set. The circle removes itself after animation is done
                //
                return this.canvas.paper.set();
                break;
            case 1:
                var circle1 = this.canvas.paper.circle(x, y, 3, 3).attr({ fill: null, stroke: "#3f72bf" });
                var circle2 = this.canvas.paper.circle(x, y, 3, 3).attr({ fill: null, stroke: "#ff0000" });
                var anim1 = Raphael.animation({ transform: "s6", opacity: 0.0, "stroke-width": 1 }, 1200, "linear").repeat(Infinity);
                circle1.animate(anim1);
                var anim2 = Raphael.animation({ transform: "s12", opacity: 0.0, "stroke-width": 4 }, 500, "linear", function () {
                    circle2.remove();
                });
                circle2.animate(anim2);

                // return the "circle1". This shape must be remove by the caller
                // "circle2" is removed automaticly
                //
                return circle1;
                break;
        }
    }

});
/**
 * @class
 * Base class for connection creation by user interaction.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.canvas.KeyboardPolicy
 */

/***/ }),

/***/ "./src/policy/connection/DragConnectionCreatePolicy.js":
/*!*************************************************************!*\
  !*** ./src/policy/connection/DragConnectionCreatePolicy.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.policy.connection.DragConnectionCreatePolicy = _packages2.default.policy.connection.ConnectionCreatePolicy.extend(
/** @lends draw2d.policy.connection.DragConnectionCreatePolicy.prototype */
{

    NAME: "draw2d.policy.connection.DragConnectionCreatePolicy",

    /**
     *
     * Creates a new connection create policy instance
     */
    init: function init(attr, setter, getter) {
        this._super(attr, setter, getter);

        this.mouseDraggingElement = null;
        this.currentDropTarget = null;
        this.currentTarget = null;
    },

    /**
     * 
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseDown: function onMouseDown(canvas, x, y, shiftKey, ctrlKey) {
        //just consider ports
        //
        var port = canvas.getBestFigure(x, y);

        // nothing found at all
        //
        if (port === null) {
            return;
        }

        // may there is a resize handle below the port or another figure
        // in this case the ResizeHandle has prio. and handled by another
        // Policy
        if (!(port instanceof _packages2.default.Port)) {
            return;
        }

        // this can happen if the user release the mouse button outside the window during a drag&drop
        // operation. In this case we must fire the "onDragEnd" event postpond.
        //
        if (port.isInDragDrop === true) {
            port.onDragEnd(x, y, shiftKey, ctrlKey);
            port.isInDragDrop = false;
        }

        // introspect the port only if it is draggable at all
        //
        if (port.isDraggable()) {
            var canDragStart = port.onDragStart(x - port.getAbsoluteX(), y - port.getAbsoluteY(), shiftKey, ctrlKey);
            if (canDragStart) {
                port.fireEvent("dragstart", { x: x - port.getAbsoluteX(), y: y - port.getAbsoluteY(), shiftKey: shiftKey, ctrlKey: ctrlKey });
            }

            // Element send a veto about the drag&drop operation
            this.mouseDraggingElement = canDragStart === false ? null : port;
            this.mouseDownElement = port;
        }
    },

    /**
     * 
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} dx The x diff between start of dragging and this event
     * @param {Number} dy The y diff between start of dragging and this event
     * @param {Number} dx2 The x diff since the last call of this dragging operation
     * @param {Number} dy2 The y diff since the last call of this dragging operation
     * @template
     */
    onMouseDrag: function onMouseDrag(canvas, dx, dy, dx2, dy2, shiftKey, ctrlKey) {
        try {
            if (this.mouseDraggingElement !== null) {
                var de = this.mouseDraggingElement;
                var ct = this.currentTarget;

                de.isInDragDrop = true;
                de.onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey);

                var target = canvas.getBestFigure(de.getAbsoluteX(), de.getAbsoluteY(), de);

                // the hovering element has been changed
                if (target !== ct) {
                    if (ct !== null) {
                        ct.onDragLeave(de);
                        ct.fireEvent("dragLeave", { draggingElement: de });
                        de.editPolicy.each(function (i, e) {
                            if (e instanceof _packages2.default.policy.port.PortFeedbackPolicy) {
                                e.onHoverLeave(canvas, de, ct);
                            }
                        });
                    }

                    // possible hoverEnter event
                    //
                    if (target !== null) {
                        this.currentTarget = ct = target.delegateTarget(de);
                        if (ct !== null) {
                            ct.onDragEnter(de); // legacy
                            ct.fireEvent("dragEnter", { draggingElement: de });
                            de.editPolicy.each(function (i, e) {
                                if (e instanceof _packages2.default.policy.port.PortFeedbackPolicy) {
                                    e.onHoverEnter(canvas, de, ct);
                                }
                            });
                        }
                    } else {
                        this.currentTarget = null;
                    }
                }

                var p = canvas.fromDocumentToCanvasCoordinate(canvas.mouseDownX + dx / canvas.zoomFactor, canvas.mouseDownY + dy / canvas.zoomFactor);
                var target = canvas.getBestFigure(p.x, p.y, this.mouseDraggingElement);

                if (target !== this.currentDropTarget) {
                    if (this.currentDropTarget !== null) {
                        this.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                        this.currentDropTarget.fireEvent("dragLeave", { draggingElement: this.mouseDraggingElement });
                        this.currentDropTarget = null;
                    }
                    if (target !== null) {
                        this.currentDropTarget = target.delegateTarget(this.mouseDraggingElement);
                        // inform all listener that the element has accept the dragEnter event
                        //
                        if (this.currentDropTarget !== null) {
                            this.currentDropTarget.onDragEnter(this.mouseDraggingElement); // legacy
                            this.currentDropTarget.fireEvent("dragEnter", { draggingElement: this.mouseDraggingElement });
                        }
                    }
                }
            }
        } catch (exc) {
            console.log(exc);
            debugger;
        }
    },

    /**
     * 
     *
     * @param {draw2d.Figure} figure the shape below the mouse or null
     * @param {Number} x the x-coordinate of the mouse down event
     * @param {Number} y the y-coordinate of the mouse down event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     */
    onMouseUp: function onMouseUp(canvas, x, y, shiftKey, ctrlKey) {
        if (this.mouseDraggingElement !== null) {

            var de = this.mouseDraggingElement;
            var ct = this.currentTarget;
            // start CommandStack transaction
            canvas.getCommandStack().startTransaction();

            de.onDragEnd(x, y, shiftKey, ctrlKey);
            // notify all installed policies
            //
            if (ct) {
                de.editPolicy.each(function (i, e) {
                    if (e instanceof _packages2.default.policy.port.PortFeedbackPolicy) {
                        e.onHoverLeave(canvas, de, ct);
                    }
                });
            }

            de.editPolicy.each(function (i, e) {
                if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
                    e.onDragEnd(canvas, de, x, y, shiftKey, ctrlKey);
                }
            });

            // Reset the drag&drop flyover information
            //
            this.currentTarget = null;
            de.isInDragDrop = false;

            // fire an event
            // @since 5.3.3
            de.fireEvent("dragend", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });

            // check if we drop the port onto a valid
            // drop target and create a connection if possible
            //
            if (this.currentDropTarget !== null) {
                this.mouseDraggingElement.onDrop(this.currentDropTarget, x, y, shiftKey, ctrlKey);

                this.currentDropTarget.onDragLeave(this.mouseDraggingElement);
                this.currentDropTarget.fireEvent("dragLeave", { draggingElement: this.mouseDraggingElement });

                // Ports accepts only Ports as DropTarget
                //
                if (this.currentDropTarget instanceof _packages2.default.Port) {
                    var request = new _packages2.default.command.CommandType(_packages2.default.command.CommandType.CONNECT);
                    request.source = this.currentDropTarget;
                    request.target = this.mouseDraggingElement;
                    var command = this.mouseDraggingElement.createCommand(request);

                    if (command !== null) {
                        command.setConnection(this.createConnection());
                        canvas.getCommandStack().execute(command);
                        this.currentDropTarget.onCatch(this.mouseDraggingElement, x, y, shiftKey, ctrlKey);
                    }
                }
            }

            // end command stack trans
            canvas.getCommandStack().commitTransaction();
            this.currentDropTarget = null;
            this.mouseDraggingElement = null;
        }
    },

    createConnection: function createConnection() {
        var connection = this._super();
        connection.setRouter(new _packages2.default.layout.connection.DirectRouter());

        return connection;
    }

});
/**
 * @class
 *
 * The DragConnectionCreatePolicy is the default configuration for connection creation.
 * You must drag a port and drop them onto another port to create connection.
 *
 * Creates a connection by drag&drop on a port.
 * <ul>
 *  <li> click on the first port</li>
 *  <li> drag it to the target port</li>
 *  <li> drop it onto the target</li>
 * </ul>
 * <br>
 * <br>
 *
 *
 *
 * @example
 *
 *    // Override the default connection creation.
 *    //
 *    canvas.installEditPolicy( new draw2d.policy.connection.DragConnectionCreatePolicy());
 *
 *    // create and add two Node which contains Ports (In and OUT)
 *    //
 *    var start = new draw2d.shape.node.Start({x:50, y:50});
 *    var endNode   = new draw2d.shape.node.End({x:200, y:70});
 *
 *    // add the two nodes to the canvas
 *    //
 *    canvas.add( start);
 *    canvas.add( endNode);
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.connection.ConnectionCreatePolicy
 */

/***/ }),

/***/ "./src/policy/connection/OrthogonalConnectionCreatePolicy.js":
/*!*******************************************************************!*\
  !*** ./src/policy/connection/OrthogonalConnectionCreatePolicy.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.policy.connection.OrthogonalConnectionCreatePolicy = _packages2.default.policy.connection.ConnectionCreatePolicy.extend(
/** @lends draw2d.policy.connection.ClickConnectionCreatePolicy.prototype */
{

    NAME: "draw2d.policy.connection.ClickConnectionCreatePolicy",

    /**
     *
     * Creates a new connection create policy instance
      */
    init: function init(attr, setter, getter) {
        this._super(attr, setter, getter);

        this.port1 = null;
        this.beeline = null;
        this.pulse = null;
        this.tempConnection = null;

        this.vertices = new _packages2.default.util.ArrayList();
    },

    /**
     * 
     * Called by the canvas if the user click on a figure.
     *
     * @param {draw2d.Figure} the figure under the click event. Can be null
     * @param {Number} x the x coordinate of the mouse during the click event
     * @param {Number} y the y coordinate of the mouse during the click event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     *
     * @since 6.1.0
     *
     * @template
     */
    onClick: function onClick(figure, x, y, shiftKey, ctrlKey) {
        var UP = _packages2.default.geo.Rectangle.DIRECTION_UP;
        var RIGHT = _packages2.default.geo.Rectangle.DIRECTION_RIGHT;
        var DOWN = _packages2.default.geo.Rectangle.DIRECTION_DOWN;
        var LEFT = _packages2.default.geo.Rectangle.DIRECTION_LEFT;

        var _this = this;
        var port = figure; // .getCanvas().getBestFigure(x, y);

        // nothing to do
        if (port === null && this.port1 === null) {
            return;
        }

        // nothing found at all
        //
        if (port === null) {
            var canvas = this.port1.getCanvas();
            var newPos = this.beeline.getEndPosition();
            this.vertices.add(newPos);
            this.beeline.setStartPosition(this.beeline.getEndPosition());
            this.tempConnection.setVertices(this.vertices);
            if (this.pulse !== null) {
                this.pulse.remove();
                this.pulse = null;
            }
            this.ripple(newPos.x, newPos.y, 0);
            return;
        }

        // we just considering ports
        //
        if (!(port instanceof _packages2.default.Port)) {
            return;
        }

        // start connection create by selection the start port
        //
        if (this.port1 === null) {
            var canvas = port.getCanvas();
            this.port1 = port;
            this.vertices.add(port.getAbsolutePosition());
            this.beeline = new _packages2.default.shape.basic.Line({
                start: this.port1.getAbsolutePosition(),
                end: this.port1.getAbsolutePosition(),
                dasharray: "- ",
                color: "#2C70FF"
            });

            this.beeline.hide = function () {
                _this.beeline.setCanvas(null);
            };

            this.beeline.show = function (canvas) {
                _this.beeline.setCanvas(canvas);
                _this.beeline.shape.toFront();
            };
            this.beeline.show(canvas);

            this.tempConnection = new _packages2.default.shape.basic.PolyLine({
                start: this.port1.getAbsolutePosition(),
                end: this.port1.getAbsolutePosition(),
                stroke: 2,
                color: "#2C70FF"
            });

            this.tempConnection.hide = function () {
                _this.tempConnection.setCanvas(null);
            };

            this.tempConnection.show = function (canvas) {
                _this.tempConnection.setCanvas(canvas);
                _this.tempConnection.shape.toFront();
            };
            this.tempConnection.show(canvas);
            this.tempConnection.setVertices([this.port1.getAbsolutePosition(), this.port1.getAbsolutePosition()]);

            var a = function a() {
                _this.tempConnection.shape.animate({ "stroke-width": 2 }, 800, b);
            };
            var b = function b() {
                _this.tempConnection.shape.animate({ "stroke-width": 1 }, 800, a);
            };
            a();

            canvas.paper.setStart();

            // delete the previews puls if the user press twice on the starting port
            //
            if (this.pulse !== null) {
                this.pulse.remove();
                this.pulse = null;
            }

            var pos = port.getAbsolutePosition();
            this.ripple(pos.x, pos.y, 1);
            this.pulse = canvas.paper.setFinish();
        } else {
            var possibleTarget = port.delegateTarget(this.port1);

            if (!(possibleTarget instanceof _packages2.default.Port)) {
                return; // silently
            }

            // check whenever the target port allows a connection
            //
            var request = new _packages2.default.command.CommandType(_packages2.default.command.CommandType.CONNECT);
            request.source = this.port1;
            request.target = port;
            var command = null;
            if (this.port1 instanceof _packages2.default.InputPort) {
                command = this.port1.createCommand(request);
            } else {
                command = port.createCommand(request);
            }

            if (command !== null) {
                var connection = this.createConnection();
                command.setConnection(connection);
                port.getCanvas().getCommandStack().execute(command);

                this.beeline.hide();
                this.tempConnection.hide();
                if (this.pulse !== null) {
                    this.pulse.remove();
                    this.pulse = null;
                }
                this.beeline = null;
                this.port1 = null;

                // use the default routing if the user didn't add some
                // vertices
                if (this.vertices.getSize() <= 2) {
                    return;
                }

                var MINDIST = command.getConnection().getRouter().MINDIST;
                var beforeVertex = this.vertices.get(this.vertices.getSize() - 2);
                var lastVertex = this.vertices.last();
                var portPos = port.getAbsolutePosition();
                var lastSegmentDir = UP;
                if (lastVertex.x === beforeVertex.x) {
                    lastSegmentDir = lastVertex.y < beforeVertex.y ? UP : DOWN;
                } else {
                    lastSegmentDir = lastVertex.x < beforeVertex.x ? LEFT : RIGHT;
                }

                // CALCULATE THE LAST MILE OF THE CONNECTION
                //
                // ensure that we have a valid "manhattan style" connection.
                // We must add or adjust some points or segments.
                //
                // The code below creates and adjust the points in that way that the
                // DOTTED line is the calculated part to the user defined vertices.
                // ==================================
                //
                switch (port.getConnectionDirection(this.port1)) {
                    case UP:
                        switch (lastSegmentDir) {
                            case UP:
                                //       o..................o lastVertex
                                //       |         .        |
                                //       |         .        |
                                //       |    +----O----+   |
                                // ------o    | portPos |   o------------
                                //            |         |      beforeVertex
                                //            +---------+
                                //
                                if (lastVertex.y < portPos.y - MINDIST) {
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x, lastVertex.y));
                                    this.vertices.add(portPos);
                                }
                                //        ...................
                                //        .        .        .
                                //        .   +----O----+   .
                                //        o   | portPos |   o lastVertex
                                //        |   |         |   |
                                //        |   +---------+   |
                                // -------o                 o------------
                                //                            beforeVertex
                                //
                                else {
                                        lastVertex.y = portPos.y - MINDIST;
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x, lastVertex.y));
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case RIGHT:
                                //  ..............................
                                //  .                   .        .
                                //  .                   .        .
                                //  o------->o     +----O----+   o---------------->O
                                //  |              | portPos |   | beforeVertex    lastVertex
                                //  |              |         |   |
                                //  |              +---------+
                                if (lastVertex.y > portPos.y - MINDIST) {
                                    beforeVertex.y = portPos.y - MINDIST;
                                    lastVertex.x = portPos.x;
                                    lastVertex.y = beforeVertex.y;
                                    this.vertices.add(portPos);
                                }
                                //
                                //                                beforeVertex   lastVertex
                                // o---------->o..................o------------->O
                                // |                     .        |
                                // |                +----O----+   |
                                // |                | portPos |   |
                                // |                |         |   |
                                //                  +---------+
                                else {
                                        lastVertex.x = portPos.x;
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case DOWN:
                                //                           beforeVertex
                                // ------o..................o------------
                                //       |         .        |
                                //       |         .        |
                                //       V    +----O----+   V
                                //       o    | portPos |   o lastVertex
                                //            |         |
                                //            +---------+
                                //
                                if (lastVertex.y < portPos.y - MINDIST) {
                                    beforeVertex.x = portPos.x;
                                    lastVertex.setPosition(portPos);
                                }
                                //        ...................
                                //        .        .        .
                                //        .   +----O----+   . beforeVertex
                                // -------o   | portPos |   o------------
                                //        |   |         |   |
                                //        V   +---------+   V
                                //        o                 o
                                //                            lastVertex
                                //
                                else {
                                        lastVertex.y = portPos.y - MINDIST;
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x, lastVertex.y));
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case LEFT:
                                //           ..................................
                                //           .         .                       .
                                //           .         .                       .
                                // o<--------o    +----O----+   o<-------------O beforeVertex
                                //           |    | portPos |    lastVertex    |
                                //           |    |         |                  |
                                //                +---------+
                                if (lastVertex.y > portPos.y - MINDIST) {
                                    beforeVertex.y = portPos.y - MINDIST;
                                    lastVertex.x = portPos.x;
                                    lastVertex.y = beforeVertex.y;
                                    this.vertices.add(portPos);
                                }
                                //             |                               |
                                //             |                               |
                                //   o<--------o................o<-------------O
                                //                      .        lastVertex     beforeVertex
                                //                 +----O----+
                                //                 | portPos |
                                //                 |         |
                                //                 +---------+
                                else {
                                        lastVertex.x = portPos.x;
                                        this.vertices.add(portPos);
                                    }
                                break;
                        }
                        break;
                    case RIGHT:
                        switch (lastSegmentDir) {
                            case UP:
                                //                    o lastVertex
                                //                    |
                                //                    |
                                //  ------------------o beforeVertex
                                //                    .
                                //  +----------+      .
                                //  |          |      .
                                //  |  portPos O.......
                                //  |          |      .
                                //  +----------+      .
                                //                    o lastVertex
                                //                    |
                                //                    |
                                //   -----------------o beforeVertex
                                //
                                if (lastVertex.x > portPos.x + MINDIST) {
                                    lastVertex.y = portPos.y;
                                    this.vertices.add(portPos);
                                }
                                //        lastVertex
                                //      o...............
                                //      |              .
                                //      |              .
                                //  ----o beforeVertex .
                                //                     .
                                //  +----------+       .
                                //  |          |       .
                                //  |  portPos O........
                                //  |          |       .
                                //  +----------+       .
                                //      o...............
                                //      | lastVertex
                                //      |
                                //------o
                                //        beforeVertex
                                //
                                //
                                else {
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x + MINDIST, lastVertex.y));
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x + MINDIST, portPos.y));
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case RIGHT:
                                //    beforeVertex     lastVertex
                                //    o-------------->o
                                //                    .
                                //  +----------+      .
                                //  |          |      .
                                //  |  portPos O.......
                                //  |          |      .
                                //  +----------+      .
                                //                    .
                                //    o-------------->o
                                //    beforeVertex     lastVertex
                                //
                                if (lastVertex.x > portPos.x + MINDIST) {
                                    this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                // beforeVertex  lastVertex
                                // o------------>o.........
                                //                         .
                                //       +----------+      .
                                //       |          |      .
                                //       |  portPos O.......
                                //       |          |      .
                                //       +----------+      .
                                //                         .
                                //  o----------->o..........
                                // beforeVertex  lastVertex
                                //
                                else {
                                        lastVertex.x = portPos.x + MINDIST;
                                        this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, portPos.y));
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case DOWN:
                                //    ----------------o beforeVertex
                                //                    |
                                //                    |
                                //                    o lastVertex
                                //                    .
                                //  +----------+      .
                                //  |          |      .
                                //  |  portPos O.......
                                //  |          |      .
                                //  +----------+      .
                                //                    .
                                //      --------------o beforeVertex
                                //                    |
                                //                    |
                                //                    o lastVertex
                                //
                                if (lastVertex.x > portPos.x + MINDIST) {
                                    lastVertex.y = portPos.y;
                                    this.vertices.add(portPos);
                                }
                                //    -----o beforeVertex
                                //         |
                                //         | lastVertex
                                //         o...........
                                //                    .
                                //  +----------+      .
                                //  |          |      .
                                //  |  portPos O.......
                                //  |          |      .
                                //  +----------+      .
                                //                    .
                                // ----o beforeVertex .
                                //     |              .
                                //     | lastVertex   .
                                //     o...............
                                //
                                else {
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x + MINDIST, lastVertex.y));
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x + MINDIST, portPos.y));
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case LEFT:
                                //                lastVertex      beforeVertex
                                //               o<--------------o
                                //               .
                                //  +----------+ .
                                //  |          | .
                                //  |  portPos O..
                                //  |          | .
                                //  +----------+ .
                                //               .
                                //               o<--------------o
                                //                lastVertex      beforeVertex
                                //
                                if (lastVertex.x > portPos.x + MINDIST) {
                                    this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                // lastVertex                beforeVertex
                                // o<-----------------------o
                                //                      .
                                //       +----------+   .
                                //       |          |   .
                                //       |  portPos O....
                                //       |          |   .
                                //       +----------+   .
                                //                      .
                                //  o<----------------------o
                                //  lastVertex               beforeVertex
                                //
                                else {
                                        lastVertex.x = portPos.x + MINDIST;
                                        this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, portPos.y));
                                        this.vertices.add(portPos);
                                    }
                                break;
                        }
                        break;
                    case DOWN:
                        switch (lastSegmentDir) {
                            case UP:
                                //       o                  o lastVertex
                                //       |                  |
                                //       |                  |
                                //       |    +---------+   |
                                // ------o    |         |   o------------
                                //       .    | portPos |   . beforeVertex
                                //       .    +----O----+   .
                                //       .         .        .
                                //       ....................
                                //
                                if (lastVertex.y < portPos.y + MINDIST) {
                                    lastVertex.y = portPos.y + MINDIST;
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x, lastVertex.y));
                                    this.vertices.add(portPos);
                                }
                                //            +---------+
                                //            |         |
                                //            | portPos |
                                //            +----O----+
                                //                 .
                                //        o.................o lastVertex
                                //        |                 |
                                //        |                 |
                                // -------o                 o------------
                                //                            beforeVertex
                                //
                                else {
                                        lastVertex.x = portPos.x;
                                        lastVertex.y = portPos.y;
                                        beforeVertex.x = portPos.x;
                                    }
                                break;
                            case RIGHT:
                                //                 +---------+
                                //                 |         |
                                //                 | portPos |
                                //  o------->o     +----O----+    o--------------->O
                                //  |        .          .         | beforeVertex   . lastVertex
                                //  |        .....................|.................
                                //  |
                                //
                                //
                                if (lastVertex.y < portPos.y + MINDIST) {
                                    this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, portPos.y + MINDIST));
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x, portPos.y + MINDIST));
                                    this.vertices.add(portPos);
                                }
                                //                  +---------+
                                //                  |         |
                                //                  | portPos |
                                //                  +----O----+
                                //                       .
                                //             ...................................
                                //             .                    beforeVertex . lastVertex
                                // o---------->o                  o------------->O
                                // |                              |
                                // |                              |
                                //
                                else {
                                        lastVertex.x = portPos.x;
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case DOWN:
                                //                           beforeVertex
                                // ------o                  o------------
                                //       |                  |
                                //       |                  |
                                //       V    +---------+   V
                                //       o    |         |   o lastVertex
                                //       .    | portPos |   .
                                //       .    +----O----+   .
                                //       .         .        .
                                //       ....................
                                //
                                if (lastVertex.y < portPos.y + MINDIST) {
                                    lastVertex.y = portPos.y + MINDIST;
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x, lastVertex.y));
                                    this.vertices.add(portPos);
                                }
                                //
                                //            +---------+     beforeVertex
                                // -------o   | portPos |   o------------
                                //        |   |         |   |
                                //        V   +----O----+   V
                                //        o        .        o
                                //        ..................  lastVertex
                                //
                                else {
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x, lastVertex.y));
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case LEFT:
                                //
                                // o<--------o    +---------+   o<-------------O beforeVertex
                                // .         |    |         |   . lastVertex   |
                                // .         |    | portPos |   .              |
                                // .              +----O----+   .
                                // .                   .        .
                                // ..............................
                                //
                                if (lastVertex.y < portPos.y - MINDIST) {
                                    beforeVertex.y = portPos.y - MINDIST;
                                    lastVertex.x = portPos.x;
                                    lastVertex.y = beforeVertex.y;
                                    this.vertices.add(portPos);
                                }
                                //
                                //                +---------+
                                //           |    |         |               |
                                //           |    | portPos |               |
                                //           |    +----O----+               |
                                //           |         .                    |
                                // o<--------o...................o<---------o
                                //
                                else {
                                        lastVertex.x = portPos.x;
                                        this.vertices.add(portPos);
                                    }
                                break;
                        }
                        break;
                    case LEFT:
                        switch (lastSegmentDir) {
                            case UP:
                                //    ................o lastVertex
                                //    .               |
                                //    .               |
                                //  --.---------------o beforeVertex
                                //    .
                                //    .   +----------+
                                //    .   |          |
                                //    ....o  portPos |
                                //    .   |          |
                                //    .   +----------+
                                //    .
                                //    ................o lastVertex
                                //                    |
                                //                    |
                                //   -----------------o beforeVertex
                                //
                                if (lastVertex.x >= portPos.x - MINDIST) {
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, lastVertex.y));
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                //
                                //            +----------+
                                //            |          |
                                //      ......o  portPos |
                                //      .     |          |
                                //      .     +----------+
                                //      o
                                //      | lastVertex
                                //      |
                                //------o
                                //        beforeVertex
                                //
                                //
                                else if (lastVertex.y > portPos.y && lastVertex.x < portPos.x - MINDIST) {
                                        lastVertex.y = portPos.y;
                                        this.vertices.add(portPos);
                                    }
                                    //          lastVertex
                                    //      o..
                                    //      | .
                                    //      | .
                                    //  ----o .   beforeVertex
                                    //        .
                                    //        .   +----------+
                                    //        .   |          |
                                    //        ....o  portPos |
                                    //            |          |
                                    //            +----------+
                                    //
                                    else {
                                            this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, lastVertex.y));
                                            this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, portPos.y));
                                            this.vertices.add(portPos);
                                        }
                                break;
                            case RIGHT:
                                //    beforeVertex     lastVertex
                                //    o-------------->o
                                //                    .
                                // ....................
                                // .
                                // .      +----------+
                                // .      |          |
                                // .......o  portPos |
                                //        |          |
                                //        +----------+
                                //
                                if (lastVertex.y < portPos.y && lastVertex.x > portPos.x - MINDIST) {
                                    var center = portPos.y - (portPos.y - lastVertex.y) / 2;
                                    this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, center));
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, center));
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                //        +----------+
                                //        |          |
                                // .......o  portPos |
                                // .      |          |
                                // .      +----------+
                                // .
                                // ....................
                                //                    .
                                //    o-------------->o
                                //    beforeVertex     lastVertex
                                //
                                else if (lastVertex.y > portPos.y && lastVertex.x > portPos.x - MINDIST) {
                                        var center = portPos.y + (lastVertex.y - portPos.y) / 2;
                                        this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, center));
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, center));
                                        this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, portPos.y));
                                        this.vertices.add(portPos);
                                    }
                                    // beforeVertex  lastVertex
                                    // o------------>o
                                    //               .
                                    //               .   +----------+
                                    //               .   |          |
                                    //               ....o  portPos |
                                    //               .   |          |
                                    //               .   +----------+
                                    //               .
                                    //  o----------->o
                                    // beforeVertex  lastVertex
                                    //
                                    else {
                                            this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, portPos.y));
                                            this.vertices.add(portPos);
                                        }
                                break;
                            case DOWN:
                                //         -----------o beforeVertex
                                //                    |
                                //                    |
                                //                    V
                                //    ................o lastVertex
                                //    .
                                //    .       +----------+
                                //    .       |          |
                                //    ........o portPos  |
                                //    .       |          |
                                //    .       +----------+
                                //    .
                                //    .        --------o beforeVertex
                                //    .                |
                                //    .                |
                                //    .                V
                                //    .................o lastVertex
                                //
                                if (lastVertex.x >= portPos.x - MINDIST) {
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, lastVertex.y));
                                    this.vertices.add(new _packages2.default.geo.Point(portPos.x - MINDIST, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                //    -----o beforeVertex
                                //         |
                                //         |
                                //         o lastVertex
                                //         .
                                //         .       +----------+
                                //         .       |          |
                                //         ........o portPos  |
                                //             .   |          |
                                //             .   +----------+
                                // beforeVertex.
                                // ------------o
                                //             |
                                //             |
                                // lastVertex  o
                                //
                                else {
                                        lastVertex.y = portPos.y;
                                        this.vertices.add(portPos);
                                    }
                                break;
                            case LEFT:
                                //   lastVertex      beforeVertex
                                //    o<--------------o
                                //    .
                                //    .       +----------+
                                //    .       |          |
                                //    ....... o portPos  |
                                //    .       |          |
                                //    .       +----------+
                                //    .
                                //    o<--------------o
                                //    lastVertex      beforeVertex
                                //
                                if (lastVertex.x < portPos.x - MINDIST) {
                                    this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, portPos.y));
                                    this.vertices.add(portPos);
                                }
                                //         lastVertex                beforeVertex
                                //  .......o<-----------------------o
                                //  .
                                //  .    +----------+
                                //  .    |          |
                                //  .....o portPos  |
                                //  .    |          |
                                //  .    +----------+
                                //  .
                                //  ........o<----------------------o
                                //         lastVertex               beforeVertex
                                //
                                else {
                                        lastVertex.x = portPos.x - MINDIST;
                                        this.vertices.add(new _packages2.default.geo.Point(lastVertex.x, portPos.y));
                                        this.vertices.add(portPos);
                                    }
                                break;
                        }
                        break;
                }

                if (this.vertices.getSize() > 3) {
                    connection._routingMetaData.routedByUserInteraction = true;
                    connection.setVertices(this.vertices);
                }
                this.vertices.clear();
            }
        }
    },

    /**
     * 
     *
     * @param {draw2d.Canvas} canvas
     * @param {Number} x the x-coordinate of the mouse event
     * @param {Number} y the y-coordinate of the mouse event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @template
     */
    onMouseMove: function onMouseMove(canvas, x, y, shiftKey, ctrlKey) {
        if (this.beeline !== null) {
            this.beeline.setEndPosition(this.orthogonal(this.vertices.last(), { x: x, y: y }));
        }
    },

    /**
     * 
     * Callback if the user press a key down
     *
     * @param {draw2d.Canvas} canvas the related canvas
     * @param {Number} keyCode the pressed key
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onKeyDown: function onKeyDown(canvas, keyCode, shiftKey, ctrlKey) {
        var KEYCODE_ENTER = 13;
        var KEYCODE_ESC = 27;
        if (keyCode === KEYCODE_ESC && this.beeline !== null) {
            this.beeline.hide();
            this.tempConnection.hide();
            this.beeline = null;
            this.port1 = null;
            this.vertices.clear();
            if (this.pulse != null) {
                this.pulse.remove();
                this.pulse = null;
            }
        }
    },

    orthogonal: function orthogonal(anchor, p) {
        // calculate vertical line distance
        //
        var xDiff = Math.abs(anchor.x - p.x) + 10;
        var xDist = _packages2.default.geo.Line.distance(anchor.x - xDiff, anchor.y, anchor.x + xDiff, anchor.y, p.x, p.y);

        // calculate horizontal line distance
        //
        var yDiff = Math.abs(anchor.y - p.y) + 10;
        var yDist = _packages2.default.geo.Line.distance(anchor.x, anchor.y - yDiff, anchor.x, anchor.y + yDiff, p.x, p.y);

        return yDist > xDist ? { x: p.x, y: anchor.y } : { x: anchor.x, y: p.y };
    },

    createConnection: function createConnection() {
        var connection = this._super();
        connection.attr({ radius: 7, stroke: 3 });
        connection.setRouter(new _packages2.default.layout.connection.InteractiveManhattanConnectionRouter());
        return connection;
    }

});
/**
 * @class
 *
 * The OrthogonalConnectionCreatePolicy can be installed into the canvas to override the
 * default connection crate behaviour. Normaly you can create connections by drag&drop a port.
 *
 * With this policy you can route the connection during creation.
 *
 * Creates a connection by clicking on a port.
 * <ul>
 *  <li> click on the first port</li>
 *  <li> click within the canvas to add additional vertices</li>
 *  <li> click on the target port to draw the connection</li>
 *  <li> press ESC to abort the operation (didn't work within this JSDoc)</li>
 * </ul>
 * <br>
 * <br>
 * <b>The generated connection has always perpendicular segments.</b>
 * <br>
 * <br>
 *
 *
 * @example
 *
 *    // Override the default connection creation.
 *    //
 *    canvas.installEditPolicy( new draw2d.policy.connection.OrthogonalConnectionCreatePolicy());
 *
 *    // create and add two Node which contains Ports (In and OUT)
 *    //
 *    var start = new draw2d.shape.node.Start({x:50, y:50});
 *    var endNode   = new draw2d.shape.node.End({x:200, y:70});
 *
 *    // add the two nodes to the canvas
 *    //
 *    canvas.add( start);
 *    canvas.add( endNode);
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.connection.ConnectionCreatePolicy
 */

/***/ }),

/***/ "./src/policy/figure/AntSelectionFeedbackPolicy.js":
/*!*********************************************************!*\
  !*** ./src/policy/figure/AntSelectionFeedbackPolicy.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Provide support for selecting and positioning a non-resizable figure.
 * Selection is indicated via rectangular handle that outlines the figure with a 1-pixel black
 * dotted line.
 *
 *
 * @example
 *
 *      circle =new draw2d.shape.basic.Circle({diameter:50, x:90, y:50});
 *      circle.installEditPolicy(new draw2d.policy.figure.AntSelectionFeedbackPolicy());
 *      canvas.add(circle);
 *
 *      canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
_packages2.default.policy.figure.AntSelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.AntSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.AntSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Called by the framework of the Policy should show a resize handle for the given shape
   *
   * @param {draw2d.Canvas} canvas the responsible canvas
   * @param {draw2d.Figure} figure the figure to decorate with a selection feedback
   * @param {Boolean} [isPrimarySelection]
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {
    if (figure.selectionHandles.isEmpty()) {
      var box = new _packages2.default.shape.basic.Rectangle({ bgColor: null, dasharray: "- ", color: "#2C70FF" });
      box.hide = function () {
        // IMPORTANT
        // don't add/remove this rectangle to the canvas resizeHandles. This rect isn't responsible for any hitTest or
        // dragDrop operation
        //canvas.resizeHandles.remove(box);
        box.setCanvas(null);
      };
      box.show = function (canvas) {
        box.setCanvas(canvas);
        // IMPORTANT
        // don't add/remove this rectangle to the canvas resizeHandles. This rect isn't responsible for any hitTest or
        // dragDrop operation
        //canvas.resizeHandles.remove(box);
        //canvas.resizeHandles.add(box);
        box.shape.toFront();
      };
      box.show(canvas);
      figure.selectionHandles.add(box);

      // add a bee line to the parent if a parent is given and if the bounding box
      // of the parent and the figure didn't have intersections
      if (figure.getParent() !== null) {
        var line = new _packages2.default.shape.basic.Line({ opacity: 0.5, bgColor: null, dasharray: "- ", color: "#2C70FF" });
        //line.setStartPosition(figure.getBoundingBox().getCenter());
        //line.setEndPosition(figure.getParent().getBoundingBox().getCenter());
        line.show = function (canvas) {
          return line.setCanvas(canvas);
        };
        line.hide = function () {
          return line.setCanvas(null);
        };
        line.show(canvas);
        figure.selectionHandles.add(line);
        this._updateBeeLine(line, figure);
      }
    }
    this.moved(canvas, figure);
  },

  /**
   *
   * Callback if the figure has been moved
   *
   * @param figure
   *
   * @template
   */
  moved: function moved(canvas, figure) {
    if (figure.selectionHandles.isEmpty()) {
      return; // silently
    }

    var margin = 2;
    var box = figure.selectionHandles.first();
    box.setPosition(figure.getAbsolutePosition().translate(-margin, -margin));
    box.setDimension(figure.getWidth() + margin * 2, figure.getHeight() + margin * 2);
    box.setRotationAngle(figure.getRotationAngle());

    if (figure.selectionHandles.getSize() > 1) {
      this._updateBeeLine(figure.selectionHandles.get(1), figure);
    }
  },

  /**
   *
   * @param {draw2d.shape.basic.Line} line
   * @param {draw2d.Figure} figure
   * @private
   */
  _updateBeeLine: function _updateBeeLine(line, figure) {
    var parent = figure.getParent();

    if (parent === null) {
      return;
    }

    if (parent instanceof _packages2.default.shape.basic.Line) {
      var center = figure.getBoundingBox().getCenter();
      var projection = parent.pointProjection(center);
      if (projection === null) {
        var p1 = line.getStartPosition();
        var p2 = line.getEndPosition();
        var d1 = center.distance(p1);
        var d2 = center.distance(p1);
        projection = d1 < d2 ? p1 : p2;
      }
      var intersection = figure.getBoundingBox().intersectionWithLine(center, projection);
      if (intersection.getSize() > 0) {
        line.setStartPosition(figure.getBoundingBox().intersectionWithLine(center, projection).get(0)).setEndPosition(projection);
      } else {
        line.setStartPosition(figure.getBoundingBox().getCenter()).setEndPosition(projection);
      }
    } else {
      var rect1 = figure.getBoundingBox(),
          rect2 = parent.getBoundingBox();

      var center1 = rect1.getCenter();
      var center2 = rect2.getCenter();
      // the rectangle overlaps -> return the center of booth
      if (rect1.intersects(rect2)) {
        line.setStartPosition(center1).setEndPosition(center2);
      }
      // one rect is inside the other rect
      //
      else if (rect1.hitTest(center2) || rect2.hitTest(center1)) {
          line.setStartPosition(center1).setEndPosition(center2);
        } else {
          rect1.scale(3, 3);
          rect2.scale(3, 3);

          line.setStartPosition(rect1.intersectionWithLine(center1, center2).get(0)).setEndPosition(rect2.intersectionWithLine(center1, center2).get(0));
        }
    }
  }
});

/***/ }),

/***/ "./src/policy/figure/BigRectangleSelectionFeedbackPolicy.js":
/*!******************************************************************!*\
  !*** ./src/policy/figure/BigRectangleSelectionFeedbackPolicy.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *      circle =new draw2d.shape.basic.Circle();
 *      circle.installEditPolicy(new draw2d.policy.figure.BigRectangleSelectionFeedbackPolicy());
 *      canvas.add(circle,90,50);
 *
 *      canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
_packages2.default.policy.figure.BigRectangleSelectionFeedbackPolicy = _packages2.default.policy.figure.RectangleSelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.BigRectangleSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.BigRectangleSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  createResizeHandle: function createResizeHandle(owner, type) {
    return new _packages2.default.ResizeHandle({ owner: owner, type: type, width: 15, height: 15 });
  }

});

/***/ }),

/***/ "./src/policy/figure/BusSelectionFeedbackPolicy.js":
/*!*********************************************************!*\
  !*** ./src/policy/figure/BusSelectionFeedbackPolicy.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
_packages2.default.policy.figure.BusSelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.BusSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.BusSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Called by the framework of the Policy should show a resize handle for the given shape
   *
   * @param {Boolean} isPrimarySelection
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {
    if (figure.selectionHandles.isEmpty()) {
      var r2 = _packages2.default.Configuration.factory.createResizeHandle(figure, 2); // 2 = CENTER_TOP
      var r4 = _packages2.default.Configuration.factory.createResizeHandle(figure, 4); // 4 = RIGHT_MIDDLE
      var r6 = _packages2.default.Configuration.factory.createResizeHandle(figure, 6); // 6 = CENTER_BOTTOM
      var r8 = _packages2.default.Configuration.factory.createResizeHandle(figure, 8); // 8 = LEFT_MIDDLE

      figure.selectionHandles.add(r2, r4, r6, r8);

      r2.setDraggable(figure.isResizeable());
      r4.setDraggable(figure.isResizeable());
      r6.setDraggable(figure.isResizeable());
      r8.setDraggable(figure.isResizeable());

      r2.show(canvas);
      r4.show(canvas);
      r6.show(canvas);
      r8.show(canvas);
    }
    this.moved(canvas, figure);
  },

  /**
   * 
   * Callback if the figure has been moved
   *
   * @param figure
   *
   * @template
   */
  moved: function moved(canvas, figure) {
    if (figure.selectionHandles.isEmpty()) {
      return; // silently
    }
    var r2 = figure.selectionHandles.find(function (handle) {
      return handle.type === 2;
    });
    var r4 = figure.selectionHandles.find(function (handle) {
      return handle.type === 4;
    });
    var r6 = figure.selectionHandles.find(function (handle) {
      return handle.type === 6;
    });
    var r8 = figure.selectionHandles.find(function (handle) {
      return handle.type === 8;
    });

    var objHeight = figure.getHeight();
    var objWidth = figure.getWidth();

    var xPos = figure.getX();
    var yPos = figure.getY();
    r2.setPosition(xPos + objWidth / 2 - r2.getWidth() / 2, yPos - r2.getHeight());
    r4.setPosition(xPos + objWidth, yPos + objHeight / 2 - r4.getHeight() / 2);
    r6.setPosition(xPos + objWidth / 2 - r6.getWidth() / 2, yPos + objHeight);
    r8.setPosition(xPos - r8.getWidth(), yPos + objHeight / 2 - r8.getHeight() / 2);
  }

});

/***/ }),

/***/ "./src/policy/figure/DragDropEditPolicy.js":
/*!*************************************************!*\
  !*** ./src/policy/figure/DragDropEditPolicy.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Called by the framework if the user edit the position of a figure with a drag drop operation.
 * Sub class like SelectionEditPolicy or RegionEditPolicy can adjust the position of the figure or the selections handles.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.figure.FigureEditPolicy
 */
_packages2.default.policy.figure.DragDropEditPolicy = _packages2.default.policy.figure.FigureEditPolicy.extend(
/** @lends draw2d.policy.figure.DragDropEditPolicy.prototype */
{

  NAME: "draw2d.policy.figure.DragDropEditPolicy",

  /**
   */
  init: function init(attr, setter, getter) {
    var _this = this;

    this._super(attr, setter, getter);
    this.moveCallback = function (emitter, event) {
      _this.moved(emitter.getCanvas(), emitter);
    };
  },

  /**
   *
   * Called by the host if the policy has been installed.
   *
   * @param {draw2d.Canvas|draw2d.Figure} host
   */
  onInstall: function onInstall(host) {
    this._super(host);
    host.on("move", this.moveCallback);
  },

  /**
   *
   * Called by the host if the policy has been uninstalled.
   *
   * @param {draw2d.Canvas|draw2d.Figure} host
   */
  onUninstall: function onUninstall(host) {
    this._super(host);
    host.off(this.moveCallback);
  },

  /**
   *
   * Called by the framework if the related shape has init a drag&drop
   * operation
   *
   * The Policy can send a veto to prevent the DragDrop operation
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean} return <b>false</b> to send a veto to the drag operation
   */
  onDragStart: function onDragStart(canvas, figure, x, y, shiftKey, ctrlKey) {
    figure.shape.attr({ cursor: "move" });

    // this happens if you drag&drop the shape outside of the screen and
    // release the mouse button outside the window. We restore the alpha
    // with the next drag&drop operation
    if (figure.isMoving === true) {
      figure.setAlpha(figure.originalAlpha);
    }

    figure.originalAlpha = figure.getAlpha();
    figure.isMoving = false;

    // return value since 6.1.0
    return true;
  },

  /**
   *
   * Called by the framework during drag a figure.
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @template
   */
  onDrag: function onDrag(canvas, figure) {
    // enable the alpha blending of the first real move of the object
    //
    if (figure.isMoving === false) {
      figure.isMoving = true;
      figure.setAlpha(figure.originalAlpha * 0.4);
    }
  },

  /**
   *
   * Called by the framework if the drag drop operation ends.
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   */
  onDragEnd: function onDragEnd(canvas, figure, x, y, shiftKey, ctrlKey) {
    figure.shape.attr({ cursor: "default" });
    figure.isMoving = false;
    figure.setAlpha(figure.originalAlpha);
  },

  /**
   *
   * Adjust the coordinates to the rectangle/region of this constraint.
   *
   * @param {draw2d.Figure} figure
   * @param {Number|draw2d.geo.Point} x
   * @param {Number} [y]
   * @returns {draw2d.geo.Point} the constraint position of the figure
   *
   * @template
   */
  adjustPosition: function adjustPosition(figure, x, y) {
    // do nothing per default implementation
    if (x instanceof _packages2.default.geo.Point) {
      return x;
    }

    return new _packages2.default.geo.Point(x, y);
  },

  /**
   *
   * ensure that the dimension didn't goes outside the given restrictions
   *
   * @param {draw2d.Figure} figure
   * @param {Number} w
   * @param {number} h
   * @returns {draw2d.geo.Rectangle} the constraint position of the figure
   */
  adjustDimension: function adjustDimension(figure, w, h) {
    return new _packages2.default.geo.Rectangle(0, 0, w, h);
  },

  /**
   *
   * Callback if the figure has moved
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   *
   * @template
   */
  moved: function moved(canvas, figure) {}
});

/***/ }),

/***/ "./src/policy/figure/FigureEditPolicy.js":
/*!***********************************************!*\
  !*** ./src/policy/figure/FigureEditPolicy.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Called by the framework if the user edit the position of a figure with a drag drop operation.
 * Sub class like SelectionEditPolicy or RegionEditPolicy can adjust the position of the figure
 * or the selections handles.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.EditPolicy
 * @since 4.4.0
 */
_packages2.default.policy.figure.FigureEditPolicy = _packages2.default.policy.EditPolicy.extend(
/** @lends draw2d.policy.figure.FigureEditPolicy.prototype */
{

  NAME: "draw2d.policy.figure.FigureEditPolicy",

  /**
   * Creates a new Router object
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Called if the user press the right mouse on the figure.<br>
   * You can either override the "onContextMenu" method of the figure or install an editor policy and override this method.
   * Booth is valid and possible.
   *
   * @param {draw2d.Figure|draw2d.shape.basic.Line} figure the figure below the mouse
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   * @since 4.4.0
   */
  onRightMouseDown: function onRightMouseDown(figure, x, y, shiftKey, ctrlKey) {}
});

/***/ }),

/***/ "./src/policy/figure/GlowSelectionFeedbackPolicy.js":
/*!**********************************************************!*\
  !*** ./src/policy/figure/GlowSelectionFeedbackPolicy.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *      circle =new draw2d.shape.basic.Circle();
 *      circle.installEditPolicy(new draw2d.policy.figure.GlowSelectionFeedbackPolicy());
 *      canvas.add(circle,90,50);
 *
 *      canvas.add(new draw2d.shape.basic.Label("Click on the circle to see the selection feedback"),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
_packages2.default.policy.figure.GlowSelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.GlowSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.GlowSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Called by the framework of the Policy should show a resize handle for the given shape
   *
   * @param {Boolean} isPrimarySelection
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {
    figure.setGlow(true);
    this.moved(canvas, figure);
  },

  /**
   * 
   *
   * @param {draw2d.Figure} figure the unselected figure
   */
  onUnselect: function onUnselect(canvas, figure) {
    this._super(canvas, figure);
    figure.setGlow(false);
  }

});

/***/ }),

/***/ "./src/policy/figure/HBusSelectionFeedbackPolicy.js":
/*!**********************************************************!*\
  !*** ./src/policy/figure/HBusSelectionFeedbackPolicy.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.policy.figure.HBusSelectionFeedbackPolicy = _packages2.default.policy.figure.BusSelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.HBusSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.HBusSelectionFeedbackPolicy",
  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Callback if the figure has been moved
   *
   * @param figure
   *
   * @template
   */
  moved: function moved(canvas, figure) {
    if (figure.selectionHandles.isEmpty()) {
      return; // silently
    }
    var r4 = figure.selectionHandles.find(function (handle) {
      return handle.type === 4;
    });
    var r8 = figure.selectionHandles.find(function (handle) {
      return handle.type === 8;
    });

    r4.setDimension(r4.getWidth(), figure.getHeight());
    r8.setDimension(r4.getWidth(), figure.getHeight());

    this._super(canvas, figure);
  }

});
/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.BusSelectionFeedbackPolicy
 */

/***/ }),

/***/ "./src/policy/figure/HorizontalEditPolicy.js":
/*!***************************************************!*\
  !*** ./src/policy/figure/HorizontalEditPolicy.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * An EditPolicy for use with Figures. With this edit policy you can move the shape only in a horizontal manner.
 *
 *
 * @example
 *      // add some demo figure to the canvas
 *      var circle =new draw2d.shape.basic.Circle({diameter:50, x:10, y:30});
 *      canvas.add(circle);
 *
 *      // add the edit policy to the shape. At this point you can move the shape only
 *      // horizontal
 *      circle.installEditPolicy(new draw2d.policy.figure.HorizontalEditPolicy());
 *
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
_packages2.default.policy.figure.HorizontalEditPolicy = _packages2.default.policy.figure.DragDropEditPolicy.extend(
/** @lends draw2d.policy.figure.HorizontalEditPolicy.prototype */
{

  NAME: "draw2d.policy.figure.HorizontalEditPolicy",

  /**
   * Creates a new constraint object
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * It is only possible to drag&drop the element in a horizontal line
   *
   * @param figure
   * @param {Number|draw2d.geo.Point} x
   * @param {number} [y]
   *
   * @returns {draw2d.geo.Point} the constraint position of the figure
   */
  adjustPosition: function adjustPosition(figure, x, y) {
    return new _packages2.default.geo.Point(x, figure.getY());
  }

});

/***/ }),

/***/ "./src/policy/figure/RectangleSelectionFeedbackPolicy.js":
/*!***************************************************************!*\
  !*** ./src/policy/figure/RectangleSelectionFeedbackPolicy.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A SelectionFeedbackPolicy with resize handles (rectangles) on each side and corner of the shape
 *
 *
 * @example
 *
 *      circle =new draw2d.shape.basic.Circle({diameter:50});
 *      circle.installEditPolicy(new draw2d.policy.RectangleSelectionFeedbackPolicy());
 *      canvas.add(circle,90,50);
 *
 *      canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
_packages2.default.policy.figure.RectangleSelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.RectangleSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.RectangleSelectionFeedbackPolicy",
  /**
   * Creates a selection feedback for a shape.
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * @inheritdoc
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {
    if (figure.selectionHandles.isEmpty()) {
      // Add a dotted line rectangle to the figure. Override the show/hide method of the standard
      // figure to avoid adding these element to the hit test of the canvas. In this case the element
      // is just visible but not part of the model or responsible for any drag/drop operation
      // #2C70FF #2096fc
      var box = new _packages2.default.shape.basic.Rectangle({ bgColor: null, dashArray: "- ", color: "#2C70FF", stroke: 0.5 });
      box.hide = function () {
        // IMPORTANT
        // don't add/remove this rectangle to the canvas resizeHandles. This rect isn't responsible for any hitTest or
        // dragDrop operation
        //canvas.resizeHandles.remove(box);
        box.setCanvas(null);
      };
      box.show = function (canvas) {
        box.setCanvas(canvas);
        // IMPORTANT
        // don't add/remove this rectangle to the canvas resizeHandles. This rect isn't responsible for any hitTest or
        // dragDrop operation
        //canvas.resizeHandles.remove(box);
        //canvas.resizeHandles.add(box);
        box.toFront(figure);
      };

      // create standard Resize handles for the figure
      //
      var r1 = this.createResizeHandle(figure, 1); // 1 = LEFT TOP
      var r3 = this.createResizeHandle(figure, 3); // 3 = RIGHT_TOP
      var r5 = this.createResizeHandle(figure, 5); // 5 = RIGHT_BOTTOM
      var r7 = this.createResizeHandle(figure, 7); // 7 = LEFT_BOTTOM
      figure.selectionHandles.add(r1, r3, r5, r7);
      r1.show(canvas);
      r3.show(canvas);
      r5.show(canvas);
      r7.show(canvas);

      // change the look&feel of the corner resizehandles if the
      // figure isn't resizeable
      //
      if (figure.isResizeable() === false) {
        var attr = { bgColor: null, draggable: false };
        r1.attr(attr);
        r3.attr(attr);
        r5.attr(attr);
        r7.attr(attr);
        r1.setDraggable(false);
        r3.setDraggable(false);
        r5.setDraggable(false);
        r7.setDraggable(false);
      }

      // show only the additional resizehandles if the figure is resizeable and didn't care about
      // the aspect ration
      //
      if (!figure.getKeepAspectRatio() && figure.isResizeable()) {
        var r2 = this.createResizeHandle(figure, 2); // 2 = CENTER_TOP
        var r4 = this.createResizeHandle(figure, 4); // 4 = RIGHT_MIDDLE
        var r6 = this.createResizeHandle(figure, 6); // 6 = CENTER_BOTTOM
        var r8 = this.createResizeHandle(figure, 8); // 8 = LEFT_MIDDLE
        figure.selectionHandles.add(r2, r4, r6, r8);
        r2.show(canvas);
        r4.show(canvas);
        r6.show(canvas);
        r8.show(canvas);
      }

      // add the reference of the "ant box" to the figure as well. But wee add them
      // to the end of the array because inherit classes expect the resizehandles
      // on index 0-7.
      //
      figure.selectionHandles.add(box);

      // call the box.show() at last to ensure that the resize handles are above the
      // rectangle. The rectangle did a toFront(parentShape);
      box.show(canvas);
    }
    this.moved(canvas, figure);
  },

  /**
   * 
   * Callback if the figure has been moved. In this case we must update the position of the
   * resize handles and the "ant" box.
   *
   * @param figure
   *
   * @template
   */
  moved: function moved(canvas, figure) {

    if (figure.selectionHandles.isEmpty()) {
      return; // silently
    }

    var margin = 3 * canvas.getZoom();
    var objHeight = figure.getHeight();
    var objWidth = figure.getWidth();
    var xPos = figure.getAbsoluteX();
    var yPos = figure.getAbsoluteY();

    var r1 = figure.selectionHandles.find(function (handle) {
      return handle.type === 1;
    });
    var r3 = figure.selectionHandles.find(function (handle) {
      return handle.type === 3;
    });
    var r5 = figure.selectionHandles.find(function (handle) {
      return handle.type === 5;
    });
    var r7 = figure.selectionHandles.find(function (handle) {
      return handle.type === 7;
    });

    r1.setPosition(xPos - r1.getWidth(), yPos - r1.getHeight());
    r3.setPosition(xPos + objWidth, yPos - r3.getHeight());
    r5.setPosition(xPos + objWidth, yPos + objHeight);
    r7.setPosition(xPos - r7.getWidth(), yPos + objHeight);

    if (!figure.getKeepAspectRatio() && figure.isResizeable()) {
      var r2 = figure.selectionHandles.find(function (handle) {
        return handle.type === 2;
      });
      var r4 = figure.selectionHandles.find(function (handle) {
        return handle.type === 4;
      });
      var r6 = figure.selectionHandles.find(function (handle) {
        return handle.type === 6;
      });
      var r8 = figure.selectionHandles.find(function (handle) {
        return handle.type === 8;
      });

      r2.setPosition(xPos + objWidth / 2 - r2.getWidth() / 2, yPos - r2.getHeight());
      r4.setPosition(xPos + objWidth, yPos + objHeight / 2 - r4.getHeight() / 2);
      r6.setPosition(xPos + objWidth / 2 - r6.getWidth() / 2, yPos + objHeight);
      r8.setPosition(xPos - r8.getWidth(), yPos + objHeight / 2 - r8.getHeight() / 2);
    }
    var box = figure.selectionHandles.last();
    box.attr({
      x: xPos - margin,
      y: yPos - margin,
      width: objWidth + margin * 2,
      height: objHeight + margin * 2,
      stroke: canvas.getZoom()
    });

    box.setRotationAngle(figure.getRotationAngle());
  },

  createResizeHandle: function createResizeHandle(owner, type) {
    return new _packages2.default.ResizeHandle({ owner: owner, type: type, width: 10, height: 10 });
  }
});

/***/ }),

/***/ "./src/policy/figure/RegionEditPolicy.js":
/*!***********************************************!*\
  !*** ./src/policy/figure/RegionEditPolicy.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * An EditPolicy for use with Figures. The constraint for RegionEditPolicy is a Rectangle. It is
 * not possible to move the related figure outside this constrained area.
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
_packages2.default.policy.figure.RegionEditPolicy = _packages2.default.policy.figure.DragDropEditPolicy.extend(
/** @lends draw2d.policy.figure.RegionEditPolicy.prototype */
{

  NAME: "draw2d.policy.figure.RegionEditPolicy",

  /**
   * Creates a new constraint object
   *
   * @param {Number|draw2d.geo.Rectangle} x x coordinate or a rectangle as constraint for the assigned figure.
   * @param {Number} y
   * @param {Number} w
   * @param {Number} h
   */
  init: function init(x, y, w, h) {
    this._super();
    if (x instanceof _packages2.default.geo.Rectangle) {
      this.constRect = x;
    } else if (typeof h === "number") {
      this.constRect = new _packages2.default.geo.Rectangle(x, y, w, h);
    } else {
      throw "Invalid parameter. RegionEditPolicy need a rectangle as parameter in the constructor";
    }
  },

  /**
   * 
   * Update the constraint bounding box for the policy.
   *
   * @param {draw2d.geo.Rectangle} boundingBox the constraint rectangle
   * @since 4.8.2
   * @returns {this}
   */
  setBoundingBox: function setBoundingBox(boundingBox) {
    this.constRect = boundingBox;

    return this;
  },

  /**
   * 
   * Adjust the coordinates to the rectangle/region of this constraint.
   *
   * @param {draw2d.Figure} figure
   * @param {Number|draw2d.geo.Point} x
   * @param {Number} [y]
   *
   * @returns {draw2d.geo.Point} the constraint position of the figure
   */
  adjustPosition: function adjustPosition(figure, x, y) {
    var r = null;
    if (x instanceof _packages2.default.geo.Point) {
      r = new _packages2.default.geo.Rectangle(x.x, x.y, figure.getWidth(), figure.getHeight());
    } else {
      r = new _packages2.default.geo.Rectangle(x, y, figure.getWidth(), figure.getHeight());
    }
    r = this.constRect.moveInside(r);
    return r.getTopLeft();
  },

  /**
   * 
   * Adjust the dimension of the rectangle to fit into the region of the policy
   *
   * @param {draw2d.Figure} figure
   * @param {Number} w
   * @param {Number} h
   * @returns {draw2d.geo.Rectangle} the constraint position of the figure
   */
  adjustDimension: function adjustDimension(figure, w, h) {
    var diffW = figure.getAbsoluteX() + w - this.constRect.getRight();
    var diffH = figure.getAbsoluteY() + h - this.constRect.getBottom();

    if (diffW > 0) {
      w = w - diffW;
    }
    if (diffH > 0) {
      h = h - diffH;
    }

    return new _packages2.default.geo.Rectangle(0, 0, w, h);
  }
});

/***/ }),

/***/ "./src/policy/figure/ResizeSelectionFeedbackPolicy.js":
/*!************************************************************!*\
  !*** ./src/policy/figure/ResizeSelectionFeedbackPolicy.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Selection feedback policy without "marching ant lines" or any other rectangle highlight. Just
 * some resize handles at each corner of the shape.
 *
 *
 * @example
 *      circle =new draw2d.shape.basic.Circle();
 *      circle.installEditPolicy(new draw2d.policy.ResizeSelectionFeedbackPolicy());
 *      canvas.add(circle,90,50);
 *
 *      canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @since 4.0.0
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 *
 */
_packages2.default.policy.figure.ResizeSelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.ResizeSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.ResizeSelectionFeedbackPolicy",
  /**
   * Creates a new Router object
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Called by the framework of the Policy should show a resize handle for the given shape
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Figure} figure the selected figure
   * @param {Boolean} [isPrimarySelection]
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {

    if (figure.selectionHandles.isEmpty()) {
      // create standard Resize handles for the figure
      //
      var r1 = _packages2.default.Configuration.factory.createResizeHandle(figure, 1); // 1 = LEFT TOP
      var r3 = _packages2.default.Configuration.factory.createResizeHandle(figure, 3); // 3 = RIGHT_TOP
      var r5 = _packages2.default.Configuration.factory.createResizeHandle(figure, 5); // 5 = RIGHT_BOTTOM
      var r7 = _packages2.default.Configuration.factory.createResizeHandle(figure, 7); // 7 = LEFT_BOTTOM
      figure.selectionHandles.add(r1, r3, r5, r7);
      r1.show(canvas);
      r3.show(canvas);
      r5.show(canvas);
      r7.show(canvas);

      // The corner ResizeHandles are only draggable fi the figure is
      // resizeable. But the Resize handles are visible
      //

      // change the look&feel of the corner resizehandles if the
      // figure isn't resizeable
      //
      if (figure.isResizeable() === false) {
        r1.setBackgroundColor(null);
        r3.setBackgroundColor(null);
        r5.setBackgroundColor(null);
        r7.setBackgroundColor(null);
        r1.setDraggable(false);
        r3.setDraggable(false);
        r5.setDraggable(false);
        r7.setDraggable(false);
      }

      // show only the additional resizehandles if the figure is resizeable
      //
      if (!figure.getKeepAspectRatio() && figure.isResizeable()) {
        var r2 = _packages2.default.Configuration.factory.createResizeHandle(figure, 2); // 2 = CENTER_TOP
        var r4 = _packages2.default.Configuration.factory.createResizeHandle(figure, 4); // 4 = RIGHT_MIDDLE
        var r6 = _packages2.default.Configuration.factory.createResizeHandle(figure, 6); // 6 = CENTER_BOTTOM
        var r8 = _packages2.default.Configuration.factory.createResizeHandle(figure, 8); // 8 = LEFT_MIDDLE
        figure.selectionHandles.add(r2, r4, r6, r8);
        r2.show(canvas);
        r4.show(canvas);
        r6.show(canvas);
        r8.show(canvas);
      }
    }
    this.moved(canvas, figure);
  },

  /**
   *
   * Callback if the figure has been moved. In this case we must update the position of the
   * resize handles.
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Figure} figure the moved figure
   *
   */
  moved: function moved(canvas, figure) {
    if (figure.selectionHandles.isEmpty()) {
      return; // silently
    }

    var objHeight = figure.getHeight();
    var objWidth = figure.getWidth();
    var xPos = figure.getX();
    var yPos = figure.getY();

    var r1 = figure.selectionHandles.find(function (handle) {
      return handle.type === 1;
    });
    var r3 = figure.selectionHandles.find(function (handle) {
      return handle.type === 3;
    });
    var r5 = figure.selectionHandles.find(function (handle) {
      return handle.type === 5;
    });
    var r7 = figure.selectionHandles.find(function (handle) {
      return handle.type === 7;
    });
    r1.setPosition(xPos - r1.getWidth(), yPos - r1.getHeight());
    r3.setPosition(xPos + objWidth, yPos - r3.getHeight());
    r5.setPosition(xPos + objWidth, yPos + objHeight);
    r7.setPosition(xPos - r7.getWidth(), yPos + objHeight);

    if (!figure.getKeepAspectRatio()) {
      var r2 = figure.selectionHandles.find(function (handle) {
        return handle.type === 2;
      });
      var r4 = figure.selectionHandles.find(function (handle) {
        return handle.type === 4;
      });
      var r6 = figure.selectionHandles.find(function (handle) {
        return handle.type === 6;
      });
      var r8 = figure.selectionHandles.find(function (handle) {
        return handle.type === 8;
      });

      r2.setPosition(xPos + objWidth / 2 - r2.getWidth() / 2, yPos - r2.getHeight());
      r4.setPosition(xPos + objWidth, yPos + objHeight / 2 - r4.getHeight() / 2);
      r6.setPosition(xPos + objWidth / 2 - r6.getWidth() / 2, yPos + objHeight);
      r8.setPosition(xPos - r8.getWidth(), yPos + objHeight / 2 - r8.getHeight() / 2);
    }
  }

});

/***/ }),

/***/ "./src/policy/figure/RoundRectangleSelectionFeedbackPolicy.js":
/*!********************************************************************!*\
  !*** ./src/policy/figure/RoundRectangleSelectionFeedbackPolicy.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *      circle =new draw2d.shape.basic.Circle();
 *      circle.installEditPolicy(new draw2d.policy.RoundRectangleSelectionFeedbackPolicy());
 *      canvas.add(circle,90,50);
 *
 *      canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.RectangleSelectionFeedbackPolicy
 */
_packages2.default.policy.figure.RoundRectangleSelectionFeedbackPolicy = _packages2.default.policy.figure.RectangleSelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.RoundRectangleSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.RoundRectangleSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  createResizeHandle: function createResizeHandle(owner, type) {
    return new _packages2.default.ResizeHandle({ owner: owner, type: type, width: 12, height: 12, radius: 4 });
  }
});

/***/ }),

/***/ "./src/policy/figure/SelectionFeedbackPolicy.js":
/*!******************************************************!*\
  !*** ./src/policy/figure/SelectionFeedbackPolicy.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A {@link  draw2d.policy.SelectionFeedbackPolicy} that is sensitive to the canvas selection. Subclasses will typically
 * decorate the {@link draw2d.Figure figure} with things like selection handles and/or focus feedback.
 * <br>
 * If you want to change the handle visibility for a figure, then you should use SelectionFeedbackPolicy to do that.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
_packages2.default.policy.figure.SelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionPolicy.extend(
/** @lends draw2d.policy.figure.SelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.SelectionFeedbackPolicy",

  /**
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   *
   * @param {draw2d.Figure} figure the unselected figure
   */
  onUnselect: function onUnselect(canvas, figure) {
    this._super(canvas, figure);

    figure.selectionHandles.each(function (i, e) {
      return e.hide();
    });
    figure.selectionHandles = new _packages2.default.util.ArrayList();
  },

  /**
   * 
   * Called by the host if the policy has been installed.
   *
   * @param {draw2d.Figure} figure
   */
  onInstall: function onInstall(figure) {
    this._super(figure);

    var canvas = figure.getCanvas();
    if (canvas !== null) {
      if (canvas.getSelection().contains(figure)) {
        this.onSelect(canvas, figure, true);
      }
    }
  },

  /**
   * 
   * Called by the host if the policy has been uninstalled.
   *
   * @param {draw2d.Figure} figure
   */
  onUninstall: function onUninstall(figure) {
    this._super(figure);

    figure.selectionHandles.each(function (i, e) {
      return e.hide();
    });
    figure.selectionHandles = new _packages2.default.util.ArrayList();
  }

});

/***/ }),

/***/ "./src/policy/figure/SelectionPolicy.js":
/*!**********************************************!*\
  !*** ./src/policy/figure/SelectionPolicy.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A {@link  draw2d.policy.SelectionFeedbackPolicy} that is sensitive to the canvas selection. Subclasses will typically
 * decorate the {@link draw2d.Figure figure} with things like selection handles and/or focus feedback.
 * <br>
 * If you want to change the handle visibility for a figure, then you should use SelectionFeedbackPolicy to do that.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
_packages2.default.policy.figure.SelectionPolicy = _packages2.default.policy.figure.DragDropEditPolicy.extend(
/** @lends draw2d.policy.figure.SelectionPolicy.prototype */
{

  NAME: "draw2d.policy.figure.SelectionPolicy",

  /**
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   *
   * @template
   * @param figure
   * @param isPrimarySelection
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {},

  /**
   *
   *
   * @param {draw2d.Figure} figure the unselected figure
   */
  onUnselect: function onUnselect(canvas, figure) {}

});

/***/ }),

/***/ "./src/policy/figure/SlimSelectionFeedbackPolicy.js":
/*!**********************************************************!*\
  !*** ./src/policy/figure/SlimSelectionFeedbackPolicy.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Add only very small resize handles to the figure.
 *
 *
 *
 * @example
 *      circle =new draw2d.shape.basic.Circle();
 *      circle.installEditPolicy(new draw2d.policy.SlimSelectionFeedbackPolicy());
 *      canvas.add(circle,90,50);
 *
 *      canvas.add(new draw2d.shape.basic.Label({text:"Click on the circle to see the selection feedback"}),20,10);
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.RectangleSelectionFeedbackPolicy
 */
_packages2.default.policy.figure.SlimSelectionFeedbackPolicy = _packages2.default.policy.figure.RectangleSelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.SlimSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.SlimSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  createResizeHandle: function createResizeHandle(owner, type) {
    return new _packages2.default.ResizeHandle({ owner: owner, type: type, width: 6, height: 6, radius: 0 });
  }
});

/***/ }),

/***/ "./src/policy/figure/VBusSelectionFeedbackPolicy.js":
/*!**********************************************************!*\
  !*** ./src/policy/figure/VBusSelectionFeedbackPolicy.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.policy.figure.VBusSelectionFeedbackPolicy = _packages2.default.policy.figure.BusSelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.VBusSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.VBusSelectionFeedbackPolicy",
  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Callback if the figure has been moved
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   *
   **/
  moved: function moved(canvas, figure) {
    if (figure.selectionHandles.isEmpty()) {
      return; // silently
    }

    var r2 = figure.selectionHandles.find(function (handle) {
      return handle.type === 2;
    });
    var r6 = figure.selectionHandles.find(function (handle) {
      return handle.type === 6;
    });

    var objWidth = figure.getWidth();
    // adjust the resize handles on the left/right to the new dimension of the shape
    //
    r2.setDimension(objWidth, r2.getHeight());
    r6.setDimension(objWidth, r6.getHeight());

    this._super(canvas, figure);
  }

});
/**
 * @class
 *
 * Selection feedback policy for vertical bus figures.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.BusSelectionFeedbackPolicy
 */

/***/ }),

/***/ "./src/policy/figure/VertexSelectionFeedbackPolicy.js":
/*!************************************************************!*\
  !*** ./src/policy/figure/VertexSelectionFeedbackPolicy.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Called by the framework if the user edit the position of a figure with a drag drop operation.
 * Sub class like SelectionEditPolicy or RegionEditPolicy cam adjust th e position of the figure or the selections handles.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
_packages2.default.policy.figure.VertexSelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.VertexSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.VertexSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Connection} connection the selected figure
   * @param {Boolean} isPrimarySelection
   */
  onSelect: function onSelect(canvas, connection, isPrimarySelection) {
    //    	this._super(canvas, connection, isPrimarySelection);

    var points = connection.getVertices();
    for (var i = 0; i < points.getSize(); i++) {
      var handle = new _packages2.default.shape.basic.VertexResizeHandle(connection, i);
      connection.selectionHandles.add(handle);
      handle.setDraggable(connection.isResizeable());
      handle.show(canvas);

      if (i !== 0) {
        var _handle = new _packages2.default.shape.basic.GhostVertexResizeHandle(connection, i - 1);
        connection.selectionHandles.add(_handle);
        _handle.setDraggable(connection.isResizeable());
        _handle.show(canvas);
      }
    }

    this.moved(canvas, connection);
  },

  /**
   *
   * Callback method if the figure has been moved.
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   */
  moved: function moved(canvas, figure) {
    figure.selectionHandles.each(function (i, e) {
      return e.relocate();
    });
  }

});

/***/ }),

/***/ "./src/policy/figure/VerticalEditPolicy.js":
/*!*************************************************!*\
  !*** ./src/policy/figure/VerticalEditPolicy.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.policy.figure.VerticalEditPolicy = _packages2.default.policy.figure.DragDropEditPolicy.extend(
/** @lends draw2d.policy.figure.VerticalEditPolicy.prototype */
{

  NAME: "draw2d.policy.figure.VerticalEditPolicy",

  /**
   * Creates a new constraint object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * It is only possible to drag&drop the element in a vertical line
   *
   * @param {draw2d.Figure} figure
   * @param {Number|draw2d.geo.Point} x
   * @param {number} [y]
   * @returns {draw2d.geo.Point} the constraint position of the figure
   */
  adjustPosition: function adjustPosition(figure, x, y) {
    return new _packages2.default.geo.Point(figure.getX(), y);
  }

});
/**
 * @class
 *
 * An EditPolicy for use with Figures. With this edit policy you can move the shape only in a vertical manner.
 *
 *
 * @example
 *      // add some demo figure to the canvas
 *      var circle =new draw2d.shape.basic.Circle({diameter:50, x:10, y:30});
 *      canvas.add(circle);
 *
 *      // add the edit policy to the shape. At this point you can move the shape only
 *      // horizontal
 *      circle.installEditPolicy(new draw2d.policy.figure.VerticalEditPolicy());
 *
 *
 * @author Andreas Herz
 *
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */

/***/ }),

/***/ "./src/policy/figure/WidthSelectionFeedbackPolicy.js":
/*!***********************************************************!*\
  !*** ./src/policy/figure/WidthSelectionFeedbackPolicy.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * This selection shows only selection handles for the width. It is only possible to change the width
 * of an shaped. The height stays always the same or is recalculated by the figure itself.
 *
 * @example
 *      // add some demo figure to the canvas
 *      //
 *      let shape =new draw2d.shape.basic.Rectangle({width:50, height:100, x:10, y:30});
 *      canvas.add(shape);
 *
 *      // At this point you can only change the width of the shape
 *      //
 *      shape.installEditPolicy(new draw2d.policy.figure.WidthSelectionFeedbackPolicy());
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
_packages2.default.policy.figure.WidthSelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.figure.BusSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.figure.BusSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Called by the framework of the Policy should show a resize handle for the given shape
   *
   * @param {draw2d.Canvas} canvas the host of the diagram
   * @param {draw2d.Figure} figure the figure to select
   * @param {Boolean} isPrimarySelection
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {
    if (figure.selectionHandles.isEmpty()) {
      var r4 = new _packages2.default.ResizeHandle({ owner: figure, type: 4 }); // 4 = RIGHT_MIDDLE
      var r8 = new _packages2.default.ResizeHandle({ owner: figure, type: 8 }); // 8 = LEFT_MIDDLE

      r4.installEditPolicy(new _packages2.default.policy.figure.HorizontalEditPolicy());
      r8.installEditPolicy(new _packages2.default.policy.figure.HorizontalEditPolicy());
      figure.selectionHandles.add(r4, r8);

      r4.setDraggable(figure.isResizeable());
      r8.setDraggable(figure.isResizeable());

      r4.show(canvas);
      r8.show(canvas);
    }
    this.moved(canvas, figure);
  },

  /**
   *
   * Callback if the figure has been moved
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   *
   * @template
   */
  moved: function moved(canvas, figure) {
    if (figure.selectionHandles.isEmpty()) {
      return; // silently
    }
    var r4 = figure.selectionHandles.find(function (handle) {
      return handle.type === 4;
    });
    var r8 = figure.selectionHandles.find(function (handle) {
      return handle.type === 8;
    });

    var objWidth = figure.getWidth();

    var xPos = figure.getX();
    var yPos = figure.getY();
    r4.setDimension(r4.getWidth(), figure.getHeight());
    r8.setDimension(r8.getWidth(), figure.getHeight());
    r4.setPosition(xPos + objWidth, yPos);
    r8.setPosition(xPos - r8.getWidth(), yPos);
  }
});

/***/ }),

/***/ "./src/policy/line/LineSelectionFeedbackPolicy.js":
/*!********************************************************!*\
  !*** ./src/policy/line/LineSelectionFeedbackPolicy.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.SelectionFeedbackPolicy
 */
_packages2.default.policy.line.LineSelectionFeedbackPolicy = _packages2.default.policy.figure.SelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.line.LineSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.line.LineSelectionFeedbackPolicy",

  /**
   * Creates a new selection feedback policy for a line or connection
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   * Called by the framework of the Policy should show a resize handle for the given shape
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @param {Boolean} [isPrimarySelection]
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {
    if (figure.selectionHandles.isEmpty()) {
      figure.selectionHandles.add(new _packages2.default.shape.basic.LineStartResizeHandle(figure));
      figure.selectionHandles.add(new _packages2.default.shape.basic.LineEndResizeHandle(figure));

      figure.selectionHandles.each(function (i, e) {
        e.setDraggable(figure.isResizeable());
        e.show(canvas);
      });
    }
    this.moved(canvas, figure);
  },

  /**
   * 
   * Callback method if the figure has been moved.
   *
   * @template
   */
  moved: function moved(canvas, figure) {
    figure.selectionHandles.each(function (i, e) {
      return e.relocate();
    });
  }

});

/***/ }),

/***/ "./src/policy/line/OrthogonalSelectionFeedbackPolicy.js":
/*!**************************************************************!*\
  !*** ./src/policy/line/OrthogonalSelectionFeedbackPolicy.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _jquery = __webpack_require__(/*! lib/jquery.contextmenu */ "./src/lib/jquery.contextmenu.js");

var _jquery2 = _interopRequireDefault(_jquery);

var _contextmenu = __webpack_require__(/*! css/contextmenu.css */ "./src/css/contextmenu.css");

var _contextmenu2 = _interopRequireDefault(_contextmenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Feedback and edit policy for the InteractiveManhattanRouter.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.line.LineSelectionFeedbackPolicy
 */
// do not delete them
_packages2.default.policy.line.OrthogonalSelectionFeedbackPolicy = _packages2.default.policy.line.LineSelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.line.OrthogonalSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.line.OrthogonalSelectionFeedbackPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    // The ResizeHandle for the Policy. This is inline to avoid that a user want to use them without
    // the right installed policy.
    //
    this.ResizeHandle = _packages2.default.ResizeHandle.extend(
    /** @lends draw2d.policy.line.OrthogonalSelectionFeedbackPolicy.ResizeHandle.prototype */
    {

      NAME: "draw2d.policy.line.OrthogonalSelectionFeedbackPolicy.ResizeHandle",

      init: function init(owner, index) {
        this._super({ owner: owner });
        this.index = index;
      },

      /**
       * 
       * Called if a drag&drop operation starts.<br>
       * @param {Number} x the x-coordinate of the mouse up event
       * @param {Number} y the y-coordinate of the mouse up event
       * @param {Boolean} shiftKey true if the shift key has been pressed during this event
       * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
       *
       * @private
       **/
      onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
        this._super(x, y, shiftKey, ctrlKey);
        this.command = this.getCanvas().getPrimarySelection().createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.MOVE_VERTICES));

        // Vertex is a reference and not a copy of the point
        this.vertex = this.owner.getVertex(this.index).clone();
      },

      /**
       * 
       * Called from the framework during a drag&drop operation of the ResizeHandles
       *
       * @param {Number} dx the x difference between the start of the drag drop operation and now
       * @param {Number} dy the y difference between the start of the drag drop operation and now
       * @param {Number} dx2 The x diff since the last call of this dragging operation
       * @param {Number} dy2 The y diff since the last call of this dragging operation
       *
       * @returns {Boolean}
       **/
      onDrag: function onDrag(dx, dy, dx2, dy2) {
        if (this.command == null) {
          return false;
        }

        var MINDIST = this.owner.getRouter().MINDIST || 10;

        var fromDir = this.owner.getSource().getConnectionDirection(this.owner.getTarget());
        var toDir = this.owner.getTarget().getConnectionDirection(this.owner.getSource());

        this.vertex.translate(dx2, dy2);

        var vertices = this.owner.getVertices();
        var count = vertices.getSize();
        //shortcut for math operations
        var max = Math.max;
        var min = Math.min;

        // Keep in mind: "p1" is always the dragged handle in the coding below
        //               marked with an '*' in the diagram
        //

        // FIRST handle of the connection
        //
        if (this.index === 1) {
          var p0 = vertices.get(this.index - 1); // first vertex of the connection
          var p1 = vertices.get(this.index); // dragged vertex
          var p2 = vertices.get(this.index + 1); // additional neighbor

          // vertex alignment to handle:
          //
          //      p0 +-----* p1       p1 *------+ p0
          //               |             |
          //               |             |
          //               + p2       p2 +
          if (p1.x === p2.x && p0.y === p1.y) {
            switch (fromDir) {
              case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
                // p0 is on the left of p1
                //
                this.owner.setVertex(1, max(p0.x + MINDIST, this.vertex.x), p1.y); // p1
                this.owner.setVertex(2, max(p0.x + MINDIST, this.vertex.x), p2.y); // p2
                break;
              // p0 is on the right of p2
              //
              case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
                this.owner.setVertex(1, min(p0.x - MINDIST, this.vertex.x), p1.y); // p1
                this.owner.setVertex(2, min(p0.x - MINDIST, this.vertex.x), p2.y); // p2
                break;
            }
          }

          // vertices alignment to handle:
          //
          //      p0 +              p1 *--------+ p2
          //         |                 |
          //         |                 |
          //      p1 *-----+ p2     p0 +
          else {
              switch (fromDir) {
                case _packages2.default.geo.Rectangle.DIRECTION_UP:
                  // p0 is below of p1
                  //
                  this.owner.setVertex(1, p1.x, min(p0.y - MINDIST, this.vertex.y)); // p1
                  this.owner.setVertex(2, p2.x, min(p0.y - MINDIST, this.vertex.y)); // p2
                  break;
                // p0 is above of p2
                //
                case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
                  this.owner.setVertex(1, p1.x, max(p0.y + MINDIST, this.vertex.y)); // p1
                  this.owner.setVertex(2, p2.x, max(p0.y + MINDIST, this.vertex.y)); // p2
                  break;
              }
            }
        }

        // LAST handle: Only the left hand side sibling can be changed
        //
        else if (this.index === count - 2) {
            var _p = vertices.get(this.index - 1); // neighbor of the dragged vertex
            var _p2 = vertices.get(this.index); // dragged vertex
            var _p3 = vertices.get(this.index + 1); // last vertex of the connection

            // vertices with this alignment.
            //
            //      p2 +-----* p1                 + p0
            //               |                    |
            //               |                    |
            //               + p0     p2 +--------* p1
            if (_p3.x === _p2.x && _p.y === _p2.y) {
              switch (toDir) {
                // p0 is below of p1
                case _packages2.default.geo.Rectangle.DIRECTION_UP:
                  this.owner.setVertex(count - 2, _p2.x, min(_p3.y - MINDIST, this.vertex.y)); // p1
                  this.owner.setVertex(count - 3, _p.x, min(_p3.y - MINDIST, this.vertex.y)); // p2
                  break;
                // p0 is above p2
                case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
                  this.owner.setVertex(count - 2, _p2.x, max(_p3.y + MINDIST, this.vertex.y)); // p1
                  this.owner.setVertex(count - 3, _p.x, max(_p3.y + MINDIST, this.vertex.y)); // p2
                  break;
              }
            }

            // vertices with this alignment.
            //
            //      p2 +              p0 +--------* p1
            //         |                          |
            //         |                          |
            //      p1 *-----+ p0              p2 +
            else {
                switch (toDir) {
                  case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
                    // p0 is on the left of p1
                    //
                    this.owner.setVertex(count - 2, max(_p3.x + MINDIST, this.vertex.x), _p2.y); // p1
                    this.owner.setVertex(count - 3, max(_p3.x + MINDIST, this.vertex.x), _p.y); // p2
                    break;
                  // p0 is on the right of p2
                  //
                  case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
                    this.owner.setVertex(count - 2, min(_p3.x - MINDIST, this.vertex.x), _p2.y); // p1
                    this.owner.setVertex(count - 3, min(_p3.x - MINDIST, this.vertex.x), _p.y); // p2
                    break;
                }
              }
          }
          // The resize handle is in the middle of the connection.
          // -> In this case the connection MUST HAVE at least 5 vertices
          //
          else {
              var p_m1 = vertices.get(this.index - 2);
              var _p4 = vertices.get(this.index - 1);
              var _p5 = vertices.get(this.index); // selected DragHandle
              var _p6 = vertices.get(this.index + 1);
              var p3 = vertices.get(this.index + 2);

              // vertices alignment to handle
              //
              //               .              .
              //               .              .
              //   p1 *------->+  p0      p0  +<---------* p1
              //      |        .              .          |
              //      |        .              .          |
              //   p2 |                                  | p2
              //   ...+...                         ......+.....
              //
              if (_p5.x === _p6.x && _p5.y === _p4.y) {
                // Exception handling if the dragged handle (p1) is near by the start of the connection
                // p_m1 is the start of the connection
                // p0 must be the immediate neighbor of p_m1
                //
                if (this.index - 2 === 0) {
                  switch (fromDir) {
                    case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
                      this.owner.setVertex(this.index - 1, _p4.x, max(this.vertex.y, p_m1.y - MINDIST)); // p0
                      this.owner.setVertex(this.index, this.vertex.x, max(this.vertex.y, p_m1.y - MINDIST)); // p1
                      this.owner.setVertex(this.index + 1, this.vertex.x, _p6.y); // p2
                      break;
                    case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
                      this.owner.setVertex(this.index - 1, _p4.x, min(this.vertex.y, p_m1.y + MINDIST)); // p0
                      this.owner.setVertex(this.index, this.vertex.x, this.vertex.y); // p1
                      this.owner.setVertex(this.index + 1, this.vertex.x, _p6.y); // p2
                      break;
                    case _packages2.default.geo.Rectangle.DIRECTION_UP:
                      this.owner.setVertex(this.index - 1, _p4.x, min(this.vertex.y, p_m1.y - MINDIST)); // p0
                      this.owner.setVertex(this.index, this.vertex.x, min(this.vertex.y, p_m1.y - MINDIST)); // p1
                      this.owner.setVertex(this.index + 1, this.vertex.x, _p6.y); // p2
                      break;
                    case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
                      this.owner.setVertex(this.index - 1, _p4.x, max(this.vertex.y, p_m1.y + MINDIST)); // p0
                      this.owner.setVertex(this.index, this.vertex.x, max(this.vertex.y, p_m1.y + MINDIST)); // p1
                      this.owner.setVertex(this.index + 1, this.vertex.x, _p6.y); // p2
                      break;
                  }
                }
                // Exception handling if the dragged handle (p1L) near by the end of the connection
                // p3 is the end of the connection
                //
                else if (this.index - count + 3 === 0) {
                    switch (toDir) {
                      case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
                        this.owner.setVertex(this.index - 1, _p4.x, this.vertex.y); // p0
                        this.owner.setVertex(this.index, max(this.vertex.x, p3.x + MINDIST), this.vertex.y); // p1
                        this.owner.setVertex(this.index + 1, max(this.vertex.x, p3.x + MINDIST), _p6.y); // p2
                        break;
                      case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
                        this.owner.setVertex(this.index - 1, _p4.x, this.vertex.y); // p0
                        this.owner.setVertex(this.index, min(this.vertex.x, p3.x - MINDIST), this.vertex.y); // p1
                        this.owner.setVertex(this.index + 1, min(this.vertex.x, p3.x - MINDIST), _p6.y); // p2
                        break;
                    }
                  } else {
                    this.owner.setVertex(this.index - 1, _p4.x, this.vertex.y); // p0
                    this.owner.setVertex(this.index, this.vertex); // p1
                    this.owner.setVertex(this.index + 1, this.vertex.x, _p6.y); // p2
                  }
              }
              // vertices alignment to handle
              //
              //  ...+...                            ...+...
              //  p0 |                        .         | p0
              //     |          .             .         |
              //     |          .             .         |
              //  p1 *----------+ p2      p2  +---------* p1
              //                .             .
              //                .             .
              else if (_p4.x === _p5.x && _p5.y === _p6.y) {
                  // p_m1 is the start of the analyzed segment
                  // p0 must be the immediate neighbor of p_m1
                  //
                  if (this.index - 2 === 0) {
                    switch (fromDir) {
                      case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
                        this.owner.setVertex(this.index - 1, max(this.vertex.x, p_m1.x + MINDIST), _p4.y); // p0
                        this.owner.setVertex(this.index, max(this.vertex.x, p_m1.x + MINDIST), this.vertex.y); // p1
                        this.owner.setVertex(this.index + 1, _p6.x, this.vertex.y); // p2
                        break;
                      case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
                        this.owner.setVertex(this.index - 1, min(this.vertex.x, p_m1.x - MINDIST), _p4.y); // p0
                        this.owner.setVertex(this.index, min(this.vertex.x, p_m1.x - MINDIST), this.vertex.y); // p1
                        this.owner.setVertex(this.index + 1, _p6.x, this.vertex.y); // p2
                        break;
                    }
                  }
                  // p3 is the end point
                  //
                  else if (this.index - count + 3 === 0) {
                      switch (toDir) {
                        case _packages2.default.geo.Rectangle.DIRECTION_UP:
                          this.owner.setVertex(this.index - 1, this.vertex.x, max(this.vertex.y, _p4.y)); // p0
                          this.owner.setVertex(this.index, this.vertex.x, min(this.vertex.y, p3.y - MINDIST)); // p1
                          this.owner.setVertex(this.index + 1, _p6.x, min(this.vertex.y, p3.y - MINDIST)); // p2
                          break;
                        case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
                          this.owner.setVertex(this.index - 1, this.vertex.x, _p4.y); // p0
                          this.owner.setVertex(this.index, this.vertex.x, max(this.vertex.y, p3.y + MINDIST)); // p1
                          this.owner.setVertex(this.index + 1, _p6.x, max(this.vertex.y, p3.y + MINDIST)); // p2
                          break;
                      }
                    }
                    // just any element in the middle of the connection
                    //
                    else {
                        this.owner.setVertex(this.index - 1, this.vertex.x, _p4.y); // p0
                        this.owner.setVertex(this.index, this.vertex); // p1
                        this.owner.setVertex(this.index + 1, _p6.x, this.vertex.y); // p2
                      }
                }
            }

        this.relocate();

        // update the command for the undo/redo stuff
        //
        if (this.command !== null) {
          this.command.updateVertices(this.owner.getVertices().clone());
        }

        // note that the user has changed the routing manually.
        // This skips the automatic routing.
        this.owner._routingMetaData.routedByUserInteraction = true;
        return true;
      },

      /**
       *  Called after a drag and drop action.<br>
       *        Sub classes can override this method to implement additional stuff. Don't forget to call the super implementation via <code>this._super();</code>
       *
       * @param {Number} x the x-coordinate of the mouse event
       * @param {Number} y the y-coordinate of the mouse event
       * @param {Boolean} shiftKey true if the shift key has been pressed during this event
       * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
       *
       * @returns {Boolean}
       */
      onDragEnd: function onDragEnd(x, y, shiftKey, ctrlKey) {
        var stack = this.getCanvas().getCommandStack();

        stack.execute(this.command);
        this.command = null;
        return true;
      },

      /**
       * 
       * Controls the location of the resize handle
       *
       * @template
       **/
      relocate: function relocate() {

        var resizeWidthHalf = this.getWidth() / 2;
        var resizeHeightHalf = this.getHeight() / 2;

        var anchor = this.owner.getVertices().get(this.index);
        if (anchor) this.setPosition(anchor.x - resizeWidthHalf, anchor.y - resizeHeightHalf);
      }

    });
  },

  /**
   * 
   *
   * @template
   * @param {draw2d.Connection} connection the selected figure
   * @param {Boolean} isPrimarySelection
   */
  onSelect: function onSelect(canvas, connection, isPrimarySelection) {
    this._super(canvas, connection, isPrimarySelection);

    var points = connection.getVertices();
    var i = 1;
    for (; i < points.getSize() - 1; i++) {
      var handle = new this.ResizeHandle(connection, i);
      connection.selectionHandles.add(handle);
      handle.setDraggable(connection.isResizeable());
      handle.show(canvas);
    }

    this.moved(canvas, connection);
  },

  /**
   * 
   * remove the segment with the given index.
   * You must check if it possible to remove the segment before. The method didn'T do any consistency checks.
   *
   * @param conn
   * @param segmentIndex
   */
  removeSegment: function removeSegment(conn, segmentIndex) {
    var PADDING = 10;

    var segmentCount = conn.getVertices().getSize() - 1;

    var fromPt = conn.getStartPoint();
    var fromDir = conn.getSource().getConnectionDirection(conn.getTarget());

    var toPt = conn.getEndPoint();
    var toDir = conn.getTarget().getConnectionDirection(conn.getSource());

    var p0 = conn.getVertex(segmentIndex - 1);
    var p1 = conn.getVertex(segmentIndex);
    var p2 = conn.getVertex(segmentIndex + 1);
    var p3 = conn.getVertex(segmentIndex + 2);

    //                                             p0 .
    // Es wird ein Horizontales Segment               .
    // geloescht. Es muessen somit die Punkte         .
    // p0 und p3 neu gesetzt werden.               p1 +------*-----+ p2
    // Ihre neue X-Koordinate ist somit in der               ^     .
    // Mitte des geloeschten Segmentes                      newX   .
    //                                                             . p3
    //
    if (p1.y === p2.y) {
      var _newX = (p1.x + p2.x) / 2;
      // Die neue X-Koordinate muss auf jeden Falls zwischen p-1 und p4 liegen
      //
      if (segmentIndex === 1) {
        switch (fromDir) {
          case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
            _newX = Math.max(_newX, fromPt.x + PADDING);
            break;
          case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
            _newX = Math.min(_newX, fromPt.x - PADDING);
            break;
          case _packages2.default.geo.Rectangle.DIRECTION_UP:
            _newX = fromPt.x;
            break;
          case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
            _newX = fromPt.x;
            break;
        }
      }

      if (segmentIndex === segmentCount - 2) {
        switch (fromDir) {
          case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
            _newX = Math.max(_newX, toPt.x + PADDING);
            break;
          case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
            _newX = Math.min(_newX, toPt.x - PADDING);
            break;
          case _packages2.default.geo.Rectangle.DIRECTION_UP:
            _newX = toPt.x;
            break;
          case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
            _newX = toPt.x;
            break;
        }
      }

      conn.setVertex(segmentIndex - 1, new _packages2.default.geo.Point(_newX, p0.y));
      conn.setVertex(segmentIndex + 2, new _packages2.default.geo.Point(_newX, p3.y));

      conn.removeVertexAt(segmentIndex);
      conn.removeVertexAt(segmentIndex);
      conn._routingMetaData.routedByUserInteraction = true;
    }

    //                                                         p2       p3
    // Es wird ein vertikales Segment                        +..........+
    // geloescht. Es muessen somit die Punkte                |
    // p0 und p3 neu gesetzt werden.                         |
    // Ihre neue Y-Koordinate ist somit in der               |
    // Mitte des geloeschten Segmentes              p0       | p1
    //                                              +........+
    //
    else if (p1.x === p2.x) {
        var newY = (p1.y + p2.y) / 2;
        // Die neue Y-Koordinate muss auf jeden Falls zwischen p-1 und p4 liegen
        //
        if (segmentIndex === 1) {
          switch (fromDir) {
            case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
            case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
              newY = fromPt.y;
              break;
            case _packages2.default.geo.Rectangle.DIRECTION_UP:
            case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
              debugger; // newX is newer read....why did I calculate them?!
              newX = fromPt.x;
              break;
          }
        }
        if (segmentIndex === segmentCount - 2) {
          switch (toDir) {
            case _packages2.default.geo.Rectangle.DIRECTION_RIGHT:
            case _packages2.default.geo.Rectangle.DIRECTION_LEFT:
              newY = toPt.y;
              break;
            case _packages2.default.geo.Rectangle.DIRECTION_UP:
            case _packages2.default.geo.Rectangle.DIRECTION_DOWN:
              debugger; // newX is newer read....why did I calculate them?!
              newX = toPt.x;
              break;
          }
        }

        conn.setVertex(segmentIndex - 1, new _packages2.default.geo.Point(p0.x, newY));
        conn.setVertex(segmentIndex + 2, new _packages2.default.geo.Point(p3.x, newY));

        conn.removeVertexAt(segmentIndex);
        conn.removeVertexAt(segmentIndex);
        conn._routingMetaData.routedByUserInteraction = true;
      }
  },

  /**
   * 
   * split the segment with the given index and insert a new segment.
   *
   * @param conn
   * @param segmentIndex
   */
  splitSegment: function splitSegment(conn, segmentIndex, x, y) {
    var segmentCount = conn.getVertices().getSize() - 1;
    var p1 = conn.getVertex(segmentIndex);
    var p2 = conn.getVertex(segmentIndex + 1);
    var length = 40;

    // the selected segment is vertical
    //
    if (p1.x === p2.x) {
      conn._routingMetaData.routedByUserInteraction = true;
      // edge case of an ManhattanRouter: One segment. This happens if the source/target on the same x - coordinate
      //
      if (segmentCount === 1) {
        //     + p1
        //     |
        // np1 +-----+ np2
        //           |
        //           |
        // np3 +-----+ np3
        //     |
        //     |
        //     + p2
        //
        var newSegLength = p1.getDistance(p2) / 4 / 2;
        var np1 = new _packages2.default.geo.Point(p1.x, y - newSegLength);
        var np2 = new _packages2.default.geo.Point(p2.x + length, y - newSegLength);
        var np3 = new _packages2.default.geo.Point(p2.x + length, y + newSegLength);
        var np4 = new _packages2.default.geo.Point(p2.x, y + newSegLength);

        conn.insertVertexAt(segmentIndex + 1, np1);
        conn.insertVertexAt(segmentIndex + 2, np2);
        conn.insertVertexAt(segmentIndex + 3, np3);
        conn.insertVertexAt(segmentIndex + 4, np4);
      } else {
        var _np = new _packages2.default.geo.Point(0, 0);
        var _np2 = new _packages2.default.geo.Point(0, 0);
        //       p2 +
        //          .
        // np1 +----+ np2
        //     .
        //     .
        //     + p1
        // p1 ist der Startpunkt und darf somit nicht verschoben werden
        //
        if (segmentIndex === 0) {
          _np.y = y;
          _np.x = p1.x;
          _np2.y = y;
          _np2.x = p2.x + length;
          conn.setVertex(segmentIndex + 1, new _packages2.default.geo.Point(_np2.x, p2.y));
        }
        // p2 ist der Schlusspunkt und darf somit nicht veaendert werden
        //
        else if (segmentIndex === segmentCount - 1) {
            _np.y = y;
            _np.x = p1.x - length;
            _np2.y = y;
            _np2.x = p2.x;
            conn.setVertex(segmentIndex, new _packages2.default.geo.Point(_np.x, p1.y));
          } else {
            _np.y = y;
            _np.x = p1.x - length / 2;
            _np2.y = y;
            _np2.x = p2.x + length / 2;
            conn.setVertex(segmentIndex, new _packages2.default.geo.Point(_np.x, p1.y));
            conn.setVertex(segmentIndex + 1, new _packages2.default.geo.Point(_np2.x, p2.y));
          }

        conn.insertVertexAt(segmentIndex + 1, _np);
        conn.insertVertexAt(segmentIndex + 2, _np2);
      }
    }
    // the selected segment is horizontal
    //
    else if (p1.y == p2.y) {
        conn._routingMetaData.routedByUserInteraction = true;
        // edge case of an ManhattanRouter: One segment. This happens if the source/target on the same y - coordinate
        //
        if (segmentCount === 1) {
          //     np2 +---------+ np3
          //         |         |
          // --------+np1   np4+--------
          //
          var _newSegLength = p1.getDistance(p2) / 4 / 2;
          var _np3 = new _packages2.default.geo.Point(x - _newSegLength, p1.y);
          var _np4 = new _packages2.default.geo.Point(x - _newSegLength, p1.y - length);
          var _np5 = new _packages2.default.geo.Point(x + _newSegLength, p1.y - length);
          var _np6 = new _packages2.default.geo.Point(x + _newSegLength, p1.y);

          conn.insertVertexAt(segmentIndex + 1, _np3);
          conn.insertVertexAt(segmentIndex + 2, _np4);
          conn.insertVertexAt(segmentIndex + 3, _np5);
          conn.insertVertexAt(segmentIndex + 4, _np6);
        } else {
          //     p1        np1
          //   +.........+
          //             |
          //             |
          //             | np2       p2
          //             +.........+
          var _np7 = new _packages2.default.geo.Point(0, 0);
          var _np8 = new _packages2.default.geo.Point(0, 0);

          // p1 ist der Startpunkt und darf somit nicht verschoben werden
          //
          if (segmentIndex === 0) {
            _np7.x = x;
            _np7.y = p1.y;
            _np8.x = x;
            _np8.y = p2.y + length;
            conn.setVertex(segmentIndex + 1, new _packages2.default.geo.Point(p2.x, _np8.y));
          }
          // p2 ist der Schlusspunkt und darf somit nicht veaendert werden
          //
          else if (segmentIndex === segmentCount - 1) {
              _np7.x = x;
              _np7.y = p1.y - length;
              _np8.x = x;
              _np8.y = p2.y;
              conn.setVertex(segmentIndex, new _packages2.default.geo.Point(p1.x, _np7.y));
            } else {
              _np7.x = x;
              _np7.y = p1.y - length / 2;
              _np8.x = x;
              _np8.y = p2.y + length / 2;
              conn.setVertex(segmentIndex, new _packages2.default.geo.Point(p1.x, _np7.y));
              conn.setVertex(segmentIndex + 1, new _packages2.default.geo.Point(p2.x, _np8.y));
            }
          conn.insertVertexAt(segmentIndex + 1, _np7);
          conn.insertVertexAt(segmentIndex + 2, _np8);
        }
      }
  },

  /**
   * 
   * Called if the user press the right mouse on the figure.<br>
   * You can either override the "onContextMenu" method of the figure or install an editor policy and override this method.
   * Booth is valid and possible.
   *
   * @param {draw2d.shape.basic.Line} conn the polyline below the mouse
   * @param {Number} x the x-coordinate of the mouse down event
   * @param {Number} y the y-coordinate of the mouse down event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   * @since 4.4.0
   */
  onRightMouseDown: function onRightMouseDown(conn, x, y, shiftKey, ctrlKey) {
    var _this = this;

    var segment = conn.hitSegment(x, y);
    var items = { "split": { name: _packages2.default.Configuration.i18n.menu.addSegment } };

    if (segment === null) {
      return;
    }

    if (conn.getRouter().canRemoveSegmentAt(conn, segment.index)) {
      items.remove = { name: _packages2.default.Configuration.i18n.menu.deleteSegment };
    }

    $.contextMenu({
      selector: 'body',
      events: {
        hide: function hide() {
          $.contextMenu('destroy');
        }
      },
      callback: function callback(key, options) {
        switch (key) {
          case "remove":
            {
              // deep copy of the vertices of the connection for the command stack to avoid side effects
              var originalVertices = conn.getVertices().clone(true);
              _this.removeSegment(conn, segment.index);
              var newVertices = conn.getVertices().clone(true);
              conn.getCanvas().getCommandStack().execute(new _packages2.default.command.CommandReplaceVertices(conn, originalVertices, newVertices));
            }
            break;
          case "split":
            {
              // deep copy of the vertices of the connection for the command stack to avoid side effects
              var _originalVertices = conn.getVertices().clone(true);
              _this.splitSegment(conn, segment.index, x, y);
              var _newVertices = conn.getVertices().clone(true);
              conn.getCanvas().getCommandStack().execute(new _packages2.default.command.CommandReplaceVertices(conn, _originalVertices, _newVertices));
            }
            break;
          default:
            break;
        }
      },
      x: x,
      y: y,
      items: items
    });
  }
});

/***/ }),

/***/ "./src/policy/line/VertexSelectionFeedbackPolicy.js":
/*!**********************************************************!*\
  !*** ./src/policy/line/VertexSelectionFeedbackPolicy.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Feedback and edit policy for the VertexRouter.
 *
 * @author  Andreas Herz
 * @extends draw2d.policy.line.LineSelectionFeedbackPolicy
 */
_packages2.default.policy.line.VertexSelectionFeedbackPolicy = _packages2.default.policy.line.LineSelectionFeedbackPolicy.extend(
/** @lends draw2d.policy.line.VertexSelectionFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.line.VertexSelectionFeedbackPolicy",

  /**
   *
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   * 
   *
   * @param {draw2d.Canvas} canvas the related canvas
   * @param {draw2d.Connection} figure the selected figure
   * @param {Boolean} isPrimarySelection
   */
  onSelect: function onSelect(canvas, figure, isPrimarySelection) {
    var startHandle = new _packages2.default.shape.basic.LineStartResizeHandle(figure);
    var endHandle = new _packages2.default.shape.basic.LineEndResizeHandle(figure);
    figure.selectionHandles.add(startHandle);
    figure.selectionHandles.add(endHandle);

    var points = figure.getVertices();
    var count = points.getSize() - 1;
    var i = 1;
    for (; i < count; i++) {
      figure.selectionHandles.add(new _packages2.default.shape.basic.VertexResizeHandle(figure, i));
      figure.selectionHandles.add(new _packages2.default.shape.basic.GhostVertexResizeHandle(figure, i - 1));
    }

    figure.selectionHandles.add(new _packages2.default.shape.basic.GhostVertexResizeHandle(figure, i - 1));

    figure.selectionHandles.each(function (i, e) {
      e.setDraggable(figure.isResizeable());
      e.show(canvas);
    });

    this.moved(canvas, figure);
  }

});

/***/ }),

/***/ "./src/policy/port/ElasticStrapFeedbackPolicy.js":
/*!*******************************************************!*\
  !*** ./src/policy/port/ElasticStrapFeedbackPolicy.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A draw2d.policy.SelectionFeedbackPolicy that is sensitive to the canvas selection. Subclasses will typically
 * decorate the {@link draw2d.Figure figure} with things like selection handles and/or focus feedback.
 * <br>
 * If you want to change the handle visibility for a figure, then you should use SelectionFeedbackPolicy to do that.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
_packages2.default.policy.port.ElasticStrapFeedbackPolicy = _packages2.default.policy.port.PortFeedbackPolicy.extend(
/** @lends draw2d.policy.port.ElasticStrapFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.port.ElasticStrapFeedbackPolicy",

  /**
   * Creates a new Router object
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
    this.connectionLine = null;
  },

  /**
   *
   * Called by the framework if the related shape has init a drag&drop
   * operation
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean} return <b>false</b> to send a veto to the drag operation
   */
  onDragStart: function onDragStart(canvas, figure, x, y, shiftKey, ctrlKey) {
    this.connectionLine = new _packages2.default.shape.basic.Line();
    this.connectionLine.setCanvas(canvas);
    this.connectionLine.getShapeElement();

    this.onDrag(canvas, figure);

    return true;
  },

  /**
   *
   * Called by the framework during drag a figure.
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   */
  onDrag: function onDrag(canvas, figure) {
    var x1 = figure.ox + figure.getParent().getAbsoluteX();
    var y1 = figure.oy + figure.getParent().getAbsoluteY();

    this.connectionLine.setStartPosition(x1, y1);
    this.connectionLine.setEndPosition(figure.getAbsoluteX(), figure.getAbsoluteY());
  },

  /**
   *
   * Called by the framework if the drag drop operation ends.
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onDragEnd: function onDragEnd(canvas, figure, x, y, shiftKey, ctrlKey) {
    this.connectionLine.setCanvas(null);
    this.connectionLine = null;
  },

  onHoverEnter: function onHoverEnter(canvas, draggedFigure, hoverFiger) {
    this.connectionLine.setGlow(true);
    hoverFiger.setGlow(true);
  },

  onHoverLeave: function onHoverLeave(canvas, draggedFigure, hoverFiger) {
    hoverFiger.setGlow(false);
    this.connectionLine.setGlow(false);
  }

});

/***/ }),

/***/ "./src/policy/port/IntrusivePortsFeedbackPolicy.js":
/*!*********************************************************!*\
  !*** ./src/policy/port/IntrusivePortsFeedbackPolicy.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _shifty = __webpack_require__(/*! shifty */ "./node_modules/shifty/dist/shifty.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
_packages2.default.policy.port.IntrusivePortsFeedbackPolicy = _packages2.default.policy.port.PortFeedbackPolicy.extend(
/** @lends draw2d.policy.port.IntrusivePortsFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.port.IntrusivePortsFeedbackPolicy",

  /**
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
    this.connectionLine = null;
    this.tweenable = null;
  },

  /**
   *
   * Called by the framework if the related shape has init a drag&drop
   * operation
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onDragStart: function onDragStart(canvas, figure, x, y, shiftKey, ctrlKey) {
    var start = 0;
    var allPorts = canvas.getAllPorts().clone();
    allPorts.each(function (i, element) {
      if (typeof element.__beforeInflate === "undefined") {
        element.__beforeInflate = element.getWidth();
      }
      start = element.__beforeInflate;
    });

    // filter all candidates for the DropEvent
    //
    allPorts.grep(function (p) {
      return p.NAME !== figure.NAME && p.parent !== figure.parent && p.getSemanticGroup() === figure.getSemanticGroup() || p instanceof _packages2.default.HybridPort || figure instanceof _packages2.default.HybridPort;
    });

    // Animate the ports for a visual feedback
    //
    this.tweenable = new _shifty.Tweenable();
    this.tweenable.tween({
      from: { 'size': start / 2 },
      to: { 'size': start },
      duration: 200,
      easing: "easeOutSine",
      step: function step(params) {
        allPorts.each(function (i, element) {
          // IMPORTANT shortcut to avoid rendering errors!!
          // performance shortcut to avoid a lot of events and recalculate/routing of all related connections
          // for each setDimension call. Additional the connection is following a port during Drag&Drop operation
          element.shape.attr({ rx: params.size, ry: params.size });
          element.width = element.height = params.size * 2;
        });
      }
    });

    this.connectionLine = new _packages2.default.shape.basic.Line();
    this.connectionLine.setCanvas(canvas);
    this.connectionLine.getShapeElement();
    this.connectionLine.setDashArray("- ");
    this.connectionLine.setColor("#30c48a");

    this.onDrag(canvas, figure);

    return true;
  },

  /**
   *
   * Called by the framework during drag a figure.
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @template
   */
  onDrag: function onDrag(canvas, figure) {
    var x1 = figure.ox + figure.getParent().getAbsoluteX();
    var y1 = figure.oy + figure.getParent().getAbsoluteY();

    this.connectionLine.setStartPosition(x1, y1);
    this.connectionLine.setEndPosition(figure.getAbsoluteX(), figure.getAbsoluteY());
  },

  /**
   *
   * Called by the framework if the drag drop operation ends.
   *
   * @param {draw2d.Canvas} canvas The host canvas
   * @param {draw2d.Figure} figure The related figure
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onDragEnd: function onDragEnd(canvas, figure, x, y, shiftKey, ctrlKey) {
    if (this.tweenable) {
      this.tweenable.stop(true);
      this.tweenable.dispose();
      this.tweenable = null;
    }

    var allPorts = canvas.getAllPorts().clone();
    // filter all candidates for the DropEvent
    //
    allPorts.grep(function (p) {
      return p.__beforeInflate;
    });

    allPorts.each(function (i, element) {
      // IMPORTANT shortcut to avoid rendering errors!!
      // performance shortcut to avoid a lot of events and recalculate/routing of all related connections
      // for each setDimension call. Additional the connection is following a port during Drag&Drop operation
      element.shape.attr({ rx: element.__beforeInflate / 2, ry: element.__beforeInflate / 2 });
      element.width = element.height = element.__beforeInflate;
      delete element.__beforeInflate;
    });
    this.connectionLine.setCanvas(null);
    this.connectionLine = null;
  },

  onHoverEnter: function onHoverEnter(canvas, draggedFigure, hoverFigure) {
    this.connectionLine.setGlow(true);
    hoverFigure.setGlow(true);
  },

  onHoverLeave: function onHoverLeave(canvas, draggedFigure, hoverFigure) {
    hoverFigure.setGlow(false);
    if (this.connectionLine === null) {
      debugger;
    }
    this.connectionLine.setGlow(false);
  }

});

/***/ }),

/***/ "./src/policy/port/PortFeedbackPolicy.js":
/*!***********************************************!*\
  !*** ./src/policy/port/PortFeedbackPolicy.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Base class for all port feedback policies. Used for grow, highlight or
 * other decorations during drag&drop and connecting of ports.
 *
 * @author Andreas Herz
 * @extends draw2d.policy.figure.DragDropEditPolicy
 */
_packages2.default.policy.port.PortFeedbackPolicy = _packages2.default.policy.figure.DragDropEditPolicy.extend(
/** @lends draw2d.policy.port.PortFeedbackPolicy.prototype */
{

  NAME: "draw2d.policy.port.PortFeedbackPolicy",

  /**
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  },

  /**
   *
   * Called if the dragged port hove another port
   *
   * @param {draw2d.Canvas} canvas
   * @param {draw2d.Port}   draggedFigure
   * @param {draw2d.Figure} hoverFigure
   */
  onHoverEnter: function onHoverEnter(canvas, draggedFigure, hoverFigure) {},

  /**
   *
   * Fired if the dragged figures leaves the hover figure
   *
   * @param {draw2d.Canvas} canvas
   * @param {draw2d.Port}   draggedFigure
   * @param {draw2d.Figure} hoverFigure
   */
  onHoverLeave: function onHoverLeave(canvas, draggedFigure, hoverFigure) {}
});

/***/ }),

/***/ "./src/shape/analog/OpAmp.js":
/*!***********************************!*\
  !*** ./src/shape/analog/OpAmp.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Hand drawn arrow which points down left
 *
 *
 * @example
 *    let figure =  new draw2d.shape.analog.OpAmp({x:10, y:10});
 *
 *    canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
_packages2.default.shape.analog.OpAmp = _packages2.default.SVGFigure.extend(
/** @lends draw2d.shape.analog.OpAmp.prototype */
{

  NAME: "draw2d.shape.analog.OpAmp",

  // custom locator for the special design of the OpAmp Input area
  MyInputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, port) {
      var parent = port.getParent();
      var calcY = (8 + 18.5 * index) * parent.scaleY;
      this.applyConsiderRotation(port, 1, calcY);
    }
  }),

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ stroke: 0, bgColor: "#f0f0ff" }, attr), setter, getter);

    this.inputLocator = new this.MyInputPortLocator();

    this.createPort("input", this.inputLocator);
    this.createPort("input", this.inputLocator);

    this.createPort("output");
  },

  /**
   * @inheritdoc
   */
  getSVG: function getSVG() {
    return '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="50"  height="50">' + '<path d="m8.2627,0l0,35.36035l31.23926,-17.76025l-31.23926,-17.60011l0,0l0,0.00001zm2.27832,27.36719l4.08105,0m-2.10449,-2.20703l0,4.27979m2.26367,-21.35938l-4.15918,0"  stroke="#1B1B1B" fill="none"/>' + '<line x1="0.53516"  y1="8"  x2="8.21191"  y2="8"  stroke="#010101"/>' + '<line x1="39.14941" y1="18" x2="45.81055" y2="18" stroke="#010101" />' + '<line x1="0.53516"  y1="27" x2="8.21191"  y2="27" stroke="#010101" />' + '</svg>';
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    // redirect the backgroundColor to an internal SVG node.
    // In this case only a small part of the shape are filled with the background color
    // and not the complete rectangle/bounding box
    //
    attributes["fill"] = "none";
    if (this.bgColor != null) {
      this.svgNodes[0].attr({ fill: this.bgColor.rgba() });
    }

    this._super(attributes);

    return this;
  }

});

/***/ }),

/***/ "./src/shape/analog/ResistorBridge.js":
/*!********************************************!*\
  !*** ./src/shape/analog/ResistorBridge.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.analog.ResistorBridge({x:10, y:10});
 *
 *    canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
_packages2.default.shape.analog.ResistorBridge = _packages2.default.SVGFigure.extend(
/** @lends draw2d.shape.analog.ResistorBridge.prototype */
{

  NAME: "draw2d.shape.analog.ResistorBridge",

  // custom locator for the special design of the ResistorBridge Input area
  MyInputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, figure) {
      var w = figure.getParent().getWidth();
      var h = figure.getParent().getHeight();
      this.applyConsiderRotation(figure, w / 2 + 1, h * index);
    }
  }),

  // custom locator for the special design of the ResistorBridge Input area
  MyOutputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, figure) {
      var w = figure.getParent().getWidth();
      var h = figure.getParent().getHeight();

      this.applyConsiderRotation(figure, w * (index - 2), h / 2);
    }
  }),

  /**
   * Create a new instance
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {

    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);

    this.inputLocator = new this.MyInputPortLocator();
    this.outputLocator = new this.MyOutputPortLocator();

    this.createPort("hybrid", this.inputLocator);
    this.createPort("hybrid", this.inputLocator);

    this.createPort("hybrid", this.outputLocator);
    this.createPort("hybrid", this.outputLocator);
  },

  /**
   * @inheritdoc
   */
  getSVG: function getSVG() {
    return '<svg  xmlns="http://www.w3.org/2000/svg" version="1.1">' + '<path fill="#010101" stroke="#010101" stroke-miterlimit="14.3" id="path12322" d="m47.62207,22.71094l0,0c0.73145,0.73242 0.71777,1.93359 -0.03027,2.68164c-0.74805,0.74951 -1.94922,0.76123 -2.68073,0.0293c-0.73138,-0.73242 -0.71967,-1.93211 0.03033,-2.68115c0.74707,-0.74803 1.94727,-0.76219 2.68066,-0.02979l0,0z"/>' + '<path fill="#010101" stroke="#010101" stroke-miterlimit="14.3" id="path12324" d="m25.84082,0.93115l0,0c0.73145,0.73096 0.71875,1.93359 -0.02832,2.68066c-0.75,0.74951 -1.94922,0.76123 -2.68164,0.0293c-0.73242,-0.73241 -0.71973,-1.93164 0.0293,-2.68065c0.74805,-0.74756 1.94922,-0.76172 2.68066,-0.0293l0,0l0,-0.00002z"/>' + '<path fill="#010101" stroke="#010101" stroke-miterlimit="14.3" id="path12326" d="m25.75098,44.58203l0,0c0.73145,0.73193 0.71875,1.93311 -0.02832,2.68115c-0.75,0.74902 -1.94922,0.76074 -2.68262,0.0293c-0.73145,-0.73193 -0.71973,-1.93262 0.03033,-2.68164c0.74707,-0.74756 1.94922,-0.76123 2.68066,-0.02879l0,0l-0.00006,-0.00002z"/>' + '<path fill="#010101" stroke="#010101" stroke-miterlimit="14.3" id="path12328" d="m3.9707,22.80127l0,0c0.73242,0.73193 0.71777,1.93359 -0.0293,2.68115c-0.74902,0.74951 -1.94922,0.76172 -2.68164,0.0293c-0.73145,-0.73242 -0.71973,-1.93164 0.03027,-2.68115c0.74707,-0.74707 1.94922,-0.76074 2.68066,-0.0293l0,0z"/>' + '<polyline fill="none" stroke="#010101" id="polyline12334" points="24.908203125,45.49267578125 31.71875,38.68310546875 31.2119140625,36.98876953125 34.892578125,37.95703125 33.953125,34.22265625 37.6650390625,35.18359375 36.6767578125,31.52490234375 40.3759765625,32.47314453125 39.873046875,30.52783203125 45.884765625,24.51708984375 " stroke-miterlimit="14.3"/>' + '<polyline fill="#010101" id="polyline12338" points="36.3408203125,23.98876953125 38.146484375,29.55810546875 33.630859375,29.55810546875 35.435546875,23.98779296875 "/>' + '<line fill="none" stroke="#010101" id="line12340" y2="28.90967" x2="35.8877" y1="41.13428" x1="35.88867" stroke-miterlimit="14.3"/>' + '<polyline fill="none" stroke="#010101" id="polyline12346" points="3.2109375,23.79248046875 10.01953125,16.98388671875 9.513671875,15.2890625 13.193359375,16.25732421875 12.251953125,12.5234375 15.9658203125,13.48486328125 14.9775390625,9.82568359375 18.6767578125,10.7734375 18.173828125,8.82958984375 24.185546875,2.81787109375 " stroke-miterlimit="14.3"/>' + '<polyline fill="#010101" id="polyline12350" points="13.126953125,23.80419921875 11.3212890625,18.236328125 15.8369140625,18.236328125 14.0322265625,23.806640625 "/>' + '<line fill="none" stroke="#010101" id="line12352" y2="18.8833" x2="13.58008" y1="6.65967" x1="13.5791" stroke-miterlimit="14.3"/>' + '<polyline fill="none" stroke="#010101" id="polyline12358" points="46.65625,24.33642578125 39.84765625,17.52783203125 38.154296875,18.033203125 39.1220703125,14.353515625 35.3876953125,15.29345703125 36.34765625,11.58056640625 32.689453125,12.56884765625 33.6376953125,8.86865234375 31.6923828125,9.373046875 24.322265625,2.00341796875 " stroke-miterlimit="14.3"/>' + '<polyline fill="#010101" id="polyline12362" points="36.578125,1.87109375 38.3828125,7.439453125 33.8681640625,7.439453125 35.6728515625,1.869140625 "/>' + '<line fill="none" stroke="#010101" id="line12364" y2="6.7915" x2="36.125" y1="19.01758" x1="36.125" stroke-miterlimit="14.3"/>' + '<polyline fill="none" stroke="#010101" id="polyline12370" points="24.494140625,46.49951171875 17.685546875,39.69091796875 15.9921875,40.1953125 16.958984375,36.515625 13.2265625,37.45556640625 14.185546875,33.7421875 10.52734375,34.73193359375 11.474609375,31.03125 9.529296875,31.53515625 2.1611328125,24.166015625 " stroke-miterlimit="14.3"/>' + '<polyline fill="#010101" id="polyline12374" points="12.150390625,44.80029296875 10.34765625,39.23193359375 14.861328125,39.23095703125 13.0556640625,44.80224609375 "/>' + '<line fill="none" stroke="#010101" id="line12376" y2="39.87891" x2="12.60352" y1="27.6543" x1="12.60352" stroke-miterlimit="14.3"/>' + '</svg>';
  }
});

/***/ }),

/***/ "./src/shape/analog/ResistorVertical.js":
/*!**********************************************!*\
  !*** ./src/shape/analog/ResistorVertical.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.analog.ResistorVertical({x:10, y:10});
 *
 *    canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
_packages2.default.shape.analog.ResistorVertical = _packages2.default.SetFigure.extend(
/** @lends draw2d.shape.analog.ResistorVertical.prototype */
{

  NAME: "draw2d.shape.analog.ResistorVertical",

  // custom locator for the special design of the Input area
  MyInputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, figure) {
      var w = figure.getParent().getWidth();
      var h = figure.getParent().getHeight();
      this.applyConsiderRotation(figure, w / 2, h);
    }
  }),

  // custom locator for the special design of the Output area
  MyOutputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, figure) {
      var w = figure.getParent().getWidth();
      this.applyConsiderRotation(figure, w / 2, 0);
    }
  }),

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {

    this._super(extend({ width: 30, height: 50, bgColor: null }, attr), setter, getter);

    this.inputLocator = new this.MyInputPortLocator();
    this.outputLocator = new this.MyOutputPortLocator();

    this.createPort("hybrid", this.inputLocator);
    this.createPort("hybrid", this.outputLocator);
  },

  /**
   * @inheritdoc
   */
  createSet: function createSet() {
    var set = this._super();

    set.push(this.canvas.paper.path("M15,0 L15,5 L0,7.5 L30,10 L0,15 L30,20 L0,25 L30,30 L15,32.5 L15,40"));

    return set;
  }
});

/***/ }),

/***/ "./src/shape/analog/VoltageSupplyHorizontal.js":
/*!*****************************************************!*\
  !*** ./src/shape/analog/VoltageSupplyHorizontal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.analog.VoltageSupplyHorizontal({x:10, y:10});
 *
 *    canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
_packages2.default.shape.analog.VoltageSupplyHorizontal = _packages2.default.SVGFigure.extend(
/** @lends draw2d.shape.analog.VoltageSupplyHorizontal.prototype */
{

  NAME: "draw2d.shape.analog.VoltageSupplyHorizontal",

  // custom locator for the special design of the Input area
  MyInputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, figure) {
      var h = figure.getParent().getHeight();
      this.applyConsiderRotation(figure, 0, h / 2);
    }
  }),

  // custom locator for the special design of the Output area
  MyOutputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, figure) {
      var w = figure.getParent().getWidth();
      var h = figure.getParent().getHeight();
      this.applyConsiderRotation(figure, w, h / 2);
    }
  }),

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 30 }, attr), setter, getter);

    this.createPort("hybrid", new this.MyInputPortLocator()); // GND
    this.createPort("hybrid", new this.MyOutputPortLocator()); // VCC
  },

  /**
   * @inheritdoc
   */
  getSVG: function getSVG() {
    return '<svg width="49" height="28" xmlns="http://www.w3.org/2000/svg" version="1.1">' + '<path d="m24.99933,18.95592l0,-9.54576m-5.78374,-9.40907l0,28.35939m-5.78718,-9.40457l0,-9.54576m-5.78374,-9.40907l0,28.35939" id="path10566" stroke-miterlimit="14.3" stroke="#010101" fill="none"/>' + '<path d="m26.79878,14.13039l6.90583,0m-33.22691,0l6.90583,0" id="path10568" stroke-miterlimit="14.3" stroke-linecap="square" stroke="#010101" fill="none"/>' + '</svg>';
  }
});

/***/ }),

/***/ "./src/shape/analog/VoltageSupplyVertical.js":
/*!***************************************************!*\
  !*** ./src/shape/analog/VoltageSupplyVertical.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.analog.VoltageSupplyVertical({x:10, y:10});
 *
 *    canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
_packages2.default.shape.analog.VoltageSupplyVertical = _packages2.default.SVGFigure.extend(
/** @lends draw2d.shape.analog.VoltageSupplyVertical.prototype */
{

  NAME: "draw2d.shape.analog.VoltageSupplyVertical",

  // custom locator for the special design of the Input area
  MyInputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, figure) {
      var w = figure.getParent().getWidth();
      var h = figure.getParent().getHeight();
      this.applyConsiderRotation(figure, w / 2, h);
    }
  }),

  // custom locator for the special design of the Output area
  MyOutputPortLocator: _packages2.default.layout.locator.PortLocator.extend({
    init: function init() {
      this._super();
    },
    relocate: function relocate(index, figure) {
      var w = figure.getParent().getWidth();
      this.applyConsiderRotation(figure, w / 2, 0);
    }
  }),

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 30, height: 50 }, attr), setter, getter);

    this.inputLocator = new this.MyInputPortLocator();
    this.outputLocator = new this.MyOutputPortLocator();

    this.createPort("hybrid", this.inputLocator); // GND
    this.createPort("hybrid", this.outputLocator); // VCC
  },

  /**
   * @inheritdoc
   */
  getSVG: function getSVG() {
    return '<svg  xmlns="http://www.w3.org/2000/svg" version="1.1">' + '<path d="m19.62398,12.37594l-9.87926,0m-9.74355,8.22145l29.36289,0m-9.74007,8.22469l-9.87927,0m-9.74355,8.22145l29.36289,0" id="path10560" stroke-miterlimit="14.3" stroke="#010101" fill="none"/>' + '<path d="m14.63157,9.81646l0,-9.81646m0,47.2328l0,-9.81646" id="path10562" stroke-miterlimit="14.3" stroke-linecap="square" stroke="#010101" fill="none"/>' + '</svg>';
  }
});

/***/ }),

/***/ "./src/shape/arrow/CalligrapherArrowDownLeft.js":
/*!******************************************************!*\
  !*** ./src/shape/arrow/CalligrapherArrowDownLeft.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Hand drawn arrow which points down left
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.arrow.CalligrapherArrowDownLeft({x:10,y:10, color:"#3d3d3d"});
 *
 *    canvas.add(figure);
 *
 *
 * @extends draw2d.SVGFigure
 */
_packages2.default.shape.arrow.CalligrapherArrowDownLeft = _packages2.default.SVGFigure.extend(
/** @lends draw2d.shape.arrow.CalligrapherArrowDownLeft.prototype */
{

  NAME: "draw2d.shape.arrow.CalligrapherArrowDownLeft",

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr);
  },

  getSVG: function getSVG() {
    return '<svg width="180" height="300" xmlns="http://www.w3.org/2000/svg" version="1.1">' + '     <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3084" d="m 159.63578,17.846597 c 0.43137,9.44641 -0.0636,18.88035 -0.8284,28.30165 c -1.73211,18.38336 -4.05381,36.71698 -6.08253,55.075313 c -1.61738,13.7075 -3.03402,27.43467 -3.97611,41.19113 c -1.09101,11.16584 -1.31019,22.36559 -1.28541,33.56466 c -0.1328,4.82188 0.3218,9.6468 0.14332,14.46812 c -0.0888,2.39977 -0.28315,3.73625 -0.55012,6.12095 c -0.85848,4.73147 -2.27416,9.40019 -4.7769,13.68272 c -1.47003,2.51544 -3.78493,5.6647 -5.47739,8.05048 c -5.02888,6.66256 -11.08555,12.65652 -18.10552,17.75963 c -4.23302,3.07716 -7.74942,5.12065 -12.22081,7.86298 c -13.253319,6.72606 -25.889792,15.11686 -40.84124,18.60576 c -3.016829,0.7039 -4.431417,0.8157 -7.450859,1.2076 c -6.983246,0.5774 -14.009174,0.3375 -21.010676,0.2509 c -3.278795,-0.033 -6.55749,0.01 -9.835897,0.045 c 0,0 20.838833,-13.2364 20.838833,-13.2364 l 0,0 c 3.147056,0.093 6.294483,0.1852 9.443646,0.2007 c 6.966697,0.011 13.971433,0.1301 20.897176,-0.6344 c 3.732439,-0.5577 7.321215,-1.2431 10.881203,-2.4145 c 1.517208,-0.4992 5.830867,-2.43339 4.487902,-1.6386 c -6.098183,3.6088 -25.104875,12.8748 -9.52514,5.223 c 4.40875,-2.5927 8.262057,-4.7459 12.425175,-7.65986 c 6.839117,-4.78709 12.633657,-10.50427 17.500607,-16.86761 c 2.53518,-3.56692 5.24684,-7.12748 7.07617,-11.03446 c 1.42357,-3.0404 2.21532,-6.28727 2.91146,-9.50152 c 0.91919,-6.88822 1.03991,-13.81392 1.25118,-20.74151 c 0.47683,-11.27871 0.96259,-22.55877 1.61689,-33.83062 c 1.21127,-14.03392 3.64191,-27.94339 5.46543,-41.92167 c 2.26899,-18.186603 4.6835,-36.384373 5.4487,-54.679643 c 0.0788,-2.46092 0.23808,-4.92087 0.23618,-7.38276 c -0.005,-6.45916 -0.62194,-13.00218 -2.13821,-19.32664 c 0,0 23.48134,-10.73998 23.48134,-10.73998 z" inkscape:connector-curvature="0" />' + '     <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3086" d="m 41.271518,252.40239 c 2.465518,-0.7264 4.879503,-1.7726 7.145328,-2.9859 c 0.955597,-0.5117 3.736822,-2.1986 2.791991,-1.6673 c -5.218817,2.9348 -10.409826,5.9187 -15.61474,8.878 c 5.366557,-3.4898 10.227818,-7.6685 14.119927,-12.75576 c 3.507157,-5.09382 4.097613,-11.17122 4.301158,-17.17644 c 0.02635,-3.95844 -0.31227,-7.90612 -0.635377,-11.84752 c 0,0 19.920693,-10.3059 19.920693,-10.3059 l 0,0 c 0.171761,4.05015 0.409899,8.09777 0.50079,12.15101 c -0.185739,6.23619 -0.347804,12.66862 -3.492579,18.24747 c -0.503375,0.75197 -0.961922,1.53596 -1.510126,2.25591 c -3.478528,4.56826 -8.226837,8.04586 -12.757403,11.47443 c -7.345206,4.3297 -14.671333,8.692 -22.035619,12.9891 c -3.551305,2.0723 -7.368692,3.8726 -11.394645,4.7773 c 0,0 18.660602,-14.0344 18.660602,-14.0344 z" inkscape:connector-curvature="0" />' + '     <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3088" d="m 37.815923,255.49919 c 3.41111,0.1581 6.814569,0.2213 10.182693,0.8184 c 6.92998,2.6928 13.533527,6.2357 20.043462,9.8162 c 3.912139,2.1362 7.91195,4.4644 10.690321,8.0298 c 1.039962,1.2802 1.510411,2.7604 1.893523,4.3313 c 0,0 -20.370847,10.9259 -20.370847,10.9259 l 0,0 c -0.225419,-1.2711 -0.55067,-2.4558 -1.329618,-3.5184 c -2.332229,-3.3633 -5.869056,-5.6279 -9.247191,-7.8233 c -6.335066,-3.7106 -12.98611,-7.1834 -20.232784,-8.6836 c -3.497247,-0.3814 -7.011372,-0.4307 -10.521829,-0.1703 c 0,0 18.89227,-13.726 18.89227,-13.726 z" inkscape:connector-curvature="0" />' + '</svg>';
  },

  /**
   *
   * propagate all attributes like color, stroke,... to the shape element
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    if (this.svgNodes !== null) {
      this.svgNodes.attr({ fill: this.color.rgba() });
    }

    this._super(attributes);
  }

});

/***/ }),

/***/ "./src/shape/arrow/CalligrapherArrowLeft.js":
/*!**************************************************!*\
  !*** ./src/shape/arrow/CalligrapherArrowLeft.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Hand drawn arrow to the left.
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.arrow.CalligrapherArrowLeft({x:10, y:10, color:"#3d3d3d"});
 *
 *    canvas.add(figure);
 *
 * @extends draw2d.SVGFigure
 */
_packages2.default.shape.arrow.CalligrapherArrowLeft = _packages2.default.SVGFigure.extend(
/** @lends draw2d.shape.arrow.CalligrapherArrowLeft.prototype */
{
  NAME: "draw2d.shape.arrow.CalligrapherArrowLeft",

  /**
   * Creates a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr);
  },

  getSVG: function getSVG() {
    return '<svg width="230" height="60" xmlns="http://www.w3.org/2000/svg" version="1.1">' + '  <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3024" d="m 218.87943,27.464763 c -1.21088,-0.0563 -2.42064,-0.14616 -3.63262,-0.16893 c -5.82495,-0.10948 -18.61676,-0.0226 -22.97385,0.0122 c -7.12848,0.057 -14.25673,0.14021 -21.38495,0.22333 c -9.03765,0.10539 -18.07511,0.22813 -27.11266,0.3422 c -10.2269,0.11878 -20.4538,0.23756 -30.6807,0.35634 c -35.488759,0.4089 -70.975849,0.82793 -106.4669238,0.95195 c 0,0 7.9718628,-5.70244 7.9718628,-5.70244 l 0,0 c 6.374241,0.28694 12.745594,0.64561 19.122722,0.86083 c 28.09499,0.94816 56.21338,0.92473 84.315959,0.32205 c 10.51273,-0.32805 21.0288,-0.56402 31.53819,-0.98412 c 27.47361,-1.09824 54.91405,-2.91665 82.28177,-5.53697 c 0,0 -12.9788,9.32351 -12.9788,9.32351 z" inkscape:connector-curvature="0" />' + '  <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3026" d="m 100.75066,1.6309831 c -7.165239,3.9571 -14.284929,7.47866 -22.036659,10.2707299 c -5.00195,1.80163 -10.10374,3.31886 -15.2402,4.79424 c -8.25878,2.37815 -16.55626,4.65805 -24.9012,6.79479 c -2.89107,0.71593 -5.74687,1.56407 -8.66266,2.20424 c -3.211679,0.70512 -6.49468,1.17333 -9.752959,1.6747 c -5.447101,0.92112 -10.9044008,1.81762 -16.3983488,2.50082 c -1.608931,0.0814 -0.850754,0.10697 -2.275834,-0.0365 C 20.004071,21.041553 19.256899,21.517873 32.515691,19.216243 c 6.21537,-1.05913 12.34875,-2.37668 18.3945,-4.03234 c 8.12719,-2.02803 16.23765,-4.1157 24.26421,-6.4321199 c 5.23574,-1.55053 10.41682,-3.15473 15.46857,-5.12875 c 1.38953,-0.54295 2.7579,-1.12682 4.12253,-1.71603 c 0.98421,-0.42496 3.86537,-1.81801999 2.92296,-1.32600999 C 93.642191,2.6934931 89.529511,4.7073031 85.450031,6.7704531 l 15.300629,-5.1394 z" inkscape:connector-curvature="0" sodipodi:nodetypes="csccsccccccsssccc" />' + '  <path style="fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none" id="path3028" d="m 80.764281,58.068863 c -2.45498,-3.50762 -6.58178,-6.10525 -10.40324,-8.66732 c -4.30614,-2.72676 -7.93958,-6.28283 -12.6021,-8.28702 c -7.39912,-4.50257 -11.70055,-7.85592 -20.85866,-9.23429 c -4.9257,-0.85706 -17.294247,-1.32043 -22.226462,-2.15427 c -3.445882,-0.42869 -6.2035918,0.70541 -9.6845138,0.57715 c -1.496337,-0.0586 -2.99355,-0.0965 -4.491229,-0.12472 l 13.9525278,-6.24562 l 3.25,-1.17153 c 1.441459,0.0813 -1.116338,0.15309 0.325505,0.23016 c 3.574557,0.17902 7.211864,0.0695 10.712655,0.73822 c 4.723107,1.08097 9.443947,2.1624 14.234177,3.05317 c 2.76739,0.64203 3.92627,0.87082 6.64127,1.66289 c 4.42146,1.28993 8.60075,3.01513 12.86503,4.58129 c 1.90199,0.73446 5.05193,1.93181 6.89302,2.7216 c 4.92005,2.11061 9.5916,4.57045 13.9716,7.31023 c 4.16708,2.62011 8.48023,5.20033 11.72012,8.56863 z" inkscape:connector-curvature="0" sodipodi:nodetypes="ccccccccccccscsccc" />' + '</svg>';
  },

  /**
   *
   * propagate all attributes like color, stroke,... to the shape element
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    if (this.svgNodes !== null) {
      this.svgNodes.attr({ fill: this.color.rgba() });
    }

    this._super(attributes);
  }

});

/***/ }),

/***/ "./src/shape/basic/Arc.js":
/*!********************************!*\
  !*** ./src/shape/basic/Arc.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Oval figure.
 * @example
 *
 *    let arc =  new draw2d.shape.basic.Arc({diameter:150, x:50, y:10, startAngle:0, endAngle:45});
 *
 *    canvas.add(arc);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
_packages2.default.shape.basic.Arc = _packages2.default.SetFigure.extend(
/** @lends draw2d.shape.basic.Arc.prototype */
{

  NAME: "draw2d.shape.basic.Arc",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.startAngle = 180;
    this.endAngle = 360;

    this._super((0, _extend2.default)({ width: 80, height: 50, bgColor: null, color: "#1B1B1B" }, attr), setter, getter);
    this.strokeScale = false; // scale the stroke width of the children nodes if the parent resize
  },

  /**
   * @template
   **/
  createSet: function createSet() {
    this.canvas.paper.setStart();

    var flag = this.endAngle - this.startAngle > 180;
    var a1 = this.startAngle % 360 * Math.PI / 180;
    var a2 = this.endAngle % 360 * Math.PI / 180;

    var w2 = this.getWidth() / 2;
    var h2 = this.getHeight() / 2;

    this.canvas.paper.path([["M", w2, h2, "l", w2 * Math.cos(a1), h2 * Math.sin(a1), "A", w2, h2, 0, +flag, 1, w2 + w2 * Math.cos(a2), h2 + h2 * Math.sin(a2), "z"]].join("")).attr({ "fill": "#fff0f0" });

    return this.canvas.paper.setFinish();
  }

});

/***/ }),

/***/ "./src/shape/basic/Circle.js":
/*!***********************************!*\
  !*** ./src/shape/basic/Circle.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A circle figure with basic background and stroke API. <br>
 * A circle can not be streched. <strong>The aspect ration is always 1:1</strong>.
 *
 *
 * @example
 *
 *    let shape =  new draw2d.shape.basic.Circle({x:40,y:10, stroke:3, color:"#3d3d3d", bgColor:"#3dff3d"});
 *
 *    canvas.add(shape);
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Oval
 */
_packages2.default.shape.basic.Circle = _packages2.default.shape.basic.Oval.extend(
/** @lends draw2d.shape.basic.Circle.prototype */
{

  NAME: "draw2d.shape.basic.Circle",

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   * @param {Object} [setter] add or replace setter methods
   * @param {Object} [getter] add or replace getter methods
   **/
  init: function init(attr, setter, getter) {
    this._super(attr, (0, _extend2.default)({
      // @attr {Number} diameter the diameter of the circle */
      diameter: this.setDiameter,
      // @attr {Number} radius the radius of the circle */
      radius: this.setRadius
    }, setter), (0, _extend2.default)({
      diameter: this.getDiameter,
      radius: this.getRadius
    }, getter));

    this.setKeepAspectRatio(true);
  },

  /**
   *
   * Set the diameter of the circle. The center of the circle will be retained.
   *
   * @param {Number} d The new diameter of the circle.
   * @since 4.0.0
   * @returns {this}
   **/
  setDiameter: function setDiameter(d) {
    var center = this.getCenter();
    this.setDimension(d, d);
    this.setCenter(center);
    this.fireEvent("change:diameter", { value: d });

    return this;
  },

  /**
   *
   * Get the diameter of the circle.
   *
   * @since 4.0.0
   * @returns {Number} the diameter of the circle
   **/
  getDiameter: function getDiameter() {
    return this.getWidth();
  },

  /**
   *
   * Set the radius of the circle. The center of the circle will be retained.
   *
   * @param {Number} r The new radius of the circle.
   * @since 4.0.0
   * @returns {this}
   **/
  setRadius: function setRadius(r) {
    this.setDiameter(r * 2);
    this.fireEvent("change:radius", { value: r });

    return this;
  },

  /**
   * Get the radius of the circle
   *
   * @returns {Number} the radius of the circle
   */
  getRadius: function getRadius() {
    return this.getWidth / 2;
  },

  /**
   * @inheritdoc
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();
    // delete the radius attribute of the parent. Because the "radius" is the corner radius
    // of the shape and not the "radius" of the circle. Design flaw.  :-/
    delete memento.radius;

    return memento;
  }
});

/***/ }),

/***/ "./src/shape/basic/Diamond.js":
/*!************************************!*\
  !*** ./src/shape/basic/Diamond.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A Diamond Figure.
 *
 *
 * @example
 *
 *    let d1 =  new draw2d.shape.basic.Diamond({x:10,y:10});
 *    let d2 =  new draw2d.shape.basic.Diamond({x:100,y:10, bgColor:"#f0f000", alpha:0.7, width:100, height:60});
 *
 *    canvas.add(d1);
 *    canvas.add(d2);
 *
 *    canvas.setCurrentSelection(d2);
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
_packages2.default.shape.basic.Diamond = _packages2.default.shape.basic.Polygon.extend(
/** @lends draw2d.shape.basic.Diamond.prototype */
{

  NAME: "draw2d.shape.basic.Diamond",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ bgColor: "#00a3f6", color: "#1B1B1B" }, attr), setter, getter);

    var pos = this.getPosition();

    this.resetVertices();

    var box = this.getBoundingBox();
    this.addVertex(box.w / 2, 0); // Go to the top center..
    this.addVertex(box.w, box.h / 2); // ...draw line to the right middle
    this.addVertex(box.w / 2, box.h); // ...bottom center...
    this.addVertex(0, box.h / 2); // ...left middle...

    // override the selection handler from the polygon. Because the vertices of
    // the diamond are not selectable and modifiable
    //
    this.installEditPolicy(new _packages2.default.policy.figure.RectangleSelectionFeedbackPolicy());

    this.setPosition(pos);
  }

});

/***/ }),

/***/ "./src/shape/basic/GhostVertexResizeHandle.js":
/*!****************************************************!*\
  !*** ./src/shape/basic/GhostVertexResizeHandle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * ResizeHandle for a vertex edit policy. Click of this kind of resize handles
 * adds a new vertex to the polyline or polygon.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.LineResizeHandle
 */
_packages2.default.shape.basic.GhostVertexResizeHandle = _packages2.default.shape.basic.LineResizeHandle.extend(
/** @lends draw2d.shape.basic.GhostVertexResizeHandle.prototype */
{

  NAME: "draw2d.shape.basic.GhostVertexResizeHandle",

  /**
   *
   *
   */
  init: function init(owner, precursorIndex) {
    this.maxOpacity = 0.35;
    this.precursorIndex = precursorIndex;

    this._super({ owner: owner, opacity: this.maxOpacity });
  },

  createShapeElement: function createShapeElement() {
    var shape = this._super();

    shape.attr({ "cursor": "pointer" });

    return shape;
  },

  /**
   *
   * Set the alpha blending of this figure.
   *
   * @param {Number} percent Value between [0..1].
   * @template
   **/
  setAlpha: function setAlpha(percent) {
    this._super(Math.min(this.maxOpacity, Math.max(0, parseFloat(percent))));

    return this;
  },

  /**
   *
   * Called when a user clicks on the element
   *
   * @template
   */
  onClick: function onClick() {
    var cmd = new _packages2.default.command.CommandAddVertex(this.owner, this.precursorIndex + 1, this.getAbsoluteX() + this.getWidth() / 2, this.getAbsoluteY() + this.getHeight() / 2);
    this.getCanvas().getCommandStack().execute(cmd);
  },

  /**
   * Called if the drag and drop action begins. You can return [false] if you
   * want avoid the that the figure can be move.
   *
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @type {Boolean}
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
    return true;
  },

  /**
   *
   * Called from the framework during a drag&drop operation
   *
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @returns {Boolean}
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2) {
    return true;
  },

  /**
   *  Called after a drag and drop action.<br>
   *        Sub classes can override this method to implement additional stuff. Don't forget to call the super implementation via <code>this._super();</code>
   *
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean}
   */
  onDragEnd: function onDragEnd(x, y, shiftKey, ctrlKey) {
    // fire an event
    // @since 5.3.3
    this.fireEvent("dragend", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });

    return true;
  },

  /**
   *
   * Controls the location of the resize handle
   *
   * @template
   **/
  relocate: function relocate() {
    var p1 = this.owner.getVertices().get(this.precursorIndex);
    var p2 = this.owner.getVertices().get(this.precursorIndex + 1);

    this.setPosition((p2.x - p1.x) / 2 + p1.x - this.getWidth() / 2, (p2.y - p1.y) / 2 + p1.y - this.getHeight() / 2);
  }

});

/***/ }),

/***/ "./src/shape/basic/Image.js":
/*!**********************************!*\
  !*** ./src/shape/basic/Image.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Simple Image shape.
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.node.Node
 */
_packages2.default.shape.basic.Image = _packages2.default.shape.node.Node.extend(
/** @lends draw2d.shape.basic.Image.prototype */
{

  NAME: "draw2d.shape.basic.Image",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr, (0, _extend2.default)({
      // @attr {String} path the image path (absolute or relative) of the shape */
      path: this.setPath
    }, setter), (0, _extend2.default)({
      path: this.getPath
    }, getter));
  },

  /**
   * 
   * Set the image path attribute of the Image shape and repaint them.
   * The path can be relative or absolute
   *
   * @param path
   * @since 2.8.0
   */
  setPath: function setPath(path) {
    this.path = path;

    if (this.shape !== null) {
      this.shape.attr({ src: this.path });
    }
    this.fireEvent("change:path", { value: this.path });

    return this;
  },

  /**
   * 
   * Return the image path attribute of the shape.
   *
   * @returns {String}
   * @since 2.8.0
   */
  getPath: function getPath() {
    return this.path;
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return this;
    }

    attributes = attributes || {};

    attributes.x = this.getAbsoluteX();
    attributes.y = this.getAbsoluteY();
    attributes.width = this.getWidth();
    attributes.height = this.getHeight();
    attributes.src = this.path;

    // propagate the width/height and the display:inline-block as CSS attribute as well because Chrome
    // did some "flickering" in some versions and sometimes the image disappear complete
    $(this.shape.node).css({ display: "inline-block", "width": attributes.width, "height": attributes.height });

    this._super(attributes);

    return this;
  },

  /**
   * @inheritdoc
   */
  createShapeElement: function createShapeElement() {
    return this.canvas.paper.image(this.path, this.getX(), this.getY(), this.getWidth(), this.getHeight());
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    return (0, _extend2.default)(this._super(), {
      path: this.path
    });
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);
    if (typeof memento.path !== "undefined") {
      this.setPath(memento.path);
    }
  }

});

/***/ }),

/***/ "./src/shape/basic/Label.js":
/*!**********************************!*\
  !*** ./src/shape/basic/Label.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _JSONUtil = __webpack_require__(/*! ../../util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Implements a simple text label.
 *
 *
 * @example
 *
 *    let shape =  new draw2d.shape.basic.Label({text:"This is a simple label", x:40, y:10});
 *
 *    canvas.add(shape);
 *
 * @author Andreas Herz
 * @extends draw2d.SetFigure
 */
_packages2.default.shape.basic.Label = _packages2.default.SetFigure.extend(
/** @lends draw2d.shape.basic.Label.prototype */
{

  NAME: "draw2d.shape.basic.Label",

  FONT_FALLBACK: {
    'Georgia': 'Georgia, serif',
    'Palatino Linotype': '"Palatino Linotype", "Book Antiqua", Palatino, serif',
    'Times New Roman': '"Times New Roman", Times, serif',
    'Arial': 'Arial, Helvetica, sans-serif',
    'Arial Black': '"Arial Black", Gadget, sans-serif',
    'Comic Sans MS': '"Comic Sans MS", cursive, sans-serif',
    'Impact': 'Impact, Charcoal, sans-serif',
    'Lucida Sans Unicode': '"Lucida Sans Unicode", "Lucida Grande", sans-serif',
    'Tahoma, Geneva': 'Tahoma, Geneva, sans-seri',
    'Trebuchet MS': '"Trebuchet MS", Helvetica, sans-serif',
    'Verdana': 'Verdana, Geneva, sans-serif',
    'Courier New': '"Courier New", Courier, monospace',
    'Lucida Console': '"Lucida Console", Monaco, monospace'
  },

  /**
   * Creates a new text element.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {

    this.text = "";
    // for performance reasons
    //
    this.cachedWidth = null;
    this.cachedHeight = null;
    this.cachedMinWidth = null;
    this.cachedMinHeight = null;

    // appearance of the shape
    //
    this.fontSize = 12;
    this.fontColor = new _packages2.default.util.Color("#080808");
    this.fontFamily = null;
    this.padding = { top: 4, right: 4, bottom: 4, left: 4 };

    this.outlineStroke = 0;
    this.outlineColor = new _packages2.default.util.Color(null);

    this.bold = false;

    // behavior of the shape
    //
    this.editor = null;

    this._super((0, _extend2.default)({ stroke: 1, width: 1, height: 1, resizeable: false }, attr), (0, _extend2.default)({
      // @attr {String} text the text to show */
      text: this.setText,
      // @attr {String} set the editor to use see {@link draw2d.ui.LabelEditor} */
      editor: this.installEditor,
      // @attr {Number} outlineStroke the line width of the text to draw. Fill color and outline of the text can be different. */
      outlineStroke: this.setOutlineStroke,
      // @attr {String|draw2d.util.Color} outlineColor the outline color of the text */
      outlineColor: this.setOutlineColor,
      // @attr {String} fontFamily the font to use*/
      fontFamily: this.setFontFamily,
      // @attr {Number} fontSize the font size to use */
      fontSize: this.setFontSize,
      // @attr {String|draw2d.util.Color} fontColor the font color */
      fontColor: this.setFontColor,
      // @attr {Number} padding the padding in pixel around the text */
      padding: this.setPadding,
      // @attr {Boolean} bold indicator if bold text should be used*/
      bold: this.setBold
    }, setter), (0, _extend2.default)({
      text: this.getText,
      outlineStroke: this.getOutlineStroke,
      outlineColor: this.getOutlineColor,
      fontFamily: this.getFontFamily,
      fontSize: this.getFontSize,
      fontColor: this.getFontColor,
      padding: this.getPadding,
      bold: this.isBold
    }, getter));

    this.installEditPolicy(new _packages2.default.policy.figure.AntSelectionFeedbackPolicy());

    // some performance improvements
    this.lastAppliedLabelRotation = "";
    this.lastAppliedTextAttributes = {};
  },

  /**
   *
   * Creates the shape object for a text node.
   *
   * @private
   **/
  createSet: function createSet() {
    return this.canvas.paper.text(0, 0, this.text);
  },

  /**
   *
   * Set the canvas element of this figures.
   *
   * @param {draw2d.Canvas} canvas the new parent of the figure or null
   * @private
   */
  setCanvas: function setCanvas(canvas) {
    this.clearCache();
    this._super(canvas);
    this.clearCache();
  },

  /**
   *
   * Trigger the repaint of the element and transport all style properties to the visual representation.<br>
   * Called by the framework.
   *
   * @private
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null || this.parent && this.parent.repaintBlocked === true) {
      return;
    }

    // style the label
    var lattr = this.calculateTextAttr();
    lattr.text = this.text;

    var attrDiff = _JSONUtil2.default.flatDiff(lattr, this.lastAppliedTextAttributes);
    this.lastAppliedTextAttributes = lattr;

    // the two "attr" calls takes 2/3 of the complete method call (chrome performance check).
    // now we check if any changes happens and call this method only if necessary.
    if (Object.getOwnPropertyNames(attrDiff).length > 0) {
      this.svgNodes.attr(lattr);
      // set of the x/y must be done AFTER the font-size and bold has been set.
      // Reason: the getBBox method needs the font attributes for calculation
      this.svgNodes.attr({
        x: this.padding.left + this.stroke,
        y: this.svgNodes.getBBox(true).height / 2 + this.padding.top + this.getStroke()
      });
    }
    this._super(attributes);
  },

  /**
   *
   * @private
   */
  calculateTextAttr: function calculateTextAttr() {
    var lattr = {
      "text-anchor": "start",
      "font-size": this.fontSize,
      "font-weight": this.bold === true ? "bold" : "normal",
      fill: this.fontColor.rgba(),
      stroke: this.outlineColor.rgba(),
      "stroke-width": this.outlineStroke
    };
    if (this.fontFamily !== null) {
      lattr["font-family"] = this.fontFamily;
    }
    return lattr;
  },

  /**
   * @private
   * @returns {this}
   */
  applyTransformation: function applyTransformation() {
    var ts = "R" + this.rotationAngle;
    //    if(ts!==this.lastAppliedLabelRotation){
    this.shape.transform(ts);
    this.lastAppliedLabelRotation = ts;
    //    }

    this.svgNodes.transform("R" + this.rotationAngle + "T" + this.getAbsoluteX() + "," + this.getAbsoluteY());

    return this;
  },

  /**
   *
   * Set the new font size in [pt].
   *
   * @returns {this}
   * @param {Number} size The new font size in <code>pt</code>
   **/
  setFontSize: function setFontSize(size) {
    this.clearCache();
    this.fontSize = size;

    this.repaint();

    this.fireEvent("change:fontSize", { value: this.fontSize });
    this.fireEvent("resize");

    // Update the resize handles if the user change the position of the element via an API call.
    //
    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    return this;
  },

  /**
   *
   * Return the current used font size in px.
   *
   * @returns {Number}
   * @since 4.0.1
   */
  getFontSize: function getFontSize() {
    return this.fontSize;
  },

  /**
   *
   * Set the label to <b>bold</b> or <b>normal</b> font weight.
   *
   * @param {Boolean} bold The bold flag for the label
   * @since 2.4.1
   * @returns {this}
   **/
  setBold: function setBold(bold) {
    this.clearCache();
    this.bold = bold;
    this.repaint();

    this.fireEvent("change:bold", { value: this.bold });
    this.fireEvent("resize");

    // Update the resize handles if the user change the position of the element via an API call.
    //
    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    return this;
  },

  /**
   *
   * Return the "bold" attribute of the label
   *
   * @since 5.0.0
   * @returns {Boolean}
   */
  isBold: function isBold() {
    return this.bold;
  },

  /**
   *
   * Set the outline color of the font.
   *
   * @param {draw2d.util.Color/String} color The new color of the line.
   * @since 4.2.1
   * @returns {this}
   **/
  setOutlineColor: function setOutlineColor(color) {
    this.outlineColor = new _packages2.default.util.Color(color);
    this.repaint();
    this.fireEvent("change:outlineColor", { value: this.outlineColor });

    return this;
  },

  /**
   *
   * The outline color of the text
   *
   * @returns {draw2d.util.Color}
   * @since 4.2.1
   */
  getOutlineColor: function getOutlineColor() {
    return this.outlineColor;
  },

  /**
   *
   * Set the stroke of the text to use.
   *
   * @param {Number} w The new line width of the figure
   * @since 4.2.1
   * @returns {this}
   **/
  setOutlineStroke: function setOutlineStroke(w) {
    this.outlineStroke = w;
    this.repaint();
    this.fireEvent("change:outlineStroke", { value: this.outlineStroke });

    return this;
  },

  /**
   *
   * The used outline line width.
   *
   * @type {Number}
   * @since 4.2.1
   **/
  getOutlineStroke: function getOutlineStroke() {
    return this.outlineStroke;
  },

  /**
   *
   * Set the color of the font.
   *
   * @param {draw2d.util.Color|String} color The new color of the line.
   * @returns {this}
   **/
  setFontColor: function setFontColor(color) {
    this.fontColor = new _packages2.default.util.Color(color);
    this.repaint();
    this.fireEvent("change:fontColor", { value: this.fontColor });

    return this;
  },

  /**
   *
   * The current used font color
   *
   * @returns {draw2d.util.Color}
   */
  getFontColor: function getFontColor() {
    return this.fontColor;
  },

  /**
   *
   * Set the padding of the element
   *
   *     // Alternatively you can use the attr method:
   *     //
   *     // set the padding for top,left,bottom,right in one call
   *     figure.attr({
   *       padding: 3
   *     });
   *
   *     // update the padding left and top
   *     figure.attr({
   *       padding: {left:3, top:30}
   *     });
   *
   * @param {Number|Object} padding The new padding
   * @returns {this}
   **/
  setPadding: function setPadding(padding) {
    this.clearCache();
    if (typeof padding === "number") {
      this.padding = { top: padding, right: padding, bottom: padding, left: padding };
    } else {
      this.padding = (0, _extend2.default)(this.padding, padding);
    }
    this.repaint();
    this.fireEvent("change:padding", { value: this.padding });

    return this;
  },

  /**
   *
   * Get the padding of the element.
   *
   * @since 4.0.1
   **/
  getPadding: function getPadding() {
    return this.padding;
  },

  /**
   *
   * Set the font family to use. If you use the shown font names the typical fallback
   * font are installed as well.
   *
   * <b>Serif Fonts</b>
   * <ul>
   *  <li><span style="font-family:'Georgia'">Georgia</span></li>
   *  <li><span style="font-family:'Palatino Linotype'">Palatino Linotype</span></li>
   *  <li><span style="font-family:'Times New Roman'">Times New Roman</span></li>
   * </ul>
   *
   * <b>Sans-Serif Fonts</b>
   * <ul>
   *  <li><span style="font-family:'Arial'">Arial</span></li>
   *  <li><span style="font-family:'Arial Black'">Arial Black</span></li>
   *  <li><span style="font-family:'Comic Sans MS'">Comic Sans MS</span></li>
   *  <li><span style="font-family:'Impact, Charcoal'">Impact, Charcoal</span></li>
   *  <li><span style="font-family:'Lucida Sans Unicode'">Lucida Sans Unicode</span></li>
   *  <li><span style="font-family:'Tahoma, Geneva'">Tahoma, Geneva</span></li>
   *  <li><span style="font-family:'Trebuchet MS'">Trebuchet MS</span> </li>
   *  <li><span style="font-family:'Verdana'">Verdana</span></li>
   * </ul>
   *
   * <b>Monospace Fonts</b>
   * <ul>
   *  <li><span style="font-family:'Courier New'">Courier New</span></li>
   *  <li><span style="font-family:'Lucida Console'">Lucida Console</span></li>
   * </ul>
   *
   * @param {String} font The font to use
   * @returns {this}
   **/
  setFontFamily: function setFontFamily(font) {
    this.clearCache();

    // check for fallback
    //
    if (typeof font !== "undefined" && font !== null && typeof this.FONT_FALLBACK[font] !== "undefined") {
      font = this.FONT_FALLBACK[font];
    }

    this.fontFamily = font;
    this.repaint();
    this.fireEvent("change:fontFamily", { value: this.fontFamily });

    return this;
  },

  /**
   *
   * Returns the used font family of the label.
   *
   * @returns {String}
   */
  getFontFamily: function getFontFamily() {
    return this.fontFamily;
  },

  /**
   *
   * A Label did have "autosize". Do nothing at all.
   *
   * @returns {this}
   **/
  setDimension: function setDimension(w, h) {
    this.clearCache();

    this._super(w, h);

    return this;
  },

  /**
   *
   * clear the internal cache for width/height precalculation
   * @private
   */
  clearCache: function clearCache() {
    this.portRelayoutRequired = true;
    this.cachedMinWidth = null;
    this.cachedMinHeight = null;
    this.cachedWidth = null;
    this.cachedHeight = null;
    this.lastAppliedTextAttributes = {};

    return this;
  },

  /**
   *
   * This value is relevant for the interactive resize of the figure.
   *
   * @returns {Number} Returns the min. width of this object.
   */
  getMinWidth: function getMinWidth() {
    if (this.shape === null) {
      return 0;
    }

    if (this.cachedMinWidth === null) {
      this.cachedMinWidth = this.svgNodes.getBBox(true).width + this.padding.left + this.padding.right + 2 * this.getStroke();
    }

    return this.cachedMinWidth;
  },

  /**
   *
   * This value is relevant for the interactive resize of the figure.
   *
   * @returns {Number} Returns the min. width of this object.
   */
  getMinHeight: function getMinHeight() {
    if (this.shape === null) {
      return 0;
    }

    if (this.cachedMinHeight === null) {
      this.cachedMinHeight = this.svgNodes.getBBox(true).height + this.padding.top + this.padding.bottom + 2 * this.getStroke();
    }

    return this.cachedMinHeight;
  },

  /**
   *
   * Return the calculate width of the set. This calculates the bounding box of all elements.
   *
   * @returns {Number} the calculated width of the label
   **/
  getWidth: function getWidth() {
    if (this.shape === null) {
      return 0;
    }

    if (this.cachedWidth === null) {
      if (this.resizeable === true) {
        this.cachedWidth = Math.max(this.width, this.getMinWidth());
      } else {
        this.cachedWidth = this.getMinWidth();
      }
    }

    return this.cachedWidth;
  },

  /**
   *
   * Return the calculated height of the set. This calculates the bounding box of all elements.
   *
   * @returns {Number} the calculated height of the label
   */
  getHeight: function getHeight() {
    if (this.shape === null) {
      return 0;
    }

    if (this.cachedHeight === null) {
      this.cachedHeight = Math.max(this.height, this.getMinHeight());
    }

    return this.cachedHeight;
  },

  /**
   *
   * Set an editor for the label. This can be a dialog or inplace editor for the
   * Text.<br>
   * The editor will be activated if you doubleClick on the label.
   *
   * @param {draw2d.ui.LabelEditor|String} editor
   */
  installEditor: function installEditor(editor) {
    if (typeof editor === "string") {
      editor = eval("new " + editor + "()");
    }
    this.editor = editor;

    return this;
  },

  /**
   *
   * Called when a user dbl clicks on the element
   *
   */
  onDoubleClick: function onDoubleClick() {
    if (this.editor !== null) {
      this.editor.start(this);
    }
  },

  /**
   *
   * Returns the current text of the label.
   *
   * @returns the current display text of the label
   * @type {String}
   **/
  getText: function getText() {
    return this.text;
  },

  /**
   *
   * Set the text for the label. Use \n for multiline text.
   *
   * @param {String} text The new text for the label.
   * @returns {this}
   **/
  setText: function setText(text) {
    this.clearCache();
    this.text = text;

    this.repaint();
    // Update the resize handles if the user change the position of the element via an API call.
    //
    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    this.fireEvent("resize");
    this.fireEvent("change:text", { value: this.text });

    if (this.parent !== null) {
      this.parent.repaint();
    }

    return this;
  },

  /**
   *
   * Detect whenever the hands over coordinate is inside the figure.
   * The default implementation is a simple bounding box test.
   *
   * @param {Number} iX
   * @param {Number} iY
   * @param {Number} [corona]
   *
   * @returns {Boolean}
   */
  hitTest: function hitTest(x, y, corona) {

    // apply a simple bounding box test if the label isn'T rotated
    //
    if (this.rotationAngle === 0) {
      return this._super(x, y, corona);
    }

    var boundingBox = this.getBoundingBox();
    if (typeof corona === "number") {
      boundingBox.scale(corona, corona);
    }

    // rotate the box with the current matrix of the
    // shape
    var matrix = this.shape.matrix;
    var points = boundingBox.getVertices();
    points.each(function (i, point) {
      var x = matrix.x(point.x, point.y);
      var y = matrix.y(point.x, point.y);
      point.x = x;
      point.y = y;
    });

    var polySides = 4;

    var j = polySides - 1;
    var oddNodes = false;

    for (var i = 0; i < polySides; i++) {
      var pi = points.get(i);
      var pj = points.get(j);
      if ((pi.y < y && pj.y >= y || pj.y < y && pi.y >= y) && (pi.x <= x || pj.x <= x)) {
        if (pi.x + (y - pi.y) / (pj.y - pi.y) * (pj.x - pi.x) < x) {
          oddNodes = !oddNodes;
        }
      }
      j = i;
    }
    return oddNodes;
  },

  /**
   *
   * Return an objects with all important attributes for XML or JSON serialization
   *
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.text = this.text;
    memento.outlineStroke = this.outlineStroke;
    memento.outlineColor = this.outlineColor.rgba();
    memento.fontSize = this.fontSize;
    memento.fontColor = this.fontColor.rgba();
    memento.fontFamily = this.fontFamily;

    if (this.editor !== null) {
      memento.editor = this.editor.NAME;
    }
    return memento;
  },

  /**
   *
   * Apply all attributes from the serialized properties to the shape.
   * Used during JSON serialisation.
   *
   * @param {Object} memento
   * @returns {this}
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);
    if (typeof memento.text !== "undefined") {
      this.setText(memento.text);
    }
    if (typeof memento.outlineStroke !== "undefined") {
      this.setOutlineStroke(memento.outlineStroke);
    }
    if (typeof memento.outlineColor !== "undefined") {
      this.setOutlineColor(memento.outlineColor);
    }
    if (typeof memento.fontFamily !== "undefined") {
      this.setFontFamily(memento.fontFamily);
    }
    if (typeof memento.fontSize !== "undefined") {
      this.setFontSize(memento.fontSize);
    }
    if (typeof memento.fontColor !== "undefined") {
      this.setFontColor(memento.fontColor);
    }

    if (typeof memento.editor === "string") {
      this.installEditor(eval("new " + memento.editor + "()"));
    }

    return this;
  }

});

/***/ }),

/***/ "./src/shape/basic/Line.js":
/*!*********************************!*\
  !*** ./src/shape/basic/Line.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _JSONUtil = __webpack_require__(/*! ../../util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @class
 * The base class for all visible elements inside a canvas.
 *
 *
 * @example
 *
 *    // Create the line and modify the start/end after inserting them into
 *    // the canvas
 *    let line1 =  new draw2d.shape.basic.Line({startX:30, startY:30, endX:100, endY:80});
 *
 *    canvas.add(line1);
 *
 *    // Create the line with a given start/end coordinate in the constructor
 *    //
 *    let line2 = new draw2d.shape.basic.Line({
 *          startX:20,
 *          startY:80,
 *          endX:200,
 *          endY:150,
 *          stroke:3,
 *          color:"#1d1dff"
 *     });
 *    canvas.add(line2);
 *
 * @author Andreas Herz
 * @extends draw2d.Figure
 */
_packages2.default.shape.basic.Line = _packages2.default.Figure.extend(
/** @lends draw2d.shape.basic.Line.prototype */
{

  NAME: "draw2d.shape.basic.Line",

  DEFAULT_COLOR: new _packages2.default.util.Color(0, 0, 0),

  /**
   * Creates a new figure element which are not assigned to any canvas witht he given start and
   * end coordinate.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    // click area for the line hit test
    this.corona = 10;
    this.isGlowing = false;
    this.lineColor = this.DEFAULT_COLOR;
    this.stroke = 1;
    this.outlineStroke = 0;
    this.outlineColor = new _packages2.default.util.Color(null);
    this.outlineVisible = false;

    this.draggedSegment = null;

    this.dasharray = null;

    this.start = new _packages2.default.geo.Point(30, 30);
    this.end = new _packages2.default.geo.Point(100, 100);

    this.vertices = new _packages2.default.util.ArrayList();
    this.vertices.add(this.start.clone());
    this.vertices.add(this.end.clone());

    this._super((0, _extend2.default)({
      deleteable: false,
      selectable: true
    }, attr), (0, _extend2.default)({}, {
      // @attr {Number} start the  coordinates of the start point */
      start: this.setStartPosition,
      // @attr {Number} startX the x coordinate of the start point */
      startX: this.setStartX,
      // @attr {Number} startY the y coordinate of the start point */
      startY: this.setStartY,
      // @attr {Number} end the coordinates of the end point */
      end: this.setEndPosition,
      // @attr {Number} endX the x coordinate of the end */
      endX: this.setEndX,
      // @attr {Number} endY the y coordinate of the end */
      endY: this.setEndY,
      // @attr {Number} vertices the x coordinate of the start point */
      vertices: this.setVertices,
      // @attr {String | draw2d.util.Color} outlineColor the outline color of the line */
      outlineColor: this.setOutlineColor,
      // @attr {Number} outlineStroke the line width of the outline */
      outlineStroke: this.setOutlineStroke,
      // @attr {String|draw2d.util.Color} color the color of the line */
      color: this.setColor,
      // @attr {Number} stroke the line width of the color */
      stroke: this.setStroke,
      // @attr {String} dasharray the line pattern see {@link draw2d.shape.basic.Line#setDashArray} for more information*/
      dasharray: this.setDashArray,
      // @attr {Boolean} glow the glow flag for the shape. The representation of the "glow" depends on the shape */
      glow: this.setGlow
    }, setter), (0, _extend2.default)({}, {
      start: this.getStartPosition,
      end: this.getEndPosition,
      outlineColor: this.getOutlineColor,
      outlineStroke: this.getOutlineStroke,
      stroke: this.getStroke,
      color: this.getColor,
      dasharray: this.getDashArray,
      vertices: this.getVertices
    }, getter));

    // some router installs a edit policy. In this case we want delete them
    //
    if (this.editPolicy.getSize() === 0) {
      this.installEditPolicy(new _packages2.default.policy.line.LineSelectionFeedbackPolicy());
    }
  },

  /**
   *
   * Set the outline color of the line.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       outlineColor: color
   *     });
   *
   * @param {draw2d.util.Color/String} color The new color of the line.
   * @since 4.2.1
   **/
  setOutlineColor: function setOutlineColor(color) {
    this.outlineColor = new _packages2.default.util.Color(color);
    this.repaint();
    this.fireEvent("change:outlineColor", { value: this.outlineColor });

    return this;
  },

  /**
   *
   * The outline color of the text
   *
   * @returns {draw2d.util.Color}
   * @since 4.2.1
   */
  getOutlineColor: function getOutlineColor() {
    return this.outlineColor;
  },

  /**
   *
   * Set the outline stroke of the line to use.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       outlineStroke: w
   *     });
   *
   * @param {Number} w The new outline width of the line
   * @since 4.2.1
   **/
  setOutlineStroke: function setOutlineStroke(w) {
    this.outlineStroke = w;
    this.repaint();
    this.fireEvent("change:outlineStroke", { value: this.outlineStroke });

    return this;
  },

  /**
   *
   * The used outline line width.
   *
   * @returns {Number}
   * @since 4.2.1
   **/
  getOutlineStroke: function getOutlineStroke() {
    return this.outlineStroke;
  },

  /**
   *
   * Called if the drag and drop action begins. You can return [false] if you
   * want avoid that the figure can be move.
   *
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean} true if the figure accepts dragging
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey, isFaked) {
    var result = this._super(x, y, shiftKey, ctrlKey);

    if (result === true && isFaked !== true) {
      this.draggedSegment = { index: 0, start: this.start, end: this.end };
    }
    return result;
  },

  /**
   *
   * Don't call them manually. This will be done by the framework.<br>
   * Will be called if the object are moved via drag and drop.
   * Sub classes can override this method to implement additional stuff. Don't forget to call
   * the super implementation via <code>this._super(dx, dy, dx2, dy2);</code>
   * @private
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2) {
    if (this.command === null) {
      return;
    }

    this.vertices.each(function (i, e) {
      e.translate(dx2, dy2);
    });
    this.command.updateVertices(this.vertices.clone());

    // start/end are separate draw2d.geo.Point objects. Required for routing and determining if a node is dragged away
    // from the connection. In this case we must modify the start/end by hand
    this.start.translate(dx2, dy2);
    this.end.translate(dx2, dy2);

    this.svgPathString = null;
    this._super(dx, dy, dx2, dy2);
  },

  /**
   *
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onDragEnd: function onDragEnd(x, y, shiftKey, ctrlKey) {
    var _this2 = this;

    // Element ist zwar schon an seine Position, das Command muss aber trotzdem
    // in dem CommandStack gelegt werden damit das Undo funktioniert.
    //
    this.isInDragDrop = false;
    this.draggedSegment = null;

    if (this.command === null) {
      return;
    }

    this.canvas.getCommandStack().execute(this.command);
    this.command = null;
    this.isMoving = false;

    // notify all installed policies
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.onDragEnd(_this2.canvas, _this2, x, y, shiftKey, ctrlKey);
      }
    });

    // inform all other listener
    this.fireEvent("move", { figure: this, dx: 0, dy: 0 });

    // fire an event
    // @since 5.3.3
    this.fireEvent("dragend", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
  },

  /**
   *
   * Called when a user clicks on the element.
   *
   *     // Alternatively you can register for this event with
   *     figure.on("click", function(emitterFigure){
   *         alert("clicked");
   *     });
   *
   * @template
   * @since 4.0.0
   */
  onClick: function onClick() {},

  /**
   *
   * Set the line style for this object.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       dasharray: dashPattern
   *     });
   *
   * @param {String} dashPattern Can be one of this ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]
   */
  setDashArray: function setDashArray(dashPattern) {
    this.dasharray = dashPattern;
    this.repaint();

    this.fireEvent("change:dashArray", { value: this.dasharray });

    return this;
  },

  /**
   *
   * Get the line style for this object.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr("dasharray");
   *
   * @since 5.1.0
   */
  getDashArray: function getDashArray() {
    return this.dasharray;
  },

  /**
   *
   * Set the width for the click hit test of this line.
   *
   * @param {Number} width the width of the line hit test.
   **/
  setCoronaWidth: function setCoronaWidth(width) {
    this.corona = width;

    return this;
  },

  /**
   *
   * Called by the framework. Don't call them manually.
   *
   * @private
   **/
  createShapeElement: function createShapeElement() {
    var set = this.canvas.paper.set();

    // the drop shadow or border line
    set.push(this.canvas.paper.path("M" + this.start.x + " " + this.start.y + "L" + this.end.x + " " + this.end.y));
    // the main path
    set.push(this.canvas.paper.path("M" + this.start.x + " " + this.start.y + "L" + this.end.x + " " + this.end.y));
    set.node = set.items[1].node;

    // indicate that the outline is visible at the moment
    // the repaint update the status correct and set the attributes for
    // the first time
    this.outlineVisible = true; //this.outlineStroke>0;

    return set;
  },

  /**
   * @inheritdoc
   *
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    // don't override existing values
    //
    if (typeof attributes === "undefined") {
      attributes = {
        "stroke": this.lineColor.rgba(),
        "stroke-width": this.stroke,
        "path": ["M", this.start.x, this.start.y, "L", this.end.x, this.end.y].join(" ")
      };
    } else {
      // may a router has calculate another path. don't override them.
      if (typeof attributes.path === "undefined") {
        attributes.path = ["M", this.start.x, this.start.y, "L", this.end.x, this.end.y].join(" ");
      }
      _JSONUtil2.default.ensureDefault(attributes, "stroke", this.lineColor.rgba());
      _JSONUtil2.default.ensureDefault(attributes, "stroke-width", this.stroke);
    }

    _JSONUtil2.default.ensureDefault(attributes, "stroke-dasharray", this.dasharray);
    this._super(attributes);

    if (this.outlineStroke > 0) {
      this.shape.items[0].attr({
        "stroke-width": this.outlineStroke + this.stroke,
        "stroke": this.outlineColor.rgba()
      });
      if (this.outlineVisible === false) this.shape.items[0].show();
      this.outlineVisible = true;
    } else if (this.outlineVisible === true) {
      // reset them once
      this.shape.items[0].attr({ "stroke-width": 0, "stroke": "none" });
      this.shape.items[0].hide();
      this.outlineVisible = false;
    }
  },

  /**
   *
   * Moves the element to the background. Additional
   * the internal model changed as well.
   *
   * @since 4.7.2
   */
  toBack: function toBack(figure) {
    this._super(figure);

    if (this.outlineVisible === true) {
      this.shape.items[0].insertBefore(this.shape.items[1]);
    }

    return this;
  },

  /**
   *
   * Highlight the element or remove the highlighting
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       glow: flag
   *     });
   *
   * @param {Boolean} flag indicates glow/noGlow
   * @template
   */
  setGlow: function setGlow(flag) {
    if (this.isGlowing === flag) {
      return;
    }

    if (flag === true) {
      // store old values for restore
      this._lineColor = this.lineColor;
      this._stroke = this.stroke;

      this.setColor(new _packages2.default.util.Color("#3f72bf"));
      this.setStroke(this.stroke * 4 | 0);
    } else {
      this.setColor(this._lineColor);
      this.setStroke(this._stroke);
    }

    this.isGlowing = flag;

    return this;
  },

  /**
   * You can't drag&drop the resize handles if the line not resizeable.
   * @returns boolean
   **/
  isResizeable: function isResizeable() {
    return true;
  },

  /**
   * Set the line width. This enforce a repaint of the line.
   * This method fires a <i>document dirty</i> event.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       stroke: w
   *     });
   *
   * @param {Number} w The new line width of the figure.
   **/
  setStroke: function setStroke(w) {
    this.stroke = parseFloat(w);

    this.repaint();
    this.fireEvent("change:stroke", { value: this.stroke });

    return this;
  },

  /**
   *
   * The used line width.
   *
   * @returns {Number}
   **/
  getStroke: function getStroke() {
    return this.stroke;
  },

  /**
   *
   * Set the color of the line.
   * This method fires a <i>document dirty</i> event.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       color: color
   *     });
   *
   * @param {draw2d.util.Color|String} color The new color of the line.
   **/
  setColor: function setColor(color) {
    this.lineColor = new _packages2.default.util.Color(color);
    this.repaint();
    this.fireEvent("change:color", { value: this.lineColor });

    return this;
  },

  /**
   *
   * Return the current paint color.
   *
   * @returns {draw2d.util.Color} The paint color of the line.
   **/
  getColor: function getColor() {
    return this.lineColor;
  },

  /**
   *
   * Translate the line with the given x/y offset.
   *
   * @param {Number} dx The new x translate offset
   * @param {Number} dy The new y translate offset
   * @since 4.1.0
   **/
  translate: function translate(dx, dy) {
    this.vertices.each(function (i, e) {
      e.translate(dx, dy);
    });

    // update start/end if the first or last vertex has been changed
    //
    this.start = this.vertices.first().clone();
    this.end = this.vertices.last().clone();

    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    this.svgPathString = null;
    this.repaint();

    return this;
  },

  /**
   *
   * return the bounding box of the line or polygon
   *
   * TODO: precalculate or cache this values
   *
   * @returns {draw2d.geo.Rectangle}
   * @since 4.8.2
   */
  getBoundingBox: function getBoundingBox() {
    var minX = Math.min.apply(Math, _toConsumableArray(this.vertices.asArray().map(function (n) {
      return n.x;
    })));
    var minY = Math.min.apply(Math, _toConsumableArray(this.vertices.asArray().map(function (n) {
      return n.y;
    })));
    var maxX = Math.max.apply(Math, _toConsumableArray(this.vertices.asArray().map(function (n) {
      return n.x;
    })));
    var maxY = Math.max.apply(Math, _toConsumableArray(this.vertices.asArray().map(function (n) {
      return n.y;
    })));
    var width = maxX - minX;
    var height = maxY - minY;

    return new _packages2.default.geo.Rectangle(minX, minY, width, height);
  },

  /**
   *
   * Set the start point of the line.
   * This method fires a <i>document dirty</i> event.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       startX: x,
   *       startY: y
   *     });
   *
   * @param {Number|draw2d.geo.Point} x the x coordinate of the start point
   * @param {Number} [y] the y coordinate of the start point
   **/
  setStartPosition: function setStartPosition(x, y) {
    var pos = new _packages2.default.geo.Point(x, y);
    if (this.start.equals(pos)) {
      return this;
    }

    this.start.setPosition(pos);
    this.vertices.first().setPosition(pos);
    this.repaint();

    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });
    this.fireEvent("change:start", { value: this.start });

    return this;
  },
  /** @deprecated */
  setStartPoint: function setStartPoint(x, y) {
    return this.setStartPosition(x, y);
  },

  setStartX: function setStartX(x) {
    this.setStartPosition(x, this.start.y);
  },

  setStartY: function setStartY(y) {
    this.setStartPosition(this.start.x, y);
  },

  setEndX: function setEndX(x) {
    this.setEndPosition(x, this.end.y);
  },

  setEndY: function setEndY(y) {
    this.setEndPosition(this.end.x, y);
  },

  /**
   * Set the end point of the line.
   * This method fires a <i>document dirty</i> event.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       endX: 3,
   *       endY: 10
   *     });
   *
   *     // or
   *     figure.attr({
   *       end: {x:3, y:10}
   *     });
   * @param {Number|draw2d.geo.Point} x the x coordinate or a draw2d.geo.Point of the end point
   * @param {Number} [y] the y coordinate of the end point
   **/
  setEndPosition: function setEndPosition(x, y) {
    var pos = new _packages2.default.geo.Point(x, y);
    if (this.end.equals(pos)) {
      return this;
    }

    this.end.setPosition(pos);
    this.vertices.last().setPosition(pos);
    this.repaint();

    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    this.fireEvent("change:end", { value: this.end });

    return this;
  },
  /** @deprecated **/
  setEndPoint: function setEndPoint(x, y) {
    return this.setEndPosition(x, y);
  },

  /**
   *
   * Return the x coordinate of the start.
   * @returns {Number}
   **/
  getStartX: function getStartX() {
    return this.start.x;
  },

  /**
   *
   * Return the y coordinate of the start.
   *
   * @returns {Number}
   **/
  getStartY: function getStartY() {
    return this.start.y;
  },

  /**
   *
   * Return the start point.
   *
   * @returns {draw2d.geo.Point}
   **/
  getStartPosition: function getStartPosition() {
    return this.start.clone();
  },
  /** @deprecated **/
  getStartPoint: function getStartPoint() {
    return this.getStartPosition();
  },

  /**
   *
   * Return the x coordinate of the end point
   *
   * @returns {Number}
   **/
  getEndX: function getEndX() {
    return this.end.x;
  },

  /**
   *
   * Return the y coordinate of the end point.
   *
   * @returns {Number}
   **/
  getEndY: function getEndY() {
    return this.end.y;
  },

  /**
   *
   * Return the end point.
   *
   * @returns {draw2d.geo.Point}
   **/
  getEndPosition: function getEndPosition() {
    return this.end.clone();
  },
  /**
   * @deprecated use `getEndPosition`
   * @returns {draw2d.geo.Point}
   **/
  getEndPoint: function getEndPoint() {
    return this.getEndPosition();
  },

  /**
   *
   * The x-offset related to the parent figure or canvas.
   *
   * @returns {Number} the x-offset to the parent figure
   **/
  getX: function getX() {
    return this.getBoundingBox().x;
  },

  /**
   *
   * The x-offset related to the parent figure or canvas.
   *
   * @returns {Number} the x-offset to the parent figure
   **/
  getY: function getY() {
    return this.getBoundingBox().y;
  },

  /**
   *
   * Return the Vertex with the given index.
   *
   * @param {Number} index the index of the vertex to return
   */
  getVertex: function getVertex(index) {
    return this.vertices.get(index);
  },

  /**
   *
   * Update the vertex at the give position with the new coordinate
   *
   * @param {Number} index the index of the vertex to update
   * @param {Number|draw2d.geo.Point} x the x coordinate or the draw2d.geo.Point object
   * @param {Number} [y] the y coordinate or undefined of the second argument is a point
   *
   * @since 4.0.0
   */
  setVertex: function setVertex(index, x, y) {
    if (x instanceof _packages2.default.geo.Point) {
      y = x.y;
      x = x.x;
    }

    var vertex = this.vertices.get(index);

    // invalid point or nothing to do
    //
    if (vertex === null || vertex.x === x && vertex.y === y) {
      return;
    }

    vertex.x = parseFloat(x);
    vertex.y = parseFloat(y);

    // update start/end if the first or last vertex has been changed
    //
    this.start = this.vertices.first().clone();
    this.end = this.vertices.last().clone();

    this.svgPathString = null;
    this.routingRequired = true;
    this.repaint();

    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });
    this.fireEvent("change:vertices", { value: this.vertices });

    return this;
  },

  /**
   *
   * Returns the vertices of the connection
   *
   * @returns {draw2d.util.ArrayList} an draw2d.util.ArrayList of type draw2d.Point
   **/
  getVertices: function getVertices() {
    return this.vertices;
  },

  /**
   *
   * Update the vertices of the object. The given array is copied and assigned.
   *
   * @param {draw2d.util.ArrayList|Array} vertices the new vertices of the polyline.
   *
   * @since 4.0.1
   */
  setVertices: function setVertices(vertices) {
    var _this3 = this;

    var _this = this;
    // convert json document/array to draw2d ArrayList
    //
    if (Array.isArray(vertices)) {
      this.vertices = new _packages2.default.util.ArrayList();
      vertices.forEach(function (element) {
        _this3.vertices.add(new _packages2.default.geo.Point(element));
      });
    }
    // use the given ArrayList
    //
    else if (vertices instanceof _packages2.default.util.ArrayList) {
        this.vertices = vertices.clone(true);
      } else {
        throw "invalid argument for Line.setVertices";
      }

    // can happen if the given vertices array is empty
    //
    if (this.vertices.getSize() > 1) {
      this.start = this.vertices.first().clone();
      this.end = this.vertices.last().clone();
    }

    // update the UI and the segment parts
    this.svgPathString = null;
    this.repaint();

    // align the SelectionHandles to the new situation
    // This is a Hack....normally this should be done below and the Line shouldn't know
    // something about this issue....this is complete a "EditPolicy" domain to handle this.
    if (!this.selectionHandles.isEmpty()) {
      this.editPolicy.each(function (i, e) {
        if (e instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy) {
          e.onUnselect(_this.canvas, _this);
          e.onSelect(_this.canvas, _this);
        }
      });
    }

    // notify the listener about the changes
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    this.fireEvent("change:vertices", { value: this.vertices });

    return this;
  },

  /**
   *
   * Return the segments of the line with {start:s, end: e} JSON array list
   *
   * @returns {draw2d.util.ArrayList}
   */
  getSegments: function getSegments() {
    var result = new _packages2.default.util.ArrayList();
    result.add({ start: this.getStartPosition(), end: this.getEndPosition() });

    return result;
  },

  /**
   *
   * Returns the length of the line.
   *
   * @returns {Number}
   **/
  getLength: function getLength() {
    return Math.sqrt((this.start.x - this.end.x) * (this.start.x - this.end.x) + (this.start.y - this.end.y) * (this.start.y - this.end.y));
  },

  /**
   *
   * Returns the angle of the line in degree.
   *
   * <pre>
   *                                270
   *                              |
   *                              |
   *                              |
   *                              |
   * 180 -------------------------+------------------------> +X
   *                              |                        0
   *                              |
   *                              |
   *                              |
   *                              V +Y
   *                             90
   * </pre>
   * @returns {Number}
   **/
  getAngle: function getAngle() {
    var length = this.getLength();
    var angle = -(180 / Math.PI) * Math.asin((this.start.y - this.end.y) / length);

    if (angle < 0) {
      if (this.end.x < this.start.x) {
        angle = Math.abs(angle) + 180;
      } else {
        angle = 360 - Math.abs(angle);
      }
    } else {
      if (this.end.x < this.start.x) {
        angle = 180 - angle;
      }
    }
    return angle;
  },

  /**
   *
   * Returns the Command to perform the specified Request or null if the shape want cancel the
   * operation or it can't operate the command.
   *
   * @param {draw2d.command.CommandType} request describes the Command being requested
   * @returns {draw2d.command.Command} null or a Command
   * @private
   **/
  createCommand: function createCommand(request) {
    if (request.getPolicy() === _packages2.default.command.CommandType.MOVE) {
      if (this.isDraggable()) {
        return new _packages2.default.command.CommandMoveVertices(this);
      }
    }

    if (request.getPolicy() === _packages2.default.command.CommandType.DELETE) {
      if (this.isDeleteable()) {
        return new _packages2.default.command.CommandDelete(this);
      }
    }

    if (request.getPolicy() === _packages2.default.command.CommandType.MOVE_BASEPOINT) {
      if (this.isDraggable()) {
        return new _packages2.default.command.CommandMoveVertex(this);
      }
    }

    return null;
  },

  installEditPolicy: function installEditPolicy(policy) {
    if (!(policy instanceof _packages2.default.policy.line.LineSelectionFeedbackPolicy) && policy instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy) {
      return; // silently
    }

    this._super(policy);
  },

  /**
   *
   * Checks if the hands over coordinate close to the line. The 'corona' is considered
   * for this test. This means the point isn't direct on the line. Is it only close to the
   * line!
   *
   * @param {Number} px the x coordinate of the test point
   * @param {Number} py the y coordinate of the test point
   * @returns {Boolean}
   **/
  hitTest: function hitTest(px, py) {
    return _packages2.default.shape.basic.Line.hit(this.corona + this.stroke, this.start.x, this.start.y, this.end.x, this.end.y, px, py);
  },

  /**
   *
   * Returns the projection of the point on the line.
   *
   * @param {Number} px the x coordinate of the test point
   * @param {Number} py the y coordinate of the test point
   * @returns {draw2d.geo.Point}
   **/
  pointProjection: function pointProjection(px, py) {
    var pt = new _packages2.default.geo.Point(px, py);
    var p1 = this.getStartPosition();
    var p2 = this.getEndPosition();
    return _packages2.default.geo.Line.pointProjection(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
  },

  /**
   *
   * Returns the point onto the line which has the 'percentage' position onto the line.
   *
   * @param {Number} percentage value between [0..1]
   * @returns {*}
   */
  lerp: function lerp(percentage) {
    var p1 = this.getStartPosition();
    var p2 = this.getEndPosition();
    percentage = Math.min(1, Math.max(0, percentage));
    return new _packages2.default.geo.Point(p1.x + (p2.x - p1.x) * percentage, p1.y + (p2.y - p1.y) * percentage);
  },

  /**
   *
   * Return all intersection points between the given Line.
   *
   * @param {draw2d.shape.basic.Line} other
   * @returns {draw2d.util.ArrayList}
   */
  intersection: function intersection(other) {
    var result = new _packages2.default.util.ArrayList();

    // empty result. the lines are equal...infinit array
    if (other === this) {
      return result;
    }

    var segments1 = this.getSegments();
    var segments2 = other.getSegments();

    segments1.each(function (i, s1) {
      segments2.each(function (j, s2) {
        var p = _packages2.default.shape.basic.Line.intersection(s1.start, s1.end, s2.start, s2.end);
        if (p !== null) {
          result.add(p);
        }
      });
    });
    return result;
  },

  /**
   *
   * Return an objects with all important attributes for XML or JSON serialization
   *
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();
    delete memento.x;
    delete memento.y;
    delete memento.width;
    delete memento.height;

    memento.stroke = this.stroke;
    memento.color = this.getColor().rgba();
    memento.outlineStroke = this.outlineStroke;
    memento.outlineColor = this.outlineColor.rgba();
    if (this.dasharray !== null) {
      memento.dasharray = this.dasharray;
    }

    if (this.editPolicy.getSize() > 0) {
      memento.policy = this.editPolicy.first().NAME;
    }

    // the attribute "vertex" will be overridden by a router if the element is a
    // "PolyLine" instance and has the correct router. Connections mainly ignore this
    // attribute because the start/end is defined by the ports and the vertices in between are
    // calculated by a router.
    memento.vertex = [];
    this.getVertices().each(function (i, e) {
      memento.vertex.push({ x: e.x, y: e.y });
    });

    return memento;
  },

  /**
   *
   * Read all attributes from the serialized properties and transfer them into the shape.
   *
   * @param {Object} memento
   * @returns {this}
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.dasharray === "string") {
      this.dasharray = memento.dasharray;
    }
    if (typeof memento.stroke !== "undefined") {
      this.setStroke(parseFloat(memento.stroke));
    }
    if (typeof memento.color !== "undefined") {
      this.setColor(memento.color);
    }
    if (typeof memento.outlineStroke !== "undefined") {
      this.setOutlineStroke(memento.outlineStroke);
    }
    if (typeof memento.outlineColor !== "undefined") {
      this.setOutlineColor(memento.outlineColor);
    }
    if (typeof memento.policy !== "undefined") {
      try {
        this.installEditPolicy(eval("new " + memento.policy + "()"));
      } catch (exc) {
        debug.warn("Unable to install edit policy '" + memento.policy + "' forced by " + this.NAME + ".setPersistentAttributes. Using default.");
      }
    }

    // restore the vertex of the connection/line if any are given
    //
    // it makes no sense to restore vertices with only zero or one vertex. This
    // isn't a "line" at all.
    if (Array.isArray(memento.vertex) && memento.vertex.length > 1) {
      this.setVertices(memento.vertex);
    }

    return this;
  }
});

/**
 * see: http://en.wikipedia.org/wiki/Line-line_intersection
 *
 * @param {draw2d.geo.Point} a1
 * @param {draw2d.geo.Point} a2
 * @param {draw2d.geo.Point} b1
 * @param {draw2d.geo.Point} b2
 *
 * @static
 * @private
 * @returns {draw2d.geo.Point}
 */
_packages2.default.shape.basic.Line.intersection = function (a1, a2, b1, b2) {
  var result = null;

  var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
  var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
  var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      result = new _packages2.default.geo.Point(a1.x + ua * (a2.x - a1.x) | 0, a1.y + ua * (a2.y - a1.y) | 0);

      // determine if the lines are crossing or just touching
      //
      result.justTouching = 0 === ua || ua === 1 || 0 === ub || ub === 1;
    }
  }

  return result;
};

/**
 * Static util function to determine is a point(px,py) on the line(x1,y1,x2,y2)
 * A simple hit test.
 *
 * @returns {Boolean}
 * @static
 * @private
 * @param {Number} coronaWidth the accepted corona for the hit test
 * @param {Number} X1 x coordinate of the start point of the line
 * @param {Number} Y1 y coordinate of the start point of the line
 * @param {Number} X2 x coordinate of the end point of the line
 * @param {Number} Y2 y coordinate of the end point of the line
 * @param {Number} px x coordinate of the point to test
 * @param {Number} py y coordinate of the point to test
 **/
_packages2.default.shape.basic.Line.hit = function (coronaWidth, X1, Y1, X2, Y2, px, py) {
  return _packages2.default.geo.Line.distance(X1, Y1, X2, Y2, px, py) < coronaWidth;
};

/***/ }),

/***/ "./src/shape/basic/LineEndResizeHandle.js":
/*!************************************************!*\
  !*** ./src/shape/basic/LineEndResizeHandle.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Selection handle for connections and normal lines.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.LineResizeHandle
 */
_packages2.default.shape.basic.LineEndResizeHandle = _packages2.default.shape.basic.LineResizeHandle.extend(
/** @lends draw2d.shape.basic.LineEndResizeHandle.prototype */
{

  NAME: "draw2d.shape.basic.LineEndResizeHandle",

  /**
   *
   */
  init: function init(figure) {
    this._super({ owner: figure, index: figure.getVertices().getSize() - 1 });
  },

  /**
   *
   * Return the Port assigned to this ResizeHandle if the line is an instance of draw2d.Connection
   *
   * @returns {draw2d.Port}
   */
  getRelatedPort: function getRelatedPort() {
    if (this.owner instanceof _packages2.default.Connection) {
      return this.owner.getTarget();
    }

    return null;
  },

  /**
   *
   * Return the peer Port assigned to this ResizeHandle if the line is an instance of draw2d.Connection
   *
   * @returns {draw2d.Port}
   */
  getOppositePort: function getOppositePort() {
    if (this.owner instanceof _packages2.default.Connection) {
      return this.owner.getSource();
    }

    return null;
  },

  /**
   *
   * Called from the framework during a drag&drop operation
   *
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @returns {Boolean}
   * @private
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2) {
    this._super(dx, dy, dx2, dy2);

    var objPos = this.owner.getEndPoint().clone();
    objPos.translate(dx2, dy2);

    if (this.command !== null) {
      this.command.updatePosition(objPos);
    }

    this.owner.setEndPoint(objPos);

    this.owner.isMoving = true;

    return true;
  },

  /**
   *
   * Resizehandle has been drop on a InputPort/OutputPort.
   *
   * @param {draw2d.Figure} dropTarget
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onDrop: function onDrop(dropTarget, x, y, shiftKey, ctrlKey) {
    this.owner.isMoving = false;

    if (this.owner instanceof _packages2.default.Connection && this.command !== null) {
      this.command.setNewPorts(this.owner.getSource(), dropTarget);
      this.getCanvas().getCommandStack().execute(this.command);
    }
    this.command = null;
  },

  /**
   *
   * Controls the location of the resize handle
   *
   **/
  relocate: function relocate() {

    var resizeWidthHalf = this.getWidth() / 2;
    var resizeHeightHalf = this.getHeight() / 2;

    var anchor = this.owner.getEndPoint();

    this.setPosition(anchor.x - resizeWidthHalf, anchor.y - resizeHeightHalf);

    return this;
  }
});

/***/ }),

/***/ "./src/shape/basic/LineResizeHandle.js":
/*!*********************************************!*\
  !*** ./src/shape/basic/LineResizeHandle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Base class for selection handle for connections and normal lines.
 *
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Circle
 */
_packages2.default.shape.basic.LineResizeHandle = _packages2.default.shape.basic.Circle.extend(
/** @lends draw2d.shape.basic.LineResizeHandle.prototype */
{

  NAME: "draw2d.shape.basic.LineResizeHandle",

  /**
   *
   */
  init: function init(attr, setter, getter) {
    var _this = this;

    this.zoomCallback = function () {
      _this.attr({
        width: _this.origWidth * _this.getCanvas().getZoom(),
        height: _this.origHeight * _this.getCanvas().getZoom(),
        stroke: _this.origStroke * _this.getCanvas().getZoom()
      });
      // size of the ResizeHandle has changed. Force a reposition of handle
      //
      if (!_this.blockEvent) _this.owner.fireEvent("move", {});
    };

    this._super((0, _extend2.default)({
      bgColor: "#5bcaff",
      stroke: 1,
      width: 10,
      height: 10,
      minWidth: 0.3,
      minHeight: 0.3,
      selectable: false
    }, attr), (0, _extend2.default)({
      owner: this.setOwner,
      index: this.setIndex
    }, setter), (0, _extend2.default)({
      owner: this.getOwner,
      index: this.getIndex
    }, getter));

    // required in the SelectionEditPolicy to indicate the type of figure
    // which the user clicks
    this.isResizeHandle = true;
    this.currentTarget = null;

    this.origWidth = this.width;
    this.origHeight = this.height;
    this.origStroke = this.stroke;
  },

  /**
   * 
   * Returns the current used SVG as string
   *
   * @returns {String}
   */
  getOwner: function getOwner() {
    return this.owner;
  },

  setOwner: function setOwner(owner) {
    this.owner = owner;
    return this;
  },

  /**
   * 
   * Returns the index of the selection. In case of a PlyLine the count is dynamic.
   *
   * @returns {Number}
   */
  getIndex: function getIndex() {
    return this.index;
  },

  setIndex: function setIndex(index) {
    this.index = index;
    return this;
  },

  /**
   * @inheritdoc
   */
  createShapeElement: function createShapeElement() {
    var shape = this._super();

    shape.attr({ "cursor": "move" });
    return shape;
  },

  /**
   * @inheritdoc
   **/
  setBackgroundColor: function setBackgroundColor(color) {
    color = new _packages2.default.util.Color(color);

    this.bgGradient = "r(.4,.3)" + color.hash() + "-" + color.darker(0.1).hash() + ":60-" + color.darker(0.2).hash();
    this._super(color);
    this.setColor(color.darker(0.3));

    return this;
  },

  /**
   * 
   * Return the port below the ResizeHandle.
   *
   * @template
   * @returns {draw2d.Port}
   */
  getRelatedPort: function getRelatedPort() {
    return null;
  },

  /**
   * 
   * Return the port of the other side of the related connection.
   *
   * @template
   * @returns {draw2d.Port}
   */
  getOppositePort: function getOppositePort() {
    return null;
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    if (this.bgColor.hash() === "none") {
      attributes.fill = this.bgColor.rgba();
    } else if (this.getAlpha() < 0.9) {
      attributes.fill = this.bgColor.rgba();
    } else {
      attributes.fill = this.bgGradient;
    }

    this._super(attributes);
  },

  /**
   * Called if the drag and drop action begins. You can return [false] if you
   * want avoid the that the figure can be move.
   *
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @type {Boolean}
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
    this.command = this.owner.createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.MOVE_BASEPOINT));
    // no drag&drop allowed if we didn'T have a valid command.
    // This is one way to send a veto for Connection reconnect
    if (this.command !== null) {
      this.command.setIndex(this.index);
    }

    this.setAlpha(0.2);
    this.shape.attr({ "cursor": "crosshair" });

    // fire an event
    // @since 5.3.3
    this.fireEvent("dragstart", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });

    return true;
  },

  /**
   * 
   * Called from the framework during a drag&drop operation
   *
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @returns {Boolean}
   * @private
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2) {
    this.setPosition(this.x + dx2, this.y + dy2);

    var port = this.getOppositePort();

    var target = port !== null ? port.getCanvas().getBestFigure(this.getX(), this.getY(), [this, this.owner]) : null;

    // the hovering element has been changed
    if (target !== this.currentTarget) {

      if (this.currentTarget !== null) {
        this.currentTarget.onDragLeave(port);
        this.currentTarget.setGlow(false);
        this.currentTarget.fireEvent("dragLeave", { draggingElement: port });
      }

      if (target !== null) {
        this.currentTarget = target.delegateTarget(port);
        if (this.currentTarget !== null) {
          this.currentTarget.setGlow(true);
          this.currentTarget.onDragEnter(port); // legacy
          this.currentTarget.fireEvent("dragEnter", { draggingElement: port });
        }
      }
    }

    return true;
  },

  /**
   *  Called after a drag and drop action.<br>
   *        Sub classes can override this method to implement additional stuff. Don't forget to call the super implementation via <code>this._super();</code>
   *
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean}
   */
  onDragEnd: function onDragEnd(x, y, shiftKey, ctrlKey) {
    if (!this.isDraggable()) {
      return false;
    }

    this.shape.attr({ "cursor": "move" });

    var port = this.getOppositePort();
    if (port !== null) {
      if (this.currentTarget !== null) {

        this.onDrop(this.currentTarget, x, y, shiftKey, ctrlKey);
        this.currentTarget.onDragLeave(port);
        this.currentTarget.setGlow(false);
        this.currentTarget.fireEvent("dragLeave", { draggingElement: port });
        this.currentTarget.onCatch(this, x, y, shiftKey, ctrlKey);
        this.currentTarget = null;
      }
    }

    this.owner.isMoving = false;
    // A Connection is stuck to the corresponding ports. So we must reset the position
    // to the origin port if we doesn't drop the ResizeHandle on a other port.
    //
    if (this.owner instanceof _packages2.default.Connection) {
      if (this.command !== null) {
        this.command.cancel();
      }
    }
    //
    else {
        // An non draggable resizeHandle doesn't create a move/resize command.
        // This happens if the selected figure has set "isResizeable=false".
        //
        if (this.command !== null) {
          this.getCanvas().getCommandStack().execute(this.command);
        }
      }
    this.command = null;

    this.setAlpha(1);

    // fire an event
    // @since 5.3.3
    this.fireEvent("dragend", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
  },

  /**
   * 
   * Controls the position of the ResizeHandle
   * Called by the framework.
   *
   **/
  relocate: function relocate() {

    return this;
  },

  /**
   * 
   * The LineResizeHandle didn't support the SnapToHelper feature if the
   * corresponding object is an Connection. A Connection is always bounded to
   * Port. In this case it makes no sense to use a Grid or Geometry for snapping.
   *
   * @returns {Boolean} return false if the corresponding object didn't support snapTo
   **/
  supportsSnapToHelper: function supportsSnapToHelper() {
    if (this.owner instanceof _packages2.default.Connection) {
      return false;
    }

    return true;
  },

  /**
   * 
   * Show the ResizeHandle and add it to the canvas.<br>
   * Additional bring it in to the front of other figures.
   *
   * @param {draw2d.Canvas} canvas the canvas to use
   * @param {Number} x the x-position
   * @param {Number} y the y-position
   **/
  show: function show(canvas, x, y) {
    if (x) debugger;
    // don't call the parent function. The parent functions make this object selectable/deleteable
    // and a resize handle can't be deleted.
    this.setCanvas(canvas);
    try {
      this.blockEvent = true;
      this.zoomCallback();
    } finally {
      this.blockEvent = false;
    }

    //     this.setPosition(x,y);
    this.shape.toFront();
    this.canvas.resizeHandles.add(this);
  },

  /**
   * 
   * Hide the resize handle and remove it from the canvas.
   *
   **/
  hide: function hide() {
    // don't call the parent function. The parent functions delete this object
    // and a resize handle shouldn't be deleted.
    if (this.shape === null) {
      return;
    }

    this.canvas.resizeHandles.remove(this);
    this.setCanvas(null);
  },

  setCanvas: function setCanvas(canvas) {

    if (this.canvas !== null) {
      this.canvas.off(this.zoomCallback);
    }

    this._super(canvas);

    if (this.canvas !== null) {
      this.canvas.on("zoom", this.zoomCallback);
    }
  },

  /**
   * 
   * Override this method and redirect them to the canvas. A ResizeHandle didn't support
   * Keyboard interaction at the moment.
   *
   * @param {Number} keyCode the id of the pressed key
   * @param {Boolean} ctrl true if the user has pressed the CTRL/STRG key as well.
   **/
  onKeyDown: function onKeyDown(keyCode, ctrl) {
    // don't call the parent function. The parent functions delete this object
    // and a resize handle can't be deleted.
    this.canvas.onKeyDown(keyCode, ctrl);
  }
});

/***/ }),

/***/ "./src/shape/basic/LineStartResizeHandle.js":
/*!**************************************************!*\
  !*** ./src/shape/basic/LineStartResizeHandle.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Selection handle for connections and normal lines.
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.LineResizeHandle
 */
_packages2.default.shape.basic.LineStartResizeHandle = _packages2.default.shape.basic.LineResizeHandle.extend(
/** @lends draw2d.shape.basic.LineStartResizeHandle.prototype */
{

  NAME: "draw2d.shape.basic.LineStartResizeHandle",

  /**
   *
   */
  init: function init(figure) {
    this._super({ owner: figure, index: 0 });
  },

  /**
   * Returns the Port below the ResizeHandle
   *
   * @returns {draw2d.Port}
   */
  getRelatedPort: function getRelatedPort() {
    if (this.owner instanceof _packages2.default.Connection) return this.owner.getSource();

    return null;
  },

  /**
   * Returns the Port on the opposite side of the ResizeHandle
   *
   * @returns {draw2d.Port}
   */
  getOppositePort: function getOppositePort() {
    if (this.owner instanceof _packages2.default.Connection) return this.owner.getTarget();

    return null;
  },

  /**
   * 
   * Called from the framework during a drag&drop operation
   *
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   * @returns {Boolean}
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2) {
    this._super(dx, dy, dx2, dy2);

    var objPos = this.owner.getStartPoint();
    objPos.translate(dx2, dy2);

    if (this.command !== null) {
      this.command.updatePosition(objPos);
    }
    this.owner.setStartPoint(objPos);

    this.owner.isMoving = true;

    return true;
  },

  /**
   * 
   * Resize handle has been drop on a InputPort/OutputPort.
   *
   * @param {draw2d.Port} dropTarget
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   **/
  onDrop: function onDrop(dropTarget, x, y, shiftKey, ctrlKey) {
    this.owner.isMoving = false;

    // The ResizeHandle of a Connection has been dropped on a Port
    // This will enforce a ReconnectCommand
    if (this.owner instanceof _packages2.default.Connection && this.command !== null) {
      this.command.setNewPorts(dropTarget, this.owner.getTarget());
      this.getCanvas().getCommandStack().execute(this.command);
    }
    this.command = null;
  },

  /**
   * 
   * Controls the location of the resize handle
   **/
  relocate: function relocate() {
    var resizeWidthHalf = this.getWidth() / 2;
    var resizeHeightHalf = this.getHeight() / 2;

    var anchor = this.owner.getStartPoint();

    this.setPosition(anchor.x - resizeWidthHalf, anchor.y - resizeHeightHalf);

    return this;
  }
});

/***/ }),

/***/ "./src/shape/basic/Oval.js":
/*!*********************************!*\
  !*** ./src/shape/basic/Oval.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Oval figure.
 *
 * @example
 *
 *    let oval =  new draw2d.shape.basic.Oval({width:150, height:100, x:50, y:10});
 *
 *    canvas.add(oval);
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
_packages2.default.shape.basic.Oval = _packages2.default.VectorFigure.extend(
/** @lends draw2d.shape.basic.Oval.prototype */
{

  NAME: "draw2d.shape.basic.Oval",

  /**
   *
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super((0, _extend2.default)({
      bgColor: "#C02B1D",
      color: "#1B1B1B"
    }, attr), (0, _extend2.default)({
      center: this.setCenter
    }, setter), getter);
  },

  /**
   * @template
   **/
  createShapeElement: function createShapeElement() {
    var halfW = this.getWidth() / 2;
    var halfH = this.getHeight() / 2;

    return this.canvas.paper.ellipse(this.getAbsoluteX() + halfW, this.getAbsoluteY() + halfH, halfW, halfH);
  },

  /**
   *
   * Get the center of the figure
   *
   */
  getCenter: function getCenter() {
    var w2 = this.getWidth() / 2;
    var h2 = this.getHeight() / 2;

    return this.getPosition().translate(w2, h2);
  },

  /**
   *
   * Set the center of the figure.
   *
   * @param {Number|draw2d.geo.Point} x the new x coordinate of the center or a draw2d.geo.Point object with the center
   * @param {Number} [y] the y coordinate of the new center of the first argument isn't a draw2d.geo.Point object
   */
  setCenter: function setCenter(x, y) {
    var pos = new _packages2.default.geo.Point(x, y);
    var w2 = this.getWidth() / 2;
    var h2 = this.getHeight() / 2;

    pos.translate(-w2, -h2);
    this.setPosition(pos);

    this.fireEvent("change:center", { value: { x: x, y: y } });

    return this;
  },

  /**
   * @inheritdoc
   *
   * @template
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    // don't override cx/cy if inherited class has set the center already.
    if (typeof attributes.rx === "undefined") {
      attributes.rx = this.width / 2;
      attributes.ry = this.height / 2;
    }

    // don't override cx/cy if inherited class has set the center already.
    if (typeof attributes.cx === "undefined") {
      attributes.cx = this.getAbsoluteX() + attributes.rx;
      attributes.cy = this.getAbsoluteY() + attributes.ry;
    }

    this._super(attributes);
  },

  /**
   *
   *
   *   NOTE: Rotation will need to be added to this function
   *
   **/
  intersectionWithLine: function intersectionWithLine(a1, a2) {
    var rx = this.getWidth() / 2;
    var ry = this.getHeight() / 2;

    var result = new _packages2.default.util.ArrayList();

    var origin = new _packages2.default.geo.Point(a1.x, a1.y);
    var dir = a2.subtract(a1);
    var center = new _packages2.default.geo.Point(this.getAbsoluteX() + rx, this.getAbsoluteY() + ry);
    var diff = origin.subtract(center);
    var mDir = new _packages2.default.geo.Point(dir.x / (rx * rx), dir.y / (ry * ry));
    var mDiff = new _packages2.default.geo.Point(diff.x / (rx * rx), diff.y / (ry * ry));

    var a = dir.dot(mDir);
    var b = dir.dot(mDiff);
    var c = diff.dot(mDiff) - 1.0;
    var d = b * b - a * c;

    if (d < 0) {
      // "Outside"
    } else if (d > 0) {
      var root = Math.sqrt(d);
      var t_a = (-b - root) / a;
      var t_b = (-b + root) / a;

      if ((t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b)) {
        if (t_a < 0 && t_b < 0 || t_a > 1 && t_b > 1) {
          //"Outside";
        } else {
            //"Inside";
          }
      } else {
        if (0 <= t_a && t_a <= 1) result.add(a1.lerp(a2, t_a));
        if (0 <= t_b && t_b <= 1) result.add(a1.lerp(a2, t_b));
      }
    } else {
      var t = -b / a;
      if (0 <= t && t <= 1) {
        result.add(a1.lerp(a2, t));
      } else {
        //"Outside";
      }
    }

    return result;
  }

});

/***/ }),

/***/ "./src/shape/basic/PolyLine.js":
/*!*************************************!*\
  !*** ./src/shape/basic/PolyLine.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _JSONUtil = __webpack_require__(/*! ../../util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A PolyLine is a line with more than 2 points.
 *
 *
 * @example
 *
 *    let line = new draw2d.shape.basic.PolyLine();
 *    line.setVertices([{x:10,y:10},{x:80,y:70},{x:100,y:110}]);
 *    canvas.add(line);
 *
 *
 *    canvas.setCurrentSelection(line);
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Line
 */
_packages2.default.shape.basic.PolyLine = _packages2.default.shape.basic.Line.extend(
/** @lends draw2d.shape.basic.PolyLine.prototype */
{

  NAME: "draw2d.shape.basic.PolyLine",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    // internal status handling for performance reasons
    //
    this.svgPathString = null;
    this.oldPoint = null;

    this.router = null;
    this.routingRequired = true;
    this.lineSegments = new _packages2.default.util.ArrayList();

    this.radius = "";

    this._super((0, _extend2.default)({
      router: new _packages2.default.layout.connection.VertexRouter()
    }, attr), (0, _extend2.default)({}, {
      // @attr {draw2d.layout.connection.ConnectionRouter} the router to use to layout the polyline */
      router: this.setRouter,
      // @attr {Number} radius the radius to render the line edges */
      radius: this.setRadius
    }, setter), (0, _extend2.default)({}, {
      router: this.getRouter,
      radius: this.getRadius
    }, getter));
  },

  /**
   * 
   * Sets the corner radius of the edges.
   *
   * @param {Number} radius the corner radius
   * @since 4.2.1
   */
  setRadius: function setRadius(radius) {
    this.radius = radius;
    this.svgPathString = null;
    this.repaint();
    this.fireEvent("change:radius", { value: this.radius });

    return this;
  },

  setOutlineStroke: function setOutlineStroke(w) {
    if (this.outlineStroke !== w) {
      this.svgPathString = null;
      this.routingRequired = true;
    }
    this._super(w);

    return this;
  },

  /**
   * 
   * Get the corner radius of the edges.
   *
   * @returns {Number}
   * @since 4.2.1
   */
  getRadius: function getRadius() {
    return this.radius;
  },

  /**
   * 
   * Set the start point of the line.
   *
   * @param {Number} x the x coordinate of the start point
   * @param {Number} y the y coordinate of the start point
   **/
  setStartPoint: function setStartPoint(x, y) {
    if (this.vertices.getSize() > 0) {
      this.vertices.first().setPosition(x, y);
    } else {
      this.vertices.add(new _packages2.default.geo.Point(x, y));
    }
    this.start = this.vertices.first().clone();
    //     if(this.isInDragDrop===false)
    this.calculatePath({ startMoved: true, endMoved: false });

    this.repaint();

    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    this.fireEvent("change:start", { value: this.start });

    return this;
  },

  /**
   * 
   * Set the end point of the line.
   *
   * @param {Number} x the x coordinate of the end point
   * @param {Number} y the y coordinate of the end point
   */
  setEndPoint: function setEndPoint(x, y) {
    if (this.vertices.getSize() > 1) {
      this.vertices.last().setPosition(x, y);
    } else {
      this.vertices.add(new _packages2.default.geo.Point(x, y));
    }
    this.end = this.vertices.last().clone();

    if (this.isInDragDrop === false) this.calculatePath({ startMoved: false, endMoved: true });

    this.repaint();

    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });
    this.fireEvent("change:end", { value: this.end });

    return this;
  },

  /**
   * 
   * Inserts the draw2d.geo.Point object into the vertex list of the polyline just after the object with the given index.
   *
   * @param {Number|draw2d.geo.Point} x the x coordinate or the draw2d.geo.Point object
   * @param {Number} [y] the y coordinate or undefined of the second argument is a point
   *
   * @since 4.0.0
   */
  addVertex: function addVertex(x, y) {
    this.vertices.add(new _packages2.default.geo.Point(x, y));

    this.start = this.vertices.first().clone();
    this.end = this.vertices.last().clone();

    this.svgPathString = null;
    this.repaint();

    if (!this.selectionHandles.isEmpty()) {
      var _this = this;
      this.editPolicy.each(function (i, e) {
        if (e instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy) {
          e.onUnselect(_this.canvas, _this);
          e.onSelect(_this.canvas, _this);
        }
      });
    }
    this.fireEvent("change:vertices", { value: this.vertices });

    return this;
  },

  /**
   * 
   * Inserts the draw2d.geo.Point object into the vertex list of the polyline just after the object with the given index.
   *
   * @param {Number} index the insert index
   * @param {Number|draw2d.geo.Point} x the x coordinate or the draw2d.geo.Point object
   * @param {Number} [y] the y coordinate or undefined of the second argument is a point
   *
   * @since 4.0.0
   */
  insertVertexAt: function insertVertexAt(index, x, y) {
    var vertex = new _packages2.default.geo.Point(x, y);

    this.vertices.insertElementAt(vertex, index);

    this.start = this.vertices.first().clone();
    this.end = this.vertices.last().clone();

    this.svgPathString = null;
    this.repaint();

    if (!this.selectionHandles.isEmpty()) {
      var _this = this;
      this.editPolicy.each(function (i, e) {
        if (e instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy) {
          e.onUnselect(_this.canvas, _this);
          e.onSelect(_this.canvas, _this);
        }
      });
    }
    this.fireEvent("change:vertices", { value: this.vertices });

    return this;
  },

  /**
   * 
   * Remove a vertex from the polyline and return the removed point. The current installed connection router
   * can send an veto for this operation.
   *
   * @param index
   * @returns {draw2d.geo.Point} the removed point or null of the current router decline this operation
   * @since 4.0.0
   */
  removeVertexAt: function removeVertexAt(index) {
    var removedPoint = this.vertices.removeElementAt(index);

    this.start = this.vertices.first().clone();
    this.end = this.vertices.last().clone();

    this.svgPathString = null;
    this.repaint();

    if (!this.selectionHandles.isEmpty()) {
      var _this = this;
      this.editPolicy.each(function (i, e) {
        if (e instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy) {
          e.onUnselect(_this.canvas, _this);
          e.onSelect(_this.canvas, _this);
        }
      });
    }
    this.fireEvent("change:vertices", { value: this.vertices });

    return removedPoint;
  },

  /**
   * 
   * Set the router for this connection.
   *
   * @param {draw2d.layout.connection.ConnectionRouter} [router] the new router for this connection or null if the connection should use the default routing
   **/
  setRouter: function setRouter(router) {
    if (this.router !== null) {
      this.router.onUninstall(this);
    }

    if (typeof router === "undefined" || router === null) {
      this.router = new _packages2.default.layout.connection.DirectRouter();
    } else {
      this.router = router;
    }

    this.router.onInstall(this);

    this.routingRequired = true;

    // repaint the connection with the new router
    this.repaint();

    this.fireEvent("change:router", { value: this.router });

    return this;
  },

  /**
   * 
   * Return the current active router of this connection.
   *
   * @returns draw2d.layout.connection.ConnectionRouter
   **/
  getRouter: function getRouter() {
    return this.router;
  },

  /**
   * 
   * Calculate the path of the polyline
   *
   * @param {Object} [routingHints] some helper attributes for the router
   * @param {Boolean} routingHints.startMoved is true if just the start location has moved
   * @param {Boolean} routingHints.endMoved is true if the destination location has changed
   * @param {Boolean} routingHints.oldVertices store old vertices for after processing
   *
   * @private
   */
  calculatePath: function calculatePath(routingHints) {
    routingHints = routingHints || {};

    if (this.shape === null) {
      return;
    }

    this.svgPathString = null;

    routingHints.oldVertices = this.vertices;

    // cleanup the routing cache
    //
    this.oldPoint = null;
    this.lineSegments = new _packages2.default.util.ArrayList();
    this.vertices = new _packages2.default.util.ArrayList();

    // Use the internal router
    //
    this.router.route(this, routingHints);
    this.routingRequired = false;
    this.fireEvent("routed");
    this.fireEvent("change:route", {});
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return this;
    }

    if (this.svgPathString === null || this.routingRequired === true) {
      this.calculatePath();
    }

    if (typeof attributes === "undefined") {
      attributes = {};
    }
    attributes.path = this.svgPathString;
    _JSONUtil2.default.ensureDefault(attributes, "stroke-linecap", "round");
    _JSONUtil2.default.ensureDefault(attributes, "stroke-linejoin", "round");

    return this._super(attributes);
  },

  /**
   * 
   * Return all line segments of the polyline.
   *
   * @returns {draw2d.util.ArrayList}
   */
  getSegments: function getSegments() {
    return this.lineSegments;
  },

  /**
   * used for the router to add the calculated points
   *
   * @param p
   * @param y
   */
  addPoint: function addPoint(p, y) {
    if (typeof y !== "undefined") {
      p = new _packages2.default.geo.Point(p, y);
    }
    this.vertices.add(p);

    if (this.oldPoint !== null) {
      // store the painted line segment for the "mouse selection test"
      // (required for user interaction)
      this.lineSegments.add({
        start: this.oldPoint,
        end: p
      });
    }
    this.svgPathString = null;
    this.oldPoint = p;
  },

  /**
   * 
   * Called if the drag and drop action begins. You can return [false] if you
   * want avoid that the figure can be move.
   *
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean} true if the figure accepts dragging
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey, isFaked) {
    var result = this._super(x, y, shiftKey, ctrlKey, isFaked);

    if (result === true && isFaked !== true) {
      this.draggedSegment = this.hitSegment(x, y);
    }
    return result;
  },

  /**
   * 
   * Returns the length of the polyline.
   *
   * @returns {Number}
   * @since 6.1.43
   **/
  getLength: function getLength() {
    var result = 0;
    for (var i = 0; i < this.lineSegments.getSize(); i++) {
      var segment = this.lineSegments.get(i);
      var p1 = segment.start;
      var p2 = segment.end;
      result += Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
    }
    return result;
  },

  setVertices: function setVertices(vertices) {
    // inform the router tha the vertices has set outside. This switch some
    // router from full autoroute to half autoroute
    this.router.verticesSet(this);

    this._super(vertices);
  },

  /**
   * 
   * Returns the projection of the point on the line.
   *
   * @param {Number} px the x coordinate of the test point
   * @param {Number} py the y coordinate of the test point
   * @returns {draw2d.geo.Point}
   **/
  pointProjection: function pointProjection(px, py) {
    var result = null,
        projection = null,
        p1 = null,
        p2 = null,
        segment = null;
    var lastDist = Number.MAX_SAFE_INTEGER;
    var pt = new _packages2.default.geo.Point(px, py);
    for (var i = 0; i < this.lineSegments.getSize(); i++) {
      segment = this.lineSegments.get(i);
      p1 = segment.start;
      p2 = segment.end;
      projection = _packages2.default.geo.Line.pointProjection(p1.x, p1.y, p2.x, p2.y, pt.x, pt.y);
      if (projection !== null) {
        var dist = projection.distance(pt);
        if (result == null || dist < lastDist) {
          result = projection;
          result.index = i;
          lastDist = dist;
        }
      }
    }

    if (result !== null) {
      var length = 0;
      var _segment = void 0;
      for (var _i = 0; _i < result.index; _i++) {
        _segment = this.lineSegments.get(_i);
        length += _segment.start.distance(_segment.end);
      }
      _segment = this.lineSegments.get(result.index);
      p1 = _segment.start;
      p2 = _segment.end;
      length += p1.distance(p2) * _packages2.default.geo.Line.inverseLerp(p2.x, p2.y, p1.x, p1.y, result.x, result.y);
      result.percentage = 1.0 / this.getLength() * length;
    }
    return result;
  },

  /**
   * 
   * Returns the point onto the line which has the relative 'percentage' position onto the line.
   *
   * @param {Number} percentage the relative position between [0..1]
   * @returns {draw2d.geo.Point}
   */
  lerp: function lerp(percentage) {
    var length = this.getLength() * percentage;
    var lastValidLength = length;
    var segment = null,
        p1 = null,
        p2 = null;
    for (var i = 0; i < this.lineSegments.getSize(); i++) {
      segment = this.lineSegments.get(i);
      p1 = segment.start;
      p2 = segment.end;
      length = length - p1.distance(p2);
      if (length <= 0) {
        percentage = 1.0 / p1.distance(p2) * lastValidLength;
        return new _packages2.default.geo.Point(p1.x + (p2.x - p1.x) * percentage, p1.y + (p2.y - p1.y) * percentage);
      }
      lastValidLength = length;
    }
    return p2;
  },

  /**
   * 
   * get the best segment of the line which is below the given coordinate or null if
   * all segment are not below the coordinate. <br>
   * The 'corona' property of the polyline is considered for this test. This means
   * the point isn't direct on the line. Is it only close to the line!
   *
   * @param {Number} px the x coordinate of the test point
   * @param {Number} py the y coordinate of the test point
   * @returns {Object}
   * @since 4.4.0
   **/
  hitSegment: function hitSegment(px, py) {
    for (var i = 0; i < this.lineSegments.getSize(); i++) {
      var segment = this.lineSegments.get(i);
      if (_packages2.default.shape.basic.Line.hit(this.corona + this.stroke, segment.start.x, segment.start.y, segment.end.x, segment.end.y, px, py)) {
        return { index: i, start: segment.start, end: segment.end };
      }
    }
    return null;
  },

  /**
   * 
   * Checks if the hands over coordinate close to the line. The 'corona' property of the polyline
   * is considered for this test. This means the point isn't direct on the line. Is it only close to the
   * line!
   *
   * @param {Number} px the x coordinate of the test point
   * @param {Number} py the y coordinate of the test point
   * @returns {Boolean}
   **/
  hitTest: function hitTest(px, py) {
    return this.hitSegment(px, py) !== null;
  },

  /**
   * @inheritdoc
   */
  createCommand: function createCommand(request) {

    if (request.getPolicy() === _packages2.default.command.CommandType.DELETE) {
      if (this.isDeleteable() === true) {
        return new _packages2.default.command.CommandDelete(this);
      }
    } else if (request.getPolicy() === _packages2.default.command.CommandType.MOVE_VERTEX) {
      if (this.isResizeable() === true) {
        return new _packages2.default.command.CommandMoveVertex(this);
      }
    } else if (request.getPolicy() === _packages2.default.command.CommandType.MOVE_VERTICES) {
      if (this.isResizeable() === true) {
        return new _packages2.default.command.CommandMoveVertices(this);
      }
    }

    return this._super(request);
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = (0, _extend2.default)(this._super(), {
      router: this.router.NAME,
      radius: this.radius
    });

    memento = this.router.getPersistentAttributes(this, memento);

    return memento;
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.router !== "undefined") {
      try {
        this.setRouter(eval("new " + memento.router + "()"));
      } catch (exc) {
        debug.warn("Unable to install router '" + memento.router + "' forced by " + this.NAME + ".setPersistentAttributes. Using default");
      }
    }

    if (typeof memento.radius !== "undefined") {
      this.setRadius(memento.radius);
    }

    this.router.setPersistentAttributes(this, memento);

    if (this.vertices.getSize() > 1) {
      this.start = this.vertices.first().clone();
      this.end = this.vertices.last().clone();
    }
  }
});

/***/ }),

/***/ "./src/shape/basic/Polygon.js":
/*!************************************!*\
  !*** ./src/shape/basic/Polygon.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _JSONUtil = __webpack_require__(/*! ../../util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @class
 * A Polygon figure.
 *
 *
 * @example
 *
 *    let p1 =  new draw2d.shape.basic.Polygon({width:100, height:100});
 *    let p2 =  new draw2d.shape.basic.Polygon({width:100, height:60});
 *
 *    canvas.add(p1,10,10);
 *    canvas.add(p2,100,10);
 *
 *    p2.attr({color:"#f0f000", alpha:0.7});
 *
 *    canvas.setCurrentSelection(p2);
 *
 * @author Andreas Herz
 * @extends draw2d.VectorFigure
 */
_packages2.default.shape.basic.Polygon = _packages2.default.VectorFigure.extend(
/** @lends draw2d.shape.basic.Polygon.prototype */
{

  NAME: "draw2d.shape.basic.Polygon",

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.minX = 0;
    this.minY = 0;
    this.maxX = 0;
    this.maxY = 0;
    this.vertices = new _packages2.default.util.ArrayList();

    this._super(attr, setter, getter);

    // we must cache the initial width/height because the width/height of the shape
    // is recalculated in the addVertex method. After the first call this values are 0/0
    if (this.vertices.getSize() === 0) {
      var w = this.width;
      var h = this.height;
      var pos = this.getPosition();
      this.addVertex(new _packages2.default.geo.Point(0, 0));
      this.addVertex(new _packages2.default.geo.Point(w, 0));
      this.addVertex(new _packages2.default.geo.Point(w, h));

      this.setPosition(pos);
    }

    this.svgPathString = null;

    this.installEditPolicy(new _packages2.default.policy.figure.VertexSelectionFeedbackPolicy());
  },

  /**
   * @inheritdoc
   */
  setRadius: function setRadius(radius) {
    this.svgPathString = null;

    this._super(radius);
    this.fireEvent("change:radius", { value: radius });

    return this;
  },

  /**
   * @inheritdoc
   */
  createShapeElement: function createShapeElement() {
    // return some good default...
    return this.canvas.paper.path("M0 10L100 100");
  },

  /**
   * 
   * calculate the path of the polygon
   *
   */
  calculatePath: function calculatePath() {
    var radius = this.getRadius();
    var path = [];
    // hard corners
    //
    if (radius === 0) {
      var _length = this.vertices.getSize();
      var p = this.vertices.get(0);
      path.push("M", p.x, " ", p.y);
      for (var i = 1; i < _length; i++) {
        p = this.vertices.get(i);
        path.push("L", p.x, " ", p.y);
      }
      path.push("Z");
    }
    // soften/round corners
    //
    else {
        length = this.vertices.getSize();
        var start = this.vertices.first();
        var end = this.vertices.last();
        if (start.equals(end)) {
          length = length - 1;
          end = this.vertices.get(length - 1);
        }
        var begin = _packages2.default.geo.Util.insetPoint(start, end, radius);
        path.push("M", begin.x, ",", begin.y);
        for (var _i = 0; _i < length; _i++) {
          start = this.vertices.get(_i);
          end = this.vertices.get((_i + 1) % length);
          var modStart = _packages2.default.geo.Util.insetPoint(start, end, radius);
          var modEnd = _packages2.default.geo.Util.insetPoint(end, start, radius);
          path.push("Q", start.x, ",", start.y, " ", modStart.x, ", ", modStart.y);
          path.push("L", modEnd.x, ",", modEnd.y);
        }
      }
    this.svgPathString = path.join("");
    return this;
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    if (this.svgPathString === null) {
      this.calculatePath();
    }

    attributes = attributes || {};

    _JSONUtil2.default.ensureDefault(attributes, "path", this.svgPathString);

    this._super(attributes);
  },

  /**
   * 
   * Translate the figure with the given x/y offset. This method modifies all
   * vertices and the bounding box.
   *
   * @param {Number} dx The new x translate offset
   * @param {Number} dy The new y translate offset
   **/
  translate: function translate(dx, dy) {
    var _this = this;

    // TODO: This is not good. If the polygon part of an "Composite" I should call
    //       the adjustPosition. IF we DragDrap the composition the figures inside should follow
    //       without modify the dx/dy.
    //
    dx = this.x + dx;
    dy = this.y + dy;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        var newPos = e.adjustPosition(_this, dx, dy);
        dx = newPos.x;
        dy = newPos.y;
      }
    });
    dx = dx - this.x;
    dy = dy - this.y;

    this.vertices.each(function (i, e) {
      e.translate(dx, dy);
    });
    this.svgPathString = null;
    this.updateBoundingBox();

    this.repaint();

    // Update the resize handles if the user change the position of the
    // element via an API call.
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    this.fireEvent("move", { figure: this, dx: dx, dy: dy });
    this.fireEvent("change:x", { value: this.x });
    this.fireEvent("change:y", { value: this.y });

    return this;
  },

  /**
   * 
   * Change the position of the polygon. This method updates all vertices.
   *
   * @param {Number|draw2d.geo.Point} x
   * @param {Number} [y]
   */
  setPosition: function setPosition(x, y) {
    if (x instanceof _packages2.default.geo.Point) {
      y = x.y;
      x = x.x;
    }
    this.svgPathString = null;

    var dx = x - this.minX;
    var dy = y - this.minY;

    this.translate(dx, dy);

    this.x = x;
    this.y = y;

    return this;
  },

  /**
   * @inheritdoc
   */
  setDimension: function setDimension(w, h) {
    var oldWidth = this.width;
    var oldHeight = this.height;

    this._super(w, h);

    var fracWidth = 1 / oldWidth * this.width;
    var fracHeight = 1 / oldHeight * this.height;

    var thisX = this.x;
    var thisY = this.y;
    this.vertices.each(function (i, e) {
      // calculate difference between point and figure origin
      var diffX = (e.getX() - thisX) * fracWidth;
      var diffY = (e.getY() - thisY) * fracHeight;
      e.setPosition(thisX + diffX, thisY + diffY);
    });

    this.svgPathString = null;
    this.repaint();
    this.fireEvent("change:dimension", { value: { width: this.width, height: this.height } });

    return this;
  },

  /**
   * 
   * Return all vertices of the polygon.
   *
   * @returns {draw2d.util.ArrayList}
   */
  getVertices: function getVertices() {
    return this.vertices;
  },

  /**
   * 
   * Return the Vertex with the given index.
   *
   * @param {Number} index the index of the vertex to return
   * @since 5.0.2
   */
  getVertex: function getVertex(index) {
    return this.vertices.get(index);
  },

  resetVertices: function resetVertices() {
    var _this2 = this;

    this.vertices = new _packages2.default.util.ArrayList();

    this.svgPathString = null;
    this.repaint();

    this.updateBoundingBox();

    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this2.canvas, _this2);
      }
    });

    return this;
  },

  /**
   * 
   * Update the vertex at the given index. The method call didn't have any effect
   * if the vertex didn't exists.
   *
   * @param {Number} index
   * @param {Number} x
   * @param {Number} y
   */
  setVertex: function setVertex(index, x, y) {
    var vertex = this.vertices.get(index);

    // invalid point or nothing to do
    //
    if (vertex === null || vertex.x === x && vertex.y === y) {
      return this;
    }

    vertex.x = parseFloat(x);
    vertex.y = parseFloat(y);

    this.svgPathString = null;
    this.repaint();

    this.updateBoundingBox();

    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });
    this.fireEvent("change:vertices", { value: this.vertices });

    return this;
  },

  /**
   * 
   * Append a new vertex to the polygon.
   *
   * @param {Number | draw2d.geo.Point} x
   * @param {Number} [y]
   */
  addVertex: function addVertex(x, y) {
    this.vertices.add(new _packages2.default.geo.Point(x, y));

    this.svgPathString = null;
    this.repaint();

    this.updateBoundingBox();

    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });
    this.fireEvent("change:vertices", { value: this.vertices });

    return this;
  },

  /**
   * 
   * Insert a new vertex at the given index. All vertices will be shifted to
   * free the requested index.
   *
   * @param {Number} index
   * @param {Number} x
   * @param {Number} y
   */
  insertVertexAt: function insertVertexAt(index, x, y) {
    this.vertices.insertElementAt(new _packages2.default.geo.Point(x, y), index);

    this.svgPathString = null;
    this.repaint();

    this.updateBoundingBox();

    if (!this.selectionHandles.isEmpty()) {
      var _this = this;
      this.editPolicy.each(function (i, e) {
        if (e instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy) {
          e.onUnselect(_this.canvas, _this);
          e.onSelect(_this.canvas, _this);
        }
      });
    }
    this.fireEvent("change:vertices", { value: this.vertices });

    return this;
  },

  /**
   * 
   * Remove a vertex from the polygon and return the removed point.
   *
   * @param {Number} index
   *
   * @returns {draw2d.geo.Point} the removed vertex
   */
  removeVertexAt: function removeVertexAt(index) {
    // a polygon need at least 3 vertices
    //
    if (this.vertices.getSize() <= 3) {
      return null;
    }

    var vertex = this.vertices.removeElementAt(index);

    this.svgPathString = null;
    this.repaint();

    this.updateBoundingBox();

    if (!this.selectionHandles.isEmpty()) {
      var _this = this;
      this.editPolicy.each(function (i, e) {
        if (e instanceof _packages2.default.policy.figure.SelectionFeedbackPolicy) {
          e.onUnselect(_this.canvas, _this);
          e.onSelect(_this.canvas, _this);
        }
      });
    }
    this.fireEvent("change:vertices", { value: this.vertices });

    return vertex;
  },

  /**
   * @inheritdoc
   */
  setRotationAngle: function setRotationAngle(angle) {
    this.rotationAngle = 360 % angle;

    // The different to the other figures is, the the vertices must rotated instead of
    // transform the shape with SVG matrix.
    //
    // Reason: the vertices are selectable and in this case the coordinates must transform
    //         and not only the resulting SVG shape.
    //
    var radian = angle / (180 / Math.PI);
    var center = this.getBoundingBox().getCenter();
    var rotate = function rotate(x, y, xm, ym, radian) {
      var cos = Math.cos,
          sin = Math.sin;
      return {
        x: (x - xm) * cos(radian) - (y - ym) * sin(radian) + xm,
        y: (x - xm) * sin(radian) + (y - ym) * cos(radian) + ym
      };
    };

    this.vertices.each(function (i, e) {
      var rot = rotate(e.x, e.y, center.x, center.y, radian);
      e.setPosition(rot.x, rot.y);
    });

    this.updateBoundingBox();

    // Update the resize handles if the user change the position of the element via an API call.
    //
    var _this = this;
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.moved(_this.canvas, _this);
      }
    });

    this.repaint();
    this.fireEvent("change:angle", { value: this.rotationAngle });

    return this;
  },

  /**
   * 
   * Calculate the bounding box of the shape and store them in an internal
   * variable for fast access.
   *
   * @private
   */
  updateBoundingBox: function updateBoundingBox() {
    if (this.vertices.isEmpty()) {
      this.minX = this.x;
      this.minY = this.y;
      this.maxX = this.x + this.width;
      this.maxY = this.y + this.height;
    } else {
      this.minX = this.x = Math.min.apply(Math, _toConsumableArray(this.vertices.asArray().map(function (n) {
        return n.x;
      })));
      this.minY = this.y = Math.min.apply(Math, _toConsumableArray(this.vertices.asArray().map(function (n) {
        return n.y;
      })));
      this.maxX = Math.max.apply(Math, _toConsumableArray(this.vertices.asArray().map(function (n) {
        return n.x;
      })));
      this.maxY = Math.max.apply(Math, _toConsumableArray(this.vertices.asArray().map(function (n) {
        return n.y;
      })));
      this.width = this.maxX - this.minX;
      this.height = this.maxY - this.minY;
    }
  },

  /**
   * @inheritdoc
   */
  createCommand: function createCommand(request) {

    if (request.getPolicy() === _packages2.default.command.CommandType.MOVE_VERTEX) {
      if (this.isResizeable() === true) {
        return new _packages2.default.command.CommandMoveVertex(this);
      }
    }

    return this._super(request);
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.vertices = [];

    this.vertices.each(function (i, e) {
      memento.vertices.push({ x: e.x, y: e.y });
    });

    return memento;
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    var _this3 = this;

    this._super(memento);

    // restore the points from the JSON data and add them to the polyline
    //
    if (typeof memento.vertices !== "undefined") {
      this.vertices = new _packages2.default.util.ArrayList();
      memento.vertices.forEach(function (point) {
        _this3.addVertex(point);
      });
    }
  }
});

/***/ }),

/***/ "./src/shape/basic/Rectangle.js":
/*!**************************************!*\
  !*** ./src/shape/basic/Rectangle.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A Rectangle Figure.
 *
 *
 * @example
 *
 *    let rect1 =  new draw2d.shape.basic.Rectangle({
 *    	x:10,
 *     y:10
 *    });
 *
 *    let rect2 =  new draw2d.shape.basic.Rectangle({
 *      x: 100,
 *      y: 10,
 *      bgColor: "#f0f000",
 *      alpha  : 0.7,
 *      width: 100,
 *      height: 60,
 *      radius: 10
 *    });
 *
 *    canvas.add(rect1);
 *    canvas.add(rect2);
 *
 *    canvas.setCurrentSelection(rect2);
 *
 * @author Andreas Herz
 * @param {Object} [attr] the configuration of the shape
 * @param {Object} [setter] add or replace setter methods
 * @param {Object} [getter] add or replace getter methods
 * @extends draw2d.VectorFigure
 */
_packages2.default.shape.basic.Rectangle = _packages2.default.VectorFigure.extend(
/** @lends draw2d.shape.basic.Rectangle.prototype */
{

  NAME: "draw2d.shape.basic.Rectangle",

  init: function init(attr, setter, getter) {
    this.dasharray = null;

    this._super((0, _extend2.default)({ bgColor: "#a0a0a0", color: "#1B1B1B" }, attr), (0, _extend2.default)({}, {
      // @attr {String} dash The dot/dash pattern for the line style. Valid values: ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]*/
      dash: this.setDashArray,
      // @attr {String} dasharray The dot/dash pattern for the line style. Valid values: ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]*/
      dasharray: this.setDashArray
    }, setter), (0, _extend2.default)({}, {
      dash: this.getDashArray,
      dasharray: this.getDashArray
    }, getter));
  },

  /**
   * @inheritdoc
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = (0, _extend2.default)({}, {
      width: this.getWidth(),
      height: this.getHeight(),
      r: this.getRadius()
    }, attributes);

    if (this.dasharray !== null) {
      attributes["stroke-dasharray"] = this.dasharray;
    }

    this._super(attributes);

    return this;
  },

  /**
   * @inheritdoc
   */
  applyTransformation: function applyTransformation() {
    var ts = "R" + this.rotationAngle;

    if (this.getRotationAngle() === 90 || this.getRotationAngle() === 270) {
      var ratio = this.getHeight() / this.getWidth();
      ts = ts + "S" + ratio + "," + 1 / ratio + "," + (this.getAbsoluteX() + this.getWidth() / 2) + "," + (this.getAbsoluteY() + this.getHeight() / 2);
    }

    this.shape.transform(ts);

    return this;
  },

  /**
   * @inheritdoc
   */
  createShapeElement: function createShapeElement() {
    return this.canvas.paper.rect(this.getAbsoluteX(), this.getAbsoluteY(), this.getWidth(), this.getHeight());
  },

  /**
   *
   * Set the line style for dot/dash styling. Possible values are
   * ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       dash: pattern
   *     });
   *
   * @param {String} pattern the string with the dot/dash pattern. valid values: ["", "-", ".", "-.", "-..", ". ", "- ", "--", "- .", "--.", "--.."]
   */
  setDashArray: function setDashArray(pattern) {
    this.dasharray = pattern;
    this.repaint();
    this.fireEvent("change:dashArray", { value: this.dasharray });

    return this;
  },

  /**
   *
   * Get the line style for this object.
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr("dash");
   *
   * @since 5.1.0
   */
  getDashArray: function getDashArray() {
    return this.dasharray;
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    if (this.dasharray !== null) {
      memento.dasharray = this.dasharray;
    }

    return memento;
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.dasharray === "string") {
      this.dasharray = memento.dasharray;
    }

    return this;
  }

});

/***/ }),

/***/ "./src/shape/basic/Text.js":
/*!*********************************!*\
  !*** ./src/shape/basic/Text.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Implements a simple text with word wrapping.<br>The height of the element is automatic calculated. The widht of
 * the element is changeable by the user and respect the minWidth constraint.
 * <br>
 *
 *
 * @example
 *
 *    let shape =  new draw2d.shape.basic.Text({text:"This is a simple text with some loooooong word in."});
 *
 *    canvas.add(shape,40,10);
 *
 * @author Andreas Herz
 * @since 4.2.3
 * @extends draw2d.shape.basic.Label
 */
_packages2.default.shape.basic.Text = _packages2.default.shape.basic.Label.extend(
/** @lends draw2d.shape.basic.Text.prototype */
{

  NAME: "draw2d.shape.basic.Text",

  /**
   * Creates a new text element.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.cachedWrappedAttr = null;

    this._super(extend({ width: 100, height: 50, resizeable: true }, attr), setter, getter);

    this.installEditPolicy(new _packages2.default.policy.figure.WidthSelectionFeedbackPolicy());
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    // style the label
    this.svgNodes.attr(extend({}, this.calculateTextAttr(), this.wrappedTextAttr(this.text, this.getWidth() - this.padding.left - this.padding.right)));

    // set of the x/y must be done AFTER the font-size and bold has been set.
    // Reason: the getHeight method needs the font-size for calculation because
    //         it redirects the calculation to the SVG element.
    this.svgNodes.attr({ x: this.padding.left, y: this.getHeight() / 2 });

    // this is an exception call. Don't call the super method (Label) to avoid
    // the calculation in this method.
    _packages2.default.SetFigure.prototype.repaint.call(this, attributes);
  },

  /**
   * @inheritdoc
   */
  setDimension: function setDimension(w, h) {
    this.clearCache();
    var attr = this.wrappedTextAttr(this.text, w);

    this.cachedMinWidth = Math.max(w, attr.width);
    this.cachedMinHeight = attr.height;

    _packages2.default.shape.node.Node.prototype.setDimension.call(this, this.cachedMinWidth, this.cachedMinHeight);
    //  this._super(Math.min(w,attr.width),attr.height);
    this.fireEvent("change:dimension", { value: { width: this.cachedMinWidth, height: this.cachedMinHeight } });

    return this;
  },

  /**
   *
   * clear the internal cache for width/height precalculation
   * @private
   */
  clearCache: function clearCache() {
    this._super();
    this.cachedWrappedAttr = null;

    return this;
  },

  /**
   * @inheritdoc
   */
  getMinWidth: function getMinWidth() {
    if (this.shape === null) {
      return 0;
    }

    if (this.cachedMinWidth === null) {
      // get the longest word in the text
      //
      var longestWord = this.text.split(" ").reduce(function (arg1, arg2) {
        return arg1.length > arg2.length ? arg1 : arg2;
      });
      var svgText = this.canvas.paper.text(0, 0, longestWord).attr(extend({}, this.calculateTextAttr(), { text: longestWord }));
      this.cachedMinWidth = svgText.getBBox(true).width + this.padding.left + this.padding.right + 2 * this.getStroke();
      svgText.remove();
    }

    return this.cachedMinWidth;
  },

  /**
   *
   * calculates the attributes (wrapped text and width, height) with the given parameter
   *
   * @private
   */
  wrappedTextAttr: function wrappedTextAttr(text, width) {
    var words = text.split(" ");
    if (this.canvas === null || words.length === 0) {
      return { text: text, width: width, height: 20 };
    }

    if (this.cachedWrappedAttr === null) {
      var abc = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
      var svgText = this.canvas.paper.text(0, 0, "").attr(extend({}, this.calculateTextAttr(), { text: abc }));

      // get a good estimation of a letter width...not correct but this is working for the very first draft implementation
      var letterWidth = svgText.getBBox(true).width / abc.length;

      var s = [words[0]],
          x = s[0].length * letterWidth;
      var w = null;
      for (var i = 1; i < words.length; i++) {
        w = words[i];
        var l = w.length * letterWidth;
        if (x + l > width) {
          s.push("\n");
          x = l;
        } else {
          s.push(" ");
          x += l;
        }
        s.push(w);
      }
      // set the wrapped text and get the resulted boudning box
      //
      svgText.attr({ text: s.join("") });
      var bbox = svgText.getBBox(true);
      svgText.remove();
      this.cachedWrappedAttr = {
        text: s.join(""),
        width: Math.max(width, bbox.width) + this.padding.left + this.padding.right,
        height: bbox.height + this.padding.top + this.padding.bottom
      };
    }
    return this.cachedWrappedAttr;
  }

});

/***/ }),

/***/ "./src/shape/basic/VertexResizeHandle.js":
/*!***********************************************!*\
  !*** ./src/shape/basic/VertexResizeHandle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Selection handle for polyline vertices.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.ResizeHandle
 */
_packages2.default.shape.basic.VertexResizeHandle = _packages2.default.ResizeHandle.extend(
/** @lends draw2d.shape.basic.VertexResizeHandle.prototype */
{

  NAME: "draw2d.shape.basic.VertexResizeHandle",

  SNAP_THRESHOLD: 3,
  LINE_COLOR: "#1387E6",
  FADEOUT_DURATION: 300,

  init: function init(owner, index) {
    this._super({ owner: owner });
    this.index = index;
    this.isDead = false;
  },

  /**
   * Called when a user double clicks on the element
   *
   * @template
   */
  onDoubleClick: function onDoubleClick() {
    var cmd = new _packages2.default.command.CommandRemoveVertex(this.owner, this.index);
    this.getCanvas().getCommandStack().execute(cmd);

    this.isDead = true;
  },

  /**
   *
   * Called if a drag&drop operation starts.<br>
   *
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @private
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
    if (this.isDead === true) {
      return;
    }

    this._super();
    this.command = this.getCanvas().getPrimarySelection().createCommand(new _packages2.default.command.CommandType(_packages2.default.command.CommandType.MOVE_VERTEX));
    if (this.command != null) {
      this.command.setIndex(this.index);
      this.setAlpha(0.2);
      this.shape.attr({ "cursor": "crosshair" });
    }

    // Vertex is a reference and not a copy of the point
    this.vertex = this.owner.getVertex(this.index).clone();

    // fire an event
    // @since 5.3.3
    this.fireEvent("dragstart", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });

    return true;
  },

  /**
   *
   * Called from the framework during a drag&drop operation
   *
   * @param {Number} dx the x difference between the start of the drag drop operation and now
   * @param {Number} dy the y difference between the start of the drag drop operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   **/
  onDrag: function onDrag(dx, dy, dx2, dy2) {
    if (this.isDead === true || this.command == null) {
      return;
    }

    this.setPosition(this.x + dx2, this.y + dy2);

    // update the polyline for immediately  drag&drop feedback
    //
    this.vertex.translate(dx2, dy2);
    var newPos = this.vertex.clone();
    // Adjust the new location if the object can snap to a helper
    // like grid, geometry, ruler,...
    //
    if (this.getCanSnapToHelper()) {
      newPos = this.getCanvas().snapToHelper(this, newPos);
    }

    this.owner.setVertex(this.index, newPos.x, newPos.y);

    // update the command for the undo/redo stuff
    //
    this.command.updatePosition(this.vertex.x, this.vertex.y);
  },

  /**
   *  Called after a drag and drop action.<br>
   *        Sub classes can override this method to implement additional stuff. Don't forget to call the super implementation via <code>this._super();</code>
   *
   * @param {Number} x the x-coordinate of the mouse event
   * @param {Number} y the y-coordinate of the mouse event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   */
  onDragEnd: function onDragEnd(x, y, shiftKey, ctrlKey) {
    if (this.isDead === true || this.command === null) {
      return;
    }

    this.shape.attr({ "cursor": "move" });

    var stack = this.getCanvas().getCommandStack();

    var transactionCommand = new _packages2.default.command.CommandCollection();

    try {
      transactionCommand.add(this.command);
      this.command = null;
      if (this.getEnclosingAngle() > 178) {
        transactionCommand.add(new _packages2.default.command.CommandRemoveVertex(this.owner, this.index));
      }
    } finally {
      stack.execute(transactionCommand);
    }

    this.setAlpha(1);

    // fire an event
    // @since 5.3.3
    this.fireEvent("dragend", { x: x, y: y, shiftKey: shiftKey, ctrlKey: ctrlKey });
  },

  /**
   *
   * Controls the location of the resize handle
   *
   * @template
   **/
  relocate: function relocate() {
    var resizeWidthHalf = this.getWidth() / 2;
    var resizeHeightHalf = this.getHeight() / 2;

    var anchor = this.owner.getVertex(this.index);

    this.setPosition(anchor.x - resizeWidthHalf, anchor.y - resizeHeightHalf);
  },

  /**
   *
   * Calculates the angle between the siblings
   *
   * @returns {Number}
   */
  getEnclosingAngle: function getEnclosingAngle() {
    // calculate the angle between the siblings
    var points = this.owner.getVertices();
    var trans = this.vertex.getScaled(-1);
    var size = points.getSize();
    var left = points.get((this.index - 1 + size) % size).translated(trans); // % is just to ensure the [0, size] interval
    var right = points.get((this.index + 1) % size).translated(trans); // % is just to ensure the [0, size] interval

    var dot = left.dot(right);

    var acos = Math.acos(dot / (left.length() * right.length()));
    return acos * 180 / Math.PI;
  }

});

/***/ }),

/***/ "./src/shape/composite/Composite.js":
/*!******************************************!*\
  !*** ./src/shape/composite/Composite.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Base interface for the composite shapes
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 * @since 4.7.2
 */
_packages2.default.shape.composite.Composite = _packages2.default.SetFigure.extend(
/** @lends draw2d.shape.composite.Composite.prototype */
{

  NAME: "draw2d.shape.composite.Composite",

  /**
   * Creates a new composite element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ stroke: 1, "color": "#f0f0f0" }, attr), setter, getter);
  },

  /**
   *
   * Called when a user dbl clicks on the element
   *
   * @template
   */
  onDoubleClick: function onDoubleClick() {
    // do nothing per default. no rotation of the shape.
  },

  /**
   *
   * Delegate method to calculate if a figure is selectable. A composite has the right to override the
   * initial selectable flag of the figure.
   *
   * @param {draw2d.Figure} figure the figure to test
   * @param {Boolean} selectable the initial selectable flag of the figure
   * @returns {Boolean} returns `selectable`. A figure in a composite is per default selectable if the figure itself allows it.
   *
   */
  isMemberSelectable: function isMemberSelectable(figure, selectable) {
    return selectable;
  },

  /**
   *
   * Delegate method to calculate if a figure is draggable. A composite has the right to override the
   * initial draggable flag of the figure.
   *
   * @param {draw2d.Figure} figure the figure to test
   * @param {Boolean} draggable the initial draggable flag of the figure
   * @returns {Boolean} returns `draggable`. A figure in a composite is per default draggable if the figure itself allows it.
   *
   */
  isMemberDraggable: function isMemberDraggable(figure, draggable) {
    return draggable;
  },

  /**
   *
   * Set the canvas element of this figures. This can be used to determine whenever an element
   * is added or removed to the canvas.
   *
   * @param {draw2d.Canvas} canvas the new parent of the figure or null
   * @returns {this}
   */
  setCanvas: function setCanvas(canvas) {
    this._super(canvas);

    // an composite shape goes always in the background
    //
    if (canvas !== null) {
      this.toBack();
    }

    return this;
  }

});

/***/ }),

/***/ "./src/shape/composite/Group.js":
/*!**************************************!*\
  !*** ./src/shape/composite/Group.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A group is a figure that acts as a transparent container for other figures. A group
 * is a StrongComposite node that controls a set of child figures. The bounding rectangle of
 * a group is the union of the bounds of its children. Child nodes cannot be selected or
 * manipulated individually.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.StrongComposite
 * @since 4.8.0
 */
_packages2.default.shape.composite.Group = _packages2.default.shape.composite.StrongComposite.extend(
/** @lends draw2d.shape.composite.Group.prototype */
{

  NAME: "draw2d.shape.composite.Group",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ bgColor: null, color: null, resizeable: false }, attr), setter, getter);

    // used during figure assignment/unassignment. The Group is resizing during figure assignment
    // and we want avoid that already assigned figures are moving during this resize.
    //
    this.stickFigures = false;
  },

  /**
   *
   * Delegate method to calculate if a figure is selectable. A composite has the right to override the
   * initial selectable flag of the figure.
   *
   * @param {draw2d.Figure} figure the figure to test
   * @param {Boolean} selectable the initial selectable flag of the figure
   * @returns {Boolean} returns false because it is not possible toselect single figures in the group
   */
  isMemberSelectable: function isMemberSelectable(figure, selectable) {
    return false;
  },

  /**
   *
   * Delegate method to calculate if a figure is draggable. A composite has the right to override the
   * initial draggable flag of the figure.
   * <br>
   * Returns false because only the complete group is draggable
   *
   * @param {draw2d.Figure} figure the figure to test
   * @param {Boolean} draggable the initial draggable flag of the figure
   * @returns {Boolean} returns always false because it is not possible to drag&drop single figures in a group
   *
   */
  isMemberDraggable: function isMemberDraggable(figure, draggable) {
    return false;
  },

  /**
   *
   * Set the position of the object.
   *
   * @param {Number/draw2d.geo.Point} x The new x coordinate of the figure
   * @param {Number} [y] The new y coordinate of the figure
   * @returns {this}
   **/
  setPosition: function setPosition(x, y) {
    var oldX = this.x;
    var oldY = this.y;

    this._super(x, y);

    var dx = this.x - oldX;
    var dy = this.y - oldY;

    if (dx === 0 && dy === 0) {
      return this;
    }

    if (this.stickFigures === false) {
      this.assignedFigures.each(function (i, figure) {
        figure.translate(dx, dy);
      });
    }

    return this;
  },

  /**
   *
   * Assign a figure to the given group.
   * The bounding box of the group is recalculated and the union of the current bounding box with the
   * figure bounding box.
   *
   * @param {draw2d.Figure} figure
   * @returns {this}
   */
  assignFigure: function assignFigure(figure) {
    if (!this.assignedFigures.contains(figure)) {
      var _this = this;
      this.stickFigures = true;
      if (this.assignedFigures.isEmpty() === true) {
        this.setBoundingBox(figure.getBoundingBox());
      } else {
        this.setBoundingBox(this.getBoundingBox().merge(figure.getBoundingBox()));
      }
      this.assignedFigures.add(figure);
      figure.setComposite(this);
      // the selection adapter defines which figure should be selected if the user clicks on
      // "figure". The "group" redirects to the group instead to allowing select the child.
      figure.setSelectionAdapter(function () {
        return _this;
      });
      this.stickFigures = false;
    }
    return this;
  },

  /**
   *
   * Remove the given figure from the group assignment
   *
   * @param {draw2d.Figure} figure the figure to remove
   * @returns {this}
   */
  unassignFigure: function unassignFigure(figure) {
    if (this.assignedFigures.contains(figure)) {
      this.stickFigures = true;
      figure.setComposite(null);
      figure.setSelectionAdapter(null);
      this.assignedFigures.remove(figure);
      if (!this.assignedFigures.isEmpty()) {
        var box = this.assignedFigures.first().getBoundingBox();
        this.assignedFigures.each(function (i, figure) {
          box.merge(figure.getBoundingBox());
        });
        this.setBoundingBox(box);
      }
      this.stickFigures = false;
    }

    return this;
  },

  /**
   * @inheritDoc
   */
  createCommand: function createCommand(request) {
    if (request === null) {
      return null;
    }

    if (request.getPolicy() === _packages2.default.command.CommandType.DELETE) {
      if (!this.isDeleteable()) {
        return null;
      }
      return new _packages2.default.command.CommandDeleteGroup(this);
    }

    return this._super(request);
  }

});

/***/ }),

/***/ "./src/shape/composite/Jailhouse.js":
/*!******************************************!*\
  !*** ./src/shape/composite/Jailhouse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A Jailhouse is a figure that acts as a container for other figures. A Jailhouse
 * is a StrongComposite node that controls a set of child figures. Child nodes can't
 * moved outside of the composite.<br>
 * Objects in a jailhouse have the same Z-order, which can be relatively controlled with
 * respect to other figures.
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.StrongComposite
 * @since 4.8.0
 */
_packages2.default.shape.composite.Jailhouse = _packages2.default.shape.composite.StrongComposite.extend(
/** @lends draw2d.shape.composite.Jailhouse.prototype */
{

  NAME: "draw2d.shape.composite.Jailhouse",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.policy = new _packages2.default.policy.figure.RegionEditPolicy(0, 0, 10, 10);
    this._super(extend({ bgColor: "#f0f0f0", color: "#333333" }, attr), setter, getter);

    this.stickFigures = false;
  },

  /**
   * 
   * Set the new width and height of the figure and update the constraint policy for the assigned
   * figures..
   *
   * @param {Number} w The new width of the figure
   * @param {Number} h The new height of the figure
   **/
  setDimension: function setDimension(w, h) {
    this._super(w, h);
    this.policy.setBoundingBox(this.getAbsoluteBounds());
  },

  /**
   * 
   * Set the position of the object.
   *
   * @param {Number/draw2d.geo.Point} x The new x coordinate of the figure
   * @param {Number} [y] The new y coordinate of the figure
   **/
  setPosition: function setPosition(x, y) {
    var oldX = this.x;
    var oldY = this.y;

    this._super(x, y);

    var dx = this.x - oldX;
    var dy = this.y - oldY;

    if (dx === 0 && dy === 0) {
      return this;
    }
    this.policy.setBoundingBox(this.getAbsoluteBounds());

    if (this.stickFigures === false) {
      this.assignedFigures.each(function (i, figure) {
        figure.translate(dx, dy);
      });
    }

    return this;
  },

  /**
   * 
   * Assign a figure to the given group.
   * The bounding box of the group is recalculated and the union of the current bounding box with the
   * figure bounding box.
   *
   * @param {draw2d.Figure} figure
   */
  assignFigure: function assignFigure(figure) {
    if (!this.assignedFigures.contains(figure) && figure !== this) {
      this.stickFigures = true;
      this.setBoundingBox(this.getBoundingBox().merge(figure.getBoundingBox()));
      this.assignedFigures.add(figure);
      figure.setComposite(this);
      figure.installEditPolicy(this.policy);
      figure.toFront(this);
      this.stickFigures = false;
    }
    return this;
  },

  /**
   * 
   * Remove the given figure from the group assignment
   *
   * @param {draw2d.Figure} figure the figure to remove
   *
   */
  unassignFigure: function unassignFigure(figure) {
    if (this.assignedFigures.contains(figure)) {
      this.stickFigures = true;
      figure.setComposite(null);
      figure.uninstallEditPolicy(this.policy);
      this.assignedFigures.remove(figure);
      if (!this.assignedFigures.isEmpty()) {
        var box = this.assignedFigures.first().getBoundingBox();
        this.assignedFigures.each(function (i, figure) {
          box.merge(figure.getBoundingBox());
        });
        this.setBoundingBox(box);
      }
      this.stickFigures = false;
    }

    return this;
  },

  onCatch: function onCatch(droppedFigure, x, y, shiftKey, ctrlKey) {
    this.getCanvas().getCommandStack().execute(new _packages2.default.command.CommandAssignFigure(droppedFigure, this));
  },

  /**
   * 
   * Return the minWidth of the jailhouse. The minWidth is calculated by care the assigned figures.
   *
   * @returns {Number} the minimum width for the figure
   */
  getMinWidth: function getMinWidth() {
    var width = 0;
    this.assignedFigures.each(function (i, figure) {
      width = Math.max(width, figure.getBoundingBox().getRight());
    });
    return width - this.getAbsoluteX();
  },

  /**
   * 
   * @returns {Number} the minimum height of the figure
   */
  getMinHeight: function getMinHeight() {
    var height = 0;
    this.assignedFigures.each(function (i, figure) {
      height = Math.max(height, figure.getBoundingBox().getBottom());
    });
    return height - this.getAbsoluteY();
  }
});

/***/ }),

/***/ "./src/shape/composite/Raft.js":
/*!*************************************!*\
  !*** ./src/shape/composite/Raft.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Raft figures are shapes, which aggregate multiple figures. It works like a real raft. Aboard figures are
 * moved if the raft figures moves.
 *
 *
 * @example
 *
 *    let rect1 =  new draw2d.shape.composite.Raft({width:200, height:100});
 *    let rect2 =  new draw2d.shape.basic.Rectangle({width:50, height:50});
 *
 *    canvas.add(rect1,10,10);
 *    canvas.add(rect2,20,20);
 *
 *    rect2.attr({bgColor:"#f0f000", width:50, height:50, radius:10});
 *
 *    canvas.setCurrentSelection(rect1);
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.WeakComposite
 * @since 4.7.0
 */
_packages2.default.shape.composite.Raft = _packages2.default.shape.composite.WeakComposite.extend(
/** @lends draw2d.shape.composite.Raft.prototype */
{

  NAME: "draw2d.shape.composite.Raft",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {

    this.aboardFigures = new _packages2.default.util.ArrayList();

    this._super(extend({ bgColor: "#f0f0f0", color: "#1B1B1B" }, attr), setter, getter);
  },

  /**
   *
   * Will be called if the drag and drop action begins. You can return [false] if you
   * want avoid that the figure can be move.
   *
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean} true if the figure accepts dragging
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
    this._super(x, y, shiftKey, ctrlKey);

    this.aboardFigures = new _packages2.default.util.ArrayList();
    // force the recalculation of the aboard figures if the shape is in a drag&drop operation
    this.getAboardFigures(this.isInDragDrop);

    return true;
  },

  /**
   *
   * Set the position of the object.
   *
   * @param {Number/draw2d.geo.Point} x The new x coordinate of the figure
   * @param {Number} [y] The new y coordinate of the figure
   * @param {boolean} [dontApplyToChildren] don't move the children if this flag is set.
   **/
  setPosition: function setPosition(x, y, dontApplyToChildren) {
    var oldX = this.x;
    var oldY = this.y;

    // we need the figures before the composite has moved. Otherwise some figures are fall out of the raft
    //
    var aboardedFigures = dontApplyToChildren ? _packages2.default.util.ArrayList.EMPTY_LIST : this.getAboardFigures(this.isInDragDrop === false);

    this._super(x, y);

    var dx = this.x - oldX;
    var dy = this.y - oldY;

    if (dx === 0 && dy === 0) {
      return this;
    }

    // we must move circuits with "user routed" elements as well if the start/target is withing
    // the raft. Some segments stay still because some coordinates has a fixed position
    //
    if (this.canvas !== null) {
      aboardedFigures = aboardedFigures.clone();
      this.canvas.getLines().each(function (i, line) {
        if (line instanceof _packages2.default.Connection) {
          if (aboardedFigures.contains(line.getSource().getRoot()) && aboardedFigures.contains(line.getTarget().getRoot())) {
            aboardedFigures.add(line);
          }
        }
      });
    }

    aboardedFigures.each(function (i, figure) {
      figure.translate(dx, dy);
    });

    return this;
  },

  onDrag: function onDrag(dx, dy, dx2, dy2, shiftKey, ctrlKey) {
    var _this = this;

    // apply all EditPolicy for DragDrop Operations
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        var _newPos = e.adjustPosition(_this, _this.ox + dx, _this.oy + dy);
        if (_newPos) {
          dx = _newPos.x - _this.ox;
          dy = _newPos.y - _this.oy;
        }
      }
    });

    var newPos = new _packages2.default.geo.Point(this.ox + dx, this.oy + dy);

    // Adjust the new location if the object can snap to a helper
    // like grid, geometry, ruler,...
    //
    if (this.getCanSnapToHelper()) {
      newPos = this.getCanvas().snapToHelper(this, newPos);
    }

    // push the shiftKey to the setPosition method and avoid to move the children objects
    // if the user press the shift key
    this.setPosition(newPos.x, newPos.y, shiftKey);

    // notify all installed policies
    //
    this.editPolicy.each(function (i, e) {
      if (e instanceof _packages2.default.policy.figure.DragDropEditPolicy) {
        e.onDrag(_this.canvas, _this);
      }
    });

    // fire an event
    // @since 5.3.3
    this.fireEvent("drag", { dx: dx, dy: dy, dx2: dx2, dy2: dy2, shiftKey: shiftKey, ctrlKey: ctrlKey });
  },

  /**
   *
   * Return all figures which are aboard of this shape. These shapes are moved as well if the raft
   * is moving.
   *
   * @returns {draw2d.util.ArrayList}
   */
  getAboardFigures: function getAboardFigures(recalculate) {
    if (recalculate === true && this.canvas !== null) {
      var raftBoundingBox = this.getBoundingBox();
      var zIndex = this.getZOrder();
      this.aboardFigures = new _packages2.default.util.ArrayList();

      var _this = this;
      this.getCanvas().getFigures().each(function (i, figure) {
        if (figure !== _this && figure.isSelectable() === true && figure.getBoundingBox().isInside(raftBoundingBox)) {
          // Don't add the figure if it is already catched by another composite with a higher z-index
          //
          if (_this.getNextComposite(figure) !== _this) {
            return;
          }
          // only add the shape if it is in front of the raft
          if (figure.getZOrder() > zIndex) {
            _this.aboardFigures.add(figure);
          }
        }
      });
    }
    return this.aboardFigures;
  },

  /**
   *
   * return the next potential composite parent figure
   *
   * @param {draw2d.Figure} figureToTest
   * @returns {draw2d.Figure}
   */
  getNextComposite: function getNextComposite(figureToTest) {
    var nextComposite = null;
    this.getCanvas().getFigures().each(function (i, figure) {
      if (figureToTest === figure) {
        return;
      }
      if (figure instanceof _packages2.default.shape.composite.Composite) {
        if (nextComposite !== null && nextComposite.getZOrder() > figure.getZOrder()) {
          return;
        }

        if (figure.getBoundingBox().contains(figureToTest.getBoundingBox())) {
          nextComposite = figure;
        }
      }
    });

    return nextComposite;
  }
});

/***/ }),

/***/ "./src/shape/composite/StrongComposite.js":
/*!************************************************!*\
  !*** ./src/shape/composite/StrongComposite.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A StrongComposite is a composite figure with strong assignment of the children and the composite.
 * The child knows everything about the assigned composite and receives events about assignment to a
 * composite.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.Composite
 * @since 4.8.0
 */
_packages2.default.shape.composite.StrongComposite = _packages2.default.shape.composite.Composite.extend(
/** @lends draw2d.shape.composite.StrongComposite.prototype */
{

  NAME: "draw2d.shape.composite.StrongComposite",

  /**
   * Creates a new strong composite element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.assignedFigures = new _packages2.default.util.ArrayList();

    this._super(attr, setter, getter);
  },

  /**
   * 
   * Check to see if a figure is a descendant of another figure.
   * <br>
   * The contains() method returns true if the figure provided by the argument is a descendant of this figure,
   * whether it is a direct child or nested more deeply. Otherwise, it returns false.
   *
   * @param {draw2d.Figure} containedFigure The figure that may be contained by (a descendant of) this figure.
   * @since 5.5.4
   */
  contains: function contains(containedFigure) {
    for (var i = 0, len = this.assignedFigures.getSize(); i < len; i++) {
      var child = this.assignedFigures.get(i);
      if (child === containedFigure || child.contains(containedFigure)) {
        return true;
      }
    }
    return this._super(containedFigure);
  },

  /**
   * 
   * Assign a figure to the composite.
   *
   * @param {draw2d.Figure} figure
   * @template
   */
  assignFigure: function assignFigure(figure) {
    return this;
  },

  /**
   * 
   * Remove the given figure from the group assignment
   *
   * @param {draw2d.Figure} figure the figure to remove
   * @template
   */
  unassignFigure: function unassignFigure(figure) {
    return this;
  },

  /**
   * 
   * Return all assigned figures of the composite
   *
   * @returns {draw2d.util.ArrayList}
   */
  getAssignedFigures: function getAssignedFigures() {
    return this.assignedFigures;
  },

  /**
   * 
   * Called if the user drop this element onto the dropTarget. This event is ONLY fired if the
   * shape return "this" in the onDragEnter method.
   *
   *
   * @param {draw2d.Figure} dropTarget The drop target.
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   * @since  4.7.4
   **/
  onDrop: function onDrop(dropTarget, x, y, shiftKey, ctrlKey) {},

  /**
   * 
   * Called if the user dropped an figure onto this element. This event is ONLY fired if the
   * shape return "this" in the onDragEnter method.
   *
   *
   * @param {draw2d.Figure} droppedFigure The dropped figure.
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   * @template
   * @since 4.7.4
   **/
  onCatch: function onCatch(droppedFigure, x, y, shiftKey, ctrlKey) {},

  /**
   * 
   * Moves the element so it is the closest to the viewers eyes, on top of other elements. Additional
   * the internal model changed as well.
   *
   * Optional: Inserts current object in front of the given one.
   *
   * @param {draw2d.Figure} [figure] move current object in front of the given one.
   */
  toFront: function toFront(figure) {
    this._super(figure);
    // ensure that all assigned figures are in front of the composite
    //
    var figures = this.getAssignedFigures().clone();
    figures.sort(function (a, b) {
      // return 1  if a before b
      // return -1 if b before a
      return a.getZOrder() > b.getZOrder() ? -1 : 1;
    });
    var _this = this;
    figures.each(function (i, f) {
      f.toFront(_this);
    });

    return this;
  },

  /**
   * 
   * Moves the element to the background. Additional
   * the internal model changed as well.
   *
   * @since 4.7.2
   */
  toBack: function toBack(figure) {
    this._super(figure);
    // ensure that all assigned figures are in front of the composite
    //
    var figures = this.getAssignedFigures().clone();
    figures.sort(function (a, b) {
      // return 1  if a before b
      // return -1 if b before a
      return a.getZOrder() > b.getZOrder() ? -1 : 1;
    });

    var _this = this;
    figures.each(function (i, f) {
      f.toBack(_this);
    });

    return this;
  }
});

/***/ }),

/***/ "./src/shape/composite/WeakComposite.js":
/*!**********************************************!*\
  !*** ./src/shape/composite/WeakComposite.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A WeakComposite is a composite figure with loose coupling of the children and the composite.
 * The child didn't know anything about the assigned composite nor did they receive any events
 * about assignment to a composite.
 *
 * Assignment without obligation.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.composite.Composite
 * @since 4.8.0
 */
_packages2.default.shape.composite.WeakComposite = _packages2.default.shape.composite.Composite.extend(
/** @lends draw2d.shape.composite.WeakComposite.prototype */
{

  NAME: "draw2d.shape.composite.WeakComposite",

  /**
   * Creates a new weak composite element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  }
});

/***/ }),

/***/ "./src/shape/diagram/Diagram.js":
/*!**************************************!*\
  !*** ./src/shape/diagram/Diagram.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

var _JSONUtil = __webpack_require__(/*! ../../util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Base class for all diagrams.
 *
 * @param {Object} [attr] the configuration of the shape
 * @extends draw2d.SetFigure
 */
_packages2.default.shape.diagram.Diagram = _packages2.default.SetFigure.extend(
/** @lends draw2d.shape.diagram.Diagram */
{

  init: function init(attr, setter, getter) {
    this.data = [];
    this.cache = {};

    this._super((0, _extend2.default)({ data: [], bgColor: "#8dabf2", stroke: 1, color: "#f0f0f0", radius: 2, resizeable: true }, attr), (0, _extend2.default)({}, {
      // @attr {Array} data the data to display in the diagram */
      data: this.setData
    }, setter), (0, _extend2.default)({}, {
      data: this.getData
    }, getter));
  },

  /**
   * 
   * Set the data for the chart/diagram element
   *
   * @param {Array} data
   *
   */
  setData: function setData(data) {
    this.data = data;
    this.cache = {};

    if (this.svgNodes !== null) {
      this.svgNodes.remove();
      this.svgNodes = this.createSet();
    }

    this.repaint();
    this.fireEvent("change:data", { value: data });
  },

  /**
   * 
   * Return the data of the diagram
   *
   * @since 5.0.0
   */
  getData: function getData() {
    return this.data;
  },

  /**
   * 
   * Set the dimension of the diagram and reset the cached calculation
   *
   * @since 5.0.0
   */
  setDimension: function setDimension(w, h) {
    this.cache = {};
    this._super(w, h);

    return this;
  },

  /**
   * 
   * Return the calculate width of the set. This calculates the bounding box of all elements.
   *
   * @returns {Number} the calculated width of the label
   **/
  getWidth: function getWidth() {
    return this.width;
  },

  /**
   * 
   * Return the calculated height of the set. This calculates the bounding box of all elements.
   *
   * @returns {Number} the calculated height of the label
   */
  getHeight: function getHeight() {
    return this.height;
  },

  /**
   *
   * @param attributes
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape == null) {
      return this;
    }

    attributes = attributes || {};

    _JSONUtil2.default.ensureDefault(attributes, "fill", "none");

    return this._super(attributes);
  },

  applyTransformation: function applyTransformation() {
    if (this.isResizeable() === true) {
      this.svgNodes.transform("S" + this.scaleX + "," + this.scaleY + "," + this.getAbsoluteX() + "," + this.getAbsoluteY() + "t" + this.getAbsoluteX() + "," + this.getAbsoluteY());
    } else {
      this.svgNodes.transform("T" + this.getAbsoluteX() + "," + this.getAbsoluteY());
    }

    return this;
  }

});

/***/ }),

/***/ "./src/shape/diagram/Pie.js":
/*!**********************************!*\
  !*** ./src/shape/diagram/Pie.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Small data pie chart.
 *
 *
 * @example
 *
 *    let pie = new draw2d.shape.diagram.Pie({
 *       diameter:80,
 *       data:[30,60,122,4],
 *       x:100,
 *       y:60
 *    });
 *
 *    canvas.add( pie);
 *
 * @param {Object} [attr] the configuration of the shape
 * @extends draw2d.shape.diagram.Diagram
 */
_packages2.default.shape.diagram.Pie = _packages2.default.shape.diagram.Diagram.extend(
/** @lends draw2d.shape.diagram.Pie */
{

  NAME: "draw2d.shape.diagram.Pie",
  COLORS: ['#00A8F0', '#b9dd69', '#f3546a', '#4DA74D', '#9440ED'],
  TWO_PI: Math.PI * 2,

  init: function init(attr, setter, getter) {

    this._super((0, _extend2.default)({ stroke: 0 }, attr), (0, _extend2.default)({
      // @attr {Number} diameter the diameter of the pie chart */
      diameter: this.setDiameter,
      // @attr {Number} radius the radius of the pie chart */
      radius: this.setRadius
    }, setter), (0, _extend2.default)({
      diameter: this.getDiameter,
      radius: this.getRadius
    }, getter));
  },

  /**
   *
   * Set the diameter of the circle. The center of the circle will be retained.
   *
   * @param {Number} d The new diameter of the circle.
   * @since 4.0.0
   **/
  setDiameter: function setDiameter(d) {
    var center = this.getCenter();
    this.setDimension(d, d);
    this.setCenter(center);
    this.fireEvent("change:diameter", { value: this.width });

    return this;
  },

  /**
   *
   * Get the diameter of the circle.
   *
   * @since 4.0.0
   **/
  getDiameter: function getDiameter() {
    return this.getWidth();
  },

  /**
   *
   * Set the radius of the circle. The center of the circle will be retained.
   *
   * @param {Number} r The new radius of the circle.
   * @since 4.0.0
   **/
  setRadius: function setRadius(r) {
    this.setDiameter(r * 2);
    this.fireEvent("change:radius", { value: this.width / 2 });

    return this;
  },

  /**
   *
   * Get the center of the circle
   *
   */
  getCenter: function getCenter() {
    var d2 = this.getDiameter() / 2;
    return this.getPosition().translate(d2, d2);
  },

  /**
   *
   * Set the center of the circle.
   *
   * @param {Number|draw2d.geo.Point} x the new x coordinate of the center or a draw2d.geo.Point object with the center
   * @param {Number} y the y coordinate of the new center of the first argument isn't a draw2d.geo.Point object
   */
  setCenter: function setCenter(x, y) {
    var pos = new _packages2.default.geo.Point(x, y);
    var d2 = this.getDiameter() / 2;
    pos.translate(-d2, -d2);
    this.setPosition(pos);
    this.fireEvent("change:center", { value: { x: x, y: y } });

    return this;
  },

  /**
   * @inheritdoc
   */
  setData: function setData(data) {
    var _this = this;

    // Normalize the Data.
    // The SUM must be == 1.
    this.sum = 0;
    data.forEach(function (val) {
      _this.sum += val;
    });
    var _sum = 1 / this.sum;
    data.forEach(function (val, i) {
      data[i] = _sum * val;
    });

    //  pass the normalize data to the base implementation
    //
    this._super(data);
    this.fireEvent("change:data", { value: data });

    return this;
  },

  /**
   * @inheritdoc
   */
  createSet: function createSet() {
    var radius = this.getWidth() / 2;
    var length = this.data.length;

    var pie = this.canvas.paper.set();

    var offsetAngle = 0;

    for (var i = 0; i < length; i++) {
      // angle is percent of TWO_PI
      var angle = this.TWO_PI * this.data[i];
      var color = this.COLORS[i % length];
      var seg = this.drawSegment(radius, angle, offsetAngle, 0.1);
      seg.attr({ stroke: this.color.rgba(), fill: color });
      pie.push(seg);
      offsetAngle += angle;
    }
    return pie;
  },

  /**
   * @inheritdoc
   */
  setDimension: function setDimension(w, h) {
    // keep the aspect ration
    //
    if (w > h) {
      this._super(w, w);
    } else {
      this._super(h, h);
    }

    // we must recreate the diagram if we change the size.
    // low performance. Better: transfor/scale the set. Can be done in the next release
    //
    if (this.svgNodes !== null) {
      this.svgNodes.remove();
      this.svgNodes = this.createSet();
    }

    this.repaint();

    return this;
  },

  polarPath: function polarPath(radius, theta, rotation) {
    var x = void 0,
        y = void 0;
    x = radius * Math.cos(theta + rotation) + radius;
    y = radius * Math.sin(theta + rotation) + radius;
    return "L " + x + " " + y + " ";
  },

  drawSegment: function drawSegment(radius, value, rotation, resolution) {
    var path = "M " + radius + " " + radius;

    for (var i = 0; i < value; i += resolution) {
      path += this.polarPath(radius, i, rotation);
    }
    path += this.polarPath(radius, value, rotation);

    path += "L " + radius + " " + radius;
    return this.getCanvas().paper.path(path);
  },

  /**
   * @inheritdoc
   */
  applyTransformation: function applyTransformation() {
    this.svgNodes.transform("T" + this.getAbsoluteX() + "," + this.getAbsoluteY());

    return this;
  }

});

/***/ }),

/***/ "./src/shape/diagram/Sparkline.js":
/*!****************************************!*\
  !*** ./src/shape/diagram/Sparkline.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @class
 *
 * Small data line diagram.
 *
 *
 * @example
 *
 *    let testData = [];
 *    for(let i=0;i<100;i++) {
 *      testData.push(Math.floor(Math.random() * 100));
 *    }
 *
 *    let sparkline = new draw2d.shape.diagram.Sparkline({
 *    	data: testData,
 *     width:150,
 *     height:50,
 *     x:100,
 *     y:60
 *    });
 *
 *    canvas.add( sparkline);
 *
 * @param {Object} [attr] the configuration of the shape
 * @extends draw2d.shape.diagram.Diagram
 */
_packages2.default.shape.diagram.Sparkline = _packages2.default.shape.diagram.Diagram.extend(
/** @lends draw2d.shape.diagram.Sparkline */
{

  NAME: "draw2d.shape.diagram.Sparkline",

  init: function init(attr, setter, getter) {
    this.min = 0;
    this.max = 10;
    this.padding = 4;

    this._super((0, _extend2.default)({ width: 180, height: 50 }, attr), setter, getter);
  },

  /**
   * @inheritdoc
   */
  setData: function setData(data) {
    if (data.length > 0) {
      // get the min/max from an array and not only from two elements..
      this.min = Math.min.apply(Math, _toConsumableArray(data));
      this.max = Math.max.apply(Math, _toConsumableArray(data));
    } else {
      this.min = 0;
      this.max = 1;
    }

    if (this.max == this.min) {
      this.max = this.min + 1;
    }

    this._super(data);
    this.fireEvent("change:data", { value: data });

    return this;
  },

  /**
   * @inheritdoc
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M0 0 l0 0");
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {
    var _this = this;

    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    attributes.fill = "90-#000:5-#4d4d4d:95";

    var padding = this.padding;
    var width = this.getWidth() - 2 * padding;
    var height = this.getHeight() - 2 * padding;
    var length = this.data.length;
    var min = this.min;
    var max = this.max;
    var toCoords = function toCoords(value, idx) {
      var step = 1;
      // avoid divisionByZero
      if (length > 1) {
        step = width / (length - 1);
      }

      return {
        y: -((value - min) / (max - min) * height) + height + padding,
        x: padding + idx * step
      };
    };

    if (this.svgNodes !== null && typeof this.cache.pathString === "undefined") {
      var prev_pt = null;
      this.data.forEach(function (item, idx) {
        var pt = toCoords(item, idx);
        if (prev_pt === null) {
          _this.cache.pathString = ["M", pt.x, pt.y].join(" ");
        } else {
          _this.cache.pathString = [_this.cache.pathString, "L", pt.x, pt.y].join(" ");
        }
        prev_pt = pt;
      });

      this.svgNodes.attr({ path: this.cache.pathString, stroke: "#f0f0f0" });
    }
    this._super(attributes);

    return this;
  }
});

/***/ }),

/***/ "./src/shape/dimetric/Rectangle.js":
/*!*****************************************!*\
  !*** ./src/shape/dimetric/Rectangle.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A Rectangle Figure in a dimetric perspective.
 *
 *
 * @example
 *
 *    let d1 =  new draw2d.shape.dimetric.Rectangle({x:10,y:10});
 *    let d2 =  new draw2d.shape.dimetric.Rectangle({x:100,y:10, bgColor:"#f0f000", alpha:0.7, width:100, height:60});
 *
 *    canvas.add(d1);
 *    canvas.add(d2);
 *
 *    canvas.setCurrentSelection(d2);
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Polygon
 */
_packages2.default.shape.dimetric.Rectangle = _packages2.default.shape.basic.Polygon.extend(
/** @lends draw2d.shape.dimetric.Rectangle.prototype */
{

  NAME: "draw2d.shape.dimetric.Rectangle",

  /**
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ bgColor: "#00a3f6", color: "#1B1B1B" }, attr), setter, getter);

    var pos = this.getPosition();

    this.resetVertices();

    var angle26 = Math.atan(.5);
    var cos30 = Math.cos(angle26);
    var sin30 = Math.sin(angle26);

    var box = this.getBoundingBox();
    var w = box.w;
    var h = box.h;

    this.addVertex(0, 0); // topLeft
    this.addVertex(cos30 * w, sin30 * w); // topRight
    this.addVertex(cos30 * w - cos30 * h, sin30 * w + sin30 * h); // bottomRight
    this.addVertex(-cos30 * h, sin30 * h); // bottomLeft

    // override the selection handler from the polygon. Because the vertices of
    // the diamond are not selectable and modifiable
    //
    this.installEditPolicy(new _packages2.default.policy.figure.RectangleSelectionFeedbackPolicy());

    this.setPosition(pos);
  }
});

/***/ }),

/***/ "./src/shape/flowchart/Document.js":
/*!*****************************************!*\
  !*** ./src/shape/flowchart/Document.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Typical flowchart <b>Document</b> shape
 *
 *
 * @example
 *
 *    let figure = new draw2d.shape.flowchart.Document({
 *       x:100,
 *       y:60
 *    });
 *
 *    canvas.add( figure);
 *
 * @extends draw2d.VectorFigure
 */
_packages2.default.shape.flowchart.Document = _packages2.default.VectorFigure.extend(
/** @lends draw2d.shape.flowchart.Document.prototype */
{

  NAME: "draw2d.shape.flowchart.Document",

  /**
   *
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.amplitude = 0.08; // percentage of height

    this._super(extend({
      width: 80,
      height: 50,
      bgColor: "#2196f3",
      color: "#1B1B1B",
      stroke: 1
    }, attr), setter, getter);
  },

  /**
   * @inheritdoc
   */
  createShapeElement: function createShapeElement() {
    return this.canvas.paper.path(this.calcPath());
  },

  calcPath: function calcPath() {
    var w = this.getWidth();
    var h = this.getHeight();
    var w2 = w / 2;
    var w4 = w / 4;
    var h2 = h * this.amplitude | 0;

    return ["M", this.getAbsoluteX(), ",", this.getAbsoluteY(), "l", w, ",", 0, "l", 0, ",", h - h2, "q", -w4, ",", -h2, -w2, ",", 0, "q", -w4, ",", h2, -w2, ",", 0, "z"].join(" ");
  },

  /**
   * @inheritdoc
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = extend({}, {
      path: this.calcPath()
    }, attributes);

    this._super(attributes);

    return this;
  }
  /*
    function draw_curve(Ax, Ay, Bx, By, M) {
     // Find midpoint J
    let Jx = Ax + (Bx - Ax) / 2
    let Jy = Ay + (By - Ay) / 2
     // We need a and b to find theta, and we need to know the sign of each to make sure that the orientation is correct.
    let a = Bx - Ax
    let asign = (a < 0 ? -1 : 1)
    let b = By - Ay
    let bsign = (b < 0 ? -1 : 1)
    let theta = Math.atan(b / a)
     // Find the point that's perpendicular to J on side
    let costheta = asign * Math.cos(theta)
    let sintheta = asign * Math.sin(theta)
     // Find c and d
    let c = M * sintheta
    let d = M * costheta
     // Use c and d to find Kx and Ky
    let Kx = Jx - c
    let Ky = Jy + d
     return "M" + Ax + "," + Ay +
           "Q" + Kx + "," + Ky +
           " " + Bx + "," + By
   }*/
});

/***/ }),

/***/ "./src/shape/icon/Acw.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Acw.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Acw();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Acw = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Acw.prototype */
{

  NAME: "draw2d.shape.icon.Acw",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M19.275,3.849l1.695,8.56l1.875-1.642c2.311,3.59,1.72,8.415-1.584,11.317c-2.24,1.96-5.186,2.57-7.875,1.908l-0.84,3.396c3.75,0.931,7.891,0.066,11.02-2.672c4.768-4.173,5.521-11.219,1.94-16.279l2.028-1.775L19.275,3.849zM8.154,20.232c-2.312-3.589-1.721-8.416,1.582-11.317c2.239-1.959,5.186-2.572,7.875-1.909l0.842-3.398c-3.752-0.93-7.893-0.067-11.022,2.672c-4.765,4.174-5.519,11.223-1.939,16.283l-2.026,1.772l8.26,2.812l-1.693-8.559L8.154,20.232z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Alarm.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Alarm.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Alarm();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Alarm = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Alarm.prototype */
{

  NAME: "draw2d.shape.icon.Alarm",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M8.179,20.115c-0.478,0.277-0.642,0.889-0.365,1.366c0.275,0.479,0.889,0.642,1.365,0.366c0.479-0.275,0.643-0.888,0.367-1.367C9.27,20.004,8.658,19.84,8.179,20.115zM9.18,12.239c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366c0.479,0.276,1.09,0.113,1.367-0.366C9.821,13.126,9.657,12.516,9.18,12.239zM8.625,17.043c-0.001-0.552-0.448-0.999-1.001-1c-0.553,0-1,0.448-1,1c0,0.553,0.449,1,1,1C8.176,18.043,8.624,17.596,8.625,17.043zM16.312,3.957V3.031h1c0.275,0,0.5-0.225,0.5-0.5v-0.5c0-0.275-0.225-0.5-0.5-0.5h-3.625c-0.275,0-0.5,0.225-0.5,0.5v0.5c0,0.275,0.225,0.5,0.5,0.5h1v0.926C7.819,4.381,2.376,10.068,2.374,17.042C2.376,24.291,8.251,30.166,15.5,30.169c7.249-0.003,13.124-5.878,13.125-13.127C28.624,10.067,23.181,4.38,16.312,3.957zM15.5,27.166C9.909,27.157,5.385,22.633,5.375,17.042C5.385,11.451,9.909,6.927,15.5,6.917c5.59,0.01,10.115,4.535,10.124,10.125C25.615,22.633,21.091,27.157,15.5,27.166zM12.062,22.998c-0.478-0.275-1.089-0.111-1.366,0.367c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.277,1.091,0.111,1.365-0.365C12.704,23.887,12.54,23.275,12.062,22.998zM12.062,11.088c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,11.2,11.584,11.364,12.062,11.088zM22.822,13.971c0.478-0.275,0.643-0.888,0.366-1.366c-0.275-0.478-0.89-0.642-1.366-0.366c-0.479,0.278-0.642,0.89-0.366,1.367C21.732,14.083,22.344,14.247,22.822,13.971zM15.501,23.92c-0.552,0-1,0.447-1,1c0,0.552,0.448,1,1,1s1-0.448,1-1C16.501,24.367,16.053,23.92,15.501,23.92zM19.938,9.355c-0.477-0.276-1.091-0.111-1.365,0.366c-0.275,0.48-0.111,1.091,0.366,1.367s1.089,0.112,1.366-0.366C20.581,10.245,20.418,9.632,19.938,9.355zM23.378,16.042c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1c0.551,0,1-0.447,1-1C24.378,16.492,23.929,16.042,23.378,16.042zM22.823,20.115c-0.48-0.275-1.092-0.111-1.367,0.365c-0.275,0.479-0.112,1.091,0.367,1.367c0.477,0.275,1.089,0.112,1.365-0.366C23.464,21.004,23.3,20.391,22.823,20.115zM15.501,8.167c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96c-0.478,0.277-0.642,0.889-0.365,1.366c0.275,0.479,0.889,0.642,1.365,0.366l3.305-1.676c0.055,0.006,0.109,0.017,0.166,0.017c0.828,0,1.5-0.672,1.5-1.5l-0.5-7.876C16.501,8.614,16.053,8.167,15.501,8.167zM18.939,22.998c-0.479,0.276-0.643,0.888-0.366,1.367c0.275,0.477,0.888,0.642,1.366,0.365c0.478-0.276,0.642-0.889,0.366-1.365C20.028,22.886,19.417,22.723,18.939,22.998zM11.197,3.593c-0.836-1.04-2.103-1.718-3.541-1.718c-2.52,0-4.562,2.042-4.562,4.562c0,0.957,0.297,1.843,0.8,2.576C5.649,6.484,8.206,4.553,11.197,3.593zM27.106,9.014c0.503-0.733,0.8-1.619,0.8-2.576c0-2.52-2.043-4.562-4.562-4.562c-1.438,0-2.704,0.678-3.541,1.717C22.794,4.553,25.351,6.484,27.106,9.014z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Anonymous.js":
/*!*************************************!*\
  !*** ./src/shape/icon/Anonymous.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Anonymous();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Anonymous = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Anonymous.prototype */
{

  NAME: "draw2d.shape.icon.Anonymous",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.523,23.813c-0.518-0.51-6.795-2.938-7.934-3.396c-1.132-0.451-1.584-1.697-1.584-1.697s-0.51,0.282-0.51-0.51c0-0.793,0.51,0.51,1.021-2.548c0,0,1.414-0.397,1.133-3.68l-0.338,0.001c0,0,0.85-3.511,0-4.699c-0.854-1.188-1.188-1.981-3.062-2.548c-1.869-0.567-1.188-0.454-2.547-0.396c-1.359,0.057-2.492,0.793-2.492,1.188c0,0-0.849,0.057-1.188,0.397c-0.34,0.34-0.906,1.924-0.906,2.32s0.283,3.059,0.566,3.624l-0.337,0.112c-0.283,3.283,1.132,3.681,1.132,3.681c0.509,3.058,1.019,1.755,1.019,2.548c0,0.792-0.51,0.51-0.51,0.51s-0.452,1.246-1.584,1.697c-1.132,0.453-7.416,2.887-7.927,3.396c-0.511,0.521-0.453,2.896-0.453,2.896h26.954C28.977,26.709,29.039,24.332,28.523,23.813zM16.618,13.693c-0.398-0.251-0.783-1.211-0.783-1.64c0-0.133,0-0.236,0-0.236c-0.105-0.106-0.574-0.096-0.67,0c0,0,0,0.104,0,0.236c0,0.429-0.385,1.389-0.783,1.64c-0.399,0.251-1.611,0.237-2.084-0.236c-0.473-0.473-0.524-1.663-0.643-1.78c-0.118-0.119-0.185-0.185-0.185-0.185l0.029-0.414c0,0,0.842-0.207,1.699-0.207s1.803,0.502,1.803,0.502c0.231-0.074,0.784-0.083,0.996,0c0,0,0.945-0.502,1.803-0.502s1.699,0.207,1.699,0.207l0.029,0.414c0,0-0.066,0.066-0.185,0.185c-0.118,0.118-0.169,1.308-0.643,1.78C18.229,13.93,17.018,13.944,16.618,13.693z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Apple.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Apple.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Apple();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Apple = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Apple.prototype */
{

  NAME: "draw2d.shape.icon.Apple",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.32,10.85c-1.743,1.233-2.615,2.719-2.615,4.455c0,2.079,1.078,3.673,3.232,4.786c-0.578,1.677-1.416,3.134-2.514,4.375c-1.097,1.241-2.098,1.862-3.004,1.862c-0.427,0-1.009-0.143-1.748-0.423l-0.354-0.138c-0.725-0.281-1.363-0.423-1.92-0.423c-0.525,0-1.1,0.11-1.725,0.331l-0.445,0.16l-0.56,0.229c-0.441,0.176-0.888,0.264-1.337,0.264c-1.059,0-2.228-0.872-3.507-2.616c-1.843-2.498-2.764-5.221-2.764-8.167c0-2.095,0.574-3.781,1.725-5.061c1.149-1.279,2.673-1.92,4.568-1.92c0.709,0,1.371,0.13,1.988,0.389l0.423,0.172l0.445,0.183c0.396,0.167,0.716,0.251,0.959,0.251c0.312,0,0.659-0.072,1.04-0.217l0.582-0.229l0.435-0.16c0.693-0.251,1.459-0.377,2.297-0.377C21.512,8.576,23.109,9.334,24.32,10.85zM19.615,3.287c0.021,0.267,0.033,0.473,0.033,0.617c0,1.317-0.479,2.473-1.438,3.467s-2.075,1.49-3.347,1.49c-0.038-0.297-0.058-0.51-0.058-0.639c0-1.12,0.445-2.171,1.337-3.153c0.891-0.982,1.922-1.558,3.096-1.725C19.32,3.329,19.447,3.311,19.615,3.287z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Apps.js":
/*!********************************!*\
  !*** ./src/shape/icon/Apps.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Apps();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Apps = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Apps.prototype */
{

  NAME: "draw2d.shape.icon.Apps",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.359,18.424l-2.326,1.215c0.708,1.174,1.384,2.281,1.844,3.033l2.043-1.066C25.538,20.822,24.966,19.652,24.359,18.424zM19.143,14.688c0.445,0.84,1.342,2.367,2.274,3.926l2.414-1.261c-0.872-1.769-1.72-3.458-2.087-4.122c-0.896-1.621-1.982-3.108-3.454-5.417c-1.673-2.625-3.462-5.492-4.052-4.947c-1.194,0.384,1.237,4.094,1.876,5.715C16.73,10.147,17.991,12.512,19.143,14.688zM26.457,22.673l-1.961,1.022l1.982,4.598c0,0,0.811,0.684,1.92,0.213c1.104-0.469,0.81-1.706,0.81-1.706L26.457,22.673zM24.35,15.711c0.168,0.339,2.924,5.93,2.924,5.93h1.983v-5.93H24.35zM18.34,15.704h-4.726l-3.424,5.935h11.66C21.559,21.159,18.771,16.479,18.34,15.704zM3.231,21.613l3.437-5.902H2.083v5.93h1.133L3.231,21.613zM15.048,10.145c0-0.93-0.754-1.685-1.685-1.685c-0.661,0-1.231,0.381-1.507,0.936l2.976,1.572C14.97,10.725,15.048,10.444,15.048,10.145zM14.343,12.06l-3.188-1.684L9.62,13.012l3.197,1.689L14.343,12.06zM3.192,26.886l-0.384,1.108v0.299l0.298-0.128l0.725-0.896l2.997-2.354l-3.137-1.651L3.192,26.886zM9.02,14.044l-4.757,8.17l3.23,1.706l4.728-8.186L9.02,14.044z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ArrowDown.js":
/*!*************************************!*\
  !*** ./src/shape/icon/ArrowDown.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ArrowDown();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ArrowDown = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ArrowDown.prototype */
{

  NAME: "draw2d.shape.icon.ArrowDown",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M5.318,6.684L15.5,24.316L25.682,6.684H5.318z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ArrowLeft.js":
/*!*************************************!*\
  !*** ./src/shape/icon/ArrowLeft.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ArrowLeft();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ArrowLeft = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ArrowLeft.prototype */
{

  NAME: "draw2d.shape.icon.ArrowLeft",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.316,5.318L6.684,15.5l17.632,10.182V5.318L24.316,5.318z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ArrowLeft2.js":
/*!**************************************!*\
  !*** ./src/shape/icon/ArrowLeft2.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ArrowLeft2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ArrowLeft2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ArrowLeft2.prototype */
{

  NAME: "draw2d.shape.icon.ArrowLeft2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.871,9.814 15.684,16.001 21.871,22.188 18.335,25.725 8.612,16.001 18.335,6.276z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ArrowRight.js":
/*!**************************************!*\
  !*** ./src/shape/icon/ArrowRight.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ArrowRight();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ArrowRight = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ArrowRight.prototype */
{

  NAME: "draw2d.shape.icon.ArrowRight",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M6.684,25.682L24.316,15.5L6.684,5.318V25.682z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ArrowRight2.js":
/*!***************************************!*\
  !*** ./src/shape/icon/ArrowRight2.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ArrowRight2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ArrowRight2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ArrowRight2.prototype */
{

  NAME: "draw2d.shape.icon.ArrowRight2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M10.129,22.186 16.316,15.999 10.129,9.812 13.665,6.276 23.389,15.999 13.665,25.725z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ArrowUp.js":
/*!***********************************!*\
  !*** ./src/shape/icon/ArrowUp.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ArrowUp();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ArrowUp = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ArrowUp.prototype */
{

  NAME: "draw2d.shape.icon.ArrowUp",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.682,24.316L15.5,6.684L5.318,24.316H25.682z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Aumade.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Aumade.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Aumade();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Aumade = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Aumade.prototype */
{

  NAME: "draw2d.shape.icon.Aumade",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.513,24.52c-0.131-0.217-0.14-0.481-0.022-0.711l1.987-3.844l0,0c0.186-0.357,0.625-0.497,0.981-0.312c0.357,0.188,0.498,0.625,0.312,0.982l-1.801,3.48l2.228,3.699h12.269l-14.8-25.631L6.433,18.178c0.434,0.242,0.909,0.479,1.391,0.654c0.571,0.211,1.148,0.342,1.658,0.342c0.276,0,0.579-0.078,0.916-0.238c0.337-0.158,0.7-0.396,1.073-0.688c0.749-0.582,1.527-1.354,2.334-2.021c0.539-0.442,1.091-0.844,1.706-1.099c0.352-0.145,0.729-0.239,1.128-0.239c0.622,0,1.174,0.214,1.622,0.5c0.449,0.287,0.813,0.646,1.11,0.995c0.59,0.697,0.902,1.359,0.924,1.394l0,0c0.18,0.361,0.021,0.801-0.341,0.977c-0.356,0.176-0.798,0.021-0.978-0.34c0-0.002-0.002-0.004-0.004-0.007c-0.002-0.011-0.008-0.021-0.018-0.034c-0.018-0.033-0.043-0.082-0.078-0.146c-0.07-0.125-0.179-0.305-0.312-0.496c-0.271-0.391-0.668-0.845-1.092-1.104c-0.281-0.178-0.561-0.272-0.844-0.272c-0.216,0-0.479,0.069-0.788,0.229c-0.309,0.153-0.653,0.396-1.016,0.688c-0.727,0.584-1.511,1.362-2.351,2.033c-0.562,0.445-1.15,0.853-1.809,1.103c-0.375,0.143-0.776,0.229-1.195,0.229c-0.749,0-1.48-0.181-2.164-0.433c-0.58-0.219-1.125-0.482-1.613-0.764L0.86,27.816h15.63L14.513,24.52zM18.214,22.242c0.222-0.557,0.537-1.217,0.963-1.848c0.427-0.627,0.957-1.232,1.646-1.646c0.379-0.229,0.812-0.391,1.282-0.438l-0.604-0.934l0,0c-0.22-0.339-0.123-0.789,0.215-1.009c0.341-0.219,0.789-0.123,1.013,0.216l1.545,2.391c0.184,0.274,0.147,0.646-0.075,0.893c-0.228,0.247-0.591,0.305-0.886,0.145c-0.354-0.191-0.646-0.258-0.901-0.258c-0.291,0-0.562,0.084-0.845,0.25c-0.277,0.164-0.562,0.414-0.813,0.719c-0.519,0.607-0.937,1.422-1.185,2.055c-0.111,0.285-0.387,0.466-0.678,0.466c-0.092,0-0.183-0.021-0.271-0.056C18.249,23.039,18.064,22.615,18.214,22.242z");
  }
});

/***/ }),

/***/ "./src/shape/icon/BarChart.js":
/*!************************************!*\
  !*** ./src/shape/icon/BarChart.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.BarChart();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.BarChart = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.BarChart.prototype */
{

  NAME: "draw2d.shape.icon.BarChart",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.25,8.375V28h6.5V8.375H21.25zM12.25,28h6.5V4.125h-6.5V28zM3.25,28h6.5V12.625h-6.5V28z");
  }
});

/***/ }),

/***/ "./src/shape/icon/BioHazard.js":
/*!*************************************!*\
  !*** ./src/shape/icon/BioHazard.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.BioHazard();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.BioHazard = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.BioHazard.prototype */
{

  NAME: "draw2d.shape.icon.BioHazard",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M26.154,13.988c-0.96-0.554-1.982-0.892-3.019-1.032c0.396-0.966,0.616-2.023,0.616-3.131c0-4.399-3.438-8.001-7.772-8.264c3.245,0.258,5.803,2.979,5.803,6.292c0,3.373-2.653,6.123-5.983,6.294v1.292c0.908,0.144,1.605,0.934,1.605,1.883c0,0.232-0.043,0.454-0.118,0.66l1.181,0.683c1.826-2.758,5.509-3.658,8.41-1.981c2.896,1.672,3.965,5.299,2.506,8.254C31.386,21.038,29.992,16.204,26.154,13.988zM4.122,16.587c2.92-1.686,6.628-0.764,8.442,2.034l1.141-0.657c-0.072-0.2-0.109-0.417-0.109-0.642c0-0.909,0.638-1.67,1.489-1.859v-1.319c-3.3-0.202-5.92-2.94-5.92-6.292c0-3.297,2.532-6.007,5.757-6.286c-4.312,0.285-7.729,3.875-7.729,8.258c0,1.078,0.206,2.106,0.581,3.05c-1.004,0.147-1.999,0.481-2.931,1.02c-3.812,2.201-5.209,6.985-3.264,10.87C0.174,21.823,1.251,18.244,4.122,16.587zM11.15,11.452c0.114,0.139,0.235,0.271,0.362,0.398c0.126,0.126,0.259,0.247,0.397,0.361c0.102,0.084,0.211,0.16,0.318,0.236c0.93-0.611,2.045-0.969,3.244-0.969c1.201,0,2.312,0.357,3.242,0.969c0.107-0.077,0.217-0.152,0.318-0.236c0.139-0.114,0.271-0.235,0.397-0.361c0.127-0.127,0.248-0.259,0.362-0.398c0.113-0.138,0.222-0.283,0.323-0.431c-1.307-0.956-2.908-1.528-4.643-1.528c-0.042,0-0.083-0.001-0.124,0c-0.019,0-0.04-0.001-0.06,0c-1.666,0.038-3.201,0.605-4.462,1.528C10.929,11.17,11.037,11.314,11.15,11.452zM9.269,16.787c-0.168-0.062-0.338-0.117-0.512-0.164c-0.173-0.047-0.348-0.083-0.525-0.113c-0.177-0.03-0.355-0.053-0.535-0.065c-0.175,1.609,0.13,3.282,0.998,4.786c0.868,1.503,2.164,2.606,3.645,3.259c0.079-0.162,0.15-0.328,0.212-0.496c0.063-0.169,0.118-0.338,0.164-0.512c0.047-0.173,0.087-0.349,0.115-0.525c0.022-0.13,0.034-0.262,0.046-0.394c-0.993-0.5-1.86-1.286-2.461-2.325c-0.6-1.04-0.847-2.182-0.783-3.294C9.512,16.889,9.392,16.833,9.269,16.787zM18.122,22.657c0.014,0.132,0.024,0.263,0.046,0.394c0.03,0.177,0.067,0.352,0.113,0.524c0.047,0.174,0.102,0.346,0.165,0.514c0.062,0.169,0.132,0.333,0.212,0.495c1.48-0.653,2.777-1.755,3.644-3.257c0.868-1.504,1.176-3.179,1.001-4.788c-0.18,0.013-0.358,0.035-0.535,0.065c-0.177,0.029-0.353,0.067-0.525,0.113s-0.345,0.101-0.513,0.163c-0.124,0.047-0.241,0.105-0.362,0.16c0.063,1.11-0.183,2.253-0.784,3.292C19.984,21.373,19.116,22.157,18.122,22.657zM20.569,27.611c-2.92-1.687-3.977-5.358-2.46-8.329l-1.192-0.689c-0.349,0.389-0.854,0.634-1.417,0.634c-0.571,0-1.086-0.254-1.436-0.653l-1.146,0.666c1.475,2.96,0.414,6.598-2.488,8.272c-2.888,1.668-6.552,0.791-8.386-1.935c2.38,3.667,7.249,4.87,11.079,2.658c0.929-0.535,1.711-1.227,2.339-2.018c0.64,0.832,1.45,1.554,2.416,2.112c3.835,2.213,8.709,1.006,11.086-2.671C27.132,28.396,23.463,29.282,20.569,27.611z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Book.js":
/*!********************************!*\
  !*** ./src/shape/icon/Book.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Book();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Book = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Book.prototype */
{

  NAME: "draw2d.shape.icon.Book",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.754,4.626c-0.233-0.161-0.536-0.198-0.802-0.097L12.16,9.409c-0.557,0.213-1.253,0.316-1.968,0.316c-0.997,0.002-2.029-0.202-2.747-0.48C7.188,9.148,6.972,9.04,6.821,8.943c0.056-0.024,0.12-0.05,0.193-0.075L18.648,4.43l1.733,0.654V3.172c0-0.284-0.14-0.554-0.374-0.714c-0.233-0.161-0.538-0.198-0.802-0.097L6.414,7.241c-0.395,0.142-0.732,0.312-1.02,0.564C5.111,8.049,4.868,8.45,4.872,8.896c0,0.012,0.004,0.031,0.004,0.031v17.186c0,0.008-0.003,0.015-0.003,0.021c0,0.006,0.003,0.01,0.003,0.016v0.017h0.002c0.028,0.601,0.371,0.983,0.699,1.255c1.034,0.803,2.769,1.252,4.614,1.274c0.874,0,1.761-0.116,2.583-0.427l12.796-4.881c0.337-0.128,0.558-0.448,0.558-0.809V5.341C26.128,5.057,25.988,4.787,25.754,4.626zM5.672,11.736c0.035,0.086,0.064,0.176,0.069,0.273l0.004,0.054c0.016,0.264,0.13,0.406,0.363,0.611c0.783,0.626,2.382,1.08,4.083,1.093c0.669,0,1.326-0.083,1.931-0.264v1.791c-0.647,0.143-1.301,0.206-1.942,0.206c-1.674-0.026-3.266-0.353-4.509-1.053V11.736zM10.181,24.588c-1.674-0.028-3.266-0.354-4.508-1.055v-2.712c0.035,0.086,0.065,0.176,0.07,0.275l0.002,0.053c0.018,0.267,0.13,0.408,0.364,0.613c0.783,0.625,2.381,1.079,4.083,1.091c0.67,0,1.327-0.082,1.932-0.262v1.789C11.476,24.525,10.821,24.588,10.181,24.588z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Bookmark.js":
/*!************************************!*\
  !*** ./src/shape/icon/Bookmark.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Bookmark();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Bookmark = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Bookmark.prototype */
{

  NAME: "draw2d.shape.icon.Bookmark",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M17.396,1.841L6.076,25.986l7.341-4.566l1.186,8.564l11.32-24.146L17.396,1.841zM19.131,9.234c-0.562-0.264-0.805-0.933-0.541-1.495c0.265-0.562,0.934-0.805,1.496-0.541s0.805,0.934,0.541,1.496S19.694,9.498,19.131,9.234z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Books.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Books.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Books();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Books = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Books.prototype */
{

  NAME: "draw2d.shape.icon.Books",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M26.679,7.858c-0.176-0.138-0.404-0.17-0.606-0.083l-9.66,4.183c-0.42,0.183-0.946,0.271-1.486,0.271c-0.753,0.002-1.532-0.173-2.075-0.412c-0.194-0.083-0.356-0.176-0.471-0.259c0.042-0.021,0.09-0.042,0.146-0.064l8.786-3.804l1.31,0.561V6.612c0-0.244-0.106-0.475-0.283-0.612c-0.176-0.138-0.406-0.17-0.605-0.083l-9.66,4.183c-0.298,0.121-0.554,0.268-0.771,0.483c-0.213,0.208-0.397,0.552-0.394,0.934c0,0.01,0.003,0.027,0.003,0.027v14.73c0,0.006-0.002,0.012-0.002,0.019c0,0.005,0.002,0.007,0.002,0.012v0.015h0.002c0.021,0.515,0.28,0.843,0.528,1.075c0.781,0.688,2.091,1.073,3.484,1.093c0.66,0,1.33-0.1,1.951-0.366l9.662-4.184c0.255-0.109,0.422-0.383,0.422-0.692V8.471C26.961,8.227,26.855,7.996,26.679,7.858zM20.553,5.058c-0.017-0.221-0.108-0.429-0.271-0.556c-0.176-0.138-0.404-0.17-0.606-0.083l-9.66,4.183C9.596,8.784,9.069,8.873,8.53,8.873C7.777,8.874,6.998,8.699,6.455,8.46C6.262,8.378,6.099,8.285,5.984,8.202C6.026,8.181,6.075,8.16,6.13,8.138l8.787-3.804l1.309,0.561V3.256c0-0.244-0.106-0.475-0.283-0.612c-0.176-0.138-0.407-0.17-0.606-0.083l-9.66,4.183C5.379,6.864,5.124,7.011,4.907,7.227C4.693,7.435,4.51,7.779,4.513,8.161c0,0.011,0.003,0.027,0.003,0.027v14.73c0,0.006-0.001,0.013-0.001,0.019c0,0.005,0.001,0.007,0.001,0.012v0.016h0.002c0.021,0.515,0.28,0.843,0.528,1.075c0.781,0.688,2.091,1.072,3.485,1.092c0.376,0,0.754-0.045,1.126-0.122V11.544c-0.01-0.7,0.27-1.372,0.762-1.856c0.319-0.315,0.708-0.564,1.19-0.756L20.553,5.058z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Bubble.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Bubble.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Bubble();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Bubble = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Bubble.prototype */
{

  NAME: "draw2d.shape.icon.Bubble",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Bug.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Bug.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Bug();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Bug = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Bug.prototype */
{

  NAME: "draw2d.shape.icon.Bug",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.589,10.903l-5.828,1.612c-0.534-1.419-1.338-2.649-2.311-3.628l3.082-5.44c0.271-0.48,0.104-1.092-0.38-1.365c-0.479-0.271-1.09-0.102-1.36,0.377l-2.924,5.162c-0.604-0.383-1.24-0.689-1.9-0.896c-0.416-1.437-1.652-2.411-3.058-2.562c-0.001-0.004-0.002-0.008-0.003-0.012c-0.061-0.242-0.093-0.46-0.098-0.65c-0.005-0.189,0.012-0.351,0.046-0.479c0.037-0.13,0.079-0.235,0.125-0.317c0.146-0.26,0.34-0.43,0.577-0.509c0.023,0.281,0.142,0.482,0.352,0.601c0.155,0.088,0.336,0.115,0.546,0.086c0.211-0.031,0.376-0.152,0.496-0.363c0.105-0.186,0.127-0.389,0.064-0.607c-0.064-0.219-0.203-0.388-0.414-0.507c-0.154-0.087-0.314-0.131-0.482-0.129c-0.167,0.001-0.327,0.034-0.481,0.097c-0.153,0.063-0.296,0.16-0.429,0.289c-0.132,0.129-0.241,0.271-0.33,0.426c-0.132,0.234-0.216,0.496-0.25,0.783c-0.033,0.286-0.037,0.565-0.009,0.84c0.017,0.16,0.061,0.301,0.094,0.449c-0.375-0.021-0.758,0.002-1.14,0.108c-0.482,0.133-0.913,0.36-1.28,0.653c-0.052-0.172-0.098-0.344-0.18-0.518c-0.116-0.249-0.263-0.486-0.438-0.716c-0.178-0.229-0.384-0.41-0.618-0.543C9.904,3.059,9.737,2.994,9.557,2.951c-0.18-0.043-0.352-0.052-0.516-0.027s-0.318,0.08-0.463,0.164C8.432,3.172,8.318,3.293,8.23,3.445C8.111,3.656,8.08,3.873,8.136,4.092c0.058,0.221,0.181,0.384,0.367,0.49c0.21,0.119,0.415,0.138,0.611,0.056C9.31,4.556,9.451,4.439,9.539,4.283c0.119-0.21,0.118-0.443-0.007-0.695c0.244-0.055,0.497-0.008,0.757,0.141c0.081,0.045,0.171,0.115,0.27,0.208c0.097,0.092,0.193,0.222,0.286,0.388c0.094,0.166,0.179,0.368,0.251,0.608c0.013,0.044,0.023,0.098,0.035,0.146c-0.911,0.828-1.357,2.088-1.098,3.357c-0.582,0.584-1.072,1.27-1.457,2.035l-5.16-2.926c-0.48-0.271-1.092-0.102-1.364,0.377C1.781,8.404,1.95,9.016,2.43,9.289l5.441,3.082c-0.331,1.34-0.387,2.807-0.117,4.297l-5.828,1.613c-0.534,0.147-0.846,0.699-0.698,1.231c0.147,0.53,0.697,0.843,1.231,0.694l5.879-1.627c0.503,1.057,1.363,2.28,2.371,3.443l-3.194,5.639c-0.272,0.481-0.104,1.092,0.378,1.363c0.239,0.137,0.512,0.162,0.758,0.094c0.248-0.068,0.469-0.229,0.604-0.471l2.895-5.109c2.7,2.594,5.684,4.123,5.778,1.053c1.598,2.56,3.451-0.338,4.502-3.976l5.203,2.947c0.24,0.138,0.514,0.162,0.762,0.094c0.246-0.067,0.467-0.229,0.603-0.471c0.272-0.479,0.104-1.091-0.377-1.362l-5.701-3.229c0.291-1.505,0.422-2.983,0.319-4.138l5.886-1.627c0.53-0.147,0.847-0.697,0.696-1.229C29.673,11.068,29.121,10.756,28.589,10.903z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Calendar.js":
/*!************************************!*\
  !*** ./src/shape/icon/Calendar.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Calendar();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Calendar = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Calendar.prototype */
{

  NAME: "draw2d.shape.icon.Calendar",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M11.758,15.318c0.312-0.3,0.408-0.492,0.408-0.492h0.024c0,0-0.012,0.264-0.012,0.528v5.469h-1.871v1.031h4.87v-1.031H13.33v-7.436h-1.055l-2.027,1.967l0.719,0.744L11.758,15.318zM16.163,21.207c0,0.205,0.024,0.42,0.06,0.647h5.457v-1.031h-4.197c0.023-1.931,4.065-2.362,4.065-5.146c0-1.463-1.114-2.436-2.674-2.436c-1.907,0-2.675,1.607-2.675,1.607l0.875,0.587c0,0,0.6-1.08,1.716-1.08c0.887,0,1.522,0.563,1.522,1.403C20.312,17.754,16.163,18.186,16.163,21.207zM12,3.604h-2v3.335h2V3.604zM23,4.77v3.17h-4V4.77h-6v3.168H9.002V4.77H6.583v21.669h18.833V4.77H23zM24.417,25.438H7.584V10.522h16.833V25.438zM22,3.604h-2v3.335h2V3.604z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Cart.js":
/*!********************************!*\
  !*** ./src/shape/icon/Cart.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Cart();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Cart = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Cart.prototype */
{

  NAME: "draw2d.shape.icon.Cart",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M29.02,11.754L8.416,9.473L7.16,4.716C7.071,4.389,6.772,4.158,6.433,4.158H3.341C3.114,3.866,2.775,3.667,2.377,3.667c-0.686,0-1.242,0.556-1.242,1.242c0,0.686,0.556,1.242,1.242,1.242c0.399,0,0.738-0.201,0.965-0.493h2.512l5.23,19.8c-0.548,0.589-0.891,1.373-0.891,2.242c0,1.821,1.473,3.293,3.293,3.293c1.82,0,3.294-1.472,3.297-3.293c0-0.257-0.036-0.504-0.093-0.743h5.533c-0.056,0.239-0.092,0.486-0.092,0.743c0,1.821,1.475,3.293,3.295,3.293s3.295-1.472,3.295-3.293c0-1.82-1.473-3.295-3.295-3.297c-0.951,0.001-1.801,0.409-2.402,1.053h-7.136c-0.601-0.644-1.451-1.052-2.402-1.053c-0.379,0-0.738,0.078-1.077,0.196l-0.181-0.685H26.81c1.157-0.027,2.138-0.83,2.391-1.959l1.574-7.799c0.028-0.145,0.041-0.282,0.039-0.414C30.823,12.733,30.051,11.86,29.02,11.754zM25.428,27.994c-0.163,0-0.295-0.132-0.297-0.295c0.002-0.165,0.134-0.297,0.297-0.297s0.295,0.132,0.297,0.297C25.723,27.862,25.591,27.994,25.428,27.994zM27.208,20.499l0.948-0.948l-0.318,1.578L27.208,20.499zM12.755,11.463l1.036,1.036l-1.292,1.292l-1.292-1.292l1.087-1.087L12.755,11.463zM17.253,11.961l0.538,0.538l-1.292,1.292l-1.292-1.292l0.688-0.688L17.253,11.961zM9.631,14.075l0.868-0.868l1.292,1.292l-1.292,1.292l-0.564-0.564L9.631,14.075zM9.335,12.956l-0.328-1.24L9.792,12.5L9.335,12.956zM21.791,16.499l-1.292,1.292l-1.292-1.292l1.292-1.292L21.791,16.499zM21.207,14.5l1.292-1.292l1.292,1.292l-1.292,1.292L21.207,14.5zM18.5,15.791l-1.293-1.292l1.292-1.292l1.292,1.292L18.5,15.791zM17.791,16.499L16.5,17.791l-1.292-1.292l1.292-1.292L17.791,16.499zM14.499,15.791l-1.292-1.292l1.292-1.292l1.292,1.292L14.499,15.791zM13.791,16.499l-1.292,1.291l-1.292-1.291l1.292-1.292L13.791,16.499zM10.499,17.207l1.292,1.292l-0.785,0.784l-0.54-2.044L10.499,17.207zM11.302,20.404l1.197-1.197l1.292,1.292L12.5,21.791l-1.131-1.13L11.302,20.404zM13.208,18.499l1.291-1.292l1.292,1.292L14.5,19.791L13.208,18.499zM16.5,19.207l1.292,1.292L16.5,21.79l-1.292-1.291L16.5,19.207zM17.208,18.499l1.292-1.292l1.291,1.292L18.5,19.79L17.208,18.499zM20.499,19.207l1.292,1.292L20.5,21.79l-1.292-1.292L20.499,19.207zM21.207,18.499l1.292-1.292l1.292,1.292l-1.292,1.292L21.207,18.499zM23.207,16.499l1.292-1.292l1.292,1.292l-1.292,1.292L23.207,16.499zM25.207,14.499l1.292-1.292L27.79,14.5l-1.291,1.292L25.207,14.499zM24.499,13.792l-1.156-1.156l2.082,0.23L24.499,13.792zM21.791,12.5l-1.292,1.292L19.207,12.5l0.29-0.29l2.253,0.25L21.791,12.5zM14.5,11.791l-0.152-0.152l0.273,0.03L14.5,11.791zM10.5,11.792l-0.65-0.65l1.171,0.129L10.5,11.792zM14.5,21.207l1.205,1.205h-2.409L14.5,21.207zM18.499,21.207l1.206,1.206h-2.412L18.499,21.207zM22.499,21.207l1.208,1.207l-2.414-0.001L22.499,21.207zM23.207,20.499l1.292-1.292l1.292,1.292l-1.292,1.292L23.207,20.499zM25.207,18.499l1.292-1.291l1.291,1.291l-1.291,1.292L25.207,18.499zM28.499,17.791l-1.291-1.292l1.291-1.291l0.444,0.444l-0.429,2.124L28.499,17.791zM29.001,13.289l-0.502,0.502l-0.658-0.658l1.016,0.112C28.911,13.253,28.956,13.271,29.001,13.289zM13.487,27.994c-0.161,0-0.295-0.132-0.295-0.295c0-0.165,0.134-0.297,0.295-0.297c0.163,0,0.296,0.132,0.296,0.297C13.783,27.862,13.651,27.994,13.487,27.994zM26.81,22.414h-1.517l1.207-1.207l0.93,0.93C27.243,22.306,27.007,22.428,26.81,22.414z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Ccw.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Ccw.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Ccw();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Ccw = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Ccw.prototype */
{

  NAME: "draw2d.shape.icon.Ccw",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.249,15.499c-0.009,4.832-3.918,8.741-8.75,8.75c-2.515,0-4.768-1.064-6.365-2.763l2.068-1.442l-7.901-3.703l0.744,8.694l2.193-1.529c2.244,2.594,5.562,4.242,9.26,4.242c6.767,0,12.249-5.482,12.249-12.249H24.249zM15.499,6.75c2.516,0,4.769,1.065,6.367,2.764l-2.068,1.443l7.901,3.701l-0.746-8.693l-2.192,1.529c-2.245-2.594-5.562-4.245-9.262-4.245C8.734,3.25,3.25,8.734,3.249,15.499H6.75C6.758,10.668,10.668,6.758,15.499,6.75z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Chat.js":
/*!********************************!*\
  !*** ./src/shape/icon/Chat.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Chat();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Chat = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Chat.prototype */
{

  NAME: "draw2d.shape.icon.Chat",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.985,5.972c-7.563,0-13.695,4.077-13.695,9.106c0,2.877,2.013,5.44,5.147,7.108c-0.446,1.479-1.336,3.117-3.056,4.566c0,0,4.015-0.266,6.851-3.143c0.163,0.04,0.332,0.07,0.497,0.107c-0.155-0.462-0.246-0.943-0.246-1.443c0-3.393,3.776-6.05,8.599-6.05c3.464,0,6.379,1.376,7.751,3.406c1.168-1.34,1.847-2.892,1.847-4.552C29.68,10.049,23.548,5.972,15.985,5.972zM27.68,22.274c0-2.79-3.401-5.053-7.599-5.053c-4.196,0-7.599,2.263-7.599,5.053c0,2.791,3.403,5.053,7.599,5.053c0.929,0,1.814-0.116,2.637-0.319c1.573,1.597,3.801,1.744,3.801,1.744c-0.954-0.804-1.447-1.713-1.695-2.534C26.562,25.293,27.68,23.871,27.68,22.274z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Check.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Check.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Check();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Check = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Check.prototype */
{

  NAME: "draw2d.shape.icon.Check",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M2.379,14.729 5.208,11.899 12.958,19.648 25.877,6.733 28.707,9.561 12.958,25.308z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Chrome.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Chrome.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Chrome();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Chrome = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Chrome.prototype */
{

  NAME: "draw2d.shape.icon.Chrome",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.318,7.677c0.071-0.029,0.148-0.046,0.229-0.046h11.949c-2.533-3.915-6.938-6.506-11.949-6.506c-5.017,0-9.428,2.598-11.959,6.522l4.291,7.431C8.018,11.041,11.274,7.796,15.318,7.677zM28.196,8.84h-8.579c2.165,1.357,3.605,3.763,3.605,6.506c0,1.321-0.334,2.564-0.921,3.649c-0.012,0.071-0.035,0.142-0.073,0.209l-5.973,10.347c7.526-0.368,13.514-6.587,13.514-14.205C29.77,13.002,29.201,10.791,28.196,8.84zM15.547,23.022c-2.761,0-5.181-1.458-6.533-3.646c-0.058-0.046-0.109-0.103-0.149-0.171L2.89,8.855c-1,1.946-1.565,4.153-1.565,6.492c0,7.624,5.999,13.846,13.534,14.205l4.287-7.425C18.073,22.698,16.848,23.022,15.547,23.022zM9.08,15.347c0,1.788,0.723,3.401,1.894,4.573c1.172,1.172,2.785,1.895,4.573,1.895c1.788,0,3.401-0.723,4.573-1.895s1.895-2.785,1.895-4.573c0-1.788-0.723-3.4-1.895-4.573c-1.172-1.171-2.785-1.894-4.573-1.894c-1.788,0-3.401,0.723-4.573,1.894C9.803,11.946,9.081,13.559,9.08,15.347z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Clip.js":
/*!********************************!*\
  !*** ./src/shape/icon/Clip.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Clip();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Clip = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Clip.prototype */
{

  NAME: "draw2d.shape.icon.Clip",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M23.898,6.135c-1.571-1.125-3.758-0.764-4.884,0.808l-8.832,12.331c-0.804,1.122-0.546,2.684,0.577,3.488c1.123,0.803,2.684,0.545,3.488-0.578l6.236-8.706l-0.813-0.583l-6.235,8.707h0c-0.483,0.672-1.42,0.828-2.092,0.347c-0.673-0.481-0.827-1.419-0.345-2.093h0l8.831-12.33l0.001-0.001l-0.002-0.001c0.803-1.119,2.369-1.378,3.489-0.576c1.12,0.803,1.379,2.369,0.577,3.489v-0.001l-9.68,13.516l0.001,0.001c-1.124,1.569-3.316,1.931-4.885,0.808c-1.569-1.125-1.93-3.315-0.807-4.885l7.035-9.822l-0.813-0.582l-7.035,9.822c-1.447,2.02-0.982,4.83,1.039,6.277c2.021,1.448,4.831,0.982,6.278-1.037l9.68-13.516C25.83,9.447,25.47,7.261,23.898,6.135z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Clock.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Clock.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Clock();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Clock = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Clock.prototype */
{

  NAME: "draw2d.shape.icon.Clock",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.5,2.374C8.251,2.375,2.376,8.251,2.374,15.5C2.376,22.748,8.251,28.623,15.5,28.627c7.249-0.004,13.124-5.879,13.125-13.127C28.624,8.251,22.749,2.375,15.5,2.374zM15.5,25.623C9.909,25.615,5.385,21.09,5.375,15.5C5.385,9.909,9.909,5.384,15.5,5.374c5.59,0.01,10.115,4.535,10.124,10.125C25.615,21.09,21.091,25.615,15.5,25.623zM8.625,15.5c-0.001-0.552-0.448-0.999-1.001-1c-0.553,0-1,0.448-1,1c0,0.553,0.449,1,1,1C8.176,16.5,8.624,16.053,8.625,15.5zM8.179,18.572c-0.478,0.277-0.642,0.889-0.365,1.367c0.275,0.479,0.889,0.641,1.365,0.365c0.479-0.275,0.643-0.887,0.367-1.367C9.27,18.461,8.658,18.297,8.179,18.572zM9.18,10.696c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366c0.479,0.276,1.09,0.113,1.367-0.366C9.821,11.584,9.657,10.973,9.18,10.696zM22.822,12.428c0.478-0.275,0.643-0.888,0.366-1.366c-0.275-0.478-0.89-0.642-1.366-0.366c-0.479,0.278-0.642,0.89-0.366,1.367C21.732,12.54,22.344,12.705,22.822,12.428zM12.062,21.455c-0.478-0.275-1.089-0.111-1.366,0.367c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.277,1.091,0.111,1.365-0.365C12.704,22.344,12.54,21.732,12.062,21.455zM12.062,9.545c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,9.658,11.584,9.822,12.062,9.545zM22.823,18.572c-0.48-0.275-1.092-0.111-1.367,0.365c-0.275,0.479-0.112,1.092,0.367,1.367c0.477,0.275,1.089,0.113,1.365-0.365C23.464,19.461,23.3,18.848,22.823,18.572zM19.938,7.813c-0.477-0.276-1.091-0.111-1.365,0.366c-0.275,0.48-0.111,1.091,0.366,1.367s1.089,0.112,1.366-0.366C20.581,8.702,20.418,8.089,19.938,7.813zM23.378,14.5c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1c0.551,0,1-0.447,1-1C24.378,14.949,23.929,14.5,23.378,14.5zM15.501,6.624c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96c-0.478,0.277-0.642,0.889-0.365,1.365c0.275,0.479,0.889,0.643,1.365,0.367l3.305-1.676C15.39,16.99,15.444,17,15.501,17c0.828,0,1.5-0.671,1.5-1.5l-0.5-7.876C16.501,7.072,16.053,6.624,15.501,6.624zM15.501,22.377c-0.552,0-1,0.447-1,1s0.448,1,1,1s1-0.447,1-1S16.053,22.377,15.501,22.377zM18.939,21.455c-0.479,0.277-0.643,0.889-0.366,1.367c0.275,0.477,0.888,0.643,1.366,0.365c0.478-0.275,0.642-0.889,0.366-1.365C20.028,21.344,19.417,21.18,18.939,21.455z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Cloud.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Cloud.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Cloud();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Cloud = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Cloud.prototype */
{

  NAME: "draw2d.shape.icon.Cloud",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.345,13.904c0.019-0.195,0.03-0.392,0.03-0.591c0-3.452-2.798-6.25-6.25-6.25c-2.679,0-4.958,1.689-5.847,4.059c-0.589-0.646-1.429-1.059-2.372-1.059c-1.778,0-3.219,1.441-3.219,3.219c0,0.21,0.023,0.415,0.062,0.613c-2.372,0.391-4.187,2.436-4.187,4.918c0,2.762,2.239,5,5,5h15.875c2.762,0,5-2.238,5-5C28.438,16.362,26.672,14.332,24.345,13.904z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Cloud2.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Cloud2.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Cloud2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Cloud2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Cloud2.prototype */
{

  NAME: "draw2d.shape.icon.Cloud2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M7.562,24.812c-3.313,0-6-2.687-6-6l0,0c0.002-2.659,1.734-4.899,4.127-5.684l0,0c0.083-2.26,1.937-4.064,4.216-4.066l0,0c0.73,0,1.415,0.19,2.01,0.517l0,0c1.266-2.105,3.57-3.516,6.208-3.517l0,0c3.947,0.002,7.157,3.155,7.248,7.079l0,0c2.362,0.804,4.062,3.034,4.064,5.671l0,0c0,3.313-2.687,6-6,6l0,0H7.562L7.562,24.812zM24.163,14.887c-0.511-0.095-0.864-0.562-0.815-1.079l0,0c0.017-0.171,0.027-0.336,0.027-0.497l0,0c-0.007-2.899-2.352-5.245-5.251-5.249l0,0c-2.249-0.002-4.162,1.418-4.911,3.41l0,0c-0.122,0.323-0.406,0.564-0.748,0.63l0,0c-0.34,0.066-0.694-0.052-0.927-0.309l0,0c-0.416-0.453-0.986-0.731-1.633-0.731l0,0c-1.225,0.002-2.216,0.993-2.22,2.218l0,0c0,0.136,0.017,0.276,0.045,0.424l0,0c0.049,0.266-0.008,0.54-0.163,0.762l0,0c-0.155,0.223-0.392,0.371-0.657,0.414l0,0c-1.9,0.313-3.352,1.949-3.35,3.931l0,0c0.004,2.209,1.792,3.995,4.001,4.001l0,0h15.874c2.209-0.006,3.994-1.792,3.999-4.001l0,0C27.438,16.854,26.024,15.231,24.163,14.887L24.163,14.887");
  }
});

/***/ }),

/***/ "./src/shape/icon/CloudDown.js":
/*!*************************************!*\
  !*** ./src/shape/icon/CloudDown.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.CloudDown();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.CloudDown = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.CloudDown.prototype */
{

  NAME: "draw2d.shape.icon.CloudDown",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.345,13.904c0.019-0.195,0.03-0.392,0.03-0.591c0-3.452-2.798-6.25-6.25-6.25c-2.679,0-4.958,1.689-5.847,4.059c-0.589-0.646-1.429-1.059-2.372-1.059c-1.778,0-3.219,1.441-3.219,3.219c0,0.21,0.023,0.415,0.062,0.613c-2.372,0.391-4.187,2.436-4.187,4.918c0,2.762,2.239,5,5,5h3.404l-0.707-0.707c-0.377-0.377-0.585-0.879-0.585-1.413c0-0.533,0.208-1.035,0.585-1.412l0.556-0.557c0.4-0.399,0.937-0.628,1.471-0.628c0.027,0,0.054,0,0.08,0.002v-0.472c0-1.104,0.898-2.002,2-2.002h3.266c1.103,0,2,0.898,2,2.002v0.472c0.027-0.002,0.054-0.002,0.081-0.002c0.533,0,1.07,0.229,1.47,0.63l0.557,0.552c0.78,0.781,0.78,2.05,0,2.828l-0.706,0.707h2.403c2.762,0,5-2.238,5-5C28.438,16.362,26.672,14.332,24.345,13.904z M21.033,20.986l-0.556-0.555c-0.39-0.389-0.964-0.45-1.276-0.137c-0.312,0.312-0.568,0.118-0.568-0.432v-1.238c0-0.55-0.451-1-1-1h-3.265c-0.55,0-1,0.45-1,1v1.238c0,0.55-0.256,0.744-0.569,0.432c-0.312-0.313-0.887-0.252-1.276,0.137l-0.556,0.555c-0.39,0.389-0.39,1.024-0.001,1.413l4.328,4.331c0.194,0.194,0.451,0.291,0.707,0.291s0.512-0.097,0.707-0.291l4.327-4.331C21.424,22.011,21.423,21.375,21.033,20.986z");
  }
});

/***/ }),

/***/ "./src/shape/icon/CloudUp.js":
/*!***********************************!*\
  !*** ./src/shape/icon/CloudUp.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.CloudUp();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.CloudUp = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.CloudUp.prototype */
{

  NAME: "draw2d.shape.icon.CloudUp",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.345,13.904c0.019-0.195,0.03-0.392,0.03-0.591c0-3.452-2.798-6.25-6.25-6.25c-2.679,0-4.958,1.689-5.847,4.059c-0.589-0.646-1.429-1.059-2.372-1.059c-1.778,0-3.219,1.441-3.219,3.219c0,0.21,0.023,0.415,0.062,0.613c-2.372,0.391-4.187,2.436-4.187,4.918c0,2.762,2.239,5,5,5h2.312c-0.126-0.266-0.2-0.556-0.2-0.859c0-0.535,0.208-1.04,0.587-1.415l4.325-4.329c0.375-0.377,0.877-0.585,1.413-0.585c0.54,0,1.042,0.21,1.417,0.587l4.323,4.329c0.377,0.373,0.585,0.878,0.585,1.413c0,0.304-0.073,0.594-0.2,0.859h1.312c2.762,0,5-2.238,5-5C28.438,16.362,26.672,14.332,24.345,13.904z M16.706,17.916c-0.193-0.195-0.45-0.291-0.706-0.291s-0.512,0.096-0.707,0.291l-4.327,4.33c-0.39,0.389-0.389,1.025,0.001,1.414l0.556,0.555c0.39,0.389,0.964,0.449,1.276,0.137s0.568-0.119,0.568,0.432v1.238c0,0.549,0.451,1,1,1h3.265c0.551,0,1-0.451,1-1v-1.238c0-0.551,0.256-0.744,0.569-0.432c0.312,0.312,0.887,0.252,1.276-0.137l0.556-0.555c0.39-0.389,0.39-1.025,0.001-1.414L16.706,17.916z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Cloudy.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Cloudy.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Cloudy();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Cloudy = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Cloudy.prototype */
{

  NAME: "draw2d.shape.icon.Cloudy",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.378,6.781c0.41,0.988,1.938,0.346,1.524-0.648C15.708,5.667,15.515,5.2,15.32,4.734c-0.289-0.695-0.875-3.233-2.042-2.747c-1.03,0.433-0.128,1.846,0.142,2.494C13.739,5.248,14.059,6.015,14.378,6.781M20.8,7.223c1.094,0.453,1.538-1.551,1.813-2.216c0.281-0.677,1.478-2.565,0.357-3.029c-1.092-0.453-1.537,1.548-1.813,2.216C20.876,4.872,19.68,6.757,20.8,7.223M18.137,6.692c1.183,0,0.829-2.019,0.829-2.742c0-0.732,0.383-2.935-0.829-2.935c-1.183,0-0.828,2.019-0.828,2.742C17.309,4.49,16.926,6.692,18.137,6.692M23.058,8.729c0.852,0.85,2.142-0.972,2.659-1.49c0.512-0.513,2.187-1.687,1.352-2.524c-0.834-0.836-2.013,0.843-2.522,1.353C24.028,6.585,22.198,7.874,23.058,8.729M24.565,10.986c0.448,1.091,2.183-0.01,2.849-0.286c0.676-0.28,2.858-0.771,2.394-1.89c-0.455-1.091-2.181,0.008-2.849,0.285C26.281,9.377,24.102,9.866,24.565,10.986M12.036,8.742c0.752,0.75,1.932-0.415,1.17-1.173c-0.253-0.347-0.646-0.645-0.949-0.946c-0.541-0.539-2.162-2.799-3.068-1.889c-0.79,0.791,0.586,1.755,1.083,2.25C10.859,7.57,11.447,8.156,12.036,8.742M29.365,17.397c-0.768-0.317-1.534-0.635-2.302-0.952c-0.646-0.268-2.07-1.169-2.495-0.135c-0.481,1.168,2.054,1.747,2.751,2.035c0.455,0.188,0.911,0.377,1.367,0.565C29.7,19.331,30.379,17.816,29.365,17.397M29.942,12.817c-0.83,0-1.66,0-2.49,0c-0.701,0-2.357-0.288-2.355,0.83c0,1.262,2.567,0.827,3.319,0.827c0.493,0,0.986,0,1.479-0.001C30.99,14.473,31.043,12.815,29.942,12.817M24.234,18.568c-0.673-0.673-1.773,0.189-1.281,1.007c-0.295-0.264-0.614-0.499-0.961-0.69c3.894-2.866,3.328-9.006-1.021-11.107c-2.024-0.978-4.481-0.828-6.368,0.394c-0.871,0.564-1.603,1.336-2.119,2.236c-0.262,0.456-0.468,0.943-0.612,1.449c-0.074,0.258-0.131,0.521-0.172,0.786c-0.083,0.534-0.109,0.553-0.553,0.871c-0.182-0.957-1.64-0.675-2.326-0.674c-0.815,0.001-1.963-0.217-2.752,0.046c-0.867,0.289-0.652,1.615,0.263,1.613c0.324,0.052,0.701-0.001,1.028-0.001c0.904-0.001,1.809-0.002,2.713-0.003c-0.308,0.352-0.496,0.969-0.94,0.77c-0.467-0.209-0.978-0.319-1.49-0.319c-0.951,0-1.877,0.375-2.561,1.036c-0.681,0.658-1.088,1.569-1.123,2.516c-0.944,0.31-1.791,0.891-2.421,1.658c-2.756,3.354-0.265,8.554,4.058,8.554v-0.002c3.597,0,7.194,0,10.792,0c1.341,0,2.843,0.167,4.168-0.113c3.652-0.772,5.361-5.21,3.133-8.229c0.548,0.547,1.096,1.094,1.644,1.641c0.183,0.183,0.364,0.424,0.575,0.574c0.552,0.552,1.524,0.066,1.403-0.713c-0.097-0.622-1.042-1.267-1.448-1.673C25.319,19.652,24.776,19.11,24.234,18.568M18.137,8.787c4.559,0.009,6.576,5.979,2.912,8.734c-0.637-3.505-4.161-5.824-7.629-5.03C13.943,10.367,15.852,8.792,18.137,8.787M22.895,24.08c-0.633,3.346-4.149,2.879-6.68,2.879c-3.017,0-6.033,0-9.049,0c-0.767,0-1.62,0.084-2.373-0.095c-2.274-0.538-3.416-3.242-2.172-5.235c0.678-1.087,1.568-1.19,2.626-1.67c0.604-0.273,0.456-0.807,0.456-1.331c0.002-0.597,0.284-1.169,0.756-1.533c0.787-0.608,1.943-0.497,2.611,0.234c1.098,1.205,1.96-1.346,2.507-1.893c2.025-2.025,5.475-1.708,7.068,0.684c0.344,0.516,0.581,1.102,0.693,1.712c0.097,0.529-0.115,1.341,0.188,1.796c0.291,0.47,0.943,0.463,1.397,0.68c0.508,0.23,0.963,0.591,1.304,1.034C22.834,22.125,23.064,23.107,22.895,24.08M6.906,9.917c0.881,0.364,1.763,0.727,2.644,1.091c0.353,0.146,0.707,0.292,1.06,0.437c0.997,0.412,1.637-1.119,0.642-1.526C10.47,9.441,9.456,9.177,8.609,8.828c-0.354-0.146-0.707-0.292-1.06-0.437C6.554,7.98,5.912,9.505,6.906,9.917");
  }
});

/***/ }),

/***/ "./src/shape/icon/Code.js":
/*!********************************!*\
  !*** ./src/shape/icon/Code.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Code();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Code = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Code.prototype */
{

  NAME: "draw2d.shape.icon.Code",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M8.982,7.107L0.322,15.77l8.661,8.662l3.15-3.15L6.621,15.77l5.511-5.511L8.982,7.107zM21.657,7.107l-3.148,3.151l5.511,5.511l-5.511,5.511l3.148,3.15l8.662-8.662L21.657,7.107z");
  }
});

/***/ }),

/***/ "./src/shape/icon/CodeTalk.js":
/*!************************************!*\
  !*** ./src/shape/icon/CodeTalk.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.CodeTalk();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.CodeTalk = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.CodeTalk.prototype */
{

  NAME: "draw2d.shape.icon.CodeTalk",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,4.938c-7.732,0-14,4.701-14,10.5c0,1.981,0.741,3.833,2.016,5.414L2,25.272l5.613-1.44c2.339,1.316,5.237,2.106,8.387,2.106c7.732,0,14-4.701,14-10.5S23.732,4.938,16,4.938zM13.704,19.47l-2.338,2.336l-6.43-6.431l6.429-6.432l2.339,2.341l-4.091,4.091L13.704,19.47zM20.775,21.803l-2.337-2.339l4.092-4.09l-4.092-4.092l2.337-2.339l6.43,6.426L20.775,21.803z");
  }
});

/***/ }),

/***/ "./src/shape/icon/CommandLine.js":
/*!***************************************!*\
  !*** ./src/shape/icon/CommandLine.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.CommandLine();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.CommandLine = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.CommandLine.prototype */
{

  NAME: "draw2d.shape.icon.CommandLine",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M2.021,9.748L2.021,9.748V9.746V9.748zM2.022,9.746l5.771,5.773l-5.772,5.771l2.122,2.123l7.894-7.895L4.143,7.623L2.022,9.746zM12.248,23.269h14.419V20.27H12.248V23.269zM16.583,17.019h10.084V14.02H16.583V17.019zM12.248,7.769v3.001h14.419V7.769H12.248z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Connect.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Connect.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Connect();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Connect = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Connect.prototype */
{

  NAME: "draw2d.shape.icon.Connect",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.06,13.719c-0.944-5.172-5.461-9.094-10.903-9.094v4c3.917,0.006,7.085,3.176,7.094,7.094c-0.009,3.917-3.177,7.085-7.094,7.093v4.002c5.442-0.004,9.959-3.926,10.903-9.096h4.69v-3.999H25.06zM20.375,15.719c0-3.435-2.784-6.219-6.219-6.219c-2.733,0-5.05,1.766-5.884,4.218H1.438v4.001h6.834c0.833,2.452,3.15,4.219,5.884,4.219C17.591,21.938,20.375,19.153,20.375,15.719z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Contract.js":
/*!************************************!*\
  !*** ./src/shape/icon/Contract.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Contract();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Contract = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Contract.prototype */
{

  NAME: "draw2d.shape.icon.Contract",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.083,18.895l-8.428-2.259l2.258,8.428l1.838-1.837l7.053,7.053l2.476-2.476l-7.053-7.053L25.083,18.895zM5.542,11.731l8.428,2.258l-2.258-8.428L9.874,7.398L3.196,0.72L0.72,3.196l6.678,6.678L5.542,11.731zM7.589,20.935l-6.87,6.869l2.476,2.476l6.869-6.869l1.858,1.857l2.258-8.428l-8.428,2.258L7.589,20.935zM23.412,10.064l6.867-6.87l-2.476-2.476l-6.868,6.869l-1.856-1.856l-2.258,8.428l8.428-2.259L23.412,10.064z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Crop.js":
/*!********************************!*\
  !*** ./src/shape/icon/Crop.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Crop();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Crop = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Crop.prototype */
{

  NAME: "draw2d.shape.icon.Crop",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.303,21.707V8.275l4.48-4.421l-2.021-2.048l-4.126,4.07H8.761V2.083H5.882v3.793H1.8v2.877h4.083v15.832h15.542v4.609h2.878v-4.609H29.2v-2.878H24.303zM19.72,8.753L8.761,19.565V8.753H19.72zM10.688,21.706l10.735-10.591l0.001,10.592L10.688,21.706z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Cross.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Cross.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Cross();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Cross = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Cross.prototype */
{

  NAME: "draw2d.shape.icon.Cross",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Cube.js":
/*!********************************!*\
  !*** ./src/shape/icon/Cube.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Cube();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Cube = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Cube.prototype */
{

  NAME: "draw2d.shape.icon.Cube",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.5,3.029l-10.8,6.235L4.7,21.735L15.5,27.971l10.8-6.235V9.265L15.5,3.029zM24.988,10.599L16,15.789v10.378c0,0.275-0.225,0.5-0.5,0.5s-0.5-0.225-0.5-0.5V15.786l-8.987-5.188c-0.239-0.138-0.321-0.444-0.183-0.683c0.138-0.238,0.444-0.321,0.683-0.183l8.988,5.189l8.988-5.189c0.238-0.138,0.545-0.055,0.684,0.184C25.309,10.155,25.227,10.461,24.988,10.599z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Customer.js":
/*!************************************!*\
  !*** ./src/shape/icon/Customer.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Customer();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Customer = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Customer.prototype */
{

  NAME: "draw2d.shape.icon.Customer",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.523,23.813c-0.518-0.51-6.795-2.938-7.934-3.396c-1.132-0.451-1.584-1.697-1.584-1.697s-0.51,0.282-0.51-0.51c0-0.793,0.51,0.51,1.021-2.548c0,0,1.414-0.397,1.133-3.68l-0.338,0.001c0,0,0.85-3.511,0-4.699c-0.854-1.188-1.188-1.981-3.062-2.548c-1.869-0.567-1.188-0.454-2.547-0.396c-1.359,0.057-2.492,0.793-2.492,1.188c0,0-0.849,0.057-1.188,0.397c-0.34,0.34-0.906,1.924-0.906,2.32s0.283,3.059,0.566,3.624l-0.337,0.112c-0.283,3.283,1.132,3.681,1.132,3.681c0.509,3.058,1.019,1.755,1.019,2.548c0,0.792-0.51,0.51-0.51,0.51s-0.452,1.246-1.584,1.697c-1.132,0.453-7.416,2.887-7.927,3.396c-0.511,0.521-0.453,2.896-0.453,2.896h12.036l0.878-3.459l-0.781-0.781l1.344-1.344l1.344,1.344l-0.781,0.781l0.879,3.459h12.035C28.977,26.709,29.039,24.332,28.523,23.813z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Db.js":
/*!******************************!*\
  !*** ./src/shape/icon/Db.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Db();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Db = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Db.prototype */
{

  NAME: "draw2d.shape.icon.Db",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.499,23.438c-3.846,0-7.708-0.987-9.534-3.117c-0.054,0.236-0.09,0.48-0.09,0.737v3.877c0,3.435,4.988,4.998,9.625,4.998s9.625-1.563,9.625-4.998v-3.877c0-0.258-0.036-0.501-0.09-0.737C23.209,22.451,19.347,23.438,15.499,23.438zM15.499,15.943c-3.846,0-7.708-0.987-9.533-3.117c-0.054,0.236-0.091,0.479-0.091,0.736v3.877c0,3.435,4.988,4.998,9.625,4.998s9.625-1.563,9.625-4.998v-3.877c0-0.257-0.036-0.501-0.09-0.737C23.209,14.956,19.347,15.943,15.499,15.943zM15.5,1.066c-4.637,0-9.625,1.565-9.625,5.001v3.876c0,3.435,4.988,4.998,9.625,4.998s9.625-1.563,9.625-4.998V6.067C25.125,2.632,20.137,1.066,15.5,1.066zM15.5,9.066c-4.211,0-7.625-1.343-7.625-3c0-1.656,3.414-3,7.625-3s7.625,1.344,7.625,3C23.125,7.724,19.711,9.066,15.5,9.066z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Detour.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Detour.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Detour();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Detour = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Detour.prototype */
{

  NAME: "draw2d.shape.icon.Detour",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M29.342,15.5l-7.556-4.363v2.614H18.75c-1.441-0.004-2.423,1.002-2.875,1.784c-0.735,1.222-1.056,2.561-1.441,3.522c-0.135,0.361-0.278,0.655-0.376,0.817c-1.626,0-0.998,0-2.768,0c-0.213-0.398-0.571-1.557-0.923-2.692c-0.237-0.676-0.5-1.381-1.013-2.071C8.878,14.43,7.89,13.726,6.75,13.75H2.812v3.499c0,0,0.358,0,1.031,0h2.741c0.008,0.013,0.018,0.028,0.029,0.046c0.291,0.401,0.634,1.663,1.031,2.888c0.218,0.623,0.455,1.262,0.92,1.897c0.417,0.614,1.319,1.293,2.383,1.293H11c2.25,0,1.249,0,3.374,0c0.696,0.01,1.371-0.286,1.809-0.657c1.439-1.338,1.608-2.886,2.13-4.127c0.218-0.608,0.453-1.115,0.605-1.314c0.006-0.01,0.012-0.018,0.018-0.025h2.85v2.614L29.342,15.5zM10.173,14.539c0.568,0.76,0.874,1.559,1.137,2.311c0.04,0.128,0.082,0.264,0.125,0.399h2.58c0.246-0.697,0.553-1.479,1.005-2.228c0.252-0.438,0.621-0.887,1.08-1.272H9.43C9.735,14.003,9.99,14.277,10.173,14.539z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Diagram.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Diagram.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Diagram();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Diagram = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Diagram.prototype */
{

  NAME: "draw2d.shape.icon.Diagram",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super((0, _extend2.default)({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M6.812,17.202l7.396-3.665v-2.164h-0.834c-0.414,0-0.808-0.084-1.167-0.237v1.159l-7.396,3.667v2.912h2V17.202zM26.561,18.875v-2.913l-7.396-3.666v-1.158c-0.358,0.152-0.753,0.236-1.166,0.236h-0.832l-0.001,2.164l7.396,3.666v1.672H26.561zM16.688,18.875v-7.501h-2v7.501H16.688zM27.875,19.875H23.25c-1.104,0-2,0.896-2,2V26.5c0,1.104,0.896,2,2,2h4.625c1.104,0,2-0.896,2-2v-4.625C29.875,20.771,28.979,19.875,27.875,19.875zM8.125,19.875H3.5c-1.104,0-2,0.896-2,2V26.5c0,1.104,0.896,2,2,2h4.625c1.104,0,2-0.896,2-2v-4.625C10.125,20.771,9.229,19.875,8.125,19.875zM13.375,10.375H18c1.104,0,2-0.896,2-2V3.75c0-1.104-0.896-2-2-2h-4.625c-1.104,0-2,0.896-2,2v4.625C11.375,9.479,12.271,10.375,13.375,10.375zM18,19.875h-4.625c-1.104,0-2,0.896-2,2V26.5c0,1.104,0.896,2,2,2H18c1.104,0,2-0.896,2-2v-4.625C20,20.771,19.104,19.875,18,19.875z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Disconnect.js":
/*!**************************************!*\
  !*** ./src/shape/icon/Disconnect.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Disconnect();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Disconnect = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Disconnect.prototype */
{

  NAME: "draw2d.shape.icon.Disconnect",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M9.219,9.5c-2.733,0-5.05,1.766-5.884,4.218H1.438v4.001h1.897c0.833,2.452,3.15,4.219,5.884,4.219c3.435,0,6.219-2.784,6.219-6.219S12.653,9.5,9.219,9.5zM27.685,13.719c-0.944-5.172-5.461-9.094-10.903-9.094v4c3.917,0.006,7.085,3.176,7.094,7.094c-0.009,3.917-3.177,7.085-7.094,7.093v4.002c5.442-0.004,9.959-3.926,10.903-9.096h2.065v-3.999H27.685z");
  }
});

/***/ }),

/***/ "./src/shape/icon/DockBottom.js":
/*!**************************************!*\
  !*** ./src/shape/icon/DockBottom.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.DockBottom();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.DockBottom = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.DockBottom.prototype */
{

  NAME: "draw2d.shape.icon.DockBottom",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M3.083,7.333v16.334h24.833V7.333H3.083zM24.915,16.833H6.083v-6.501h18.833L24.915,16.833L24.915,16.833z");
  }
});

/***/ }),

/***/ "./src/shape/icon/DockLeft.js":
/*!************************************!*\
  !*** ./src/shape/icon/DockLeft.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.DockLeft();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.DockLeft = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.DockLeft.prototype */
{

  NAME: "draw2d.shape.icon.DockLeft",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M3.084,7.333v16.334h24.832V7.333H3.084z M11.667,10.332h13.251v10.336H11.667V10.332z");
  }
});

/***/ }),

/***/ "./src/shape/icon/DockRight.js":
/*!*************************************!*\
  !*** ./src/shape/icon/DockRight.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.DockRight();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.DockRight = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.DockRight.prototype */
{

  NAME: "draw2d.shape.icon.DockRight",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M3.083,7.333v16.334h24.833V7.333H3.083z M19.333,20.668H6.083V10.332h13.25V20.668z");
  }
});

/***/ }),

/***/ "./src/shape/icon/DockTop.js":
/*!***********************************!*\
  !*** ./src/shape/icon/DockTop.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.DockTop();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.DockTop = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.DockTop.prototype */
{

  NAME: "draw2d.shape.icon.DockTop",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.916,23.667V7.333H3.083v16.334H27.916zM24.915,20.668H6.083v-6.501h18.833L24.915,20.668L24.915,20.668z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Download.js":
/*!************************************!*\
  !*** ./src/shape/icon/Download.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Download();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Download = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Download.prototype */
{

  NAME: "draw2d.shape.icon.Download",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM16,28.792c-1.549,0-2.806-1.256-2.806-2.806s1.256-2.806,2.806-2.806c1.55,0,2.806,1.256,2.806,2.806S17.55,28.792,16,28.792zM16,21.087l-7.858-6.562h3.469V5.747h8.779v8.778h3.468L16,21.087z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Dry.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Dry.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Dry();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Dry = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Dry.prototype */
{

  NAME: "draw2d.shape.icon.Dry",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.784,26.991c0,1.238-1.329,1.696-1.835,1.696c-0.504,0-1.536-0.413-1.65-1.812c0-0.354-0.288-0.642-0.644-0.642c-0.354,0-0.641,0.287-0.641,0.642c0.045,1.056,0.756,3.052,2.935,3.052c2.432,0,3.166-1.882,3.166-3.144v-8.176l-1.328-0.024C14.787,18.584,14.784,25.889,14.784,26.991zM15.584,9.804c-6.807,0-11.084,4.859-11.587,8.326c0.636-0.913,1.694-1.51,2.89-1.51c1.197,0,2.22,0.582,2.855,1.495c0.638-0.904,1.69-1.495,2.88-1.495c1.2,0,2.26,0.6,2.896,1.517c0.635-0.917,1.83-1.517,3.03-1.517c1.19,0,2.241,0.591,2.879,1.495c0.636-0.913,1.659-1.495,2.855-1.495c1.197,0,2.254,0.597,2.89,1.51C26.669,14.663,22.393,9.804,15.584,9.804zM14.733,7.125v2.081h1.323V7.125c0-0.365-0.296-0.661-0.661-0.661C15.029,6.464,14.733,6.76,14.733,7.125zM7.562,6.015c0.54,0.312,1.229,0.128,1.54-0.412c0.109-0.189,0.157-0.398,0.15-0.602L9.251,3.09L7.59,4.047c-0.178,0.095-0.333,0.24-0.441,0.428C6.837,5.015,7.022,5.703,7.562,6.015zM5.572,11.717c0.109-0.19,0.158-0.398,0.151-0.602L5.721,9.203l-1.66,0.957c-0.178,0.096-0.333,0.241-0.441,0.429c-0.311,0.539-0.127,1.229,0.413,1.539C4.571,12.44,5.26,12.256,5.572,11.717zM10.523,9.355c0.539,0.312,1.229,0.126,1.541-0.412c0.109-0.189,0.156-0.398,0.15-0.603L12.214,6.43l-1.662,0.956c-0.177,0.097-0.332,0.241-0.441,0.43C9.799,8.354,9.984,9.044,10.523,9.355zM15.251,3.998c0.539,0.312,1.229,0.126,1.54-0.412c0.11-0.19,0.157-0.398,0.15-0.603L16.94,1.072l-1.661,0.956c-0.178,0.097-0.332,0.242-0.441,0.43C14.526,2.998,14.711,3.687,15.251,3.998zM19.348,8.914c0.539,0.312,1.228,0.128,1.541-0.412c0.109-0.189,0.156-0.398,0.149-0.602h-0.001V5.988l-1.661,0.957c-0.178,0.096-0.332,0.241-0.441,0.429C18.623,7.914,18.809,8.603,19.348,8.914zM23.633,5.196c0.54,0.312,1.23,0.126,1.542-0.413c0.109-0.189,0.156-0.398,0.149-0.602h-0.001V2.27l-1.662,0.957c-0.177,0.096-0.331,0.24-0.44,0.43C22.909,4.195,23.094,4.885,23.633,5.196zM27.528,8.51l-1.659,0.956c-0.18,0.097-0.334,0.242-0.443,0.43c-0.312,0.539-0.127,1.229,0.413,1.54c0.539,0.312,1.229,0.127,1.541-0.412c0.109-0.19,0.158-0.398,0.151-0.603L27.528,8.51z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Employee.js":
/*!************************************!*\
  !*** ./src/shape/icon/Employee.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Employee();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Employee = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Employee.prototype */
{

  NAME: "draw2d.shape.icon.Employee",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.523,23.813c-0.518-0.51-6.795-2.938-7.934-3.396c-1.132-0.451-1.584-1.697-1.584-1.697s-0.51,0.282-0.51-0.51c0-0.793,0.51,0.51,1.021-2.548c0,0,1.414-0.397,1.133-3.68l-0.338,0.001c0,0,0.85-3.511,0-4.699c-0.854-1.188-1.188-1.981-3.062-2.548c-1.869-0.567-1.188-0.454-2.547-0.396c-1.359,0.057-2.492,0.793-2.492,1.188c0,0-0.849,0.057-1.188,0.397c-0.34,0.34-0.906,1.924-0.906,2.32s0.283,3.059,0.566,3.624l-0.337,0.112c-0.283,3.283,1.132,3.681,1.132,3.681c0.509,3.058,1.019,1.755,1.019,2.548c0,0.792-0.51,0.51-0.51,0.51s-0.452,1.246-1.584,1.697c-1.132,0.453-7.416,2.887-7.927,3.396c-0.511,0.521-0.453,2.896-0.453,2.896h26.954C28.977,26.709,29.039,24.332,28.523,23.813zM22.188,26.062h-4.562v-1.25h4.562V26.062z");
  }
});

/***/ }),

/***/ "./src/shape/icon/End.js":
/*!*******************************!*\
  !*** ./src/shape/icon/End.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.End();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.End = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.End.prototype */
{

  NAME: "draw2d.shape.icon.End",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.167,5.5,21.167,13.681,6.684,5.318,6.684,25.682,21.167,17.318,21.167,25.5,25.5,25.5,25.5,5.5z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Ethernet.js":
/*!************************************!*\
  !*** ./src/shape/icon/Ethernet.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Ethernet();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Ethernet = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Ethernet.prototype */
{

  NAME: "draw2d.shape.icon.Ethernet",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.5,8.5v3.168l3.832,3.832L22.5,19.332V22.5l7-7L22.5,8.5zM8.5,22.5v-3.168L4.667,15.5L8.5,11.668V8.5l-7,7L8.5,22.5zM15.5,14.101c-0.928,0-1.68,0.751-1.68,1.68c0,0.927,0.752,1.681,1.68,1.681c0.927,0,1.68-0.754,1.68-1.681C17.18,14.852,16.427,14.101,15.5,14.101zM10.46,14.101c-0.928,0-1.68,0.751-1.68,1.68c0,0.927,0.752,1.681,1.68,1.681s1.68-0.754,1.68-1.681C12.14,14.852,11.388,14.101,10.46,14.101zM20.541,14.101c-0.928,0-1.682,0.751-1.682,1.68c0,0.927,0.754,1.681,1.682,1.681s1.68-0.754,1.68-1.681C22.221,14.852,21.469,14.101,20.541,14.101z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Exchange.js":
/*!************************************!*\
  !*** ./src/shape/icon/Exchange.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Exchange();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Exchange = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Exchange.prototype */
{

  NAME: "draw2d.shape.icon.Exchange",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.786,12.876l7.556-4.363l-7.556-4.363v2.598H2.813v3.5h18.973V12.876zM10.368,18.124l-7.556,4.362l7.556,4.362V24.25h18.974v-3.501H10.368V18.124z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Expand.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Expand.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Expand();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Expand = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Expand.prototype */
{

  NAME: "draw2d.shape.icon.Expand",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.545,23.328,17.918,15.623,25.534,8.007,27.391,9.864,29.649,1.436,21.222,3.694,23.058,5.53,15.455,13.134,7.942,5.543,9.809,3.696,1.393,1.394,3.608,9.833,5.456,8.005,12.98,15.608,5.465,23.123,3.609,21.268,1.351,29.695,9.779,27.438,7.941,25.6,15.443,18.098,23.057,25.791,21.19,27.638,29.606,29.939,27.393,21.5z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Export.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Export.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Export();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Export = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Export.prototype */
{

  NAME: "draw2d.shape.icon.Export",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.086,20.904c-1.805,3.113-5.163,5.212-9.023,5.219c-5.766-0.01-10.427-4.672-10.438-10.435C4.636,9.922,9.297,5.261,15.063,5.25c3.859,0.007,7.216,2.105,9.022,5.218l3.962,2.284l0.143,0.082C26.879,6.784,21.504,2.25,15.063,2.248C7.64,2.25,1.625,8.265,1.624,15.688c0.002,7.42,6.017,13.435,13.439,13.437c6.442-0.002,11.819-4.538,13.127-10.589l-0.141,0.081L24.086,20.904zM28.4,15.688l-7.15-4.129v2.297H10.275v3.661H21.25v2.297L28.4,15.688z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Fave.js":
/*!********************************!*\
  !*** ./src/shape/icon/Fave.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Fave();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Fave = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Fave.prototype */
{

  NAME: "draw2d.shape.icon.Fave",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.132,7.971c-2.203-2.205-5.916-2.098-8.25,0.235L15.5,8.588l-0.382-0.382c-2.334-2.333-6.047-2.44-8.25-0.235c-2.204,2.203-2.098,5.916,0.235,8.249l8.396,8.396l8.396-8.396C26.229,13.887,26.336,10.174,24.132,7.971z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Feed.js":
/*!********************************!*\
  !*** ./src/shape/icon/Feed.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Feed();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Feed = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Feed.prototype */
{

  NAME: "draw2d.shape.icon.Feed",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.135,16.762c3.078,0,5.972,1.205,8.146,3.391c2.179,2.187,3.377,5.101,3.377,8.202h4.745c0-9.008-7.299-16.335-16.269-16.335V16.762zM4.141,8.354c10.973,0,19.898,8.975,19.898,20.006h4.743c0-13.646-11.054-24.749-24.642-24.749V8.354zM10.701,25.045c0,1.815-1.471,3.287-3.285,3.287s-3.285-1.472-3.285-3.287c0-1.813,1.471-3.285,3.285-3.285S10.701,23.231,10.701,25.045z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Ff.js":
/*!******************************!*\
  !*** ./src/shape/icon/Ff.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Ff();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Ff = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Ff.prototype */
{

  NAME: "draw2d.shape.icon.Ff",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.5,15.5,15.2,9.552,15.2,15.153,5.5,9.552,5.5,21.447,15.2,15.847,15.2,21.447z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Firefox.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Firefox.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Firefox();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Firefox = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Firefox.prototype */
{

  NAME: "draw2d.shape.icon.Firefox",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.4,22.469c0.479-0.964,0.851-1.991,1.095-3.066c0.953-3.661,0.666-6.854,0.666-6.854l-0.327,2.104c0,0-0.469-3.896-1.044-5.353c-0.881-2.231-1.273-2.214-1.274-2.21c0.542,1.379,0.494,2.169,0.483,2.288c-0.01-0.016-0.019-0.032-0.027-0.047c-0.131-0.324-0.797-1.819-2.225-2.878c-2.502-2.481-5.943-4.014-9.745-4.015c-4.056,0-7.705,1.745-10.238,4.525C5.444,6.5,5.183,5.938,5.159,5.317c0,0-0.002,0.002-0.006,0.005c0-0.011-0.003-0.021-0.003-0.031c0,0-1.61,1.247-1.436,4.612c-0.299,0.574-0.56,1.172-0.777,1.791c-0.375,0.817-0.75,2.004-1.059,3.746c0,0,0.133-0.422,0.399-0.988c-0.064,0.482-0.103,0.971-0.116,1.467c-0.09,0.845-0.118,1.865-0.039,3.088c0,0,0.032-0.406,0.136-1.021c0.834,6.854,6.667,12.165,13.743,12.165l0,0c1.86,0,3.636-0.37,5.256-1.036C24.938,27.771,27.116,25.196,28.4,22.469zM16.002,3.356c2.446,0,4.73,0.68,6.68,1.86c-2.274-0.528-3.433-0.261-3.423-0.248c0.013,0.015,3.384,0.589,3.981,1.411c0,0-1.431,0-2.856,0.41c-0.065,0.019,5.242,0.663,6.327,5.966c0,0-0.582-1.213-1.301-1.42c0.473,1.439,0.351,4.17-0.1,5.528c-0.058,0.174-0.118-0.755-1.004-1.155c0.284,2.037-0.018,5.268-1.432,6.158c-0.109,0.07,0.887-3.189,0.201-1.93c-4.093,6.276-8.959,2.539-10.934,1.208c1.585,0.388,3.267,0.108,4.242-0.559c0.982-0.672,1.564-1.162,2.087-1.047c0.522,0.117,0.87-0.407,0.464-0.872c-0.405-0.466-1.392-1.105-2.725-0.757c-0.94,0.247-2.107,1.287-3.886,0.233c-1.518-0.899-1.507-1.63-1.507-2.095c0-0.366,0.257-0.88,0.734-1.028c0.58,0.062,1.044,0.214,1.537,0.466c0.005-0.135,0.006-0.315-0.001-0.519c0.039-0.077,0.015-0.311-0.047-0.596c-0.036-0.287-0.097-0.582-0.19-0.851c0.01-0.002,0.017-0.007,0.021-0.021c0.076-0.344,2.147-1.544,2.299-1.659c0.153-0.114,0.55-0.378,0.506-1.183c-0.015-0.265-0.058-0.294-2.232-0.286c-0.917,0.003-1.425-0.894-1.589-1.245c0.222-1.231,0.863-2.11,1.919-2.704c0.02-0.011,0.015-0.021-0.008-0.027c0.219-0.127-2.524-0.006-3.76,1.604C9.674,8.045,9.219,7.95,8.71,7.95c-0.638,0-1.139,0.07-1.603,0.187c-0.05,0.013-0.122,0.011-0.208-0.001C6.769,8.04,6.575,7.88,6.365,7.672c0.161-0.18,0.324-0.356,0.495-0.526C9.201,4.804,12.43,3.357,16.002,3.356z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Flag.js":
/*!********************************!*\
  !*** ./src/shape/icon/Flag.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Flag();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Flag = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Flag.prototype */
{

  NAME: "draw2d.shape.icon.Flag",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M26.04,9.508c0.138-0.533,0.15-1.407,0.028-1.943l-0.404-1.771c-0.122-0.536-0.665-1.052-1.207-1.146l-3.723-0.643c-0.542-0.094-1.429-0.091-1.97,0.007l-4.033,0.726c-0.542,0.098-1.429,0.108-1.973,0.023L8.812,4.146C8.817,4.165,8.826,4.182,8.83,4.201l2.701,12.831l1.236,0.214c0.542,0.094,1.428,0.09,1.97-0.007l4.032-0.727c0.541-0.097,1.429-0.107,1.973-0.022l4.329,0.675c0.544,0.085,0.906-0.288,0.807-0.829l-0.485-2.625c-0.1-0.541-0.069-1.419,0.068-1.952L26.04,9.508zM6.667,3.636C6.126,3.75,5.78,4.279,5.894,4.819l5.763,27.378H13.7L7.852,4.409C7.736,3.867,7.207,3.521,6.667,3.636z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Flickr.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Flickr.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Flickr();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Flickr = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Flickr.prototype */
{

  NAME: "draw2d.shape.icon.Flickr",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.77,8.895c-2.379,0-4.479,1.174-5.77,2.969c-1.289-1.795-3.39-2.969-5.77-2.969c-3.924,0-7.105,3.181-7.105,7.105c0,3.924,3.181,7.105,7.105,7.105c2.379,0,4.48-1.175,5.77-2.97c1.29,1.795,3.391,2.97,5.77,2.97c3.925,0,7.105-3.182,7.105-7.105C28.875,12.075,25.694,8.895,21.77,8.895zM21.769,21.822c-3.211,0-5.821-2.61-5.821-5.821c0-3.213,2.61-5.824,5.821-5.824c3.213,0,5.824,2.611,5.824,5.824C27.593,19.212,24.981,21.822,21.769,21.822z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Folder.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Folder.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Folder();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Folder = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Folder.prototype */
{

  NAME: "draw2d.shape.icon.Folder",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.625,26.75h-26.5V8.375h1.124c1.751,0,0.748-3.125,3-3.125c3.215,0,1.912,0,5.126,0c2.251,0,1.251,3.125,3.001,3.125h14.25V26.75z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Font.js":
/*!********************************!*\
  !*** ./src/shape/icon/Font.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Font();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Font = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Font.prototype */
{

  NAME: "draw2d.shape.icon.Font",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.255,19.327l-1.017,0.131c-0.609,0.081-1.067,0.208-1.375,0.382c-0.521,0.293-0.779,0.76-0.779,1.398c0,0.484,0.178,0.867,0.532,1.146c0.354,0.28,0.774,0.421,1.262,0.421c0.593,0,1.164-0.138,1.72-0.412c0.938-0.453,1.4-1.188,1.4-2.229v-1.354c-0.205,0.131-0.469,0.229-0.792,0.328C22.883,19.229,22.564,19.29,22.255,19.327zM8.036,18.273h4.309l-2.113-6.063L8.036,18.273zM28.167,7.75H3.168c-0.552,0-1,0.448-1,1v16.583c0,0.553,0.448,1,1,1h24.999c0.554,0,1-0.447,1-1V8.75C29.167,8.198,28.721,7.75,28.167,7.75zM14.305,23.896l-1.433-4.109H7.488L6,23.896H4.094L9.262,10.17h2.099l4.981,13.727H14.305L14.305,23.896zM26.792,23.943c-0.263,0.074-0.461,0.121-0.599,0.141c-0.137,0.02-0.323,0.027-0.562,0.027c-0.579,0-0.999-0.204-1.261-0.615c-0.138-0.219-0.231-0.525-0.29-0.926c-0.344,0.449-0.834,0.839-1.477,1.169c-0.646,0.329-1.354,0.493-2.121,0.493c-0.928,0-1.688-0.28-2.273-0.844c-0.589-0.562-0.884-1.271-0.884-2.113c0-0.928,0.29-1.646,0.868-2.155c0.578-0.511,1.34-0.824,2.279-0.942l2.682-0.336c0.388-0.05,0.646-0.211,0.775-0.484c0.063-0.146,0.104-0.354,0.104-0.646c0-0.575-0.203-0.993-0.604-1.252c-0.408-0.26-0.99-0.389-1.748-0.389c-0.877,0-1.5,0.238-1.865,0.713c-0.205,0.263-0.34,0.654-0.399,1.174H17.85c0.031-1.237,0.438-2.097,1.199-2.582c0.77-0.484,1.659-0.726,2.674-0.726c1.176,0,2.131,0.225,2.864,0.673c0.729,0.448,1.093,1.146,1.093,2.093v5.766c0,0.176,0.035,0.313,0.106,0.422c0.071,0.104,0.223,0.156,0.452,0.156c0.076,0,0.16-0.005,0.254-0.015c0.093-0.011,0.191-0.021,0.299-0.041L26.792,23.943L26.792,23.943z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Fork.js":
/*!********************************!*\
  !*** ./src/shape/icon/Fork.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Fork();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Fork = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Fork.prototype */
{

  NAME: "draw2d.shape.icon.Fork",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M13.741,10.249h8.045v2.627l7.556-4.363l-7.556-4.363v2.598H9.826C11.369,7.612,12.616,8.922,13.741,10.249zM21.786,20.654c-0.618-0.195-1.407-0.703-2.291-1.587c-1.79-1.756-3.712-4.675-5.731-7.227c-2.049-2.486-4.159-4.972-7.451-5.091h-3.5v3.5h3.5c0.656-0.027,1.683,0.486,2.879,1.683c1.788,1.753,3.712,4.674,5.731,7.226c1.921,2.331,3.907,4.639,6.863,5.016v2.702l7.556-4.362l-7.556-4.362V20.654z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ForkAlt.js":
/*!***********************************!*\
  !*** ./src/shape/icon/ForkAlt.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ForkAlt();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ForkAlt = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ForkAlt.prototype */
{

  NAME: "draw2d.shape.icon.ForkAlt",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.786,12.873l7.556-4.361l-7.556-4.362v2.701c-2.929,0.374-4.905,2.64-6.809,4.952c0.545,0.703,1.08,1.418,1.604,2.127c0.192,0.26,0.383,0.514,0.573,0.77c0.802-1.043,1.584-1.999,2.341-2.74c0.884-0.885,1.673-1.393,2.291-1.588V12.873zM17.661,17.006c-1.893-2.371-3.815-5.354-6.009-7.537c-1.461-1.428-3.155-2.664-5.34-2.693h-3.5v3.5h3.5c0.971-0.119,2.845,1.333,4.712,3.771c1.895,2.371,3.815,5.354,6.011,7.537c1.326,1.297,2.847,2.426,4.751,2.645v2.646l7.556-4.363l-7.556-4.362v2.535C20.746,20.346,19.205,19.022,17.661,17.006z");
  }
});

/***/ }),

/***/ "./src/shape/icon/FullCube.js":
/*!************************************!*\
  !*** ./src/shape/icon/FullCube.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.FullCube();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.FullCube = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.FullCube.prototype */
{

  NAME: "draw2d.shape.icon.FullCube",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.5,3.029l-10.8,6.235L4.7,21.735L15.5,27.971l10.8-6.235V9.265L15.5,3.029zM15.5,7.029l6.327,3.652L15.5,14.334l-6.326-3.652L15.5,7.029zM24.988,10.599L16,15.789v10.378c0,0.275-0.225,0.5-0.5,0.5s-0.5-0.225-0.5-0.5V15.786l-8.987-5.188c-0.239-0.138-0.321-0.444-0.183-0.683c0.138-0.238,0.444-0.321,0.683-0.183l8.988,5.189l8.988-5.189c0.238-0.138,0.545-0.055,0.684,0.184C25.309,10.155,25.227,10.461,24.988,10.599z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Future.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Future.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Future();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Future = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Future.prototype */
{

  NAME: "draw2d.shape.icon.Future",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M17.001,15.5l-0.5-7.876c0-0.552-0.448-1-1-1c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96c-0.478,0.277-0.642,0.89-0.365,1.365c0.275,0.479,0.889,0.644,1.365,0.367l3.305-1.677C15.39,16.99,15.444,17,15.501,17C16.329,17,17.001,16.329,17.001,15.5zM18.939,21.455c-0.479,0.277-0.644,0.889-0.366,1.367c0.274,0.477,0.888,0.643,1.366,0.365c0.478-0.275,0.642-0.89,0.365-1.365C20.027,21.344,19.417,21.18,18.939,21.455zM19.938,7.813c-0.477-0.276-1.09-0.111-1.364,0.366c-0.275,0.48-0.111,1.091,0.366,1.367c0.477,0.276,1.088,0.112,1.365-0.366C20.581,8.702,20.418,8.089,19.938,7.813zM21.823,20.305c0.477,0.274,1.089,0.112,1.364-0.365c0.276-0.479,0.112-1.092-0.364-1.367c-0.48-0.275-1.093-0.111-1.367,0.365C21.182,19.416,21.344,20.029,21.823,20.305zM22.822,12.428c0.478-0.275,0.643-0.888,0.365-1.366c-0.274-0.478-0.89-0.642-1.365-0.366c-0.479,0.278-0.643,0.89-0.366,1.367S22.344,12.705,22.822,12.428zM24.378,15.5c0-0.551-0.448-1-1-1c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1C23.93,16.5,24.378,16.053,24.378,15.5zM9.546,12.062c0.275-0.478,0.111-1.089-0.366-1.366c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366C8.658,12.704,9.269,12.541,9.546,12.062zM6.624,15.5c0,0.553,0.449,1,1,1c0.552,0,1-0.447,1.001-1c-0.001-0.552-0.448-0.999-1.001-1C7.071,14.5,6.624,14.948,6.624,15.5zM9.179,20.305c0.479-0.275,0.643-0.888,0.367-1.367c-0.276-0.477-0.888-0.641-1.367-0.365c-0.478,0.277-0.642,0.889-0.365,1.367C8.089,20.418,8.703,20.58,9.179,20.305zM12.062,9.545c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,9.658,11.584,9.822,12.062,9.545zM14.501,23.377c0,0.553,0.448,1,1,1c0.552,0,1-0.447,1-1s-0.448-1-1-1C14.949,22.377,14.501,22.824,14.501,23.377zM10.696,21.822c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.276,1.091,0.11,1.365-0.365c0.277-0.479,0.113-1.09-0.365-1.367C11.584,21.18,10.973,21.344,10.696,21.822zM28.674,14.087l-3.27-1.186c0.291,1.105,0.41,2.274,0.309,3.478c-0.492,5.639-5.449,9.809-11.091,9.333c-5.639-0.495-9.809-5.45-9.333-11.09c0.494-5.641,5.449-9.812,11.089-9.335c2.428,0.212,4.567,1.266,6.194,2.833l-1.637,1.377l7.031,2.548l-1.309-7.364l-1.771,1.492c-2.133-2.151-4.996-3.597-8.25-3.877C9.346,1.67,2.926,7.072,2.297,14.364c-0.625,7.291,4.777,13.71,12.066,14.339c7.293,0.625,13.713-4.776,14.342-12.066C28.779,15.771,28.762,14.919,28.674,14.087z");
  }
});

/***/ }),

/***/ "./src/shape/icon/GRaphael.js":
/*!************************************!*\
  !*** ./src/shape/icon/GRaphael.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.GRaphael();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.GRaphael = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.GRaphael.prototype */
{

  NAME: "draw2d.shape.icon.GRaphael",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.833,15.709c0-1.477-0.574-2.862-1.617-3.904l-7.002-7.001l-0.003,0.002c-1.027-1.03-2.445-1.62-3.9-1.62c-1.455,0-2.871,0.59-3.9,1.621l-0.002-0.002l-7,7C4.376,12.836,3.79,14.25,3.79,15.709s0.586,2.873,1.619,3.902l6.312,6.312c0.253,0.285,0.519,0.556,0.8,0.8c1.049,0.989,2.463,1.534,3.908,1.51c1.417-0.021,2.783-0.604,3.785-1.604l6.812-6.812c0.021-0.021,0.035-0.029,0.062-0.062l0.143-0.146c0.271-0.271,0.484-0.562,0.725-0.86l-0.012-0.002C28.516,17.85,28.833,16.805,28.833,15.709zM18.77,25.17c-1.121,1.119-2.917,1.336-4.271,0.514l0.002-0.002c-0.213-0.145-0.414-0.303-0.61-0.471c-0.016-0.016-7.04-7.041-7.04-7.041c-1.34-1.34-1.342-3.584,0-4.92l7-6.998c1.121-1.121,2.908-1.338,4.259-0.512v0.002c0.213,0.141,0.414,0.299,0.604,0.467c0.021,0.016,7.053,7.043,7.053,7.043c0.396,0.388,0.655,0.852,0.818,1.348l-2.607,0.006c-0.537-3.754-3.769-6.641-7.667-6.641c-4.277,0-7.744,3.468-7.745,7.746c0.001,4.277,3.468,7.744,7.745,7.744c3.917,0,7.156-2.91,7.668-6.688l2.638-0.021c-0.16,0.521-0.441,1.02-0.849,1.412L18.77,25.17zM16.312,16.789c0.002,0,0.002,0,0.004,0l5.476-0.02c-0.5,2.562-2.76,4.518-5.48,4.521c-3.084-0.004-5.578-2.5-5.584-5.582c0.006-3.084,2.5-5.58,5.584-5.584c2.708,0.004,4.959,1.929,5.472,4.484l-5.476,0.018c-0.596,0.002-1.078,0.488-1.076,1.084C15.233,16.308,15.715,16.789,16.312,16.789z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Gear.js":
/*!********************************!*\
  !*** ./src/shape/icon/Gear.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Gear();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Gear = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Gear.prototype */
{

  NAME: "draw2d.shape.icon.Gear",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M26.974,16.514l3.765-1.991c-0.074-0.738-0.217-1.454-0.396-2.157l-4.182-0.579c-0.362-0.872-0.84-1.681-1.402-2.423l1.594-3.921c-0.524-0.511-1.09-0.977-1.686-1.406l-3.551,2.229c-0.833-0.438-1.73-0.77-2.672-0.984l-1.283-3.976c-0.364-0.027-0.728-0.056-1.099-0.056s-0.734,0.028-1.099,0.056l-1.271,3.941c-0.967,0.207-1.884,0.543-2.738,0.986L7.458,4.037C6.863,4.466,6.297,4.932,5.773,5.443l1.55,3.812c-0.604,0.775-1.11,1.629-1.49,2.55l-4.05,0.56c-0.178,0.703-0.322,1.418-0.395,2.157l3.635,1.923c0.041,1.013,0.209,1.994,0.506,2.918l-2.742,3.032c0.319,0.661,0.674,1.303,1.085,1.905l4.037-0.867c0.662,0.72,1.416,1.351,2.248,1.873l-0.153,4.131c0.663,0.299,1.352,0.549,2.062,0.749l2.554-3.283C15.073,26.961,15.532,27,16,27c0.507,0,1.003-0.046,1.491-0.113l2.567,3.301c0.711-0.2,1.399-0.45,2.062-0.749l-0.156-4.205c0.793-0.513,1.512-1.127,2.146-1.821l4.142,0.889c0.411-0.602,0.766-1.243,1.085-1.905l-2.831-3.131C26.778,18.391,26.93,17.467,26.974,16.514zM20.717,21.297l-1.785,1.162l-1.098-1.687c-0.571,0.22-1.186,0.353-1.834,0.353c-2.831,0-5.125-2.295-5.125-5.125c0-2.831,2.294-5.125,5.125-5.125c2.83,0,5.125,2.294,5.125,5.125c0,1.414-0.573,2.693-1.499,3.621L20.717,21.297z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Gear2.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Gear2.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Gear2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Gear2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Gear2.prototype */
{

  NAME: "draw2d.shape.icon.Gear2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M17.047,27.945c-0.34,0.032-0.688,0.054-1.046,0.054l0,0c-0.32,0-0.631-0.017-0.934-0.043l0,0l-2.626,3.375l-0.646-0.183c-0.758-0.213-1.494-0.48-2.202-0.8l0,0L8.979,30.07l0.158-4.24c-0.558-0.39-1.079-0.825-1.561-1.302l0,0L3.424,25.42l-0.379-0.557c-0.445-0.654-0.824-1.339-1.16-2.032l0,0l-0.292-0.605l2.819-3.12c-0.176-0.661-0.293-1.343-0.353-2.038l0,0l-3.736-1.975l0.068-0.669c0.08-0.801,0.235-1.567,0.42-2.303l0,0l0.165-0.653l4.167-0.577c0.297-0.627,0.647-1.221,1.041-1.78l0,0l-1.59-3.914l0.48-0.47c0.564-0.55,1.168-1.048,1.798-1.503l0,0l0.546-0.394l3.597,2.259c0.606-0.279,1.24-0.509,1.897-0.685l0,0l1.304-4.046l0.672-0.051c0.362-0.027,0.751-0.058,1.174-0.058l0,0c0.422,0,0.81,0.031,1.172,0.058l0,0l0.672,0.051l1.318,4.088c0.632,0.176,1.244,0.401,1.831,0.674l0,0l3.647-2.291l0.548,0.394c0.63,0.455,1.235,0.954,1.798,1.501l0,0l0.482,0.47l-1.639,4.031c0.357,0.519,0.679,1.068,0.954,1.646l0,0l4.297,0.595l0.167,0.653c0.188,0.735,0.342,1.501,0.42,2.303l0,0l0.068,0.669l-3.866,2.044c-0.058,0.634-0.161,1.258-0.315,1.866l0,0l2.913,3.218l-0.293,0.608c-0.335,0.695-0.712,1.382-1.159,2.034l0,0l-0.379,0.555l-4.255-0.912c-0.451,0.451-0.939,0.866-1.461,1.241l0,0l0.162,4.323l-0.615,0.278c-0.709,0.319-1.444,0.587-2.202,0.8l0,0l-0.648,0.183L17.047,27.945L17.047,27.945zM20.424,29.028c0.227-0.076,0.45-0.157,0.671-0.244l0,0l-0.152-4.083l0.479-0.307c0.717-0.466,1.37-1.024,1.95-1.658l0,0l0.386-0.423l4.026,0.862c0.121-0.202,0.238-0.409,0.351-0.62l0,0l-2.754-3.045l0.171-0.544c0.243-0.783,0.381-1.623,0.422-2.5l0,0l0.025-0.571l3.658-1.933c-0.038-0.234-0.082-0.467-0.132-0.7l0,0l-4.07-0.563l-0.219-0.527c-0.327-0.787-0.76-1.524-1.277-2.204l0,0l-0.342-0.453l1.548-3.808c-0.179-0.157-0.363-0.31-0.552-0.458l0,0l-3.455,2.169L20.649,7.15c-0.754-0.397-1.569-0.698-2.429-0.894l0,0l-0.556-0.127l-1.248-3.87c-0.121-0.006-0.239-0.009-0.354-0.009l0,0c-0.117,0-0.235,0.003-0.357,0.009l0,0l-1.239,3.845l-0.564,0.12c-0.875,0.188-1.709,0.494-2.486,0.896l0,0l-0.508,0.264L7.509,5.249c-0.188,0.148-0.372,0.301-0.55,0.458l0,0l1.507,3.708L8.112,9.869c-0.552,0.709-1.011,1.485-1.355,2.319l0,0l-0.218,0.529l-3.939,0.545c-0.05,0.233-0.094,0.466-0.131,0.7l0,0l3.531,1.867l0.022,0.575c0.037,0.929,0.192,1.82,0.459,2.653l0,0l0.175,0.548l-2.667,2.95c0.112,0.212,0.229,0.419,0.351,0.621l0,0l3.916-0.843l0.39,0.423c0.601,0.657,1.287,1.229,2.043,1.703l0,0l0.488,0.305l-0.149,4.02c0.221,0.087,0.445,0.168,0.672,0.244l0,0l2.479-3.188l0.566,0.07c0.427,0.054,0.843,0.089,1.257,0.089l0,0c0.445,0,0.894-0.039,1.353-0.104l0,0l0.571-0.08L20.424,29.028L20.424,29.028zM21.554,20.75l0.546,0.839l-3.463,2.253l-1.229-1.891l0,0c-0.447,0.109-0.917,0.173-1.406,0.173l0,0c-3.384,0-6.126-2.743-6.126-6.123l0,0c0-3.384,2.742-6.126,6.126-6.126l0,0c3.38,0,6.123,2.742,6.123,6.126l0,0c0,1.389-0.467,2.676-1.25,3.704l0,0L21.554,20.75M19.224,21.073l0.108-0.069l-0.987-1.519l0.572-0.572c0.748-0.75,1.207-1.773,1.207-2.912l0,0c-0.004-2.278-1.848-4.122-4.123-4.126l0,0c-2.28,0.004-4.122,1.846-4.126,4.126l0,0c0.004,2.275,1.848,4.119,4.126,4.123l0,0c0.509,0,0.999-0.104,1.473-0.286l0,0l0.756-0.29L19.224,21.073L19.224,21.073z");
  }
});

/***/ }),

/***/ "./src/shape/icon/GitHub.js":
/*!**********************************!*\
  !*** ./src/shape/icon/GitHub.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.GitHub();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.GitHub = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.GitHub.prototype */
{

  NAME: "draw2d.shape.icon.GitHub",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.436,15.099c-1.201-0.202-2.451-0.335-3.466-0.371l-0.179-0.006c0.041-0.09,0.072-0.151,0.082-0.16c0.022-0.018,0.04-0.094,0.042-0.168c0-0.041,0.018-0.174,0.046-0.35c0.275,0.01,0.64,0.018,1.038,0.021c1.537,0.012,3.145,0.136,4.248,0.331c0.657,0.116,0.874,0.112,0.389-0.006c-0.491-0.119-1.947-0.294-3.107-0.37c-0.779-0.053-1.896-0.073-2.554-0.062c0.019-0.114,0.041-0.241,0.064-0.371c0.093-0.503,0.124-1.009,0.126-2.016c0.002-1.562-0.082-1.992-0.591-3.025c-0.207-0.422-0.441-0.78-0.724-1.104c0.247-0.729,0.241-1.858-0.015-2.848c-0.211-0.812-0.285-0.864-1.021-0.708C22.19,4.019,21.69,4.2,21.049,4.523c-0.303,0.153-0.721,0.391-1.024,0.578c-0.79-0.278-1.607-0.462-2.479-0.561c-0.884-0.1-3.051-0.044-3.82,0.098c-0.752,0.139-1.429,0.309-2.042,0.511c-0.306-0.189-0.75-0.444-1.067-0.604C9.973,4.221,9.473,4.041,8.847,3.908c-0.734-0.157-0.81-0.104-1.02,0.708c-0.26,1.003-0.262,2.151-0.005,2.878C7.852,7.577,7.87,7.636,7.877,7.682c-1.042,1.312-1.382,2.78-1.156,4.829c0.059,0.534,0.15,1.024,0.277,1.473c-0.665-0.004-1.611,0.02-2.294,0.064c-1.162,0.077-2.618,0.25-3.109,0.369c-0.484,0.118-0.269,0.122,0.389,0.007c1.103-0.194,2.712-0.32,4.248-0.331c0.29-0.001,0.561-0.007,0.794-0.013c0.07,0.237,0.15,0.463,0.241,0.678L7.26,14.759c-1.015,0.035-2.264,0.168-3.465,0.37c-0.901,0.151-2.231,0.453-2.386,0.54c-0.163,0.091-0.03,0.071,0.668-0.106c1.273-0.322,2.928-0.569,4.978-0.741l0.229-0.02c0.44,1.022,1.118,1.802,2.076,2.41c0.586,0.373,1.525,0.756,1.998,0.816c0.13,0.016,0.508,0.094,0.84,0.172c0.333,0.078,0.984,0.195,1.446,0.262h0.011c-0.009,0.006-0.017,0.01-0.025,0.016c-0.56,0.291-0.924,0.744-1.169,1.457c-0.11,0.033-0.247,0.078-0.395,0.129c-0.529,0.18-0.735,0.217-1.271,0.221c-0.556,0.004-0.688-0.02-1.02-0.176c-0.483-0.225-0.933-0.639-1.233-1.133c-0.501-0.826-1.367-1.41-2.089-1.41c-0.617,0-0.734,0.25-0.288,0.615c0.672,0.549,1.174,1.109,1.38,1.537c0.116,0.24,0.294,0.611,0.397,0.824c0.109,0.227,0.342,0.535,0.564,0.748c0.522,0.498,1.026,0.736,1.778,0.848c0.504,0.074,0.628,0.074,1.223-0.002c0.287-0.035,0.529-0.076,0.746-0.127c0,0.244,0,0.525,0,0.855c0,1.766-0.021,2.334-0.091,2.5c-0.132,0.316-0.428,0.641-0.716,0.787c-0.287,0.146-0.376,0.307-0.255,0.455c0.067,0.08,0.196,0.094,0.629,0.066c0.822-0.051,1.403-0.355,1.699-0.891c0.095-0.172,0.117-0.518,0.147-2.318c0.032-1.953,0.046-2.141,0.173-2.42c0.077-0.166,0.188-0.346,0.25-0.395c0.104-0.086,0.111,0.084,0.111,2.42c-0.001,2.578-0.027,2.889-0.285,3.385c-0.058,0.113-0.168,0.26-0.245,0.33c-0.135,0.123-0.192,0.438-0.098,0.533c0.155,0.154,0.932-0.088,1.356-0.422c0.722-0.572,0.808-1.045,0.814-4.461l0.003-2.004l0.219,0.021l0.219,0.02l0.036,2.621c0.041,2.951,0.047,2.994,0.549,3.564c0.285,0.322,0.572,0.5,1.039,0.639c0.625,0.188,0.813-0.102,0.393-0.605c-0.457-0.547-0.479-0.756-0.454-3.994c0.017-2.076,0.017-2.076,0.151-1.955c0.282,0.256,0.336,0.676,0.336,2.623c0,2.418,0.069,2.648,0.923,3.07c0.399,0.195,0.511,0.219,1.022,0.221c0.544,0.002,0.577-0.006,0.597-0.148c0.017-0.115-0.05-0.193-0.304-0.348c-0.333-0.205-0.564-0.467-0.709-0.797c-0.055-0.127-0.092-0.959-0.117-2.672c-0.036-2.393-0.044-2.502-0.193-2.877c-0.201-0.504-0.508-0.902-0.897-1.166c-0.101-0.066-0.202-0.121-0.333-0.162c0.161-0.016,0.317-0.033,0.468-0.055c1.572-0.209,2.403-0.383,3.07-0.641c1.411-0.543,2.365-1.445,2.882-2.724c0.046-0.114,0.092-0.222,0.131-0.309l0.398,0.033c2.051,0.173,3.706,0.42,4.979,0.743c0.698,0.177,0.831,0.198,0.668,0.105C30.666,15.551,29.336,15.25,28.436,15.099zM22.422,15.068c-0.233,0.512-0.883,1.17-1.408,1.428c-0.518,0.256-1.33,0.451-2.25,0.544c-0.629,0.064-4.137,0.083-4.716,0.026c-1.917-0.188-2.991-0.557-3.783-1.296c-0.75-0.702-1.1-1.655-1.039-2.828c0.039-0.734,0.216-1.195,0.679-1.755c0.421-0.51,0.864-0.825,1.386-0.985c0.437-0.134,1.778-0.146,3.581-0.03c0.797,0.051,1.456,0.051,2.252,0c1.886-0.119,3.145-0.106,3.61,0.038c0.731,0.226,1.397,0.834,1.797,1.644c0.18,0.362,0.215,0.516,0.241,1.075C22.808,13.699,22.675,14.517,22.422,15.068zM12.912,11.762c-1.073-0.188-1.686,1.649-0.863,2.587c0.391,0.445,0.738,0.518,1.172,0.248c0.402-0.251,0.62-0.72,0.62-1.328C13.841,12.458,13.472,11.862,12.912,11.762zM19.425,11.872c-1.073-0.188-1.687,1.647-0.864,2.586c0.392,0.445,0.738,0.519,1.173,0.247c0.401-0.25,0.62-0.72,0.62-1.328C20.354,12.569,19.985,11.971,19.425,11.872zM16.539,15.484c-0.023,0.074-0.135,0.184-0.248,0.243c-0.286,0.147-0.492,0.096-0.794-0.179c-0.187-0.169-0.272-0.258-0.329-0.081c-0.053,0.164,0.28,0.493,0.537,0.594c0.236,0.094,0.405,0.097,0.661-0.01c0.254-0.106,0.476-0.391,0.476-0.576C16.842,15.303,16.595,15.311,16.539,15.484zM16.222,14.909c0.163-0.144,0.2-0.44,0.044-0.597s-0.473-0.133-0.597,0.043c-0.144,0.206-0.067,0.363,0.036,0.53C15.865,15.009,16.08,15.034,16.222,14.909z");
  }
});

/***/ }),

/***/ "./src/shape/icon/GitHubAlt.js":
/*!*************************************!*\
  !*** ./src/shape/icon/GitHubAlt.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.GitHubAlt();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.GitHubAlt = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.GitHubAlt.prototype */
{

  NAME: "draw2d.shape.icon.GitHubAlt",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M23.356,17.485c-0.004,0.007-0.007,0.013-0.01,0.021l0.162,0.005c0.107,0.004,0.218,0.01,0.33,0.016c-0.046-0.004-0.09-0.009-0.136-0.013L23.356,17.485zM15.5,1.249C7.629,1.25,1.25,7.629,1.249,15.5C1.25,23.371,7.629,29.75,15.5,29.751c7.871-0.001,14.25-6.38,14.251-14.251C29.75,7.629,23.371,1.25,15.5,1.249zM3.771,17.093c0.849-0.092,1.833-0.148,2.791-0.156c0.262,0,0.507-0.006,0.717-0.012c0.063,0.213,0.136,0.419,0.219,0.613H7.492c-0.918,0.031-2.047,0.152-3.134,0.335c-0.138,0.023-0.288,0.051-0.441,0.08C3.857,17.67,3.81,17.383,3.771,17.093zM12.196,22.224c-0.1,0.028-0.224,0.07-0.357,0.117c-0.479,0.169-0.665,0.206-1.15,0.206c-0.502,0.015-0.621-0.019-0.921-0.17C9.33,22.171,8.923,21.8,8.651,21.353c-0.453-0.746-1.236-1.275-1.889-1.275c-0.559,0-0.664,0.227-0.261,0.557c0.608,0.496,1.062,0.998,1.248,1.385c0.105,0.215,0.266,0.546,0.358,0.744c0.099,0.206,0.311,0.474,0.511,0.676c0.472,0.441,0.928,0.659,1.608,0.772c0.455,0.06,0.567,0.06,1.105-0.004c0.26-0.03,0.479-0.067,0.675-0.118v0.771c0,1.049-0.008,1.628-0.031,1.945c-1.852-0.576-3.507-1.595-4.848-2.934c-1.576-1.578-2.706-3.592-3.195-5.848c0.952-0.176,2.073-0.32,3.373-0.43l0.208-0.018c0.398,0.925,1.011,1.631,1.876,2.179c0.53,0.337,1.38,0.685,1.808,0.733c0.118,0.02,0.46,0.09,0.76,0.16c0.302,0.066,0.89,0.172,1.309,0.236h0.009c-0.007,0.018-0.014,0.02-0.022,0.02C12.747,21.169,12.418,21.579,12.196,22.224zM13.732,27.207c-0.168-0.025-0.335-0.056-0.5-0.087c0.024-0.286,0.038-0.785,0.054-1.723c0.028-1.767,0.041-1.94,0.156-2.189c0.069-0.15,0.17-0.32,0.226-0.357c0.095-0.078,0.101,0.076,0.101,2.188C13.769,26.143,13.763,26.786,13.732,27.207zM15.5,27.339c-0.148,0-0.296-0.006-0.443-0.012c0.086-0.562,0.104-1.428,0.106-2.871l0.003-1.82l0.197,0.019l0.199,0.02l0.032,2.365c0.017,1.21,0.027,1.878,0.075,2.296C15.613,27.335,15.558,27.339,15.5,27.339zM17.006,27.24c-0.039-0.485-0.037-1.243-0.027-2.553c0.019-1.866,0.019-1.866,0.131-1.769c0.246,0.246,0.305,0.623,0.305,2.373c0,0.928,0.011,1.497,0.082,1.876C17.334,27.196,17.17,27.22,17.006,27.24zM27.089,17.927c-0.155-0.029-0.307-0.057-0.446-0.08c-0.96-0.162-1.953-0.275-2.804-0.32c1.25,0.108,2.327,0.248,3.246,0.418c-0.479,2.289-1.618,4.33-3.214,5.928c-1.402,1.4-3.15,2.448-5.106,3.008c-0.034-0.335-0.058-1.048-0.066-2.212c-0.03-2.167-0.039-2.263-0.17-2.602c-0.181-0.458-0.47-0.811-0.811-1.055c-0.094-0.057-0.181-0.103-0.301-0.14c0.145-0.02,0.282-0.021,0.427-0.057c1.418-0.188,2.168-0.357,2.772-0.584c1.263-0.492,2.129-1.301,2.606-2.468c0.044-0.103,0.088-0.2,0.123-0.279l0.011,0.001c0.032-0.07,0.057-0.118,0.064-0.125c0.02-0.017,0.036-0.085,0.038-0.151c0-0.037,0.017-0.157,0.041-0.317c0.249,0.01,0.58,0.018,0.938,0.02c0.959,0.008,1.945,0.064,2.794,0.156C27.194,17.356,27.148,17.644,27.089,17.927zM25.823,16.87c-0.697-0.049-1.715-0.064-2.311-0.057c0.02-0.103,0.037-0.218,0.059-0.336c0.083-0.454,0.111-0.912,0.113-1.823c0.002-1.413-0.074-1.801-0.534-2.735c-0.188-0.381-0.399-0.705-0.655-0.998c0.225-0.659,0.207-1.68-0.02-2.575c-0.19-0.734-0.258-0.781-0.924-0.64c-0.563,0.12-1.016,0.283-1.598,0.576c-0.274,0.138-0.652,0.354-0.923,0.522c-0.715-0.251-1.451-0.419-2.242-0.508c-0.799-0.092-2.759-0.04-3.454,0.089c-0.681,0.126-1.293,0.28-1.848,0.462c-0.276-0.171-0.678-0.4-0.964-0.547C9.944,8.008,9.491,7.846,8.925,7.727c-0.664-0.144-0.732-0.095-0.922,0.64c-0.235,0.907-0.237,1.945-0.004,2.603c0.026,0.075,0.043,0.129,0.05,0.17c-0.942,1.187-1.25,2.515-1.046,4.367c0.053,0.482,0.136,0.926,0.251,1.333c-0.602-0.004-1.457,0.018-2.074,0.057c-0.454,0.031-0.957,0.076-1.418,0.129c-0.063-0.5-0.101-1.008-0.101-1.524c0-3.273,1.323-6.225,3.468-8.372c2.146-2.144,5.099-3.467,8.371-3.467c3.273,0,6.226,1.323,8.371,3.467c2.145,2.147,3.468,5.099,3.468,8.372c0,0.508-0.036,1.008-0.098,1.499C26.78,16.946,26.276,16.899,25.823,16.87z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Glasses.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Glasses.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Glasses();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Glasses = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Glasses.prototype */
{

  NAME: "draw2d.shape.icon.Glasses",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.075,9.531c0,0-2.705-1.438-5.158-1.438c-2.453,0-4.862,0.593-4.862,0.593L3.971,9.869c0,0,0.19,0.19,0.528,0.53c0.338,0.336,0.486,3.741,1.838,5.094c1.353,1.354,4.82,1.396,5.963,0.676c1.14-0.718,2.241-3.466,2.241-4.693c0-0.38,0-0.676,0-0.676c0.274-0.275,1.615-0.303,1.917,0c0,0,0,0.296,0,0.676c0,1.227,1.101,3.975,2.241,4.693c1.144,0.72,4.611,0.678,5.963-0.676c1.355-1.353,1.501-4.757,1.839-5.094c0.338-0.34,0.528-0.53,0.528-0.53l-0.084-1.183c0,0-2.408-0.593-4.862-0.593c-2.453,0-5.158,1.438-5.158,1.438C16.319,9.292,14.737,9.32,14.075,9.531z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Globe.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Globe.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Globe();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Globe = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Globe.prototype */
{

  NAME: "draw2d.shape.icon.Globe",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM19.158,23.269c-0.079,0.064-0.183,0.13-0.105,0.207c0.078,0.078-0.09,0.131-0.09,0.17s0.104,0.246,0.052,0.336c-0.052,0.092-0.091,0.223-0.13,0.301c-0.039,0.077-0.131,0.155-0.104,0.272c0.025,0.116-0.104,0.077-0.104,0.194c0,0.116,0.116,0.065,0.09,0.208c-0.025,0.144-0.09,0.183-0.09,0.285c0,0.104,0.064,0.247,0.064,0.286s-0.064,0.17-0.155,0.272c-0.092,0.104-0.155,0.17-0.144,0.233c0.014,0.065,0.104,0.144,0.091,0.184c-0.013,0.037-0.129,0.168-0.116,0.259c0.014,0.09,0.129,0.053,0.155,0.116c0.026,0.065-0.155,0.118-0.078,0.183c0.078,0.064,0.183,0.051,0.156,0.208c-0.019,0.112,0.064,0.163,0.126,0.198c-0.891,0.221-1.818,0.352-2.777,0.352C9.639,27.533,4.466,22.36,4.466,16c0-2.073,0.557-4.015,1.518-5.697c0.079-0.042,0.137-0.069,0.171-0.062c0.065,0.013,0.079,0.104,0.183,0.13c0.104,0.026,0.195-0.078,0.26-0.117c0.064-0.039,0.116-0.195,0.051-0.182c-0.065,0.013-0.234,0-0.234,0s0.183-0.104,0.183-0.169s0.025-0.169,0.129-0.208C6.83,9.655,6.83,9.681,6.765,9.837C6.7,9.993,6.896,9.928,6.973,9.863s0.13-0.013,0.272-0.104c0.143-0.091,0.143-0.143,0.221-0.143c0.078,0,0.221,0.143,0.299,0.091c0.077-0.052,0.299,0.065,0.429,0.065c0.129,0,0.545,0.169,0.624,0.169c0.078,0,0.312,0.09,0.325,0.259c0.013,0.169,0.09,0.156,0.168,0.156s0.26,0.065,0.26,0.13c0,0.065-0.052,0.325,0.078,0.39c0.129,0.064,0.247,0.169,0.299,0.143c0.052-0.026,0-0.233-0.064-0.26c-0.065-0.026-0.027-0.117-0.052-0.169c-0.026-0.051,0.078-0.051,0.117,0.039c0.039,0.091,0.143,0.26,0.208,0.26c0.064,0,0.208,0.156,0.168,0.247c-0.039,0.091,0.039,0.221,0.156,0.221c0.116,0,0.26,0.182,0.312,0.195c0.052,0.013,0.117,0.078,0.117,0.117c0,0.04,0.065,0.26,0.065,0.351c0,0.09-0.04,0.454-0.053,0.597s0.104,0.39,0.234,0.52c0.129,0.13,0.246,0.377,0.324,0.429c0.079,0.052,0.13,0.195,0.247,0.182c0.117-0.013,0.195,0.078,0.299,0.26c0.104,0.182,0.208,0.48,0.286,0.506c0.078,0.026,0.208,0.117,0.142,0.182c-0.064,0.064-0.168,0.208-0.051,0.208c0.117,0,0.156-0.065,0.247,0.053c0.09,0.116,0.208,0.181,0.194,0.26c-0.013,0.077,0.104,0.103,0.156,0.116c0.052,0.013,0.169,0.247,0.286,0.143c0.117-0.104-0.155-0.259-0.234-0.326c-0.078-0.064,0-0.207-0.182-0.35c-0.182-0.143-0.156-0.247-0.286-0.351c-0.13-0.104-0.233-0.195-0.104-0.286c0.13-0.091,0.143,0.091,0.195,0.208c0.052,0.116,0.324,0.351,0.441,0.454c0.117,0.104,0.326,0.468,0.39,0.468s0.247,0.208,0.247,0.208s0.103,0.168,0.064,0.22c-0.039,0.052,0.053,0.247,0.144,0.299c0.09,0.052,0.455,0.22,0.507,0.247c0.052,0.027,0.155,0.221,0.299,0.221c0.142,0,0.247,0.014,0.286,0.053c0.039,0.038,0.155,0.194,0.234,0.104c0.078-0.092,0.09-0.131,0.208-0.131c0.117,0,0.168,0.091,0.233,0.156c0.065,0.065,0.247,0.235,0.338,0.222c0.091-0.013,0.208,0.104,0.273,0.064s0.169,0.025,0.22,0.052c0.054,0.026,0.234,0.118,0.222,0.272c-0.013,0.157,0.103,0.195,0.182,0.234c0.078,0.039,0.182,0.13,0.248,0.195c0.064,0.063,0.206,0.077,0.246,0.116c0.039,0.039,0.065,0.117,0.182,0.052c0.116-0.064,0.092-0.181,0.092-0.181s0.129-0.026,0.194,0.026c0.064,0.05,0.104,0.22,0.144,0.246c0.038,0.026,0.115,0.221,0.063,0.362c-0.051,0.145-0.038,0.286-0.091,0.286c-0.052,0-0.116,0.17-0.195,0.209c-0.076,0.039-0.285,0.221-0.272,0.286c0.013,0.063,0.131,0.258,0.104,0.35c-0.025,0.091-0.194,0.195-0.154,0.338c0.038,0.144,0.312,0.183,0.323,0.312c0.014,0.131,0.209,0.417,0.235,0.546c0.025,0.13,0.246,0.272,0.246,0.453c0,0.184,0.312,0.3,0.377,0.312c0.063,0.013,0.182,0.131,0.272,0.17s0.169,0.116,0.233,0.221s0.053,0.261,0.053,0.299c0,0.039-0.039,0.44-0.078,0.674C19.145,23.021,19.235,23.203,19.158,23.269zM10.766,11.188c0.039,0.013,0.117,0.091,0.156,0.091c0.04,0,0.234,0.156,0.286,0.208c0.053,0.052,0.053,0.195-0.013,0.208s-0.104-0.143-0.117-0.208c-0.013-0.065-0.143-0.065-0.208-0.104C10.805,11.344,10.66,11.152,10.766,11.188zM27.51,16.41c-0.144,0.182-0.13,0.272-0.195,0.286c-0.064,0.013,0.065,0.065,0.09,0.194c0.022,0.112-0.065,0.224,0.063,0.327c-0.486,4.619-3.71,8.434-8.016,9.787c-0.007-0.011-0.019-0.025-0.021-0.034c-0.027-0.078-0.027-0.233,0.064-0.285c0.091-0.053,0.312-0.233,0.363-0.272c0.052-0.04,0.13-0.221,0.091-0.247c-0.038-0.026-0.232,0-0.26-0.039c-0.026-0.039-0.026-0.092,0.104-0.182c0.13-0.091,0.195-0.222,0.247-0.26c0.052-0.039,0.155-0.117,0.195-0.209c0.038-0.09-0.041-0.039-0.118-0.039s-0.117-0.142-0.117-0.207s0.195,0.026,0.339,0.052c0.143,0.024,0.077-0.065,0.064-0.142c-0.013-0.078,0.026-0.209,0.105-0.17c0.076,0.039,0.479-0.013,0.531-0.026c0.052-0.013,0.194-0.246,0.246-0.312c0.053-0.065,0.064-0.129,0-0.168c-0.065-0.04-0.143-0.184-0.168-0.221c-0.026-0.041-0.039-0.274-0.013-0.34c0.025-0.063,0,0.377,0.181,0.43c0.183,0.052,0.286,0.078,0.455-0.078c0.169-0.155,0.298-0.26,0.312-0.363c0.013-0.104,0.052-0.209,0.117-0.246c0.065-0.039,0.104,0.103,0.182-0.065c0.078-0.17,0.156-0.157,0.234-0.299c0.077-0.144-0.13-0.325,0.024-0.43c0.157-0.103,0.43-0.233,0.43-0.233s0.078-0.039,0.234-0.078c0.155-0.038,0.324-0.014,0.376-0.09c0.052-0.079,0.104-0.247,0.182-0.338c0.079-0.092,0.169-0.234,0.13-0.299c-0.039-0.065,0.104-0.352,0.091-0.429c-0.013-0.078-0.13-0.261,0.065-0.416s0.402-0.391,0.416-0.454c0.012-0.065,0.169-0.338,0.154-0.469c-0.012-0.129-0.154-0.285-0.245-0.325c-0.092-0.037-0.286-0.05-0.364-0.154s-0.299-0.208-0.377-0.182c-0.077,0.026-0.208,0.051-0.312-0.015c-0.104-0.063-0.272-0.143-0.337-0.194c-0.066-0.051-0.234-0.09-0.312-0.09s-0.065-0.053-0.182,0.103c-0.117,0.157,0,0.209-0.208,0.182c-0.209-0.024,0.025-0.038,0.144-0.194c0.115-0.155-0.014-0.247-0.144-0.207c-0.13,0.039-0.039,0.117-0.247,0.156c-0.207,0.038-0.207-0.092-0.077-0.117c0.13-0.026,0.363-0.143,0.363-0.194c0-0.053-0.026-0.196-0.13-0.196s-0.078-0.129-0.233-0.297c-0.156-0.17-0.351-0.274-0.508-0.249c-0.154,0.026-0.272,0.065-0.35-0.076c-0.078-0.144-0.169-0.17-0.222-0.247c-0.051-0.078-0.182,0-0.221-0.039s-0.039-0.039-0.039-0.039s-0.169,0.039-0.077-0.078c0.09-0.117,0.129-0.338,0.09-0.325c-0.038,0.013-0.104,0.196-0.168,0.183c-0.064-0.013-0.014-0.04-0.144-0.117c-0.13-0.078-0.337-0.013-0.337,0.052c0,0.065-0.065,0.117-0.065,0.117s-0.039-0.038-0.078-0.117c-0.039-0.078-0.221-0.091-0.312-0.013c-0.09,0.078-0.142-0.196-0.207-0.196s-0.194,0.065-0.26,0.184c-0.064,0.116-0.038,0.285-0.092,0.272c-0.05-0.013-0.063-0.233-0.05-0.312c0.012-0.079,0.155-0.208,0.05-0.234c-0.103-0.026-0.259,0.13-0.323,0.143c-0.065,0.013-0.195,0.104-0.273,0.209c-0.077,0.103-0.116,0.168-0.195,0.207c-0.077,0.039-0.193,0-0.167-0.039c0.025-0.039-0.222-0.181-0.261-0.13c-0.04,0.052-0.155,0.091-0.272,0.144c-0.117,0.052-0.222-0.065-0.247-0.117s-0.079-0.064-0.091-0.234c-0.013-0.168,0.027-0.351,0.065-0.454c0.038-0.104-0.195-0.312-0.286-0.3c-0.091,0.015-0.182,0.105-0.272,0.091c-0.092-0.012-0.052-0.038-0.195-0.038c-0.143,0-0.026-0.025,0-0.143c0.025-0.116-0.052-0.273,0.092-0.377c0.142-0.104,0.091-0.351,0-0.363c-0.092-0.014-0.261,0.039-0.377,0.026c-0.116-0.014-0.208,0.091-0.169,0.207c0.039,0.117-0.065,0.195-0.104,0.183c-0.039-0.013-0.09-0.078-0.234,0.026c-0.142,0.103-0.194,0.064-0.337-0.052c-0.143-0.118-0.299-0.234-0.325-0.416c-0.026-0.182-0.04-0.364,0.013-0.468c0.051-0.104,0.051-0.285-0.026-0.312c-0.078-0.025,0.09-0.155,0.181-0.181c0.092-0.026,0.234-0.143,0.26-0.195c0.026-0.052,0.156-0.04,0.298-0.04c0.143,0,0.169,0,0.312,0.078c0.143,0.078,0.169-0.039,0.169-0.078c0-0.039,0.052-0.117,0.208-0.104c0.156,0.013,0.376-0.052,0.416-0.013s0.116,0.195,0.194,0.143c0.079-0.051,0.104-0.143,0.131,0.014c0.025,0.155,0.09,0.39,0.208,0.429c0.116,0.039,0.052,0.194,0.168,0.207c0.115,0.013,0.17-0.246,0.131-0.337c-0.04-0.09-0.118-0.363-0.183-0.428c-0.064-0.065-0.064-0.234,0.064-0.286c0.13-0.052,0.442-0.312,0.532-0.389c0.092-0.079,0.338-0.144,0.261-0.248c-0.078-0.104-0.104-0.168-0.104-0.247s0.078-0.052,0.117,0s0.194-0.078,0.155-0.143c-0.038-0.064-0.026-0.155,0.065-0.143c0.091,0.013,0.116-0.065,0.078-0.117c-0.039-0.052,0.091-0.117,0.182-0.091c0.092,0.026,0.325-0.013,0.364-0.065c0.038-0.052-0.078-0.104-0.078-0.208c0-0.104,0.155-0.195,0.247-0.208c0.091-0.013,0.207,0,0.221-0.039c0.012-0.039,0.143-0.143,0.155-0.052c0.014,0.091,0,0.247,0.104,0.247c0.104,0,0.232-0.117,0.272-0.129c0.038-0.013,0.286-0.065,0.338-0.078c0.052-0.013,0.363-0.039,0.325-0.13c-0.039-0.09-0.078-0.181-0.118-0.22c-0.039-0.039-0.077,0.013-0.13,0.078c-0.051,0.065-0.143,0.065-0.168,0.013c-0.026-0.051,0.012-0.207-0.078-0.156c-0.092,0.052-0.104,0.104-0.157,0.078c-0.052-0.026-0.103-0.117-0.103-0.117s0.129-0.064,0.038-0.182c-0.09-0.117-0.221-0.091-0.35-0.025c-0.13,0.064-0.118,0.051-0.273,0.09s-0.234,0.078-0.234,0.078s0.209-0.129,0.299-0.208c0.091-0.078,0.209-0.117,0.286-0.195c0.078-0.078,0.285,0.039,0.285,0.039s0.105-0.104,0.105-0.039s-0.027,0.234,0.051,0.234c0.079,0,0.299-0.104,0.21-0.131c-0.093-0.026,0.129,0,0.219-0.065c0.092-0.065,0.194-0.065,0.247-0.09c0.052-0.026,0.092-0.143,0.182-0.143c0.092,0,0.13,0.117,0,0.195s-0.143,0.273-0.208,0.325c-0.064,0.052-0.026,0.117,0.078,0.104c0.104-0.013,0.194,0.013,0.286-0.013s0.143,0.026,0.168,0.065c0.026,0.039,0.104-0.039,0.104-0.039s0.169-0.039,0.221,0.026c0.053,0.064,0.092-0.039,0.053-0.104c-0.039-0.064-0.092-0.129-0.13-0.208c-0.039-0.078-0.091-0.104-0.194-0.078c-0.104,0.026-0.13-0.026-0.195-0.064c-0.065-0.04-0.118,0.052-0.065-0.04c0.053-0.09,0.078-0.117,0.117-0.195c0.039-0.078,0.209-0.221,0.039-0.259c-0.169-0.04-0.222-0.065-0.247-0.143c-0.026-0.078-0.221-0.221-0.272-0.221c-0.053,0-0.233,0-0.247-0.065c-0.013-0.065-0.143-0.208-0.208-0.273c-0.064-0.065-0.312-0.351-0.351-0.377c-0.039-0.026-0.091-0.013-0.208,0.143c-0.116,0.157-0.22,0.183-0.312,0.144c-0.091-0.039-0.104-0.026-0.193-0.13c-0.093-0.104,0.09-0.117,0.051-0.182c-0.04-0.064-0.247-0.091-0.377-0.104c-0.13-0.013-0.221-0.156-0.416-0.169c-0.194-0.013-0.428,0.026-0.493,0.026c-0.064,0-0.064,0.091-0.09,0.234c-0.027,0.143,0.09,0.182-0.027,0.208c-0.116,0.026-0.169,0.039-0.052,0.091c0.117,0.052,0.273,0.26,0.273,0.26s0,0.117-0.092,0.182c-0.09,0.065-0.182,0.13-0.233,0.053c-0.053-0.079-0.195-0.065-0.155,0.013c0.038,0.078,0.116,0.117,0.116,0.195c0,0.077,0.117,0.272,0.039,0.337c-0.078,0.065-0.168,0.014-0.233,0.026s-0.131-0.104-0.078-0.13c0.051-0.026-0.014-0.221-0.014-0.221s-0.155,0.221-0.143,0.104c0.014-0.117-0.064-0.13-0.064-0.221c0-0.091-0.079-0.13-0.194-0.104c-0.118,0.026-0.26-0.04-0.482-0.079c-0.22-0.039-0.311-0.064-0.493-0.156c-0.182-0.091-0.247-0.026-0.338-0.013c-0.091,0.013-0.052-0.182-0.169-0.207c-0.116-0.027-0.181,0.025-0.207-0.144c-0.026-0.168,0.039-0.208,0.324-0.39c0.286-0.182,0.247-0.26,0.468-0.286c0.22-0.026,0.325,0.026,0.325-0.039s0.052-0.325,0.052-0.195S16.95,9.109,16.832,9.2c-0.116,0.091-0.052,0.104,0.04,0.104c0.091,0,0.259-0.091,0.259-0.091s0.208-0.091,0.26-0.013c0.053,0.078,0.053,0.156,0.144,0.156s0.285-0.104,0.116-0.195c-0.168-0.091-0.272-0.078-0.376-0.182s-0.078-0.065-0.195-0.039c-0.116,0.026-0.116-0.039-0.156-0.039s-0.104,0.026-0.13-0.026c-0.025-0.052,0.014-0.065,0.145-0.065c0.129,0,0.285,0.039,0.285,0.039s0.155-0.052,0.194-0.065c0.039-0.013,0.247-0.039,0.208-0.155c-0.04-0.117-0.169-0.117-0.208-0.156s0.078-0.09,0.143-0.117c0.065-0.026,0.247,0,0.247,0s0.117,0.013,0.117-0.039S17.897,8.2,17.976,8.239s0,0.156,0.117,0.13c0.116-0.026,0.143,0,0.207,0.039c0.065,0.039-0.013,0.195-0.077,0.221c-0.065,0.025-0.169,0.077-0.026,0.09c0.144,0.014,0.246,0.014,0.246,0.014s0.092-0.091,0.131-0.169c0.038-0.078,0.104-0.026,0.155,0c0.052,0.025,0.247,0.065,0.065,0.117c-0.183,0.052-0.221,0.117-0.26,0.182c-0.038,0.065-0.053,0.104-0.221,0.065c-0.17-0.039-0.26-0.026-0.299,0.039c-0.039,0.064-0.013,0.273,0.053,0.247c0.063-0.026,0.129-0.026,0.207-0.052c0.078-0.026,0.39,0.026,0.467,0.013c0.078-0.013,0.209,0.13,0.248,0.104c0.039-0.026,0.117,0.052,0.194,0.104c0.078,0.052,0.052-0.117,0.194-0.013c0.144,0.104,0.065,0.104,0.144,0.104c0.076,0,0.246,0.013,0.246,0.013s0.014-0.129,0.144-0.104c0.13,0.026,0.245,0.169,0.232,0.064c-0.012-0.103,0.013-0.181-0.09-0.259c-0.104-0.078-0.272-0.13-0.299-0.169c-0.026-0.039-0.052-0.091-0.013-0.117c0.039-0.025,0.221,0.013,0.324,0.079c0.104,0.065,0.195,0.13,0.273,0.078c0.077-0.052,0.17-0.078,0.208-0.117c0.038-0.04,0.13-0.156,0.13-0.156s-0.391-0.051-0.441-0.117c-0.053-0.065-0.235-0.156-0.287-0.156s-0.194,0.091-0.246-0.039s-0.052-0.286-0.105-0.299c-0.05-0.013-0.597-0.091-0.674-0.13c-0.078-0.039-0.39-0.13-0.507-0.195s-0.286-0.156-0.389-0.156c-0.104,0-0.533,0.052-0.611,0.039c-0.078-0.013-0.312,0.026-0.403,0.039c-0.091,0.013,0.117,0.182-0.077,0.221c-0.195,0.039-0.169,0.065-0.13-0.13c0.038-0.195-0.131-0.247-0.299-0.169c-0.169,0.078-0.442,0.13-0.377,0.221c0.065,0.091-0.012,0.157,0.117,0.247c0.13,0.091,0.183,0.117,0.35,0.104c0.17-0.013,0.339,0.025,0.339,0.025s0,0.157-0.064,0.182c-0.065,0.026-0.169,0.026-0.196,0.104c-0.025,0.078-0.155,0.117-0.155,0.078s0.065-0.169-0.026-0.234c-0.09-0.065-0.117-0.078-0.221-0.013c-0.104,0.065-0.116,0.091-0.169-0.013C16.053,8.291,15.897,8.2,15.897,8.2s-0.104-0.129-0.182-0.194c-0.077-0.065-0.22-0.052-0.234,0.013c-0.013,0.064,0.026,0.129,0.078,0.247c0.052,0.117,0.104,0.337,0.013,0.351c-0.091,0.013-0.104,0.026-0.195,0.052c-0.091,0.026-0.13-0.039-0.13-0.143s-0.04-0.195-0.013-0.234c0.026-0.039-0.104,0.027-0.234,0c-0.13-0.025-0.233,0.052-0.104,0.092c0.13,0.039,0.157,0.194,0.039,0.233c-0.117,0.039-0.559,0-0.702,0s-0.35,0.039-0.39-0.039c-0.039-0.078,0.118-0.129,0.208-0.129c0.091,0,0.363,0.012,0.467-0.13c0.104-0.143-0.13-0.169-0.233-0.169c-0.104,0-0.183-0.039-0.299-0.155c-0.118-0.117,0.078-0.195,0.052-0.247c-0.026-0.052-0.156-0.014-0.272-0.014c-0.117,0-0.299-0.09-0.299,0.014c0,0.104,0.143,0.402,0.052,0.337c-0.091-0.064-0.078-0.156-0.143-0.234c-0.065-0.078-0.168-0.065-0.299-0.052c-0.129,0.013-0.35,0.052-0.415,0.039c-0.064-0.013-0.013-0.013-0.156-0.078c-0.142-0.065-0.208-0.052-0.312-0.117C12.091,7.576,12.182,7.551,12,7.538c-0.181-0.013-0.168,0.09-0.35,0.065c-0.182-0.026-0.234,0.013-0.416,0c-0.182-0.013-0.272-0.026-0.299,0.065c-0.025,0.091-0.078,0.247-0.156,0.247c-0.077,0-0.169,0.091,0.078,0.104c0.247,0.013,0.105,0.129,0.325,0.117c0.221-0.013,0.416-0.013,0.468-0.117c0.052-0.104,0.091-0.104,0.117-0.065c0.025,0.039,0.22,0.272,0.22,0.272s0.131,0.104,0.183,0.13c0.051,0.026-0.052,0.143-0.156,0.078c-0.104-0.065-0.299-0.051-0.377-0.116c-0.078-0.065-0.429-0.065-0.52-0.052c-0.09,0.013-0.247-0.039-0.299-0.039c-0.051,0-0.221,0.13-0.221,0.13S10.532,8.252,10.494,8.2c-0.039-0.052-0.104,0.052-0.156,0.065c-0.052,0.013-0.208-0.104-0.364-0.052C9.818,8.265,9.87,8.317,9.649,8.304s-0.272-0.052-0.35-0.039C9.22,8.278,9.22,8.278,9.22,8.278S9.233,8.33,9.143,8.382C9.052,8.434,8.986,8.499,8.921,8.421C8.857,8.343,8.818,8.343,8.779,8.33c-0.04-0.013-0.118-0.078-0.286-0.04C8.324,8.33,8.064,8.239,8.013,8.239c-0.04,0-0.313-0.015-0.491-0.033c2.109-2.292,5.124-3.74,8.478-3.74c2.128,0,4.117,0.589,5.83,1.598c-0.117,0.072-0.319,0.06-0.388,0.023c-0.078-0.043-0.158-0.078-0.475-0.061c-0.317,0.018-0.665,0.122-0.595,0.226c0.072,0.104-0.142,0.165-0.197,0.113c-0.055-0.052-0.309,0.06-0.293,0.165c0.016,0.104-0.039,0.225-0.175,0.199c-0.134-0.027-0.229,0.06-0.237,0.146c-0.007,0.087-0.309,0.147-0.332,0.147c-0.024,0-0.412-0.008-0.27,0.095c0.097,0.069,0.15,0.027,0.27,0.052c0.119,0.026,0.214,0.217,0.277,0.243c0.062,0.026,0.15,0,0.189-0.052c0.04-0.052,0.095-0.234,0.095-0.234s0,0.173,0.097,0.208c0.095,0.035,0.331-0.026,0.395-0.017c0.064,0.008,0.437,0.061,0.538,0.112c0.104,0.052,0.356,0.087,0.428,0.199c0.071,0.113,0.08,0.503,0.119,0.546c0.04,0.043,0.174-0.139,0.205-0.182c0.031-0.044,0.198-0.018,0.254,0.042c0.056,0.061,0.182,0.208,0.175,0.269C21.9,8.365,21.877,8.459,21.83,8.425c-0.048-0.034-0.127-0.025-0.096-0.095c0.032-0.069,0.048-0.217-0.015-0.217c-0.064,0-0.119,0-0.119,0s-0.12-0.035-0.199,0.095s-0.015,0.26,0.04,0.26s0.184,0,0.184,0.034c0,0.035-0.136,0.139-0.128,0.2c0.009,0.061,0.11,0.268,0.144,0.312c0.031,0.043,0.197,0.086,0.244,0.096c0.049,0.008-0.111,0.017-0.07,0.077c0.04,0.061,0.102,0.208,0.189,0.243c0.087,0.035,0.333,0.19,0.363,0.26c0.032,0.069,0.222-0.052,0.262-0.061c0.04-0.008,0.032,0.182,0.143,0.191c0.11,0.008,0.15-0.018,0.245-0.096s0.072-0.182,0.079-0.26c0.009-0.078,0-0.138,0.104-0.113c0.104,0.026,0.158-0.018,0.15-0.104c-0.008-0.087-0.095-0.191,0.07-0.217c0.167-0.026,0.254-0.138,0.357-0.138c0.103,0,0.389,0.043,0.419,0c0.032-0.043,0.167-0.243,0.254-0.251c0.067-0.007,0.224-0.021,0.385-0.042c1.582,1.885,2.561,4.284,2.673,6.905c-0.118,0.159-0.012,0.305,0.021,0.408c0.001,0.03,0.005,0.058,0.005,0.088c0,0.136-0.016,0.269-0.021,0.404C27.512,16.406,27.512,16.408,27.51,16.41zM17.794,12.084c-0.064,0.013-0.169-0.052-0.169-0.143s-0.091,0.169-0.04,0.247c0.053,0.078-0.104,0.169-0.155,0.169s-0.091-0.116-0.078-0.233c0.014-0.117-0.077-0.221-0.221-0.208c-0.143,0.014-0.208,0.13-0.259,0.169c-0.053,0.039-0.053,0.259-0.04,0.312s0.013,0.235-0.116,0.221c-0.118-0.013-0.092-0.233-0.079-0.312c0.014-0.078-0.039-0.273,0.014-0.376c0.053-0.104,0.207-0.143,0.312-0.156s0.324,0.065,0.363,0.052c0.04-0.014,0.222-0.014,0.312,0C17.729,11.837,17.858,12.071,17.794,12.084zM18.027,12.123c0.04,0.026,0.311-0.039,0.364,0.026c0.051,0.065-0.054,0.078-0.183,0.13c-0.129,0.052-0.169,0.039-0.221,0.104s-0.221,0.09-0.299,0.168c-0.078,0.079-0.217,0.125-0.246,0.065c-0.04-0.078,0.013-0.039,0.025-0.078c0.013-0.039,0.245-0.129,0.245-0.129S17.988,12.097,18.027,12.123zM16.988,11.668c-0.038,0.013-0.182-0.026-0.3-0.026c-0.116,0-0.091-0.078-0.143-0.064c-0.051,0.013-0.168,0.039-0.247,0.078c-0.078,0.039-0.208,0.03-0.208-0.04c0-0.104,0.052-0.078,0.221-0.143c0.169-0.065,0.352-0.247,0.429-0.169c0.078,0.078,0.221,0.169,0.312,0.182C17.144,11.5,17.026,11.655,16.988,11.668zM15.659,7.637c-0.079,0.026-0.347,0.139-0.321,0.199c0.01,0.023,0.078,0.069,0.19,0.052c0.113-0.018,0.276-0.035,0.355-0.043c0.078-0.009,0.095-0.139,0.009-0.147C15.805,7.689,15.736,7.611,15.659,7.637zM14.698,7.741c-0.061,0.026-0.243-0.043-0.338,0.018c-0.061,0.038-0.026,0.164,0.07,0.172c0.095,0.009,0.259-0.06,0.276-0.008c0.018,0.052,0.078,0.286,0.234,0.208c0.156-0.078,0.147-0.147,0.19-0.156c0.043-0.009-0.008-0.199-0.078-0.243C14.983,7.689,14.758,7.715,14.698,7.741zM14.385,7.005c0.017,0.044-0.008,0.078,0.113,0.095c0.121,0.018,0.173,0.035,0.243,0.035c0.069,0,0.042-0.113-0.018-0.19c-0.061-0.078-0.043-0.069-0.199-0.113c-0.156-0.043-0.312-0.043-0.416-0.035c-0.104,0.009-0.217-0.017-0.243,0.104c-0.013,0.062,0.07,0.112,0.174,0.112S14.368,6.962,14.385,7.005zM14.611,7.481c0.043,0.095,0.043,0.051,0.165,0.061C14.896,7.551,14.991,7.421,15,7.378c0.009-0.044-0.061-0.13-0.225-0.113c-0.165,0.017-0.667-0.026-0.736,0.034c-0.066,0.058,0,0.233-0.026,0.251c-0.026,0.017,0.009,0.095,0.077,0.078c0.069-0.017,0.104-0.182,0.157-0.182C14.299,7.447,14.568,7.386,14.611,7.481zM12.982,7.126c0.052,0.043,0.183,0.008,0.173-0.035c-0.008-0.043,0.053-0.217-0.051-0.225C13,6.858,12.854,6.962,12.697,7.014c-0.101,0.033-0.078,0.13-0.009,0.13S12.931,7.083,12.982,7.126zM13.72,7.282c-0.087,0.043-0.114,0.069-0.191,0.052c-0.078-0.017-0.078-0.156-0.217-0.13c-0.138,0.026-0.164,0.104-0.207,0.139s-0.139,0.061-0.173,0.043c-0.034-0.017-0.234-0.129-0.234-0.129s-0.416-0.018-0.433-0.07c-0.017-0.052-0.086-0.138-0.277-0.121s-0.52,0.13-0.572,0.13c-0.052,0,0.062,0.104-0.009,0.104c-0.069,0-0.155-0.008-0.181,0.069c-0.018,0.053,0.078,0.052,0.189,0.052c0.112,0,0.295,0,0.347-0.026c0.052-0.026,0.312-0.087,0.303-0.009c-0.009,0.079,0.104,0.199,0.164,0.182c0.061-0.017,0.183-0.13,0.243-0.086c0.061,0.043,0.07,0.146,0.13,0.173c0.061,0.025,0.226,0.025,0.304,0c0.077-0.027,0.294-0.027,0.389-0.009c0.095,0.018,0.373,0.069,0.399,0.018c0.026-0.053,0.104-0.061,0.112-0.113s0.051-0.216,0.051-0.216S13.806,7.239,13.72,7.282zM18.105,16.239c-0.119,0.021-0.091,0.252,0.052,0.21C18.3,16.407,18.223,16.217,18.105,16.239zM19.235,15.929c-0.104-0.026-0.221,0-0.299,0.013c-0.078,0.013-0.299,0.208-0.299,0.208s0.143,0.026,0.233,0.026c0.092,0,0.144,0.051,0.221,0.09c0.078,0.04,0.221-0.052,0.272-0.052c0.053,0,0.118,0.156,0.131-0.013C19.508,16.032,19.339,15.955,19.235,15.929zM15.616,7.507c-0.043-0.104-0.259-0.139-0.304-0.035C15.274,7.563,15.659,7.611,15.616,7.507zM18.093,15.292c0.143-0.026,0.064-0.144-0.053-0.13C17.922,15.175,17.949,15.318,18.093,15.292zM19.82,16.095c-0.119,0.022-0.092,0.253,0.051,0.211C20.015,16.264,19.937,16.074,19.82,16.095zM18.247,15.708c-0.09,0.013-0.285-0.09-0.389-0.182c-0.104-0.091-0.299-0.091-0.377-0.091c-0.077,0-0.39,0.091-0.39,0.091c-0.013,0.13,0.117,0.091,0.273,0.091s0.429-0.026,0.479,0.039c0.053,0.064,0.286,0.168,0.352,0.221c0.064,0.052,0.272,0.065,0.285,0.013S18.338,15.695,18.247,15.708zM16.698,7.412c-0.13-0.009-0.295-0.009-0.399,0c-0.104,0.008-0.182-0.069-0.26-0.113c-0.077-0.043-0.251-0.182-0.354-0.199c-0.104-0.017-0.086-0.017-0.303-0.069c-0.11-0.027-0.294-0.061-0.294-0.086c0-0.026-0.052,0.121,0.043,0.165c0.095,0.043,0.251,0.121,0.363,0.164c0.114,0.043,0.329,0.052,0.399,0.139c0.069,0.086,0.303,0.156,0.303,0.156l0.277,0.026c0,0,0.191-0.043,0.39-0.026c0.199,0.017,0.493,0.043,0.659,0.035c0.163-0.008,0.189-0.061,0.208-0.095c0.016-0.035-0.304-0.104-0.383-0.095C17.271,7.42,16.827,7.42,16.698,7.412zM17.182,9.404c-0.034,0.039,0.157,0.095,0.191,0.043C17.407,9.396,17.271,9.309,17.182,9.404zM17.764,9.585c0.086-0.035,0.043-0.139-0.079-0.104C17.547,9.521,17.676,9.62,17.764,9.585z");
  }
});

/***/ }),

/***/ "./src/shape/icon/GlobeAlt.js":
/*!************************************!*\
  !*** ./src/shape/icon/GlobeAlt.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.GlobeAlt();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.GlobeAlt = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.GlobeAlt.prototype */
{

  NAME: "draw2d.shape.icon.GlobeAlt",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM27.436,17.39c0.001,0.002,0.004,0.002,0.005,0.004c-0.022,0.187-0.054,0.37-0.085,0.554c-0.015-0.012-0.034-0.025-0.047-0.036c-0.103-0.09-0.254-0.128-0.318-0.115c-0.157,0.032,0.229,0.305,0.267,0.342c0.009,0.009,0.031,0.03,0.062,0.058c-1.029,5.312-5.709,9.338-11.319,9.338c-4.123,0-7.736-2.18-9.776-5.441c0.123-0.016,0.24-0.016,0.28-0.076c0.051-0.077,0.102-0.241,0.178-0.331c0.077-0.089,0.165-0.229,0.127-0.292c-0.039-0.064,0.101-0.344,0.088-0.419c-0.013-0.076-0.127-0.256,0.064-0.407s0.394-0.382,0.407-0.444c0.012-0.063,0.166-0.331,0.152-0.458c-0.012-0.127-0.152-0.28-0.24-0.318c-0.09-0.037-0.28-0.05-0.356-0.151c-0.077-0.103-0.292-0.203-0.368-0.178c-0.076,0.025-0.204,0.05-0.305-0.015c-0.102-0.062-0.267-0.139-0.33-0.189c-0.065-0.05-0.229-0.088-0.305-0.088c-0.077,0-0.065-0.052-0.178,0.101c-0.114,0.153,0,0.204-0.204,0.177c-0.204-0.023,0.025-0.036,0.141-0.189c0.113-0.152-0.013-0.242-0.141-0.203c-0.126,0.038-0.038,0.115-0.241,0.153c-0.203,0.036-0.203-0.09-0.076-0.115s0.355-0.139,0.355-0.19c0-0.051-0.025-0.191-0.127-0.191s-0.077-0.126-0.229-0.291c-0.092-0.101-0.196-0.164-0.299-0.204c-0.09-0.579-0.15-1.167-0.15-1.771c0-2.844,1.039-5.446,2.751-7.458c0.024-0.02,0.048-0.034,0.069-0.036c0.084-0.009,0.31-0.025,0.51-0.059c0.202-0.034,0.418-0.161,0.489-0.153c0.069,0.008,0.241,0.008,0.186-0.042C8.417,8.2,8.339,8.082,8.223,8.082S8.215,7.896,8.246,7.896c0.03,0,0.186,0.025,0.178,0.11C8.417,8.091,8.471,8.2,8.625,8.167c0.156-0.034,0.132-0.162,0.102-0.195C8.695,7.938,8.672,7.853,8.642,7.794c-0.031-0.06-0.023-0.136,0.14-0.153C8.944,7.625,9.168,7.708,9.16,7.573s0-0.28,0.046-0.356C9.253,7.142,9.354,7.09,9.299,7.065C9.246,7.04,9.176,7.099,9.121,6.972c-0.054-0.127,0.047-0.22,0.108-0.271c0.02-0.015,0.067-0.06,0.124-0.112C11.234,5.257,13.524,4.466,16,4.466c3.213,0,6.122,1.323,8.214,3.45c-0.008,0.022-0.01,0.052-0.031,0.056c-0.077,0.013-0.166,0.063-0.179-0.051c-0.013-0.114-0.013-0.331-0.102-0.203c-0.089,0.127-0.127,0.127-0.127,0.191c0,0.063,0.076,0.127,0.051,0.241C23.8,8.264,23.8,8.341,23.84,8.341c0.036,0,0.126-0.115,0.239-0.141c0.116-0.025,0.319-0.088,0.332,0.026c0.013,0.115,0.139,0.152,0.013,0.203c-0.128,0.051-0.267,0.026-0.293-0.051c-0.025-0.077-0.114-0.077-0.203-0.013c-0.088,0.063-0.279,0.292-0.279,0.292s-0.306,0.139-0.343,0.114c-0.04-0.025,0.101-0.165,0.203-0.228c0.102-0.064,0.178-0.204,0.14-0.242c-0.038-0.038-0.088-0.279-0.063-0.343c0.025-0.063,0.139-0.152,0.013-0.216c-0.127-0.063-0.217-0.14-0.318-0.178s-0.216,0.152-0.305,0.204c-0.089,0.051-0.076,0.114-0.191,0.127c-0.114,0.013-0.189,0.165,0,0.254c0.191,0.089,0.255,0.152,0.204,0.204c-0.051,0.051-0.267-0.025-0.267-0.025s-0.165-0.076-0.268-0.076c-0.101,0-0.229-0.063-0.33-0.076c-0.102-0.013-0.306-0.013-0.355,0.038c-0.051,0.051-0.179,0.203-0.28,0.152c-0.101-0.051-0.101-0.102-0.241-0.051c-0.14,0.051-0.279-0.038-0.355,0.038c-0.077,0.076-0.013,0.076-0.255,0c-0.241-0.076-0.189,0.051-0.419,0.089s-0.368-0.038-0.432,0.038c-0.064,0.077-0.153,0.217-0.19,0.127c-0.038-0.088,0.126-0.241,0.062-0.292c-0.062-0.051-0.33-0.025-0.367,0.013c-0.039,0.038-0.014,0.178,0.011,0.229c0.026,0.05,0.064,0.254-0.011,0.216c-0.077-0.038-0.064-0.166-0.141-0.152c-0.076,0.013-0.165,0.051-0.203,0.077c-0.038,0.025-0.191,0.025-0.229,0.076c-0.037,0.051,0.014,0.191-0.051,0.203c-0.063,0.013-0.114,0.064-0.254-0.025c-0.14-0.089-0.14-0.038-0.178-0.012c-0.038,0.025-0.216,0.127-0.229,0.012c-0.013-0.114,0.025-0.152-0.089-0.229c-0.115-0.076-0.026-0.076,0.127-0.025c0.152,0.05,0.343,0.075,0.622-0.013c0.28-0.089,0.395-0.127,0.28-0.178c-0.115-0.05-0.229-0.101-0.406-0.127c-0.179-0.025-0.42-0.025-0.7-0.127c-0.279-0.102-0.343-0.14-0.457-0.165c-0.115-0.026-0.813-0.14-1.132-0.089c-0.317,0.051-1.193,0.28-1.245,0.318s-0.128,0.19-0.292,0.318c-0.165,0.127-0.47,0.419-0.712,0.47c-0.241,0.051-0.521,0.254-0.521,0.305c0,0.051,0.101,0.242,0.076,0.28c-0.025,0.038,0.05,0.229,0.191,0.28c0.139,0.05,0.381,0.038,0.393-0.039c0.014-0.076,0.204-0.241,0.217-0.127c0.013,0.115,0.14,0.292,0.114,0.368c-0.025,0.077,0,0.153,0.09,0.14c0.088-0.012,0.559-0.114,0.559-0.114s0.153-0.064,0.127-0.166c-0.026-0.101,0.166-0.241,0.203-0.279c0.038-0.038,0.178-0.191,0.014-0.241c-0.167-0.051-0.293-0.064-0.115-0.216s0.292,0,0.521-0.229c0.229-0.229-0.051-0.292,0.191-0.305c0.241-0.013,0.496-0.025,0.444,0.051c-0.05,0.076-0.342,0.242-0.508,0.318c-0.166,0.077-0.14,0.216-0.076,0.292c0.063,0.076,0.09,0.254,0.204,0.229c0.113-0.025,0.254-0.114,0.38-0.101c0.128,0.012,0.383-0.013,0.42-0.013c0.039,0,0.216,0.178,0.114,0.203c-0.101,0.025-0.229,0.013-0.445,0.025c-0.215,0.013-0.456,0.013-0.456,0.051c0,0.039,0.292,0.127,0.19,0.191c-0.102,0.063-0.203-0.013-0.331-0.026c-0.127-0.012-0.203,0.166-0.241,0.267c-0.039,0.102,0.063,0.28-0.127,0.216c-0.191-0.063-0.331-0.063-0.381-0.038c-0.051,0.025-0.203,0.076-0.331,0.114c-0.126,0.038-0.076-0.063-0.242-0.063c-0.164,0-0.164,0-0.164,0l-0.103,0.013c0,0-0.101-0.063-0.114-0.165c-0.013-0.102,0.05-0.216-0.013-0.241c-0.064-0.026-0.292,0.012-0.33,0.088c-0.038,0.076-0.077,0.216-0.026,0.28c0.052,0.063,0.204,0.19,0.064,0.152c-0.14-0.038-0.317-0.051-0.419,0.026c-0.101,0.076-0.279,0.241-0.279,0.241s-0.318,0.025-0.318,0.102c0,0.077,0,0.178-0.114,0.191c-0.115,0.013-0.268,0.05-0.42,0.076c-0.153,0.025-0.139,0.088-0.317,0.102s-0.204,0.089-0.038,0.114c0.165,0.025,0.418,0.127,0.431,0.241c0.014,0.114-0.013,0.242-0.076,0.356c-0.043,0.079-0.305,0.026-0.458,0.026c-0.152,0-0.456-0.051-0.584,0c-0.127,0.051-0.102,0.305-0.064,0.419c0.039,0.114-0.012,0.178-0.063,0.216c-0.051,0.038-0.065,0.152,0,0.204c0.063,0.051,0.114,0.165,0.166,0.178c0.051,0.013,0.215-0.038,0.279,0.025c0.064,0.064,0.127,0.216,0.165,0.178c0.039-0.038,0.089-0.203,0.153-0.166c0.064,0.039,0.216-0.012,0.331-0.025s0.177-0.14,0.292-0.204c0.114-0.063,0.05-0.063,0.013-0.14c-0.038-0.076,0.114-0.165,0.204-0.254c0.088-0.089,0.253-0.013,0.292-0.115c0.038-0.102,0.051-0.279,0.151-0.267c0.103,0.013,0.243,0.076,0.331,0.076c0.089,0,0.279-0.14,0.332-0.165c0.05-0.025,0.241-0.013,0.267,0.102c0.025,0.114,0.241,0.254,0.292,0.279c0.051,0.025,0.381,0.127,0.433,0.165c0.05,0.038,0.126,0.153,0.152,0.254c0.025,0.102,0.114,0.102,0.128,0.013c0.012-0.089-0.065-0.254,0.025-0.242c0.088,0.013,0.191-0.026,0.191-0.026s-0.243-0.165-0.331-0.203c-0.088-0.038-0.255-0.114-0.331-0.241c-0.076-0.127-0.267-0.153-0.254-0.279c0.013-0.127,0.191-0.051,0.292,0.051c0.102,0.102,0.356,0.241,0.445,0.33c0.088,0.089,0.229,0.127,0.267,0.242c0.039,0.114,0.152,0.241,0.19,0.292c0.038,0.051,0.165,0.331,0.204,0.394c0.038,0.063,0.165-0.012,0.229-0.063c0.063-0.051,0.179-0.076,0.191-0.178c0.013-0.102-0.153-0.178-0.203-0.216c-0.051-0.038,0.127-0.076,0.191-0.127c0.063-0.05,0.177-0.14,0.228-0.063c0.051,0.077,0.026,0.381,0.051,0.432c0.025,0.051,0.279,0.127,0.331,0.191c0.05,0.063,0.267,0.089,0.304,0.051c0.039-0.038,0.242,0.026,0.294,0.038c0.049,0.013,0.202-0.025,0.304-0.05c0.103-0.025,0.204-0.102,0.191,0.063c-0.013,0.165-0.051,0.419-0.179,0.546c-0.127,0.127-0.076,0.191-0.202,0.191c-0.06,0-0.113,0-0.156,0.021c-0.041-0.065-0.098-0.117-0.175-0.097c-0.152,0.038-0.344,0.038-0.47,0.19c-0.128,0.153-0.178,0.165-0.204,0.114c-0.025-0.051,0.369-0.267,0.317-0.331c-0.05-0.063-0.355-0.038-0.521-0.038c-0.166,0-0.305-0.102-0.433-0.127c-0.126-0.025-0.292,0.127-0.418,0.254c-0.128,0.127-0.216,0.038-0.331,0.038c-0.115,0-0.331-0.165-0.331-0.165s-0.216-0.089-0.305-0.089c-0.088,0-0.267-0.165-0.318-0.165c-0.05,0-0.19-0.115-0.088-0.166c0.101-0.05,0.202,0.051,0.101-0.229c-0.101-0.279-0.33-0.216-0.419-0.178c-0.088,0.039-0.724,0.025-0.775,0.025c-0.051,0-0.419,0.127-0.533,0.178c-0.116,0.051-0.318,0.115-0.369,0.14c-0.051,0.025-0.318-0.051-0.433,0.013c-0.151,0.084-0.291,0.216-0.33,0.216c-0.038,0-0.153,0.089-0.229,0.28c-0.077,0.19,0.013,0.355-0.128,0.419c-0.139,0.063-0.394,0.204-0.495,0.305c-0.102,0.101-0.229,0.458-0.355,0.623c-0.127,0.165,0,0.317,0.025,0.419c0.025,0.101,0.114,0.292-0.025,0.471c-0.14,0.178-0.127,0.266-0.191,0.279c-0.063,0.013,0.063,0.063,0.088,0.19c0.025,0.128-0.114,0.255,0.128,0.369c0.241,0.113,0.355,0.217,0.418,0.367c0.064,0.153,0.382,0.407,0.382,0.407s0.229,0.205,0.344,0.293c0.114,0.089,0.152,0.038,0.177-0.05c0.025-0.09,0.178-0.104,0.355-0.104c0.178,0,0.305,0.04,0.483,0.014c0.178-0.025,0.356-0.141,0.42-0.166c0.063-0.025,0.279-0.164,0.443-0.063c0.166,0.103,0.141,0.241,0.23,0.332c0.088,0.088,0.24,0.037,0.355-0.051c0.114-0.09,0.064-0.052,0.203,0.025c0.14,0.075,0.204,0.151,0.077,0.267c-0.128,0.113-0.051,0.293-0.128,0.47c-0.076,0.178-0.063,0.203,0.077,0.278c0.14,0.076,0.394,0.548,0.47,0.638c0.077,0.088-0.025,0.342,0.064,0.495c0.089,0.151,0.178,0.254,0.077,0.331c-0.103,0.075-0.28,0.216-0.292,0.47s0.051,0.431,0.102,0.521s0.177,0.331,0.241,0.419c0.064,0.089,0.14,0.305,0.152,0.445c0.013,0.14-0.024,0.306,0.039,0.381c0.064,0.076,0.102,0.191,0.216,0.292c0.115,0.103,0.152,0.318,0.152,0.318s0.039,0.089,0.051,0.229c0.012,0.14,0.025,0.228,0.152,0.292c0.126,0.063,0.215,0.076,0.28,0.013c0.063-0.063,0.381-0.077,0.546-0.063c0.165,0.013,0.355-0.075,0.521-0.19s0.407-0.419,0.496-0.508c0.089-0.09,0.292-0.255,0.268-0.356c-0.025-0.101-0.077-0.203,0.024-0.254c0.102-0.052,0.344-0.152,0.356-0.229c0.013-0.077-0.09-0.395-0.115-0.457c-0.024-0.064,0.064-0.18,0.165-0.306c0.103-0.128,0.421-0.216,0.471-0.267c0.051-0.053,0.191-0.267,0.217-0.433c0.024-0.167-0.051-0.369,0-0.457c0.05-0.09,0.013-0.165-0.103-0.268c-0.114-0.102-0.089-0.407-0.127-0.457c-0.037-0.051-0.013-0.319,0.063-0.345c0.076-0.023,0.242-0.279,0.344-0.393c0.102-0.114,0.394-0.47,0.534-0.496c0.139-0.025,0.355-0.229,0.368-0.343c0.013-0.115,0.38-0.547,0.394-0.635c0.013-0.09,0.166-0.42,0.102-0.497c-0.062-0.076-0.559,0.115-0.622,0.141c-0.064,0.025-0.241,0.127-0.446,0.113c-0.202-0.013-0.114-0.177-0.127-0.254c-0.012-0.076-0.228-0.368-0.279-0.381c-0.051-0.012-0.203-0.166-0.267-0.317c-0.063-0.153-0.152-0.343-0.254-0.458c-0.102-0.114-0.165-0.38-0.268-0.559c-0.101-0.178-0.189-0.407-0.279-0.572c-0.021-0.041-0.045-0.079-0.067-0.117c0.118-0.029,0.289-0.082,0.31-0.009c0.024,0.088,0.165,0.279,0.19,0.419s0.165,0.089,0.178,0.216c0.014,0.128,0.14,0.433,0.19,0.47c0.052,0.038,0.28,0.242,0.318,0.318c0.038,0.076,0.089,0.178,0.127,0.369c0.038,0.19,0.076,0.444,0.179,0.482c0.102,0.038,0.444-0.064,0.508-0.102s0.482-0.242,0.635-0.255c0.153-0.012,0.179-0.115,0.368-0.152c0.191-0.038,0.331-0.177,0.458-0.28c0.127-0.101,0.28-0.355,0.33-0.444c0.052-0.088,0.179-0.152,0.115-0.253c-0.063-0.103-0.331-0.254-0.433-0.268c-0.102-0.012-0.089-0.178-0.152-0.178s-0.051,0.088-0.178,0.153c-0.127,0.063-0.255,0.19-0.344,0.165s0.026-0.089-0.113-0.203s-0.192-0.14-0.192-0.228c0-0.089-0.278-0.255-0.304-0.382c-0.026-0.127,0.19-0.305,0.254-0.19c0.063,0.114,0.115,0.292,0.279,0.368c0.165,0.076,0.318,0.204,0.395,0.229c0.076,0.025,0.267-0.14,0.33-0.114c0.063,0.024,0.191,0.253,0.306,0.292c0.113,0.038,0.495,0.051,0.559,0.051s0.33,0.013,0.381-0.063c0.051-0.076,0.089-0.076,0.153-0.076c0.062,0,0.177,0.229,0.267,0.254c0.089,0.025,0.254,0.013,0.241,0.179c-0.012,0.164,0.076,0.305,0.165,0.317c0.09,0.012,0.293-0.191,0.293-0.191s0,0.318-0.012,0.433c-0.014,0.113,0.139,0.534,0.139,0.534s0.19,0.393,0.241,0.482s0.267,0.355,0.267,0.47c0,0.115,0.025,0.293,0.103,0.293c0.076,0,0.152-0.203,0.24-0.331c0.091-0.126,0.116-0.305,0.153-0.432c0.038-0.127,0.038-0.356,0.038-0.444c0-0.09,0.075-0.166,0.255-0.242c0.178-0.076,0.304-0.292,0.456-0.407c0.153-0.115,0.141-0.305,0.446-0.305c0.305,0,0.278,0,0.355-0.077c0.076-0.076,0.151-0.127,0.19,0.013c0.038,0.14,0.254,0.343,0.292,0.394c0.038,0.052,0.114,0.191,0.103,0.344c-0.013,0.152,0.012,0.33,0.075,0.33s0.191-0.216,0.191-0.216s0.279-0.189,0.267,0.013c-0.014,0.203,0.025,0.419,0.025,0.545c0,0.053,0.042,0.135,0.088,0.21c-0.005,0.059-0.004,0.119-0.009,0.178C27.388,17.153,27.387,17.327,27.436,17.39zM20.382,12.064c0.076,0.05,0.102,0.127,0.152,0.203c0.052,0.076,0.14,0.05,0.203,0.114c0.063,0.064-0.178,0.14-0.075,0.216c0.101,0.077,0.151,0.381,0.165,0.458c0.013,0.076-0.279,0.114-0.369,0.102c-0.089-0.013-0.354-0.102-0.445-0.127c-0.089-0.026-0.139-0.343-0.025-0.331c0.116,0.013,0.141-0.025,0.267-0.139c0.128-0.115-0.189-0.166-0.278-0.191c-0.089-0.025-0.268-0.305-0.331-0.394c-0.062-0.089-0.014-0.228,0.141-0.331c0.076-0.051,0.279,0.063,0.381,0c0.101-0.063,0.203-0.14,0.241-0.165c0.039-0.025,0.293,0.038,0.33,0.114c0.039,0.076,0.191,0.191,0.141,0.229c-0.052,0.038-0.281,0.076-0.356,0c-0.075-0.077-0.255,0.012-0.268,0.152C20.242,12.115,20.307,12.013,20.382,12.064zM16.875,12.28c-0.077-0.025,0.025-0.178,0.102-0.229c0.075-0.051,0.164-0.178,0.241-0.305c0.076-0.127,0.178-0.14,0.241-0.127c0.063,0.013,0.203,0.241,0.241,0.318c0.038,0.076,0.165-0.026,0.217-0.051c0.05-0.025,0.127-0.102,0.14-0.165s0.127-0.102,0.254-0.102s0.013,0.102-0.076,0.127c-0.09,0.025-0.038,0.077,0.113,0.127c0.153,0.051,0.293,0.191,0.459,0.279c0.165,0.089,0.19,0.267,0.088,0.292c-0.101,0.025-0.406,0.051-0.521,0.038c-0.114-0.013-0.254-0.127-0.419-0.153c-0.165-0.025-0.369-0.013-0.433,0.077s-0.292,0.05-0.395,0.05c-0.102,0-0.228,0.127-0.253,0.077C16.875,12.534,16.951,12.306,16.875,12.28zM17.307,9.458c0.063-0.178,0.419,0.038,0.355,0.127C17.599,9.675,17.264,9.579,17.307,9.458zM17.802,18.584c0.063,0.102-0.14,0.431-0.254,0.407c-0.113-0.027-0.076-0.318-0.038-0.382C17.548,18.545,17.769,18.529,17.802,18.584zM13.189,12.674c0.025-0.051-0.039-0.153-0.127-0.013C13.032,12.71,13.164,12.725,13.189,12.674zM20.813,8.035c0.141,0.076,0.339,0.107,0.433,0.013c0.076-0.076,0.013-0.204-0.05-0.216c-0.064-0.013-0.104-0.115,0.062-0.203c0.165-0.089,0.343-0.204,0.534-0.229c0.19-0.025,0.622-0.038,0.774,0c0.152,0.039,0.382-0.166,0.445-0.254s-0.203-0.152-0.279-0.051c-0.077,0.102-0.444,0.076-0.521,0.051c-0.076-0.025-0.686,0.102-0.812,0.102c-0.128,0-0.179,0.152-0.356,0.229c-0.179,0.076-0.42,0.191-0.509,0.229c-0.088,0.038-0.177,0.19-0.101,0.216C20.509,7.947,20.674,7.959,20.813,8.035zM14.142,12.674c0.064-0.089-0.051-0.217-0.114-0.217c-0.12,0-0.178,0.191-0.103,0.254C14.002,12.776,14.078,12.763,14.142,12.674zM14.714,13.017c0.064,0.025,0.114,0.102,0.165,0.114c0.052,0.013,0.217,0,0.167-0.127s-0.167-0.127-0.204-0.127c-0.038,0-0.203-0.038-0.267,0C14.528,12.905,14.65,12.992,14.714,13.017zM11.308,10.958c0.101,0.013,0.217-0.063,0.305-0.101c0.088-0.038,0.216-0.114,0.216-0.229c0-0.114-0.025-0.216-0.077-0.267c-0.051-0.051-0.14-0.064-0.216-0.051c-0.115,0.02-0.127,0.14-0.203,0.14c-0.076,0-0.165,0.025-0.14,0.114s0.077,0.152,0,0.19C11.117,10.793,11.205,10.946,11.308,10.958zM11.931,10.412c0.127,0.051,0.394,0.102,0.292,0.153c-0.102,0.051-0.28,0.19-0.305,0.267s0.216,0.153,0.216,0.153s-0.077,0.089-0.013,0.114c0.063,0.025,0.102-0.089,0.203-0.089c0.101,0,0.304,0.063,0.406,0.063c0.103,0,0.267-0.14,0.254-0.229c-0.013-0.089-0.14-0.229-0.254-0.28c-0.113-0.051-0.241-0.28-0.317-0.331c-0.076-0.051,0.076-0.178-0.013-0.267c-0.09-0.089-0.153-0.076-0.255-0.14c-0.102-0.063-0.191,0.013-0.254,0.089c-0.063,0.076-0.14-0.013-0.217,0.012c-0.102,0.035-0.063,0.166-0.012,0.229C11.714,10.221,11.804,10.361,11.931,10.412zM24.729,17.198c-0.083,0.037-0.153,0.47,0,0.521c0.152,0.052,0.241-0.202,0.191-0.267C24.868,17.39,24.843,17.147,24.729,17.198zM20.114,20.464c-0.159-0.045-0.177,0.166-0.304,0.306c-0.128,0.141-0.267,0.254-0.317,0.241c-0.052-0.013-0.331,0.089-0.242,0.279c0.089,0.191,0.076,0.382-0.013,0.472c-0.089,0.088,0.076,0.342,0.052,0.482c-0.026,0.139,0.037,0.229,0.215,0.229s0.242-0.064,0.318-0.229c0.076-0.166,0.088-0.331,0.164-0.47c0.077-0.141,0.141-0.434,0.179-0.51c0.038-0.075,0.114-0.316,0.102-0.457C20.254,20.669,20.204,20.489,20.114,20.464zM10.391,8.802c-0.069-0.06-0.229-0.102-0.306-0.11c-0.076-0.008-0.152,0.06-0.321,0.06c-0.168,0-0.279,0.067-0.347,0C9.349,8.684,9.068,8.65,9.042,8.692C9.008,8.749,8.941,8.751,9.008,8.87c0.069,0.118,0.12,0.186,0.179,0.178s0.262-0.017,0.288,0.051C9.5,9.167,9.569,9.226,9.712,9.184c0.145-0.042,0.263-0.068,0.296-0.119c0.033-0.051,0.263-0.059,0.263-0.059S10.458,8.861,10.391,8.802z");
  }
});

/***/ }),

/***/ "./src/shape/icon/GlobeAlt2.js":
/*!*************************************!*\
  !*** ./src/shape/icon/GlobeAlt2.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.GlobeAlt2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.GlobeAlt2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.GlobeAlt2.prototype */
{

  NAME: "draw2d.shape.icon.GlobeAlt2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM8.251,7.48c0.122,0.055,0.255,0.104,0.28,0.137C8.57,7.668,8.621,7.823,8.557,7.861C8.492,7.9,8.39,7.887,8.376,7.771c-0.013-0.115-0.026-0.128-0.18-0.18c-0.022-0.007-0.035-0.01-0.051-0.015C8.18,7.544,8.216,7.512,8.251,7.48zM7.733,7.974c0.031,0.087,0.113,0.125,0,0.17C7.673,8.168,7.611,8.172,7.559,8.165C7.617,8.102,7.672,8.035,7.733,7.974zM16,27.533C9.639,27.533,4.466,22.36,4.466,16c0-0.085,0.011-0.168,0.013-0.254c0.004-0.003,0.008-0.006,0.012-0.009c0.129-0.102,0.283-0.359,0.334-0.45c0.052-0.089,0.181-0.154,0.116-0.256c-0.059-0.096-0.292-0.23-0.407-0.261c0.01-0.099,0.032-0.195,0.045-0.294c0.063,0.077,0.137,0.17,0.208,0.194c0.115,0.038,0.501,0.052,0.566,0.052c0.063,0,0.334,0.014,0.386-0.064c0.051-0.077,0.09-0.077,0.154-0.077c0.064,0,0.18,0.231,0.271,0.257c0.089,0.026,0.257,0.013,0.244,0.181c-0.012,0.166,0.077,0.309,0.167,0.321c0.09,0.013,0.296-0.194,0.296-0.194s0,0.322-0.012,0.438C6.846,15.698,7,16.124,7,16.124s0.193,0.397,0.244,0.488c0.052,0.09,0.27,0.36,0.27,0.476c0,0.117,0.026,0.297,0.104,0.297s0.155-0.206,0.244-0.335c0.091-0.128,0.117-0.31,0.155-0.438c0.039-0.129,0.039-0.36,0.039-0.45c0-0.091,0.076-0.168,0.257-0.245c0.181-0.077,0.309-0.296,0.463-0.412c0.155-0.116,0.142-0.309,0.452-0.309c0.308,0,0.282,0,0.36-0.078c0.077-0.077,0.154-0.128,0.192,0.013c0.039,0.142,0.257,0.347,0.296,0.399c0.039,0.052,0.116,0.193,0.104,0.348c-0.013,0.153,0.012,0.334,0.077,0.334c0.064,0,0.193-0.219,0.193-0.219s0.283-0.192,0.27,0.014c-0.014,0.205,0.025,0.425,0.025,0.552c0,0.13,0.232,0.438,0.232,0.362c0-0.079,0.103-0.296,0.103-0.413c0-0.114,0.064-0.063,0.231,0.051c0.167,0.116,0.283,0.349,0.283,0.349s0.168,0.154,0.193,0.219c0.026,0.064,0.206-0.025,0.244-0.104c0.039-0.076,0.065-0.115,0.167-0.141c0.104-0.026,0.231-0.026,0.271-0.168c0.039-0.142,0.154-0.308,0-0.502c-0.154-0.193-0.232-0.321-0.347-0.412c-0.117-0.09-0.206-0.322-0.206-0.322s0.244-0.218,0.321-0.296c0.079-0.077,0.193-0.025,0.207,0.064c0.013,0.091-0.115,0.168-0.141,0.361c-0.026,0.192,0.154,0.257,0.206,0.192c0.051-0.065,0.18-0.219,0.18-0.257c0-0.039-0.089-0.026-0.102-0.167c-0.013-0.142,0.166-0.245,0.23-0.207c0.066,0.039,0.477-0.051,0.67-0.154s0.308-0.322,0.425-0.412c0.116-0.089,0.515-0.386,0.489-0.527c-0.026-0.142,0.012-0.334-0.09-0.515c-0.103-0.18-0.232-0.295-0.283-0.373c-0.051-0.077,0.219-0.09,0.347-0.206c0.129-0.116,0-0.219-0.064-0.206c-0.064,0.013-0.232,0.052-0.296,0.039c-0.064-0.013-0.103-0.077-0.206-0.155c-0.102-0.077,0.026-0.192,0.091-0.179c0.064,0.013,0.23-0.129,0.308-0.193c0.077-0.064,0.193-0.115,0.154-0.051c-0.038,0.064-0.128,0.296-0.026,0.309c0.104,0.013,0.348-0.193,0.388-0.18c0.038,0.013,0.102,0.18,0.064,0.257c-0.039,0.077-0.039,0.206,0.013,0.193c0.051-0.013,0.154-0.129,0.18-0.09c0.027,0.039,0.154,0.116,0.09,0.257c-0.063,0.142-0.193,0.193-0.039,0.284c0.154,0.089,0.206,0.012,0.322-0.052c0.115-0.064,0.193-0.347,0.128-0.438c-0.064-0.09-0.218-0.27-0.218-0.334c0-0.064,0.257-0.064,0.257-0.167s0.09-0.18,0.18-0.219c0.091-0.039,0.206-0.206,0.244-0.154c0.039,0.052,0.271,0.116,0.334,0.039c0.064-0.077,0.4-0.36,0.605-0.515c0.206-0.154,0.283-0.334,0.336-0.515c0.051-0.18,0.128-0.296,0.102-0.437v0c0.077,0.18,0.09,0.309,0.077,0.45c-0.013,0.142,0,0.438,0.026,0.476c0.025,0.039,0.129,0.128,0.192,0.103c0.064-0.025-0.025-0.283-0.025-0.334c0-0.052,0.09-0.129,0.142-0.142c0.052-0.013,0-0.231-0.065-0.322c-0.063-0.09-0.154-0.142-0.102-0.154c0.051-0.013,0.115-0.116,0.077-0.142c-0.039-0.025-0.014-0.116-0.103-0.09c-0.065,0.019-0.241-0.015-0.235,0.095c-0.037-0.11-0.116-0.183-0.216-0.172c-0.116,0.013-0.181,0.077-0.296,0.077s-0.025-0.18-0.077-0.18c-0.051,0-0.168,0.167-0.231,0.077c-0.064-0.09,0.18-0.206,0.373-0.27c0.192-0.064,0.514-0.438,0.644-0.451c0.128-0.013,0.45,0.026,0.733,0.013c0.283-0.013,0.373-0.129,0.463-0.064s0.283,0.142,0.399,0.129c0.116-0.014,0.064,0,0.244-0.129c0.18-0.129,0.348-0.193,0.438-0.296c0.09-0.103,0.335-0.18,0.348-0.077c0.014,0.103-0.026,0.206,0.077,0.206s0.258-0.103,0.386-0.154c0.129-0.051,0.231-0.116,0.231-0.116s-0.527,0.36-0.655,0.438c-0.129,0.077-0.438,0.129-0.567,0.283c-0.128,0.155-0.205,0.206-0.192,0.374c0.014,0.167,0.231,0.386,0.128,0.54c-0.103,0.154-0.141,0.373-0.141,0.373s0.154-0.219,0.373-0.36s0.348-0.334,0.425-0.412s0.309-0.091,0.309-0.181s0.064-0.206,0.104-0.309c0.038-0.103-0.077-0.078,0-0.206c0.076-0.129,0.064-0.232,0.45-0.232s0.257,0.026,0.566,0.013c0.309-0.013,0.424-0.167,0.72-0.245c0.296-0.077,0.527-0.128,0.618-0.089c0.09,0.038,0.232,0.012,0.141-0.078c-0.089-0.09-0.295-0.219-0.193-0.245c0.104-0.026,0.207-0.039,0.246-0.142c0.039-0.103-0.142-0.283-0.039-0.386c0.104-0.103-0.077-0.231-0.207-0.257c-0.128-0.025-0.63,0.026-0.731-0.025c-0.104-0.052-0.271-0.116-0.322-0.078c-0.052,0.039-0.168,0.245-0.168,0.245s-0.09,0.025-0.168-0.09c-0.076-0.116-0.5-0.103-0.629-0.103s-0.271,0.025-0.413,0.039c-0.141,0.013-0.219,0.052-0.322-0.039c-0.102-0.09-0.243-0.129-0.296-0.167c-0.051-0.039-0.334-0.039-0.553-0.012c-0.218,0.025-0.438,0.025-0.438,0.025s-0.104-0.039-0.257-0.129c-0.154-0.09-0.309-0.154-0.361-0.154c-0.051,0-0.449,0.064-0.539,0c-0.091-0.064-0.181-0.103-0.245-0.103s-0.115-0.103-0.038-0.103s0.437-0.103,0.437-0.103s-0.103-0.142-0.231-0.142c-0.128,0-0.359-0.064-0.424-0.064s-0.014,0.064-0.142,0.039c-0.13-0.026-0.258-0.078-0.335-0.026c-0.076,0.051-0.258,0.128-0.064,0.18c0.193,0.052,0.373,0,0.425,0.078c0.052,0.077,0,0.115,0,0.167s-0.103,0.193-0.167,0.219c-0.064,0.025-0.143-0.039-0.27,0.025c-0.129,0.064-0.451,0.013-0.49,0.052c-0.038,0.039-0.115-0.103-0.18-0.077c-0.064,0.025-0.232,0.193-0.322,0.18c-0.089-0.013-0.206-0.103-0.206-0.206s-0.038-0.232-0.077-0.258c-0.038-0.025-0.322-0.039-0.425-0.025c-0.103,0.013-0.424,0.038-0.477,0.09c-0.052,0.052-0.193,0.09-0.283,0.09s-0.167-0.09-0.36-0.116c-0.192-0.026-0.617-0.039-0.669-0.026s-0.218-0.025-0.155-0.077c0.065-0.051,0.257-0.219,0.143-0.295c-0.117-0.078-0.375-0.078-0.489-0.09c-0.117-0.013-0.232-0.039-0.413-0.013c-0.181,0.026-0.219,0.116-0.296,0.039c-0.077-0.077,0.193,0.039-0.077-0.077c-0.27-0.116-0.399-0.103-0.477-0.064c-0.077,0.039,0.013,0.025-0.192,0.103c-0.206,0.078-0.322,0.116-0.374,0.129c-0.051,0.012-0.372-0.065-0.411-0.091c-0.038-0.025-0.181,0.013-0.309,0.064S9.895,7.025,9.767,7C9.638,6.973,9.432,6.973,9.303,7.025C9.174,7.076,9.084,7.076,8.956,7.166c-0.13,0.09-0.373,0.142-0.373,0.142S8.522,7.305,8.448,7.301C10.474,5.541,13.111,4.466,16,4.466c6.361,0,11.534,5.173,11.534,11.534S22.36,27.533,16,27.533zM14.888,19.92c0,0,0.207-0.026,0.207-0.117c0-0.089-0.207-0.205-0.282-0.102c-0.078,0.102-0.219,0.205-0.207,0.296C14.625,20.138,14.888,19.92,14.888,19.92zM14.875,17.023c-0.181,0.233-0.167,0.182-0.296,0.128c-0.128-0.05-0.334,0.116-0.296,0.182c0.039,0.064,0.322-0.014,0.386,0.102c0.065,0.116,0.065,0.129,0.193,0.104c0.128-0.026,0.257-0.205,0.219-0.295C15.043,17.151,14.875,17.023,14.875,17.023zM14.837,18.245c-0.051,0-0.412,0.064-0.451,0.079c-0.039,0.013-0.27-0.025-0.27-0.025c-0.09,0.089-0.026,0.179,0.116,0.166s0.438-0.052,0.502-0.052C14.799,18.413,14.888,18.245,14.837,18.245zM14.284,14.668c-0.19,0.03-0.308,0.438-0.155,0.425C14.284,15.081,14.451,14.643,14.284,14.668zM14.734,16.959c-0.052-0.064-0.181-0.271-0.323-0.219c-0.042,0.017-0.153,0.245-0.012,0.245C14.541,16.985,14.786,17.023,14.734,16.959zM14.85,16.805c0.232-0.013,0.167-0.245-0.013-0.257C14.786,16.544,14.618,16.818,14.85,16.805zM17.591,18.928c-0.193-0.039-0.244-0.102-0.45-0.205c-0.207-0.103-0.67-0.103-0.682-0.039c-0.014,0.064,0,0-0.155-0.05c-0.153-0.054-0.271,0-0.309-0.091c-0.038-0.091-0.128-0.117-0.244-0.002c-0.097,0.097-0.142,0.104,0.078,0.143c0.218,0.039,0.283,0.039,0.192,0.141c-0.09,0.104-0.154,0.233-0.077,0.244c0.077,0.015,0.309-0.05,0.334,0c0.026,0.054-0.051,0.064,0.207,0.105c0.258,0.037,0.309,0.128,0.359,0.178c0.051,0.052,0.206,0.22,0.104,0.22c-0.104,0-0.219,0.128-0.142,0.143c0.077,0.013,0.309-0.039,0.321,0c0.014,0.037,0.143,0.283,0.271,0.271c0.129-0.013,0.206-0.244,0.27-0.31c0.065-0.064,0.322-0.104,0.349,0.012c0.026,0.116,0.104,0.233,0.257,0.311c0.154,0.076,0.335,0.154,0.348,0.089c0.013-0.064-0.077-0.309-0.181-0.346c-0.103-0.041-0.282-0.259-0.282-0.348c0-0.091-0.155-0.117-0.232-0.182C17.849,19.147,17.784,18.967,17.591,18.928zM8.042,17.023c-0.084,0.037-0.155,0.476,0,0.527c0.154,0.052,0.244-0.205,0.193-0.271C8.183,17.218,8.158,16.973,8.042,17.023zM15.429,18.117c-0.118-0.05-0.335,0.424-0.181,0.463C15.403,18.62,15.518,18.156,15.429,18.117zM15.687,13.703c0.077,0,0.18-0.051,0.18-0.193c0-0.142,0.18,0,0.27-0.013s0.141-0.103,0.18-0.206c0.005-0.013,0.008-0.021,0.009-0.027c-0.003,0.024-0.001,0.093,0.095,0.117c0.154,0.038,0.205-0.064,0.205-0.103s0.283-0.103,0.336-0.142c0.051-0.038,0.258-0.103,0.27-0.154c0.013-0.051,0-0.348,0.064-0.373c0.064-0.026,0.154-0.026,0.052-0.206c-0.104-0.181-0.104-0.348-0.232-0.271c-0.095,0.057-0.038,0.284-0.115,0.438s-0.142,0.296-0.193,0.296s-0.321,0.103-0.399,0.18c-0.076,0.077-0.45-0.064-0.501,0c-0.052,0.064-0.154,0.141-0.219,0.193c-0.065,0.051-0.245,0.013-0.207,0.167C15.518,13.562,15.609,13.703,15.687,13.703zM17.449,12.056c0.18-0.013,0.348-0.064,0.348-0.064s0.271,0.013,0.232-0.116c-0.04-0.128-0.322-0.141-0.375-0.128c-0.051,0.013-0.142-0.142-0.244-0.116c-0.096,0.023-0.128,0.155-0.128,0.193c0,0.039-0.36,0.115-0.245,0.219C17.153,12.146,17.27,12.069,17.449,12.056zM13.91,19.058c0.104,0.064,0.296-0.219,0.349-0.13c0.051,0.091-0.013,0.13,0.076,0.246c0.091,0.114,0.258,0.102,0.258,0.102s-0.013-0.309-0.155-0.387c-0.142-0.077-0.232-0.166-0.064-0.141c0.167,0.026,0.257-0.039,0.219-0.114c-0.039-0.078-0.283-0.039-0.361-0.026s-0.193-0.052-0.193-0.052c-0.077,0.024-0.063,0.089-0.09,0.219C13.923,18.902,13.807,18.992,13.91,19.058zM20.924,21.618c-0.231-0.052-0.077,0.039,0,0.154c0.077,0.116,0.232,0.176,0.258,0.05C21.193,21.759,21.155,21.67,20.924,21.618zM21.915,24.744c-0.077,0.064,0,0.091-0.219,0.22c-0.22,0.13-0.49,0.271-0.541,0.386c-0.052,0.116,0.051,0.181,0.258,0.192c0.206,0.013,0.154,0.053,0.296-0.103s0.271-0.244,0.438-0.373c0.168-0.128,0.168-0.322,0.168-0.322s-0.181-0.178-0.193-0.141C22.1,24.665,21.992,24.681,21.915,24.744zM18.504,21.618c0.014-0.116-0.219-0.116-0.334-0.207c-0.116-0.089-0.128-0.359-0.193-0.515c-0.064-0.153-0.192-0.257-0.322-0.397c-0.128-0.143-0.192-0.465-0.23-0.438c-0.039,0.025-0.154,0.399-0.064,0.515c0.09,0.116-0.039,0.348-0.103,0.503c-0.065,0.153-0.22-0.026-0.349-0.104c-0.129-0.078-0.308-0.128-0.398-0.219c-0.09-0.091,0.155-0.335,0.091-0.426c-0.065-0.09-0.412-0.013-0.45-0.013c-0.039,0-0.116-0.128-0.194-0.128c-0.077,0-0.064,0.258-0.064,0.258s-0.078-0.091-0.193-0.207c-0.117-0.115,0.012,0.077-0.103,0.193c-0.117,0.117-0.079,0.078-0.129,0.206c-0.051,0.129-0.167,0.077-0.283-0.052c-0.116-0.128-0.179-0.037-0.258,0c-0.077,0.039-0.141,0.259-0.18,0.309c-0.039,0.052-0.309,0.117-0.374,0.182c-0.064,0.062-0.09,0.27-0.09,0.322c0,0.05-0.271,0.023-0.361,0.089c-0.09,0.064-0.23,0.025-0.321,0.025c-0.09,0-0.399,0.244-0.502,0.308c-0.103,0.066-0.103,0.298-0.051,0.362c0.051,0.063,0.154,0.219,0.09,0.244c-0.064,0.026-0.104,0.206,0.051,0.359c0.154,0.155,0.103,0.194,0.115,0.271c0.014,0.077,0.078,0.104,0.181,0.232c0.102,0.128-0.181,0.231-0.219,0.31c-0.039,0.076,0.091,0.192,0.167,0.257c0.077,0.063,0.271,0.026,0.386-0.013c0.117-0.039,0.245-0.143,0.321-0.155c0.079-0.013,0.438-0.026,0.438-0.026s0.129-0.192,0.219-0.296c0.089-0.102,0.372-0.013,0.372-0.013s0.117-0.076,0.426-0.141c0.309-0.065,0.179,0.064,0.296,0.104c0.115,0.037,0.27,0.062,0.359,0.128c0.09,0.064,0,0.218-0.012,0.283c-0.014,0.064,0.219,0.038,0.23-0.026c0.014-0.064,0.077-0.128,0.207-0.205c0.128-0.078,0.025,0.114,0.076,0.231c0.052,0.116,0.129-0.157,0.129-0.026c0,0.039,0.039,0.078,0.051,0.116c0.014,0.039,0.181,0.052,0.181,0.18c0,0.13,0,0.207,0.039,0.231c0.038,0.026,0.244,0,0.335,0.155c0.089,0.154,0.154,0.013,0.205-0.052c0.052-0.064,0.231,0.026,0.283,0.078c0.052,0.05,0.193-0.104,0.387-0.155c0.192-0.051,0.167-0.039,0.219-0.115c0.051-0.078,0.09-0.283,0.205-0.438c0.115-0.153,0.271-0.424,0.271-0.631c0-0.206-0.014-0.682-0.155-0.899C18.761,21.953,18.492,21.733,18.504,21.618zM18.029,24.77c-0.065-0.013-0.207-0.062-0.207-0.062c-0.142,0.141,0.142,0.141,0.104,0.283c-0.039,0.141,0.193,0.089,0.257,0.064c0.063-0.027,0.22-0.323,0.193-0.399C18.351,24.577,18.093,24.783,18.029,24.77zM22.803,24.178c-0.052,0-0.077,0.064-0.192,0c-0.117-0.063-0.091-0.037-0.168-0.167c-0.077-0.127-0.091-0.296-0.219-0.23c-0.051,0.025,0,0.168,0.051,0.218c0.053,0.052,0.077,0.231,0.064,0.283c-0.012,0.052-0.231,0.116-0.129,0.18c0.104,0.064,0.297,0,0.271,0.078c-0.025,0.077-0.129,0.179-0.013,0.205c0.115,0.025,0.154-0.089,0.207-0.178c0.051-0.093,0.089-0.169,0.179-0.221C22.944,24.294,22.854,24.178,22.803,24.178zM22.815,21.18c0.168,0.064,0.464-0.231,0.347-0.27C23.047,20.871,22.815,21.18,22.815,21.18zM13.923,19.906c-0.029,0.115,0.193,0.167,0.206,0.039C14.141,19.816,13.949,19.803,13.923,19.906zM14.27,16.47c-0.064,0.065-0.257,0.193-0.283,0.31c-0.025,0.115,0.309-0.182,0.399-0.296c0.091-0.117,0.27-0.052,0.308-0.117c0.04-0.063,0.04-0.063,0.04-0.063s-0.142-0.025-0.257-0.063c-0.117-0.039-0.258,0.102-0.193-0.104c0.064-0.206,0.257-0.167,0.219-0.322c-0.039-0.154-0.168-0.193-0.207-0.193c-0.09,0,0.013,0.141-0.116,0.231c-0.128,0.09-0.271,0.128-0.193,0.283C14.064,16.29,14.334,16.405,14.27,16.47zM13.254,19.751c0.013-0.076-0.142-0.192-0.206-0.192c-0.065,0-0.386-0.077-0.386-0.077c-0.058,0.023-0.135,0.045-0.158,0.077c-0.007-0.011-0.022-0.024-0.049-0.039c-0.142-0.075-0.309,0-0.361-0.102c-0.05-0.104-0.127-0.104-0.179-0.039c-0.094,0.117,0.025,0.206,0.063,0.231c0.038,0.024,0.181,0.052,0.309,0.039c0.08-0.008,0.181-0.027,0.21-0.059c0.004,0.014,0.016,0.027,0.035,0.044c0.103,0.092,0.167,0.13,0.321,0.116C13.009,19.74,13.241,19.829,13.254,19.751zM12.881,18.992c0.065,0,0.193,0,0.283,0.026c0.09,0.025,0.386,0.05,0.373-0.064c-0.013-0.115-0.038-0.297,0.089-0.411c0.13-0.117,0.257-0.18,0.193-0.348c-0.063-0.167-0.193-0.271-0.103-0.349c0.09-0.076,0.192-0.102,0.192-0.166c0-0.065-0.217,0.18-0.244-0.246c-0.005-0.091-0.206,0.025-0.219,0.116c-0.012,0.091,0.142,0.167-0.103,0.167c-0.245,0-0.257,0.194-0.309,0.232c-0.052,0.039-0.103,0.051-0.207,0.076c-0.102,0.026-0.127,0.13-0.153,0.194c-0.025,0.063-0.206-0.116-0.257-0.064c-0.051,0.052-0.013,0.296,0.077,0.501C12.585,18.863,12.816,18.992,12.881,18.992zM11.979,18.928c0.065-0.077,0.038-0.192-0.063-0.18c-0.103,0.013-0.193-0.168-0.36-0.283c-0.168-0.114-0.296-0.194-0.451-0.36c-0.154-0.167-0.347-0.271-0.45-0.359c-0.104-0.091-0.257-0.13-0.322-0.116c-0.159,0.032,0.231,0.309,0.271,0.346c0.039,0.041,0.387,0.335,0.387,0.478s0.231,0.476,0.296,0.527c0.064,0.052,0.385,0.244,0.437,0.348c0.052,0.103,0.167,0.13,0.167-0.013C11.89,19.174,11.916,19.006,11.979,18.928zM11.002,17.474c0.064,0.232,0.193,0.464,0.244,0.555c0.052,0.089,0.271,0.217,0.348,0.281c0.077,0.064,0.192-0.024,0.143-0.102c-0.052-0.078-0.155-0.192-0.167-0.283c-0.013-0.091-0.078-0.233-0.181-0.387c-0.102-0.153-0.192-0.192-0.257-0.295c-0.064-0.104-0.296-0.297-0.296-0.297c-0.102,0.013-0.102,0.205-0.051,0.271C10.834,17.28,10.938,17.243,11.002,17.474z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Hail.js":
/*!********************************!*\
  !*** ./src/shape/icon/Hail.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Hail();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Hail = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Hail.prototype */
{

  NAME: "draw2d.shape.icon.Hail",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.372,6.912c-0.093-3.925-3.302-7.078-7.248-7.08c-2.638,0.002-4.942,1.412-6.208,3.518c-0.595-0.327-1.28-0.518-2.01-0.518C7.627,2.834,5.773,4.639,5.69,6.898c-2.393,0.786-4.125,3.025-4.127,5.686c0,3.312,2.687,6,6,6v-0.002h15.875c3.312,0,6-2.688,6-6C29.434,9.944,27.732,7.715,25.372,6.912zM23.436,16.584H7.562c-2.209-0.006-3.997-1.793-4.001-4c-0.002-1.983,1.45-3.619,3.35-3.933c0.265-0.043,0.502-0.19,0.657-0.414C7.723,8.015,7.78,7.74,7.731,7.475C7.703,7.326,7.686,7.187,7.686,7.051c0.004-1.225,0.995-2.217,2.22-2.219c0.647,0,1.217,0.278,1.633,0.731c0.233,0.257,0.587,0.375,0.927,0.31c0.342-0.066,0.626-0.308,0.748-0.631c0.749-1.992,2.662-3.412,4.911-3.41c2.898,0.004,5.244,2.351,5.251,5.25c0,0.16-0.009,0.325-0.026,0.496c-0.05,0.518,0.305,0.984,0.814,1.079c1.859,0.345,3.273,1.966,3.271,3.923C27.43,14.791,25.645,16.578,23.436,16.584zM11.503,23.709c-0.784-0.002-1.418-0.636-1.418-1.416c0-0.785,0.634-1.416,1.418-1.418c0.78,0.002,1.413,0.633,1.416,1.418C12.917,23.073,12.284,23.707,11.503,23.709zM19.002,23.709c-0.783-0.002-1.418-0.636-1.418-1.416c0-0.785,0.635-1.416,1.418-1.418c0.779,0.002,1.414,0.633,1.414,1.418C20.417,23.073,19.784,23.707,19.002,23.709zM7.503,28.771c-0.783-0.002-1.417-0.637-1.417-1.418s0.634-1.414,1.417-1.416c0.78,0.002,1.415,0.635,1.415,1.416C8.917,28.135,8.284,28.77,7.503,28.771zM15.001,28.771c-0.782-0.002-1.417-0.637-1.417-1.418s0.634-1.414,1.417-1.416c0.78,0.002,1.413,0.635,1.415,1.416C16.415,28.135,15.784,28.77,15.001,28.771zM22.5,28.771c-0.782-0.002-1.416-0.634-1.416-1.416c0-0.785,0.634-1.418,1.416-1.42c0.781,0.002,1.414,0.635,1.418,1.42C23.915,28.138,23.282,28.77,22.5,28.771z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Hammer.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Hammer.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Hammer();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Hammer = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Hammer.prototype */
{

  NAME: "draw2d.shape.icon.Hammer",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M7.831,29.354c0.685,0.353,1.62,1.178,2.344,0.876c0.475-0.195,0.753-1.301,1.048-1.883c2.221-4.376,4.635-9.353,6.392-13.611c0-0.19,0.101-0.337-0.049-0.595c0.983-1.6,1.65-3.358,2.724-5.138c0.34-0.566,0.686-1.351,1.163-1.577l0.881-0.368c1.12-0.288,1.938-0.278,2.719,0.473c0.396,0.383,0.578,1.015,0.961,1.395c0.259,0.26,1.246,0.899,1.613,0.8c0.285-0.077,0.52-0.364,0.72-0.728l0.696-1.286c0.195-0.366,0.306-0.718,0.215-0.999c-0.117-0.362-1.192-0.84-1.552-0.915c-0.528-0.113-1.154,0.081-1.692-0.041c-1.057-0.243-1.513-0.922-1.883-2.02c-2.608-1.533-6.119-2.53-10.207-1.244c-1.109,0.349-2.172,0.614-2.901,1.323c-0.146,0.412,0.143,0.494,0.446,0.489c-0.237,0.216-0.62,0.341-0.399,0.848c2.495-1.146,7.34-1.542,7.669,0.804c0.072,0.522-0.395,1.241-0.682,1.835c-0.905,1.874-2.011,3.394-2.813,5.091c-0.298,0.017-0.366,0.18-0.525,0.287c-2.604,3.8-5.451,8.541-7.9,12.794c-0.326,0.566-1.098,1.402-1.002,1.906C5.961,28.641,7.146,29,7.831,29.354z");
  }
});

/***/ }),

/***/ "./src/shape/icon/HammerAndScrewDriver.js":
/*!************************************************!*\
  !*** ./src/shape/icon/HammerAndScrewDriver.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.HammerAndScrewDriver();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.HammerAndScrewDriver = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.HammerAndScrewDriver.prototype */
{

  NAME: "draw2d.shape.icon.HammerAndScrewDriver",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.537,9.859c-0.473-0.259-1.127-0.252-1.609-0.523c-0.943-0.534-1.186-1.316-1.226-2.475c-2.059-2.215-5.138-4.176-9.424-4.114c-1.162,0.017-2.256-0.035-3.158,0.435c-0.258,0.354-0.004,0.516,0.288,0.599c-0.29,0.138-0.692,0.147-0.626,0.697c2.72-0.383,7.475,0.624,7.116,2.966c-0.08,0.521-0.735,1.076-1.179,1.563c-1.263,1.382-2.599,2.45-3.761,3.667l0.336,0.336c0.742-0.521,1.446-0.785,2.104-0.785c0.707,0,1.121,0.297,1.276,0.433c0.575-0.618,1.166-1.244,1.839-1.853c0.488-0.444,1.047-1.099,1.566-1.178l0.949-0.101c1.156,0.047,1.937,0.29,2.471,1.232c0.27,0.481,0.262,1.139,0.521,1.613c0.175,0.324,0.937,1.218,1.316,1.228c0.294,0.009,0.603-0.199,0.899-0.49l1.033-1.034c0.291-0.294,0.501-0.6,0.492-0.896C29.754,10.801,28.861,10.035,28.537,9.859zM13.021,15.353l-0.741-0.741c-3.139,2.643-6.52,5.738-9.531,8.589c-0.473,0.443-1.452,1.021-1.506,1.539c-0.083,0.781,0.95,1.465,1.506,2c0.556,0.533,1.212,1.602,1.994,1.51c0.509-0.043,1.095-1.029,1.544-1.502c2.255-2.374,4.664-4.976,6.883-7.509c-0.312-0.371-0.498-0.596-0.498-0.596C12.535,18.451,11.779,17.272,13.021,15.353zM20.64,15.643c-0.366-0.318-1.466,0.143-1.777-0.122c-0.311-0.266,0.171-1.259-0.061-1.455c-0.482-0.406-0.77-0.646-0.77-0.646s-0.862-0.829-2.812,0.928L7.44,6.569C7.045,6.173,7.203,4.746,7.203,4.746L3.517,2.646L2.623,3.541l2.1,3.686c0,0,1.428-0.158,1.824,0.237l7.792,7.793c-1.548,1.831-0.895,2.752-0.895,2.752s0.238,0.288,0.646,0.771c0.196,0.23,1.188-0.249,1.455,0.061c0.264,0.312-0.196,1.41,0.12,1.777c2.666,3.064,6.926,7.736,8.125,7.736c0.892,0,2.021-0.724,2.948-1.64c0.925-0.917,1.639-2.055,1.639-2.947C28.377,22.567,23.704,18.309,20.64,15.643z");
  }
});

/***/ }),

/***/ "./src/shape/icon/HangUp.js":
/*!**********************************!*\
  !*** ./src/shape/icon/HangUp.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.HangUp();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.HangUp = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.HangUp.prototype */
{

  NAME: "draw2d.shape.icon.HangUp",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.563,10.494c-7.35-7.349-19.265-7.348-26.612,0.001c-1.796,1.796-0.247,6.84-0.247,6.84c0.135,0.443,0.616,0.72,1.067,0.614l6.898-1.604c0.451-0.105,0.82-0.57,0.82-1.033l0.001-3.685c0-0.463,0.379-0.842,0.842-0.842h8.285c0.464,0,0.843,0.379,0.843,0.842l-0.001,3.471c0.001,0.462,0.375,0.907,0.83,0.986l7.635,1.316c0.456,0.08,0.873-0.232,0.926-0.692C29.851,16.708,30.359,12.29,28.563,10.494zM17.264,14.072h-3.501v4.39h-2.625l4.363,7.556l4.363-7.556h-2.6V14.072z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Help.js":
/*!********************************!*\
  !*** ./src/shape/icon/Help.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Help();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Help = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Help.prototype */
{

  NAME: "draw2d.shape.icon.Help",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.834,4.834L4.833,4.833c-5.889,5.892-5.89,15.443,0.001,21.334s15.44,5.888,21.33-0.002c5.891-5.891,5.893-15.44,0.002-21.33C20.275-1.056,10.725-1.056,4.834,4.834zM25.459,5.542c0.833,0.836,1.523,1.757,2.104,2.726l-4.08,4.08c-0.418-1.062-1.053-2.06-1.912-2.918c-0.859-0.859-1.857-1.494-2.92-1.913l4.08-4.08C23.7,4.018,24.622,4.709,25.459,5.542zM10.139,20.862c-2.958-2.968-2.959-7.758-0.001-10.725c2.966-2.957,7.756-2.957,10.725,0c2.954,2.965,2.955,7.757-0.001,10.724C17.896,23.819,13.104,23.817,10.139,20.862zM5.542,25.459c-0.833-0.837-1.524-1.759-2.105-2.728l4.081-4.081c0.418,1.063,1.055,2.06,1.914,2.919c0.858,0.859,1.855,1.494,2.917,1.913l-4.081,4.081C7.299,26.982,6.379,26.292,5.542,25.459zM8.268,3.435l4.082,4.082C11.288,7.935,10.29,8.571,9.43,9.43c-0.858,0.859-1.494,1.855-1.912,2.918L3.436,8.267c0.58-0.969,1.271-1.89,2.105-2.727C6.377,4.707,7.299,4.016,8.268,3.435zM22.732,27.563l-4.082-4.082c1.062-0.418,2.061-1.053,2.919-1.912c0.859-0.859,1.495-1.857,1.913-2.92l4.082,4.082c-0.58,0.969-1.271,1.891-2.105,2.728C24.623,26.292,23.701,26.983,22.732,27.563z");
  }
});

/***/ }),

/***/ "./src/shape/icon/History.js":
/*!***********************************!*\
  !*** ./src/shape/icon/History.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.History();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.History = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.History.prototype */
{

  NAME: "draw2d.shape.icon.History",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M10.666,18.292c0.275,0.479,0.889,0.644,1.365,0.367l3.305-1.677C15.39,16.99,15.444,17,15.501,17c0.828,0,1.5-0.671,1.5-1.5l-0.5-7.876c0-0.552-0.448-1-1-1c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96C10.553,17.204,10.389,17.816,10.666,18.292zM12.062,9.545c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,9.658,11.584,9.822,12.062,9.545zM8.179,18.572c-0.478,0.277-0.642,0.889-0.365,1.367c0.275,0.479,0.889,0.641,1.365,0.365c0.479-0.275,0.643-0.888,0.367-1.367C9.27,18.461,8.658,18.297,8.179,18.572zM9.18,10.696c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366c0.479,0.276,1.09,0.113,1.367-0.366C9.821,11.584,9.657,10.973,9.18,10.696zM6.624,15.5c0,0.553,0.449,1,1,1c0.552,0,1-0.447,1.001-1c-0.001-0.552-0.448-0.999-1.001-1C7.071,14.5,6.624,14.948,6.624,15.5zM14.501,23.377c0,0.553,0.448,1,1,1c0.552,0,1-0.447,1-1s-0.448-1-1-1C14.949,22.377,14.501,22.824,14.501,23.377zM10.696,21.822c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.276,1.091,0.11,1.365-0.365c0.277-0.479,0.113-1.09-0.365-1.367C11.584,21.18,10.973,21.344,10.696,21.822zM21.822,10.696c-0.479,0.278-0.643,0.89-0.366,1.367s0.888,0.642,1.366,0.365c0.478-0.275,0.643-0.888,0.365-1.366C22.913,10.584,22.298,10.42,21.822,10.696zM21.456,18.938c-0.274,0.479-0.112,1.092,0.367,1.367c0.477,0.274,1.089,0.112,1.364-0.365c0.276-0.479,0.112-1.092-0.364-1.367C22.343,18.297,21.73,18.461,21.456,18.938zM24.378,15.5c0-0.551-0.448-1-1-1c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1C23.93,16.5,24.378,16.053,24.378,15.5zM18.573,22.822c0.274,0.477,0.888,0.643,1.366,0.365c0.478-0.275,0.642-0.89,0.365-1.365c-0.277-0.479-0.888-0.643-1.365-0.367C18.46,21.732,18.296,22.344,18.573,22.822zM18.939,9.546c0.477,0.276,1.088,0.112,1.365-0.366c0.276-0.478,0.113-1.091-0.367-1.367c-0.477-0.276-1.09-0.111-1.364,0.366C18.298,8.659,18.462,9.27,18.939,9.546zM28.703,14.364C28.074,7.072,21.654,1.67,14.364,2.295c-3.254,0.281-6.118,1.726-8.25,3.877L4.341,4.681l-1.309,7.364l7.031-2.548L8.427,8.12c1.627-1.567,3.767-2.621,6.194-2.833c5.64-0.477,10.595,3.694,11.089,9.335c0.477,5.64-3.693,10.595-9.333,11.09c-5.643,0.476-10.599-3.694-11.092-9.333c-0.102-1.204,0.019-2.373,0.31-3.478l-3.27,1.186c-0.089,0.832-0.106,1.684-0.031,2.55c0.629,7.29,7.048,12.691,14.341,12.066C23.926,28.074,29.328,21.655,28.703,14.364z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Home.js":
/*!********************************!*\
  !*** ./src/shape/icon/Home.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Home();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Home = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Home.prototype */
{

  NAME: "draw2d.shape.icon.Home",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.812,16l-3.062-3.062V5.625h-2.625v4.688L16,4.188L4.188,16L7,15.933v11.942h17.875V16H27.812zM16,26.167h-5.833v-7H16V26.167zM21.667,23.167h-3.833v-4.042h3.833V23.167z");
  }
});

/***/ }),

/***/ "./src/shape/icon/IMac.js":
/*!********************************!*\
  !*** ./src/shape/icon/IMac.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.IMac();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.IMac = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.IMac.prototype */
{

  NAME: "draw2d.shape.icon.IMac",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.936,2.099H2.046c-0.506,0-0.919,0.414-0.919,0.92v21.097c0,0.506,0.413,0.919,0.919,0.919h17.062v-0.003h9.828c0.506,0,0.92-0.413,0.92-0.921V3.019C29.854,2.513,29.439,2.099,28.936,2.099zM28.562,20.062c0,0.412-0.338,0.75-0.75,0.75H3.062c-0.413,0-0.75-0.338-0.75-0.75v-16c0-0.413,0.337-0.75,0.75-0.75h24.75c0.412,0,0.75,0.337,0.75,0.75V20.062zM20.518,28.4c-0.033-0.035-0.062-0.055-0.068-0.062l-0.01-0.004l-0.008-0.004c0,0-0.046-0.021-0.119-0.062c-0.108-0.056-0.283-0.144-0.445-0.237c-0.162-0.097-0.32-0.199-0.393-0.271c-0.008-0.014-0.035-0.079-0.058-0.17c-0.083-0.32-0.161-0.95-0.22-1.539h-7.5c-0.023,0.23-0.048,0.467-0.076,0.691c-0.035,0.272-0.073,0.524-0.113,0.716c-0.02,0.096-0.039,0.175-0.059,0.23c-0.009,0.025-0.018,0.05-0.024,0.062c-0.003,0.006-0.005,0.01-0.007,0.013c-0.094,0.096-0.34,0.246-0.553,0.36c-0.107,0.062-0.209,0.11-0.283,0.146c-0.074,0.037-0.119,0.062-0.119,0.062l-0.007,0.004l-0.008,0.004c-0.01,0.009-0.038,0.022-0.07,0.062c-0.031,0.037-0.067,0.103-0.067,0.185c0.002,0.002-0.004,0.037-0.006,0.088c0,0.043,0.007,0.118,0.068,0.185c0.061,0.062,0.143,0.08,0.217,0.08h9.716c0.073,0,0.153-0.021,0.215-0.08c0.062-0.063,0.068-0.142,0.068-0.185c-0.001-0.051-0.008-0.086-0.007-0.088C20.583,28.503,20.548,28.439,20.518,28.4z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Icon.js":
/*!********************************!*\
  !*** ./src/shape/icon/Icon.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.SetFigure
 */
_packages2.default.shape.icon.Icon = _packages2.default.SetFigure.extend(
/** @lends draw2d.shape.icon.Icon.prototype */
{

  NAME: "draw2d.shape.icon.Icon",

  /**
   *
   * Creates a new figure element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
    this.setBackgroundColor("#333333");
    this.keepAspectRatio = false;
  },

  /**
   * 
   * propagate all attributes like color, stroke,... to the shape element
   **/
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    // redirect the bgColor to the inner set and not to the outer container
    //
    attributes.fill = "none";
    if (this.svgNodes !== null) {
      this.svgNodes.attr({ fill: this.bgColor.rgba(), stroke: "none" });
    }

    this._super(attributes);
  },

  applyTransformation: function applyTransformation() {
    var trans = [];

    if (this.rotationAngle !== 0) {
      trans.push("R" + this.rotationAngle);
    }

    if (this.getRotationAngle() === 90 || this.getRotationAngle() === 270) {
      var ratio = this.getHeight() / this.getWidth();
      trans.push("T" + -this.offsetY + "," + -this.offsetX);
      trans.push("S" + ratio + "," + 1 / ratio + ",0,0");
    } else {
      trans.push("T" + -this.offsetX + "," + -this.offsetY);
    }
    if (this.isResizeable() === true) {
      trans.push("T" + this.getAbsoluteX() + "," + this.getAbsoluteY() + "S" + this.scaleX + "," + this.scaleY + "," + this.getAbsoluteX() + "," + this.getAbsoluteY());
    } else {
      trans.push("T" + this.getAbsoluteX() + "," + this.getAbsoluteY());
    }

    this.svgNodes.transform(trans.join(" "));

    return this;
  },

  /**
   * @private
   */
  createShapeElement: function createShapeElement() {
    var shape = this._super();

    var bb = this.svgNodes.getBBox();

    this.offsetX = bb.x;
    this.offsetY = bb.y;

    return shape;
  }
});

/***/ }),

/***/ "./src/shape/icon/Icons.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Icons.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Icons();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Icons = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Icons.prototype */
{

  NAME: "draw2d.shape.icon.Icons",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.083,14H14V4.083H4.083V14zM17,4.083V14h9.917V4.083H17zM17,26.917h9.917v-9.918H17V26.917zM4.083,26.917H14v-9.918H4.083V26.917z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Ie.js":
/*!******************************!*\
  !*** ./src/shape/icon/Ie.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Ie();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Ie = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Ie.prototype */
{

  NAME: "draw2d.shape.icon.Ie",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.998,2.266c-2.12-1.91-6.925,0.382-9.575,1.93c-0.76-0.12-1.557-0.185-2.388-0.185c-3.349,0-6.052,0.985-8.106,2.843c-2.336,2.139-3.631,4.94-3.631,8.177c0,0.028,0.001,0.056,0.001,0.084c3.287-5.15,8.342-7.79,9.682-8.487c0.212-0.099,0.338,0.155,0.141,0.253c-0.015,0.042-0.015,0,0,0c-2.254,1.35-6.434,5.259-9.146,10.886l-0.003-0.007c-1.717,3.547-3.167,8.529-0.267,10.358c2.197,1.382,6.13-0.248,9.295-2.318c0.764,0.108,1.567,0.165,2.415,0.165c5.84,0,9.937-3.223,11.399-7.924l-8.022-0.014c-0.337,1.661-1.464,2.548-3.223,2.548c-2.21,0-3.729-1.211-3.828-4.012l15.228-0.014c0.028-0.578-0.042-0.985-0.042-1.436c0-5.251-3.143-9.355-8.255-10.663c2.081-1.294,5.974-3.209,7.848-1.681c1.407,1.14,0.633,3.533,0.295,4.518c-0.056,0.254,0.24,0.296,0.296,0.057C28.814,5.573,29.026,3.194,27.998,2.266zM13.272,25.676c-2.469,1.475-5.873,2.539-7.539,1.289c-1.243-0.935-0.696-3.468,0.398-5.938c0.664,0.992,1.495,1.886,2.473,2.63C9.926,24.651,11.479,25.324,13.272,25.676zM12.714,13.046c0.042-2.435,1.787-3.49,3.617-3.49c1.928,0,3.49,1.112,3.49,3.49H12.714z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Ie9.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Ie9.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Ie9();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Ie9 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Ie9.prototype */
{

  NAME: "draw2d.shape.icon.Ie9",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.751,17.887c0.054-0.434,0.081-0.876,0.081-1.324c0-1.744-0.413-3.393-1.146-4.854c1.133-2.885,1.155-5.369-0.201-6.777c-1.756-1.822-5.391-1.406-9.433,0.721c-0.069-0.001-0.138-0.003-0.206-0.003c-6.069,0-10.988,4.888-10.988,10.917c0,0.183,0.005,0.354,0.014,0.529c-2.688,4.071-3.491,7.967-1.688,9.838c1.557,1.613,4.691,1.344,8.2-0.392c1.363,0.604,2.873,0.938,4.462,0.938c4.793,0,8.867-3.049,10.369-7.299H21.26c-0.814,1.483-2.438,2.504-4.307,2.504c-2.688,0-4.867-2.104-4.867-4.688c0-0.036,0.002-0.071,0.003-0.106h15.662V17.887zM26.337,6.099c0.903,0.937,0.806,2.684-0.087,4.818c-1.27-2.083-3.221-3.71-5.546-4.576C23.244,5.217,25.324,5.047,26.337,6.099zM16.917,10.372c2.522,0,4.585,1.991,4.748,4.509h-9.496C12.333,12.363,14.396,10.372,16.917,10.372zM5.687,26.501c-1.103-1.146-0.712-3.502,0.799-6.298c0.907,2.546,2.736,4.658,5.09,5.938C8.92,27.368,6.733,27.587,5.687,26.501z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Import.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Import.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Import();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Import = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Import.prototype */
{

  NAME: "draw2d.shape.icon.Import",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.067,2.25c-5.979,0-11.035,3.91-12.778,9.309h3.213c1.602-3.705,5.271-6.301,9.565-6.309c5.764,0.01,10.428,4.674,10.437,10.437c-0.009,5.764-4.673,10.428-10.437,10.438c-4.294-0.007-7.964-2.605-9.566-6.311H2.289c1.744,5.399,6.799,9.31,12.779,9.312c7.419-0.002,13.437-6.016,13.438-13.438C28.504,8.265,22.486,2.252,15.067,2.25zM10.918,19.813l7.15-4.126l-7.15-4.129v2.297H-0.057v3.661h10.975V19.813z");
  }
});

/***/ }),

/***/ "./src/shape/icon/InkScape.js":
/*!************************************!*\
  !*** ./src/shape/icon/InkScape.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.InkScape();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.InkScape = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.InkScape.prototype */
{

  NAME: "draw2d.shape.icon.InkScape",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.402,17.626c0.84-0.772,2.468-0.381,5.979-1.853c1.716-0.72,1.572-1.265,1.566-1.928c-0.001-0.014,0-0.027,0-0.041h-0.005c-0.012-0.667-0.291-1.332-0.846-1.845L17.049,2.684c-0.566-0.522-1.304-0.782-2.042-0.782V1.898c-0.738,0-1.475,0.261-2.04,0.783l-10.05,9.276c-0.554,0.512-0.832,1.176-0.843,1.844H2.07c0,0,0.003,0.011,0.004,0.011c0,0.012-0.004,0.024-0.004,0.034h0.017c0.193,0.676,5.164,1.536,5.718,2.049c0.838,0.774-3.211,1.339-2.374,2.114c0.838,0.773,5.062,1.496,5.898,2.271c0.838,0.771-1.711,1.596-0.874,2.366c0.837,0.773,3.651-0.191,3.142,1.822c1.13,1.045,3.49,0.547,5.071-0.498c0.837-0.771-1.607-0.703-0.77-1.477c0.836-0.774,2.949-0.777,4.73-2.627C21.913,18.838,19.566,18.398,20.402,17.626zM10.973,16.868l-0.42-0.504c1.497,0.358,3.162,0.827,4.498,0.837l0.058,0.554C13.964,17.646,11.544,17.137,10.973,16.868zM18.161,8.58l-1.396-0.74L14.53,9.594l-1.067-3.192l-1.177,2.545L8.998,9.25l0.036-1.352c0-0.324,1.895-2.596,3.05-3.136l2.112-1.401c0.312-0.186,0.53-0.261,0.727-0.257c0.327,0.011,0.593,0.239,1.112,0.55l4.748,3.25c0.357,0.215,0.619,0.522,0.626,0.898l-2.813-1.254L18.161,8.58zM26.434,19.594c-0.313-0.07-1.688-0.691-2.035,0.165c0.968,0.981,2.645,2.181,3.316,1.482C28.391,20.543,27.102,19.745,26.434,19.594zM4.663,21.566c-0.315,0.074-1.842,0.115-1.719,1.021c1.351,0.451,3.438,0.792,3.684-0.113C6.873,21.566,5.33,21.414,4.663,21.566zM17.877,26.396c-0.232,0.209-1.53,0.953-0.929,1.681c1.413-0.236,3.403-0.914,3.12-1.812C19.786,25.369,18.37,25.953,17.877,26.396z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Ipad.js":
/*!********************************!*\
  !*** ./src/shape/icon/Ipad.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Ipad();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Ipad = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Ipad.prototype */
{

  NAME: "draw2d.shape.icon.Ipad",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.221,1.417H6.11c-0.865,0-1.566,0.702-1.566,1.566v25.313c0,0.865,0.701,1.565,1.566,1.565h19.111c0.865,0,1.565-0.7,1.565-1.565V2.984C26.787,2.119,26.087,1.417,25.221,1.417zM15.666,29.299c-0.346,0-0.626-0.279-0.626-0.625s0.281-0.627,0.626-0.627c0.346,0,0.627,0.281,0.627,0.627S16.012,29.299,15.666,29.299zM24.376,26.855c0,0.174-0.142,0.312-0.313,0.312H7.27c-0.173,0-0.313-0.142-0.313-0.312V4.3c0-0.173,0.14-0.313,0.313-0.313h16.792c0.172,0,0.312,0.14,0.312,0.313L24.376,26.855L24.376,26.855z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Iphone.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Iphone.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Iphone();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Iphone = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Iphone.prototype */
{

  NAME: "draw2d.shape.icon.Iphone",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.755,1H10.62C9.484,1,8.562,1.921,8.562,3.058v24.385c0,1.136,0.921,2.058,2.058,2.058h10.135c1.136,0,2.058-0.922,2.058-2.058V3.058C22.812,1.921,21.891,1,20.755,1zM14.659,3.264h2.057c0.101,0,0.183,0.081,0.183,0.18c0,0.1-0.082,0.18-0.183,0.18h-2.057c-0.1,0-0.181-0.081-0.181-0.18C14.478,3.344,14.559,3.264,14.659,3.264zM13.225,3.058c0.199,0,0.359,0.162,0.359,0.36c0,0.198-0.161,0.36-0.359,0.36c-0.2,0-0.36-0.161-0.36-0.36S13.025,3.058,13.225,3.058zM15.688,28.473c-0.796,0-1.44-0.646-1.44-1.438c0-0.799,0.645-1.439,1.44-1.439s1.44,0.646,1.44,1.439S16.483,28.473,15.688,28.473zM22.041,24.355c0,0.17-0.139,0.309-0.309,0.309H9.642c-0.17,0-0.308-0.139-0.308-0.309V6.042c0-0.17,0.138-0.309,0.308-0.309h12.09c0.17,0,0.309,0.138,0.309,0.309V24.355z");
  }
});

/***/ }),

/***/ "./src/shape/icon/JQuery.js":
/*!**********************************!*\
  !*** ./src/shape/icon/JQuery.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.JQuery();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.JQuery = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.JQuery.prototype */
{

  NAME: "draw2d.shape.icon.JQuery",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M10.322,23.041C4.579,18.723,2.777,11.07,5.494,4.583c-0.254,0.291-0.502,0.59-0.739,0.904c-5.177,6.887-4.008,16.505,2.613,21.482c6.62,4.979,16.184,3.432,21.362-3.455c0.237-0.314,0.454-0.635,0.663-0.959C23.915,26.963,16.064,27.357,10.322,23.041zM13.662,18.598c4.765,3.582,11.604,2.564,15.567-2.198c-3.609,2.641-9.09,2.475-13.361-0.736S9.916,7.231,11.451,3.03C7.976,8.161,8.897,15.015,13.662,18.598zM18.642,11.976c3.254,2.447,8.146,1.438,10.967-2.242c-2.604,1.921-6.341,1.955-9.157-0.164c-2.819-2.118-3.826-5.718-2.701-8.754C14.998,4.549,15.387,9.528,18.642,11.976z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Jigsaw.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Jigsaw.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Jigsaw();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Jigsaw = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Jigsaw.prototype */
{

  NAME: "draw2d.shape.icon.Jigsaw",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M3.739,13.619c0,0,3.516-4.669,5.592-3.642c2.077,1.027-0.414,2.795,1.598,3.719c2.011,0.924,5.048-0.229,4.376-2.899c-0.672-2.67-1.866-0.776-2.798-2.208c-0.934-1.432,4.586-4.59,4.586-4.59s3.361,6.651,4.316,4.911c1.157-2.105,3.193-4.265,5.305-1.025c0,0,1.814,2.412,0.246,3.434s-2.917,0.443-3.506,1.553c-0.586,1.112,3.784,4.093,3.784,4.093s-2.987,4.81-4.926,3.548c-1.939-1.262,0.356-3.364-2.599-3.989c-1.288-0.23-3.438,0.538-3.818,2.34c-0.13,2.709,1.604,2.016,2.797,3.475c1.191,1.457-4.484,4.522-4.484,4.522s-1.584-3.923-3.811-4.657c-2.227-0.735-0.893,2.135-2.917,2.531c-2.024,0.396-4.816-2.399-3.46-4.789c1.358-2.391,3.275-0.044,3.441-1.951C7.629,16.087,3.739,13.619,3.739,13.619z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Key.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Key.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Key();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Key = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Key.prototype */
{

  NAME: "draw2d.shape.icon.Key",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M18.386,16.009l0.009-0.006l-0.58-0.912c1.654-2.226,1.876-5.319,0.3-7.8c-2.043-3.213-6.303-4.161-9.516-2.118c-3.212,2.042-4.163,6.302-2.12,9.517c1.528,2.402,4.3,3.537,6.944,3.102l0.424,0.669l0.206,0.045l0.779-0.447l-0.305,1.377l2.483,0.552l-0.296,1.325l1.903,0.424l-0.68,3.06l1.406,0.313l-0.424,1.906l4.135,0.918l0.758-3.392L18.386,16.009z M10.996,8.944c-0.685,0.436-1.593,0.233-2.029-0.452C8.532,7.807,8.733,6.898,9.418,6.463s1.594-0.233,2.028,0.452C11.883,7.6,11.68,8.509,10.996,8.944z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Lab.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Lab.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Lab();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Lab = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Lab.prototype */
{

  NAME: "draw2d.shape.icon.Lab",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.121,24.438l-3.362-7.847c-0.329-0.769-0.599-2.081-0.599-2.917s0.513-1.521,1.14-1.521s1.141-0.513,1.141-1.14s-0.685-1.14-1.521-1.14h-6.84c-0.836,0-1.52,0.513-1.52,1.14s0.513,1.14,1.14,1.14s1.14,0.685,1.14,1.521s-0.269,2.148-0.599,2.917l-3.362,7.847C8.55,25.206,8.28,26.177,8.28,26.595s0.342,1.103,0.76,1.521s1.444,0.76,2.28,0.76h8.359c0.836,0,1.862-0.342,2.28-0.76s0.76-1.103,0.76-1.521S22.45,25.206,22.121,24.438zM16.582,7.625c0,0.599,0.484,1.083,1.083,1.083s1.083-0.484,1.083-1.083s-0.484-1.084-1.083-1.084S16.582,7.026,16.582,7.625zM13.667,7.792c0.276,0,0.5-0.224,0.5-0.5s-0.224-0.5-0.5-0.5s-0.5,0.224-0.5,0.5S13.391,7.792,13.667,7.792zM15.584,5.292c0.874,0,1.583-0.709,1.583-1.583c0-0.875-0.709-1.584-1.583-1.584C14.709,2.125,14,2.834,14,3.709C14,4.583,14.709,5.292,15.584,5.292z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Lamp.js":
/*!********************************!*\
  !*** ./src/shape/icon/Lamp.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Lamp();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Lamp = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Lamp.prototype */
{

  NAME: "draw2d.shape.icon.Lamp",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.5,2.833c-3.866,0-7,3.134-7,7c0,3.859,3.945,4.937,4.223,9.499h5.553c0.278-4.562,4.224-5.639,4.224-9.499C22.5,5.968,19.366,2.833,15.5,2.833zM15.5,28.166c1.894,0,2.483-1.027,2.667-1.666h-5.334C13.017,27.139,13.606,28.166,15.5,28.166zM12.75,25.498h5.5v-5.164h-5.5V25.498z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Lamp_alt.js":
/*!************************************!*\
  !*** ./src/shape/icon/Lamp_alt.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Lamp_alt();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Lamp_alt = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Lamp_alt.prototype */
{

  NAME: "draw2d.shape.icon.Lamp_alt",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M12.75,25.498h5.5v-5.164h-5.5V25.498zM15.5,28.166c1.894,0,2.483-1.027,2.667-1.666h-5.334C13.017,27.139,13.606,28.166,15.5,28.166zM15.5,2.833c-3.866,0-7,3.134-7,7c0,3.859,3.945,4.937,4.223,9.499h1.271c-0.009-0.025-0.024-0.049-0.029-0.078L11.965,8.256c-0.043-0.245,0.099-0.485,0.335-0.563c0.237-0.078,0.494,0.026,0.605,0.25l0.553,1.106l0.553-1.106c0.084-0.17,0.257-0.277,0.446-0.277c0.189,0,0.362,0.107,0.446,0.277l0.553,1.106l0.553-1.106c0.084-0.17,0.257-0.277,0.448-0.277c0.189,0,0.36,0.107,0.446,0.277l0.554,1.106l0.553-1.106c0.111-0.224,0.368-0.329,0.604-0.25s0.377,0.318,0.333,0.563l-1.999,10.998c-0.005,0.029-0.02,0.053-0.029,0.078h1.356c0.278-4.562,4.224-5.639,4.224-9.499C22.5,5.968,19.366,2.833,15.5,2.833zM17.458,10.666c-0.191,0-0.364-0.107-0.446-0.275l-0.554-1.106l-0.553,1.106c-0.086,0.168-0.257,0.275-0.446,0.275c-0.191,0-0.364-0.107-0.449-0.275l-0.553-1.106l-0.553,1.106c-0.084,0.168-0.257,0.275-0.446,0.275c-0.012,0-0.025,0-0.037-0.001l1.454,8.001h1.167l1.454-8.001C17.482,10.666,17.47,10.666,17.458,10.666z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Landing.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Landing.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Landing();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Landing = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Landing.prototype */
{

  NAME: "draw2d.shape.icon.Landing",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M23.322,19.491c0,0,1.903,0.342,0.299-1.869c-1.353-1.866-5.261-3.104-5.261-3.104l-4.213-8.229l-2.47-0.394l0.973,5.449L9.241,10.11L8.772,7.273L7.008,6.302c0,0-0.496,2.742-0.149,5.271C6.859,11.573,13.965,17.999,23.322,19.491zM3.251,23.106v1.998h24.498v-1.998H3.251zM14,17.94c0,0.414,0.336,0.75,0.75,0.75s0.75-0.336,0.75-0.75s-0.336-0.75-0.75-0.75S14,17.526,14,17.94z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Landscape1.js":
/*!**************************************!*\
  !*** ./src/shape/icon/Landscape1.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Landscape1();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Landscape1 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Landscape1.prototype */
{

  NAME: "draw2d.shape.icon.Landscape1",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M19.883,5.71H2.746c-0.163,0-0.319,0.071-0.435,0.188c-0.118,0.117-0.18,0.272-0.18,0.435v18.364c0,0.164,0.063,0.318,0.18,0.436c0.123,0.117,0.287,0.18,0.435,0.18h25.75c0.164,0,0.324-0.066,0.438-0.18c0.118-0.114,0.182-0.273,0.182-0.436V14.551c-0.002-0.102-0.01-0.188-0.021-0.271c-0.186-1.543-1.543-3.424-3.236-5.168C24.039,7.31,21.869,5.753,19.883,5.71zM26.914,12.314c-0.008-0.005-0.019-0.007-0.029-0.01c-1.092-0.293-2.33-0.355-3.199-0.355c-0.162,0-0.312,0.002-0.445,0.004c-0.037-0.604-0.129-1.604-0.356-2.625c-0.11-0.461-0.246-0.94-0.433-1.42c0.857,0.541,1.748,1.264,2.535,2.068C25.74,10.718,26.41,11.551,26.914,12.314zM3.365,6.947h16.517c0.058,0,0.12,0,0.183,0.004c0.694,0.105,1.307,1.221,1.616,2.646c0.335,1.484,0.354,2.997,0.354,3l0.007,0.656l0.651-0.051c0,0,0.398-0.027,0.99-0.025c0.809,0,1.977,0.062,2.871,0.312c0.939,0.275,1.352,0.635,1.326,1.051h0.002v9.542H3.365V6.951V6.947z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Landscape2.js":
/*!**************************************!*\
  !*** ./src/shape/icon/Landscape2.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Landscape2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Landscape2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Landscape2.prototype */
{

  NAME: "draw2d.shape.icon.Landscape2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M19.883,5.71H2.746c-0.163,0-0.319,0.071-0.435,0.188c-0.118,0.117-0.18,0.272-0.18,0.435v18.364c0,0.164,0.063,0.318,0.18,0.436c0.123,0.117,0.287,0.18,0.435,0.18h25.75c0.164,0,0.324-0.066,0.438-0.18c0.118-0.114,0.182-0.273,0.182-0.436V14.551c-0.002-0.102-0.01-0.188-0.021-0.271c-0.186-1.543-1.543-3.424-3.236-5.168C24.039,7.31,21.869,5.753,19.883,5.71zM3.365,6.947h16.517c0.058,0,0.12,0,0.183,0.004c0.694,0.105,1.307,1.221,1.616,2.646c0.335,1.484,0.354,2.997,0.354,3l0.007,0.656l0.651-0.051c0,0,0.398-0.027,0.99-0.025c0.809,0,1.977,0.062,2.871,0.312c0.939,0.275,1.352,0.635,1.326,1.051h0.002v9.542H3.365V6.951V6.947z");
  }
});

/***/ }),

/***/ "./src/shape/icon/LineChart.js":
/*!*************************************!*\
  !*** ./src/shape/icon/LineChart.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.LineChart();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.LineChart = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.LineChart.prototype */
{

  NAME: "draw2d.shape.icon.LineChart",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M3.625,25.062c-0.539-0.115-0.885-0.646-0.77-1.187l0,0L6.51,6.584l2.267,9.259l1.923-5.188l3.581,3.741l3.883-13.103l2.934,11.734l1.96-1.509l5.271,11.74c0.226,0.504,0,1.095-0.505,1.321l0,0c-0.505,0.227-1.096,0-1.322-0.504l0,0l-4.23-9.428l-2.374,1.826l-1.896-7.596l-2.783,9.393l-3.754-3.924L8.386,22.66l-1.731-7.083l-1.843,8.711c-0.101,0.472-0.515,0.794-0.979,0.794l0,0C3.765,25.083,3.695,25.076,3.625,25.062L3.625,25.062z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Link.js":
/*!********************************!*\
  !*** ./src/shape/icon/Link.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Link();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Link = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Link.prototype */
{

  NAME: "draw2d.shape.icon.Link",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16.45,18.085l-2.47,2.471c0.054,1.023-0.297,2.062-1.078,2.846c-1.465,1.459-3.837,1.459-5.302-0.002c-1.461-1.465-1.46-3.836-0.001-5.301c0.783-0.781,1.824-1.131,2.847-1.078l2.469-2.469c-2.463-1.057-5.425-0.586-7.438,1.426c-2.634,2.637-2.636,6.907,0,9.545c2.638,2.637,6.909,2.635,9.545,0l0.001,0.002C17.033,23.511,17.506,20.548,16.45,18.085zM14.552,12.915l2.467-2.469c-0.053-1.023,0.297-2.062,1.078-2.848C19.564,6.139,21.934,6.137,23.4,7.6c1.462,1.465,1.462,3.837,0,5.301c-0.783,0.783-1.822,1.132-2.846,1.079l-2.469,2.468c2.463,1.057,5.424,0.584,7.438-1.424c2.634-2.639,2.633-6.91,0-9.546c-2.639-2.636-6.91-2.637-9.545-0.001C13.967,7.489,13.495,10.451,14.552,12.915zM18.152,10.727l-7.424,7.426c-0.585,0.584-0.587,1.535,0,2.121c0.585,0.584,1.536,0.584,2.121-0.002l7.425-7.424c0.584-0.586,0.584-1.535,0-2.121C19.687,10.141,18.736,10.142,18.152,10.727z");
  }
});

/***/ }),

/***/ "./src/shape/icon/LinkedIn.js":
/*!************************************!*\
  !*** ./src/shape/icon/LinkedIn.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.LinkedIn();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.LinkedIn = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.LinkedIn.prototype */
{

  NAME: "draw2d.shape.icon.LinkedIn",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.25,3.125h-22c-1.104,0-2,0.896-2,2v22c0,1.104,0.896,2,2,2h22c1.104,0,2-0.896,2-2v-22C29.25,4.021,28.354,3.125,27.25,3.125zM11.219,26.781h-4v-14h4V26.781zM9.219,11.281c-1.383,0-2.5-1.119-2.5-2.5s1.117-2.5,2.5-2.5s2.5,1.119,2.5,2.5S10.602,11.281,9.219,11.281zM25.219,26.781h-4v-8.5c0-0.4-0.403-1.055-0.687-1.213c-0.375-0.211-1.261-0.229-1.665-0.034l-1.648,0.793v8.954h-4v-14h4v0.614c1.583-0.723,3.78-0.652,5.27,0.184c1.582,0.886,2.73,2.864,2.73,4.702V26.781z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Linux.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Linux.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Linux();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Linux = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Linux.prototype */
{

  NAME: "draw2d.shape.icon.Linux",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M11.791,25.229c1.027-0.104,1.162-1.191,0.68-1.666c-0.398-0.392-2.598-2.022-3.171-2.664C9.033,20.6,8.673,20.454,8.52,20.12c-0.352-0.771-0.598-1.869-0.151-2.658c0.081-0.144,0.133-0.078,0.071,0.22c-0.351,1.684,0.746,3.059,0.986,2.354c0.167-0.487,0.013-1.358,0.102-2.051c0.158-1.226,1.273-3.577,1.763-3.712c-0.755-1.398,0.886-2.494,0.866-3.723c-0.014-0.798,0.701,0.982,1.419,1.359c0.802,0.422,1.684-0.794,2.936-1.41c0.354-0.176,0.809-0.376,0.776-0.524c-0.146-0.718-1.644,0.886-2.979,0.939c-0.61,0.024-0.837-0.12-1.072-0.347c-0.712-0.689,0.073-0.115,1.132-0.307c0.471-0.085,0.629-0.163,1.128-0.365c0.5-0.201,1.069-0.5,1.636-0.654c0.395-0.106,0.361-0.402,0.208-0.491c-0.088-0.051-0.219-0.046-0.321,0.133c-0.244,0.419-1.383,0.661-1.74,0.771c-0.457,0.14-0.962,0.271-1.634,0.243c-1.021-0.042-0.782-0.509-1.513-0.928c-0.213-0.122-0.156-0.444,0.129-0.729c0.148-0.148,0.557-0.232,0.76-0.572c0.028-0.047,0.289-0.32,0.494-0.461c0.07-0.049,0.076-1.295-0.562-1.32c-0.543-0.021-0.697,0.398-0.675,0.818c0.022,0.419,0.245,0.765,0.393,0.764c0.285-0.004,0.019,0.311-0.138,0.361c-0.237,0.078-0.562-0.934-0.525-1.418c0.039-0.506,0.303-1.4,0.942-1.383c0.576,0.016,0.993,0.737,0.973,1.983c-0.003,0.211,0.935-0.101,1.247,0.229c0.224,0.236-0.767-2.207,1.438-2.375c0.582,0.111,1.14,0.305,1.371,1.641c-0.086,0.139,0.146,1.07-0.215,1.182c-0.438,0.135-0.707-0.02-0.453-0.438c0.172-0.418,0.004-1.483-0.882-1.42c-0.887,0.064-0.769,1.637-0.526,1.668c0.243,0.031,0.854,0.465,1.282,0.549c1.401,0.271,0.371,1.075,0.555,2.048c0.205,1.099,0.929,0.809,1.578,3.717c0.137,0.177,0.676,0.345,1.199,2.579c0.473,2.011-0.195,3.473,0.938,3.353c0.256-0.026,0.629-0.1,0.792-0.668c0.425-1.489-0.213-3.263-0.855-4.46c-0.375-0.698-0.729-1.174-0.916-1.337c0.738,0.436,1.683,1.829,1.898,2.862c0.286,1.358,0.49,1.934,0.059,3.37c0.25,0.125,0.871,0.39,0.871,0.685c-0.647-0.53-2.629-0.625-2.68,0.646c-0.338,0.008-0.594,0.034-0.811,0.293c-0.797,0.944-0.059,2.842-0.139,3.859c-0.07,0.896-0.318,1.783-0.46,2.683c-0.474-0.019-0.428-0.364-0.274-0.852c0.135-0.431,0.351-0.968,0.365-1.484c0.012-0.467-0.039-0.759-0.156-0.831c-0.118-0.072-0.303,0.074-0.559,0.485c-0.543,0.875-1.722,1.261-2.821,1.397c-1.099,0.138-2.123,0.028-2.664-0.578c-0.186-0.207-0.492,0.058-0.529,0.111c-0.049,0.074,0.18,0.219,0.352,0.533c0.251,0.461,0.49,1.159-0.105,1.479C12.83,26.314,12.316,26.221,11.791,25.229L11.791,25.229zM11.398,25.188c0.395,0.621,1.783,3.232-0.652,3.571c-0.814,0.114-2.125-0.474-3.396-0.784c-1.142-0.279-2.301-0.444-2.949-0.627c-0.391-0.108-0.554-0.25-0.588-0.414c-0.091-0.434,0.474-1.041,0.503-1.555c0.028-0.514-0.188-0.779-0.364-1.199c-0.177-0.42-0.224-0.734-0.081-0.914c0.109-0.141,0.334-0.199,0.698-0.164c0.462,0.047,1.02-0.049,1.319-0.23c0.505-0.309,0.742-0.939,0.516-1.699c0,0.744-0.244,1.025-0.855,1.366c-0.577,0.319-1.467,0.062-1.875,0.416c-0.492,0.427,0.175,1.528,0.12,2.338c-0.042,0.622-0.69,1.322-0.401,1.946c0.291,0.627,1.648,0.695,3.064,0.99c2.012,0.422,3.184,1.153,4.113,1.188c1.356,0.05,1.564-1.342,3.693-1.36c0.621-0.033,1.229-0.052,1.835-0.06c0.688-0.009,1.375-0.003,2.079,0.014c1.417,0.034,0.931,0.773,1.851,1.246c0.774,0.397,2.17,0.241,2.504-0.077c0.451-0.431,1.662-1.467,2.592-1.935c1.156-0.583,3.876-1.588,1.902-2.812c-0.461-0.285-1.547-0.588-1.639-2.676c-0.412,0.366-0.365,2.312,0.784,2.697c1.283,0.431,2.085,1.152-0.301,1.969c-1.58,0.54-1.849,0.706-3.099,1.747c-1.267,1.054-3.145,0.636-2.815-1.582c0.171-1.155,0.269-2.11-0.019-3.114c-0.142-0.49-0.211-1.119-0.114-1.562c0.187-0.858,0.651-1.117,1.106-0.293c0.285,0.519,0.385,1.122,1.408,1.171c1.607,0.077,1.926-1.553,2.439-1.627c0.343-0.05,0.686-1.02,0.425-2.589c-0.28-1.681-1.269-4.332-2.536-5.677c-1.053-1.118-1.717-2.098-2.135-3.497c-0.352-1.175-0.547-2.318-0.475-3.412c0.094-1.417-0.691-3.389-1.943-4.316c-0.782-0.581-2.011-0.893-3.122-0.88c-0.623,0.007-1.21,0.099-1.661,0.343c-1.855,1.008-2.113,2.445-2.086,4.088c0.025,1.543,0.078,3.303,0.254,4.977c-0.208,0.77-1.288,2.227-1.979,3.114C8.59,14.233,8.121,16.01,7.52,17.561c-0.321,0.828-0.862,1.2-0.908,2.265C6.6,20.122,6.61,20.891,6.894,20.672C7.98,19.829,9.343,21.95,11.398,25.188L11.398,25.188zM17.044,2.953c-0.06,0.176-0.3,0.321-0.146,0.443c0.152,0.123,0.24-0.171,0.549-0.281c0.08-0.028,0.449,0.012,0.519-0.164c0.03-0.077-0.19-0.164-0.321-0.291c-0.133-0.125-0.262-0.236-0.386-0.229C16.938,2.451,17.096,2.798,17.044,2.953L17.044,2.953zM18.934,9.35c0.115-0.121,0.174,0.207,0.483,0.402c0.244,0.154,0.481,0.04,0.545,0.354c0.044,0.225-0.097,0.467-0.284,0.436C19.35,10.486,18.596,9.705,18.934,9.35L18.934,9.35zM13.832,7.375c-0.508-0.037-0.543,0.33-0.375,0.324C13.629,7.693,13.523,7.408,13.832,7.375L13.832,7.375zM12.96,6.436c0.06-0.013,0.146,0.09,0.119,0.233c-0.037,0.199-0.021,0.324,0.117,0.325c0.022,0,0.048-0.005,0.056-0.057c0.066-0.396-0.14-0.688-0.225-0.711C12.834,6.178,12.857,6.458,12.96,6.436L12.96,6.436zM16.663,6.268c0.129,0.039,0.253,0.262,0.28,0.504c0.002,0.021,0.168-0.035,0.17-0.088c0.011-0.389-0.321-0.571-0.408-0.562C16.506,6.139,16.562,6.238,16.663,6.268L16.663,6.268zM14.765,7.423c0.463-0.214,0.625,0.118,0.465,0.171C15.066,7.648,15.065,7.345,14.765,7.423L14.765,7.423zM9.178,15.304c-0.219-0.026,0.063-0.19,0.184-0.397c0.131-0.227,0.105-0.511,0.244-0.469s0.061,0.2-0.033,0.461C9.491,15.121,9.258,15.313,9.178,15.304L9.178,15.304z");
  }
});

/***/ }),

/***/ "./src/shape/icon/List.js":
/*!********************************!*\
  !*** ./src/shape/icon/List.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.List();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.List = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.List.prototype */
{

  NAME: "draw2d.shape.icon.List",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.082,4.083v2.999h22.835V4.083H4.082zM4.082,20.306h22.835v-2.999H4.082V20.306zM4.082,13.694h22.835v-2.999H4.082V13.694zM4.082,26.917h22.835v-2.999H4.082V26.917z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Location.js":
/*!************************************!*\
  !*** ./src/shape/icon/Location.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Location();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Location = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Location.prototype */
{

  NAME: "draw2d.shape.icon.Location",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,3.5c-4.142,0-7.5,3.358-7.5,7.5c0,4.143,7.5,18.121,7.5,18.121S23.5,15.143,23.5,11C23.5,6.858,20.143,3.5,16,3.5z M16,14.584c-1.979,0-3.584-1.604-3.584-3.584S14.021,7.416,16,7.416S19.584,9.021,19.584,11S17.979,14.584,16,14.584z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Lock.js":
/*!********************************!*\
  !*** ./src/shape/icon/Lock.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Lock();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Lock = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Lock.prototype */
{

  NAME: "draw2d.shape.icon.Lock",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.335,12.833V9.999h-0.001C22.333,6.501,19.498,3.666,16,3.666S9.666,6.502,9.666,10h0v2.833H7.375V25h17.25V12.833H22.335zM11.667,10C11.667,10,11.667,10,11.667,10c0-2.39,1.944-4.334,4.333-4.334c2.391,0,4.335,1.944,4.335,4.333c0,0,0,0,0,0v2.834h-8.668V10z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Locked.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Locked.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Locked();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Locked = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Locked.prototype */
{

  NAME: "draw2d.shape.icon.Locked",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M26.711,14.085L16.914,4.29c-0.778-0.778-2.051-0.778-2.829,0L4.29,14.086c-0.778,0.778-0.778,2.05,0,2.829l9.796,9.796c0.778,0.777,2.051,0.777,2.829,0l9.797-9.797C27.488,16.136,27.488,14.863,26.711,14.085zM8.218,16.424c-0.4-0.153-0.687-0.533-0.687-0.987s0.287-0.834,0.687-0.987V16.424zM8.969,16.424v-1.974c0.4,0.152,0.687,0.533,0.687,0.987S9.369,16.272,8.969,16.424zM13.5,19.188l1.203-3.609c-0.689-0.306-1.172-0.994-1.172-1.797c0-1.087,0.881-1.969,1.969-1.969c1.087,0,1.969,0.881,1.969,1.969c0,0.803-0.482,1.491-1.172,1.797l1.203,3.609H13.5zM22.03,16.549c-0.399-0.152-0.687-0.533-0.687-0.986s0.287-0.834,0.687-0.987V16.549zM22.781,16.549v-1.973c0.4,0.152,0.688,0.533,0.688,0.987S23.182,16.397,22.781,16.549z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Magic.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Magic.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Magic();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Magic = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Magic.prototype */
{

  NAME: "draw2d.shape.icon.Magic",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M23.043,4.649l-0.404-2.312l-1.59,1.727l-2.323-0.33l1.151,2.045l-1.032,2.108l2.302-0.463l1.686,1.633l0.271-2.332l2.074-1.099L23.043,4.649zM26.217,18.198l-0.182-1.25l-0.882,0.905l-1.245-0.214l0.588,1.118l-0.588,1.118l1.245-0.214l0.882,0.905l0.182-1.25l1.133-0.56L26.217,18.198zM4.92,7.672L5.868,7.3l0.844,0.569L6.65,6.853l0.802-0.627L6.467,5.97L6.118,5.013L5.571,5.872L4.553,5.908l0.647,0.786L4.92,7.672zM10.439,10.505l1.021-1.096l1.481,0.219l-0.727-1.31l0.667-1.341l-1.47,0.287l-1.069-1.048L10.16,7.703L8.832,8.396l1.358,0.632L10.439,10.505zM17.234,12.721c-0.588-0.368-1.172-0.618-1.692-0.729c-0.492-0.089-1.039-0.149-1.425,0.374L2.562,30.788h6.68l9.669-15.416c0.303-0.576,0.012-1.041-0.283-1.447C18.303,13.508,17.822,13.09,17.234,12.721zM13.613,21.936c-0.254-0.396-0.74-0.857-1.373-1.254c-0.632-0.396-1.258-0.634-1.726-0.69l4.421-7.052c0.064-0.013,0.262-0.021,0.543,0.066c0.346,0.092,0.785,0.285,1.225,0.562c0.504,0.313,0.908,0.677,1.133,0.97c0.113,0.145,0.178,0.271,0.195,0.335c0.002,0.006,0.004,0.011,0.004,0.015L13.613,21.936z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Magnet.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Magnet.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Magnet();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Magnet = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Magnet.prototype */
{

  NAME: "draw2d.shape.icon.Magnet",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.812,19.5h5.002v-6.867c-0.028-1.706-0.61-3.807-2.172-5.841c-1.539-2.014-4.315-3.72-7.939-3.687C12.076,3.073,9.3,4.779,7.762,6.792C6.2,8.826,5.617,10.928,5.588,12.634V19.5h5v-6.866c-0.027-0.377,0.303-1.789,1.099-2.748c0.819-0.979,1.848-1.747,4.014-1.778c2.165,0.032,3.195,0.799,4.013,1.778c0.798,0.959,1.126,2.372,1.099,2.748V19.5L20.812,19.5zM25.814,25.579c0,0,0-2.354,0-5.079h-5.002c0,2.727,0,5.08,0,5.08l5.004-0.001H25.814zM5.588,25.58h5c0,0,0-2.354,0-5.08h-5C5.588,23.227,5.588,25.58,5.588,25.58z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Mail.js":
/*!********************************!*\
  !*** ./src/shape/icon/Mail.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Mail();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Mail = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Mail.prototype */
{

  NAME: "draw2d.shape.icon.Mail",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.516,7.167H3.482l12.517,7.108L28.516,7.167zM16.74,17.303C16.51,17.434,16.255,17.5,16,17.5s-0.51-0.066-0.741-0.197L2.5,10.06v14.773h27V10.06L16.74,17.303z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Man.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Man.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Man();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Man = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Man.prototype */
{

  NAME: "draw2d.shape.icon.Man",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.021,16.349c-0.611-1.104-1.359-1.998-2.109-2.623c-0.875,0.641-1.941,1.031-3.103,1.031c-1.164,0-2.231-0.391-3.105-1.031c-0.75,0.625-1.498,1.519-2.111,2.623c-1.422,2.563-1.578,5.192-0.35,5.874c0.55,0.307,1.127,0.078,1.723-0.496c-0.105,0.582-0.166,1.213-0.166,1.873c0,2.932,1.139,5.307,2.543,5.307c0.846,0,1.265-0.865,1.466-2.189c0.201,1.324,0.62,2.189,1.463,2.189c1.406,0,2.545-2.375,2.545-5.307c0-0.66-0.061-1.291-0.168-1.873c0.598,0.574,1.174,0.803,1.725,0.496C22.602,21.541,22.443,18.912,21.021,16.349zM15.808,13.757c2.362,0,4.278-1.916,4.278-4.279s-1.916-4.279-4.278-4.279c-2.363,0-4.28,1.916-4.28,4.279S13.445,13.757,15.808,13.757z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Merge.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Merge.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Merge();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Merge = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Merge.prototype */
{

  NAME: "draw2d.shape.icon.Merge",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M29.342,15.5l-7.556-4.363v2.613h-1.411c-0.788-0.01-1.331-0.241-2.019-0.743c-1.021-0.745-2.094-2.181-3.551-3.568C13.367,8.06,11.291,6.73,8.5,6.749H2.812v3.5H8.5c2.231,0.012,3.441,1.185,5.07,2.934c0.697,0.753,1.428,1.58,2.324,2.323c-1.396,1.165-2.412,2.516-3.484,3.501c-1.183,1.081-2.202,1.723-3.912,1.741H2.813v3.5h5.716c3.752,0.001,6.035-2.319,7.619-4.066c0.817-0.895,1.537-1.691,2.209-2.191c0.686-0.502,1.23-0.732,2.017-0.742h1.412v2.614L29.342,15.5z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Mic.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Mic.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Mic();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Mic = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Mic.prototype */
{

  NAME: "draw2d.shape.icon.Mic",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.5,21.125c2.682,0,4.875-2.25,4.875-5V5.875c0-2.75-2.193-5-4.875-5s-4.875,2.25-4.875,5v10.25C10.625,18.875,12.818,21.125,15.5,21.125zM21.376,11v5.125c0,3.308-2.636,6-5.876,6s-5.875-2.691-5.875-6V11H6.626v5.125c0,4.443,3.194,8.132,7.372,8.861v2.139h-3.372v3h9.749v-3h-3.376v-2.139c4.181-0.727,7.375-4.418,7.375-8.861V11H21.376z");
  }
});

/***/ }),

/***/ "./src/shape/icon/MicMute.js":
/*!***********************************!*\
  !*** ./src/shape/icon/MicMute.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.MicMute();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.MicMute = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.MicMute.prototype */
{

  NAME: "draw2d.shape.icon.MicMute",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M10.121,18.529c-0.317-0.736-0.496-1.549-0.496-2.404V11H6.626v5.125c0,1.693,0.466,3.275,1.272,4.627L10.121,18.529zM20.375,8.276V5.875c0-2.75-2.193-5-4.875-5s-4.875,2.25-4.875,5v10.25c0,0.568,0.113,1.105,0.285,1.615L20.375,8.276zM21.376,12.931v3.195c0,3.308-2.636,6-5.876,6c-0.958,0-1.861-0.24-2.661-0.657l-2.179,2.179c0.995,0.659,2.123,1.128,3.338,1.34v2.139h-3.372v3h9.749v-3h-3.376v-2.139c4.181-0.727,7.375-4.418,7.375-8.861V11h-1.068L21.376,12.931zM20.375,16.125v-2.194l-6.788,6.788c0.588,0.26,1.234,0.405,1.913,0.405C18.182,21.125,20.375,18.875,20.375,16.125zM25.542,4.522L4.855,25.209l1.415,1.416L26.956,5.937L25.542,4.522z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Minus.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Minus.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Minus();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Minus = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Minus.prototype */
{

  NAME: "draw2d.shape.icon.Minus",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z");
  }
});

/***/ }),

/***/ "./src/shape/icon/NewWindow.js":
/*!*************************************!*\
  !*** ./src/shape/icon/NewWindow.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.NewWindow();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.NewWindow = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.NewWindow.prototype */
{

  NAME: "draw2d.shape.icon.NewWindow",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M5.896,5.333V21.25h23.417V5.333H5.896zM26.312,18.25H8.896V8.334h17.417V18.25L26.312,18.25zM4.896,9.542H1.687v15.917h23.417V22.25H4.896V9.542z");
  }
});

/***/ }),

/***/ "./src/shape/icon/No.js":
/*!******************************!*\
  !*** ./src/shape/icon/No.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.No();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.No = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.No.prototype */
{

  NAME: "draw2d.shape.icon.No",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,2.939C9.006,2.942,3.338,8.61,3.335,15.605C3.335,22.6,9.005,28.268,16,28.27c6.994-0.002,12.662-5.67,12.664-12.664C28.663,8.61,22.995,2.939,16,2.939zM25.663,15.605c-0.003,1.943-0.583,3.748-1.569,5.264L10.736,7.513c1.515-0.988,3.32-1.569,5.265-1.573C21.337,5.951,25.654,10.269,25.663,15.605zM6.335,15.605c0.004-1.943,0.584-3.75,1.573-5.266l13.355,13.357c-1.516,0.986-3.32,1.566-5.264,1.569C10.664,25.26,6.346,20.941,6.335,15.605z");
  }
});

/***/ }),

/***/ "./src/shape/icon/NoMagnet.js":
/*!************************************!*\
  !*** ./src/shape/icon/NoMagnet.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.NoMagnet();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.NoMagnet = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.NoMagnet.prototype */
{

  NAME: "draw2d.shape.icon.NoMagnet",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M10.59,17.857v-5.225c-0.027-0.376,0.303-1.789,1.099-2.748c0.819-0.979,1.849-1.748,4.014-1.778c1.704,0.026,2.699,0.508,3.447,1.189l3.539-3.539c-1.616-1.526-4.01-2.679-6.986-2.652C12.077,3.073,9.3,4.779,7.762,6.793C6.2,8.826,5.617,10.928,5.59,12.634V19.5h3.357L10.59,17.857zM5.59,20.5v2.357L7.947,20.5H5.59zM20.812,13.29v6.21h5.002v-6.866c-0.021-1.064-0.252-2.283-0.803-3.542L20.812,13.29zM25.339,4.522L4.652,25.209l1.415,1.416L26.753,5.937L25.339,4.522zM20.812,25.58h5.002c0,0,0-2.354,0-5.08h-5.002C20.812,23.227,20.812,25.58,20.812,25.58zM10.59,25.58c0,0,0-0.827,0-2.064L8.525,25.58H10.59z");
  }
});

/***/ }),

/***/ "./src/shape/icon/NodeJs.js":
/*!**********************************!*\
  !*** ./src/shape/icon/NodeJs.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.NodeJs();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.NodeJs = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.NodeJs.prototype */
{

  NAME: "draw2d.shape.icon.NodeJs",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.783,4.458L2.59,3.196C2.553,3.174,2.511,3.163,2.469,3.161H2.447C2.405,3.163,2.363,3.174,2.326,3.196L0.133,4.458C0.051,4.505,0,4.593,0,4.688l0.005,3.398c0,0.047,0.024,0.092,0.066,0.114c0.041,0.024,0.091,0.024,0.132,0l1.303-0.746c0.083-0.049,0.132-0.136,0.132-0.229V5.637c0-0.095,0.05-0.183,0.132-0.229l0.555-0.32c0.041-0.023,0.086-0.035,0.132-0.035c0.045,0,0.092,0.012,0.132,0.035l0.555,0.32c0.082,0.047,0.133,0.135,0.133,0.229v1.588c0,0.094,0.051,0.182,0.132,0.229l1.303,0.746c0.041,0.024,0.092,0.024,0.132,0c0.041-0.022,0.066-0.067,0.066-0.114l0.004-3.398C4.915,4.593,4.865,4.505,4.783,4.458zM17.93,0.745l-1.305-0.729c-0.042-0.023-0.091-0.022-0.132,0.001c-0.041,0.024-0.065,0.067-0.065,0.114v3.365c0,0.033-0.018,0.064-0.046,0.081s-0.064,0.017-0.093,0l-0.549-0.316c-0.082-0.047-0.183-0.047-0.265,0l-2.193,1.266c-0.082,0.047-0.133,0.135-0.133,0.229V7.29c0,0.095,0.051,0.182,0.132,0.229l2.194,1.267c0.082,0.048,0.183,0.048,0.265,0l2.194-1.267c0.082-0.048,0.133-0.135,0.133-0.229V0.977C18.066,0.88,18.014,0.792,17.93,0.745zM16.421,6.458c0,0.023-0.013,0.045-0.033,0.057l-0.753,0.435c-0.021,0.012-0.045,0.012-0.066,0l-0.753-0.435c-0.021-0.012-0.033-0.034-0.033-0.057v-0.87c0-0.023,0.013-0.045,0.033-0.058l0.753-0.435c0.021-0.012,0.045-0.012,0.066,0l0.753,0.435c0.021,0.012,0.033,0.034,0.033,0.058V6.458zM24.473,4.493l-2.18-1.266c-0.082-0.047-0.183-0.048-0.265,0l-2.193,1.266c-0.082,0.047-0.132,0.135-0.132,0.229v2.532c0,0.096,0.051,0.184,0.133,0.23l2.18,1.242c0.08,0.045,0.179,0.046,0.26,0.001l1.318-0.732c0.042-0.023,0.067-0.067,0.068-0.115c0-0.048-0.025-0.092-0.066-0.116l-2.207-1.266c-0.041-0.023-0.066-0.067-0.066-0.115V5.59c0-0.047,0.025-0.091,0.065-0.115l0.688-0.396c0.041-0.024,0.091-0.024,0.132,0l0.688,0.396c0.041,0.023,0.066,0.067,0.066,0.115v0.625c0,0.047,0.025,0.091,0.066,0.114c0.041,0.024,0.092,0.024,0.132,0l1.314-0.764c0.081-0.047,0.132-0.135,0.132-0.229V4.722C24.605,4.628,24.555,4.541,24.473,4.493zM11.363,4.48L9.169,3.214c-0.082-0.047-0.183-0.047-0.265,0L6.711,4.48C6.629,4.527,6.579,4.615,6.579,4.709v2.534c0,0.095,0.051,0.182,0.133,0.229l2.193,1.267c0.082,0.048,0.183,0.048,0.265,0l2.193-1.267c0.082-0.048,0.132-0.135,0.132-0.229V4.709C11.495,4.615,11.445,4.527,11.363,4.48zM31.019,4.382L28.95,3.187c-0.13-0.074-0.304-0.074-0.435,0l-2.068,1.195c-0.135,0.077-0.218,0.222-0.218,0.377v2.386c0,0.156,0.083,0.301,0.218,0.378l0.542,0.312c0.263,0.13,0.356,0.13,0.477,0.13c0.389,0,0.612-0.236,0.612-0.646V4.962c0-0.033-0.027-0.06-0.06-0.06h-0.263c-0.033,0-0.061,0.026-0.061,0.06v2.356c0,0.182-0.188,0.363-0.495,0.209l-0.566-0.326c-0.021-0.012-0.033-0.033-0.033-0.057V4.759c0-0.023,0.013-0.045,0.033-0.057l2.067-1.193c0.019-0.011,0.044-0.011,0.063,0l2.067,1.193c0.02,0.012,0.032,0.034,0.032,0.057v2.386c0,0.023-0.013,0.046-0.032,0.057l-2.068,1.193c-0.018,0.012-0.045,0.012-0.063,0l-0.53-0.314c-0.017-0.01-0.036-0.013-0.052-0.004c-0.146,0.083-0.175,0.094-0.312,0.143c-0.034,0.012-0.084,0.031,0.019,0.09l0.691,0.408c0.065,0.038,0.141,0.059,0.217,0.059s0.151-0.021,0.218-0.059l2.068-1.194c0.134-0.078,0.217-0.222,0.217-0.378V4.759C31.235,4.604,31.152,4.459,31.019,4.382zM29.371,6.768c-0.548,0-0.668-0.138-0.708-0.41c-0.005-0.029-0.029-0.051-0.06-0.051h-0.268c-0.033,0-0.06,0.026-0.06,0.06c0,0.349,0.189,0.765,1.095,0.765c0.655,0,1.031-0.259,1.031-0.709c0-0.447-0.302-0.566-0.938-0.65c-0.643-0.085-0.708-0.128-0.708-0.279c0-0.125,0.056-0.29,0.531-0.29c0.425,0,0.581,0.091,0.646,0.378c0.006,0.027,0.03,0.047,0.059,0.047h0.269c0.017,0,0.032-0.007,0.044-0.019c0.011-0.013,0.017-0.029,0.016-0.046c-0.042-0.493-0.37-0.723-1.032-0.723c-0.59,0-0.941,0.249-0.941,0.666c0,0.453,0.35,0.578,0.916,0.634c0.677,0.066,0.729,0.166,0.729,0.298C29.992,6.669,29.807,6.768,29.371,6.768zM22.128,5.446l-0.42,0.243c-0.016,0.009-0.025,0.026-0.025,0.044v0.486c0,0.019,0.01,0.035,0.025,0.044l0.42,0.243c0.016,0.009,0.035,0.009,0.052,0l0.421-0.243c0.016-0.009,0.025-0.025,0.025-0.044V5.733c0-0.018-0.01-0.035-0.025-0.044L22.18,5.446C22.163,5.438,22.144,5.438,22.128,5.446z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Notebook.js":
/*!************************************!*\
  !*** ./src/shape/icon/Notebook.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Notebook();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Notebook = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Notebook.prototype */
{

  NAME: "draw2d.shape.icon.Notebook",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.875,1.375H8c-1.033,0-1.874,0.787-1.979,1.792h1.604c1.102,0,2,0.898,2,2c0,1.102-0.898,2-2,2H6v0.999h1.625c1.104,0,2.002,0.898,2.002,2.002c0,1.104-0.898,2.001-2.002,2.001H6v0.997h1.625c1.102,0,2,0.898,2,2c0,1.104-0.898,2.004-2,2.004H6v0.994h1.625c1.102,0,2,0.898,2,2.002s-0.898,2.002-2,2.002H6v0.997h1.624c1.104,0,2.002,0.897,2.002,2.001c0,1.104-0.898,2.002-2.002,2.002H6.004C6.027,28.252,6.91,29.125,8,29.125h16.875c1.104,0,2-0.896,2-2V3.375C26.875,2.271,25.979,1.375,24.875,1.375zM25.25,8.375c0,0.552-0.447,1-1,1H14c-0.553,0-1-0.448-1-1V4c0-0.552,0.447-1,1-1h10.25c0.553,0,1,0.448,1,1V8.375zM8.625,25.166c0-0.554-0.449-1.001-1-1.001h-3.25c-0.552,0-1,0.447-1,1.001c0,0.552,0.449,1,1,1h3.25C8.176,26.166,8.625,25.718,8.625,25.166zM4.375,6.166h3.251c0.551,0,0.999-0.448,0.999-0.999c0-0.555-0.448-1-0.999-1H4.375c-0.553,0-1,0.445-1,1C3.374,5.718,3.822,6.166,4.375,6.166zM4.375,11.167h3.25c0.553,0,1-0.448,1-1s-0.448-1-1-1h-3.25c-0.553,0-1,0.448-1,1S3.822,11.167,4.375,11.167zM4.375,16.167h3.25c0.551,0,1-0.448,1-1.001s-0.448-0.999-1-0.999h-3.25c-0.553,0-1.001,0.446-1.001,0.999S3.822,16.167,4.375,16.167zM3.375,20.165c0,0.553,0.446,1.002,1,1.002h3.25c0.551,0,1-0.449,1-1.002c0-0.552-0.448-1-1-1h-3.25C3.821,19.165,3.375,19.613,3.375,20.165z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Noview.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Noview.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Noview();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Noview = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Noview.prototype */
{

  NAME: "draw2d.shape.icon.Noview",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M11.478,17.568c-0.172-0.494-0.285-1.017-0.285-1.568c0-2.65,2.158-4.807,4.807-4.807c0.552,0,1.074,0.113,1.568,0.285l2.283-2.283C18.541,8.647,17.227,8.286,16,8.286C8.454,8.286,2.5,16,2.5,16s2.167,2.791,5.53,5.017L11.478,17.568zM23.518,11.185l-3.056,3.056c0.217,0.546,0.345,1.138,0.345,1.76c0,2.648-2.158,4.807-4.807,4.807c-0.622,0-1.213-0.128-1.76-0.345l-2.469,2.47c1.327,0.479,2.745,0.783,4.229,0.783c5.771,0,13.5-7.715,13.5-7.715S26.859,13.374,23.518,11.185zM25.542,4.917L4.855,25.604L6.27,27.02L26.956,6.332L25.542,4.917z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Opera.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Opera.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Opera();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Opera = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Opera.prototype */
{

  NAME: "draw2d.shape.icon.Opera",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.954,2.046c-7.489,0-12.872,5.432-12.872,13.581c0,7.25,5.234,13.835,12.873,13.835c7.712,0,12.974-6.583,12.974-13.835C28.929,7.413,23.375,2.046,15.954,2.046zM15.952,26.548L15.952,26.548c-2.289,0-3.49-1.611-4.121-3.796c-0.284-1.037-0.458-2.185-0.563-3.341c-0.114-1.374-0.129-2.773-0.129-4.028c0-0.993,0.018-1.979,0.074-2.926c0.124-1.728,0.386-3.431,0.89-4.833c0.694-1.718,1.871-2.822,3.849-2.822c2.5,0,3.763,1.782,4.385,4.322c0.429,1.894,0.56,4.124,0.56,6.274c0,2.299-0.103,5.153-0.763,7.442C19.473,24.979,18.242,26.548,15.952,26.548z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Package.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Package.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Package();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Package = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Package.prototype */
{

  NAME: "draw2d.shape.icon.Package",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M17.078,22.004l-1.758-4.129l-2.007,4.752l-7.519-3.289l0.174,3.905l9.437,4.374l10.909-5.365l-0.149-4.989L17.078,22.004zM29.454,6.619L18.521,3.383l-3.006,2.671l-3.091-2.359L1.546,8.199l3.795,3.048l-3.433,5.302l10.879,4.757l2.53-5.998l2.257,5.308l11.393-5.942l-3.105-4.709L29.454,6.619zM15.277,14.579l-9.059-3.83l9.275-4.101l9.608,3.255L15.277,14.579z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Page.js":
/*!********************************!*\
  !*** ./src/shape/icon/Page.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Page();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Page = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Page.prototype */
{

  NAME: "draw2d.shape.icon.Page",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M23.024,5.673c-1.744-1.694-3.625-3.051-5.168-3.236c-0.084-0.012-0.171-0.019-0.263-0.021H7.438c-0.162,0-0.322,0.063-0.436,0.18C6.889,2.71,6.822,2.87,6.822,3.033v25.75c0,0.162,0.063,0.317,0.18,0.435c0.117,0.116,0.271,0.179,0.436,0.179h18.364c0.162,0,0.317-0.062,0.434-0.179c0.117-0.117,0.182-0.272,0.182-0.435V11.648C26.382,9.659,24.824,7.49,23.024,5.673zM25.184,28.164H8.052V3.646h9.542v0.002c0.416-0.025,0.775,0.386,1.05,1.326c0.25,0.895,0.313,2.062,0.312,2.871c0.002,0.593-0.027,0.991-0.027,0.991l-0.049,0.652l0.656,0.007c0.003,0,1.516,0.018,3,0.355c1.426,0.308,2.541,0.922,2.645,1.617c0.004,0.062,0.005,0.124,0.004,0.182V28.164z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Page2.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Page2.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Page2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Page2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Page2.prototype */
{

  NAME: "draw2d.shape.icon.Page2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M23.024,5.673c-1.744-1.694-3.625-3.051-5.168-3.236c-0.084-0.012-0.171-0.019-0.263-0.021H7.438c-0.162,0-0.322,0.063-0.436,0.18C6.889,2.71,6.822,2.87,6.822,3.033v25.75c0,0.162,0.063,0.317,0.18,0.435c0.117,0.116,0.271,0.179,0.436,0.179h18.364c0.162,0,0.317-0.062,0.434-0.179c0.117-0.117,0.182-0.272,0.182-0.435V11.648C26.382,9.659,24.824,7.49,23.024,5.673zM22.157,6.545c0.805,0.786,1.529,1.676,2.069,2.534c-0.468-0.185-0.959-0.322-1.42-0.431c-1.015-0.228-2.008-0.32-2.625-0.357c0.003-0.133,0.004-0.283,0.004-0.446c0-0.869-0.055-2.108-0.356-3.2c-0.003-0.01-0.005-0.02-0.009-0.03C20.584,5.119,21.416,5.788,22.157,6.545zM25.184,28.164H8.052V3.646h9.542v0.002c0.416-0.025,0.775,0.386,1.05,1.326c0.25,0.895,0.313,2.062,0.312,2.871c0.002,0.593-0.027,0.991-0.027,0.991l-0.049,0.652l0.656,0.007c0.003,0,1.516,0.018,3,0.355c1.426,0.308,2.541,0.922,2.645,1.617c0.004,0.062,0.005,0.124,0.004,0.182V28.164z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Pallete.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Pallete.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Pallete();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Pallete = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Pallete.prototype */
{

  NAME: "draw2d.shape.icon.Pallete",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.653,7.25c-3.417,0-8.577,0.983-8.577,3.282c0,1.91,2.704,3.229,1.691,3.889c-1.02,0.666-2.684-1.848-4.048-1.848c-1.653,0-2.815,1.434-2.815,2.926c0,4.558,6.326,8.25,13.749,8.25c7.424,0,13.443-3.692,13.443-8.25C29.096,10.944,23.077,7.25,15.653,7.25zM10.308,13.521c0-0.645,0.887-1.166,1.98-1.166c1.093,0,1.979,0.521,1.979,1.166c0,0.644-0.886,1.166-1.979,1.166C11.195,14.687,10.308,14.164,10.308,13.521zM14.289,22.299c-1.058,0-1.914-0.68-1.914-1.518s0.856-1.518,1.914-1.518c1.057,0,1.914,0.68,1.914,1.518S15.346,22.299,14.289,22.299zM19.611,21.771c-1.057,0-1.913-0.681-1.913-1.519c0-0.84,0.856-1.521,1.913-1.521c1.059,0,1.914,0.681,1.914,1.521C21.525,21.092,20.67,21.771,19.611,21.771zM20.075,10.66c0-0.838,0.856-1.518,1.914-1.518s1.913,0.68,1.913,1.518c0,0.839-0.855,1.518-1.913,1.518C20.934,12.178,20.075,11.499,20.075,10.66zM24.275,19.482c-1.057,0-1.914-0.681-1.914-1.519s0.857-1.518,1.914-1.518c1.059,0,1.914,0.68,1.914,1.518S25.334,19.482,24.275,19.482zM25.286,15.475c-1.058,0-1.914-0.68-1.914-1.519c0-0.838,0.856-1.518,1.914-1.518c1.057,0,1.913,0.68,1.913,1.518C27.199,14.795,26.343,15.475,25.286,15.475z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Palm.js":
/*!********************************!*\
  !*** ./src/shape/icon/Palm.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Palm();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Palm = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Palm.prototype */
{

  NAME: "draw2d.shape.icon.Palm",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.296,27.885v-2.013c0,0-0.402-1.408-1.073-2.013c-0.671-0.604-1.274-1.274-1.409-1.61c0,0-0.268,0.135-0.737-0.335s-1.812-2.616-1.812-2.616l-0.671-0.872c0,0-0.47-0.671-1.275-1.342c-0.805-0.672-0.938-0.067-1.476-0.738s0.604-1.275,1.006-1.409c0.403-0.134,1.946,0.134,2.684,0.872c0.738,0.738,0.738,0.738,0.738,0.738l1.073,1.141l0.537,0.201l0.671-1.073l-0.269-2.281c0,0-0.604-2.55-0.737-4.764c-0.135-2.214-0.47-5.703,1.006-5.837s1.007,2.55,1.073,3.489c0.067,0.938,0.806,5.232,1.208,5.568c0.402,0.335,0.671,0.066,0.671,0.066l0.402-7.514c0,0-0.479-2.438,1.073-2.549c0.939-0.067,0.872,1.543,0.872,2.147c0,0.604,0.269,7.514,0.269,7.514l0.537,0.135c0,0,0.402-2.214,0.604-3.153s0.604-2.416,0.537-3.087c-0.067-0.671-0.135-2.348,1.006-2.348s0.872,1.812,0.939,2.415s-0.134,3.153-0.134,3.757c0,0.604-0.738,3.623-0.537,3.824s2.08-2.817,2.349-3.958c0.268-1.141,0.201-3.02,1.408-2.885c1.208,0.134,0.47,2.817,0.402,3.086c-0.066,0.269-0.671,2.349-0.872,2.952s-0.805,1.476-1.006,2.013s0.402,2.349,0,4.629c-0.402,2.281-1.61,5.166-1.61,5.166l0.604,2.08c0,0-1.744,0.671-3.824,0.805C16.443,28.221,14.296,27.885,14.296,27.885z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Paper.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Paper.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Paper();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Paper = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Paper.prototype */
{

  NAME: "draw2d.shape.icon.Paper",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.916,8.009L15.953,1.888c-0.251-0.119-0.548-0.115-0.798,0.008c-0.25,0.125-0.433,0.357-0.491,0.629c-0.002,0.01-1.04,4.83-2.578,9.636c-0.526,1.646-1.114,3.274-1.728,4.704l1.665,0.786c2-4.643,3.584-11.052,4.181-13.614l11.264,5.316c-0.346,1.513-1.233,5.223-2.42,8.927c-0.767,2.399-1.665,4.797-2.585,6.532c-0.889,1.79-1.958,2.669-2.197,2.552c-1.419,0.03-2.418-1.262-3.09-2.918c-0.32-0.803-0.53-1.63-0.657-2.246c-0.127-0.618-0.166-1.006-0.168-1.006c-0.034-0.317-0.232-0.597-0.52-0.731l-12.962-6.12c-0.301-0.142-0.654-0.11-0.925,0.081c-0.27,0.193-0.416,0.518-0.38,0.847c0.008,0.045,0.195,1.848,0.947,3.736c0.521,1.321,1.406,2.818,2.845,3.575l12.956,6.131l0.006-0.013c0.562,0.295,1.201,0.487,1.947,0.496c1.797-0.117,2.777-1.668,3.818-3.525c3-5.69,5.32-16.602,5.338-16.642C29.512,8.615,29.302,8.19,28.916,8.009z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Parent.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Parent.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Parent();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Parent = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Parent.prototype */
{

  NAME: "draw2d.shape.icon.Parent",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.423,12.17c-0.875,0.641-1.941,1.031-3.102,1.031c-1.164,0-2.231-0.391-3.104-1.031c-0.75,0.625-1.498,1.519-2.111,2.623c-1.422,2.563-1.578,5.192-0.35,5.874c0.549,0.312,1.127,0.078,1.723-0.496c-0.105,0.582-0.166,1.213-0.166,1.873c0,2.938,1.139,5.312,2.543,5.312c0.846,0,1.265-0.865,1.466-2.188c0.2,1.314,0.62,2.188,1.461,2.188c1.396,0,2.545-2.375,2.545-5.312c0-0.66-0.062-1.291-0.168-1.873c0.6,0.574,1.176,0.812,1.726,0.496c1.227-0.682,1.068-3.311-0.354-5.874C15.921,13.689,15.173,12.795,14.423,12.17zM11.32,12.201c2.361,0,4.277-1.916,4.277-4.279s-1.916-4.279-4.277-4.279c-2.363,0-4.28,1.916-4.28,4.279S8.957,12.201,11.32,12.201zM21.987,17.671c1.508,0,2.732-1.225,2.732-2.735c0-1.51-1.225-2.735-2.732-2.735c-1.511,0-2.736,1.225-2.736,2.735C19.251,16.446,20.477,17.671,21.987,17.671zM25.318,19.327c-0.391-0.705-0.869-1.277-1.349-1.677c-0.56,0.41-1.24,0.659-1.982,0.659c-0.744,0-1.426-0.25-1.983-0.659c-0.479,0.399-0.958,0.972-1.35,1.677c-0.909,1.638-1.009,3.318-0.224,3.754c0.351,0.2,0.721,0.05,1.101-0.317c-0.067,0.372-0.105,0.775-0.105,1.197c0,1.878,0.728,3.396,1.625,3.396c0.54,0,0.808-0.553,0.937-1.398c0.128,0.841,0.396,1.398,0.934,1.398c0.893,0,1.627-1.518,1.627-3.396c0-0.422-0.04-0.825-0.107-1.197c0.383,0.367,0.752,0.52,1.104,0.317C26.328,22.646,26.227,20.965,25.318,19.327z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Pc.js":
/*!******************************!*\
  !*** ./src/shape/icon/Pc.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Pc();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Pc = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Pc.prototype */
{

  NAME: "draw2d.shape.icon.Pc",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M29.249,3.14h-9.188l-0.459,0.459v18.225l0.33,2.389H19.57v0.245h-0.307v-0.306h-0.611v0.244h-0.311v-0.367h-0.486v0.307h-1.104l-2.022-0.367v-0.92h0.858l0.302-1.47h2.728c0.188,0,0.339-0.152,0.339-0.339V7.828c0-0.187-0.149-0.338-0.339-0.338H1.591c-0.187,0-0.339,0.152-0.339,0.338V21.24c0,0.187,0.152,0.339,0.339,0.339h3.016l0.199,1.47h1.409l-3.4,3.4L2.11,27.951c0,0,2.941,1.102,6.678,1.102c3.737,0,9.679-0.857,10.476-0.857s4.84,0,4.84,0v-1.225l-0.137-1.068h1.744c-0.2,0.106-0.322,0.244-0.322,0.396v0.979c0,0.341,0.604,0.613,1.352,0.613c0.742,0,1.348-0.272,1.348-0.613v-0.979c0-0.339-0.604-0.611-1.348-0.611c-0.188,0-0.364,0.019-0.525,0.049v-0.17h-2.29l-0.055-0.432h5.382L29.249,3.14L29.249,3.14zM2.478,20.17V8.714h15.07V20.17H2.478z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Pen.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Pen.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Pen();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Pen = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Pen.prototype */
{

  NAME: "draw2d.shape.icon.Pen",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M13.587,12.074c-0.049-0.074-0.11-0.147-0.188-0.202c-0.333-0.243-0.803-0.169-1.047,0.166c-0.244,0.336-0.167,0.805,0.167,1.048c0.303,0.22,0.708,0.167,0.966-0.091l-7.086,9.768l-2.203,7.997l6.917-4.577L26.865,4.468l-4.716-3.42l-1.52,2.096c-0.087-0.349-0.281-0.676-0.596-0.907c-0.73-0.529-1.751-0.369-2.28,0.363C14.721,6.782,16.402,7.896,13.587,12.074zM10.118,25.148L6.56,27.503l1.133-4.117L10.118,25.148zM14.309,11.861c2.183-3.225,1.975-4.099,3.843-6.962c0.309,0.212,0.664,0.287,1.012,0.269L14.309,11.861z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Pensil.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Pensil.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Pensil();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Pensil = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Pensil.prototype */
{

  NAME: "draw2d.shape.icon.Pensil",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.31,2.872l-3.384-2.127c-0.854-0.536-1.979-0.278-2.517,0.576l-1.334,2.123l6.474,4.066l1.335-2.122C26.42,4.533,26.164,3.407,25.31,2.872zM6.555,21.786l6.474,4.066L23.581,9.054l-6.477-4.067L6.555,21.786zM5.566,26.952l-0.143,3.819l3.379-1.787l3.14-1.658l-6.246-3.925L5.566,26.952z");
  }
});

/***/ }),

/***/ "./src/shape/icon/People.js":
/*!**********************************!*\
  !*** ./src/shape/icon/People.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.People();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.People = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.People.prototype */
{

  NAME: "draw2d.shape.icon.People",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.066,20.667c1.227-0.682,1.068-3.311-0.354-5.874c-0.611-1.104-1.359-1.998-2.109-2.623c-0.875,0.641-1.941,1.031-3.102,1.031c-1.164,0-2.231-0.391-3.104-1.031c-0.75,0.625-1.498,1.519-2.111,2.623c-1.422,2.563-1.578,5.192-0.35,5.874c0.549,0.312,1.127,0.078,1.723-0.496c-0.105,0.582-0.166,1.213-0.166,1.873c0,2.938,1.139,5.312,2.543,5.312c0.846,0,1.265-0.865,1.466-2.188c0.2,1.314,0.62,2.188,1.461,2.188c1.396,0,2.545-2.375,2.545-5.312c0-0.66-0.062-1.291-0.168-1.873C19.939,20.745,20.516,20.983,21.066,20.667zM15.5,12.201c2.361,0,4.277-1.916,4.277-4.279S17.861,3.644,15.5,3.644c-2.363,0-4.28,1.916-4.28,4.279S13.137,12.201,15.5,12.201zM24.094,14.914c1.938,0,3.512-1.573,3.512-3.513c0-1.939-1.573-3.513-3.512-3.513c-1.94,0-3.513,1.573-3.513,3.513C20.581,13.341,22.153,14.914,24.094,14.914zM28.374,17.043c-0.502-0.907-1.116-1.641-1.732-2.154c-0.718,0.526-1.594,0.846-2.546,0.846c-0.756,0-1.459-0.207-2.076-0.55c0.496,1.093,0.803,2.2,0.861,3.19c0.093,1.516-0.381,2.641-1.329,3.165c-0.204,0.117-0.426,0.183-0.653,0.224c-0.056,0.392-0.095,0.801-0.095,1.231c0,2.412,0.935,4.361,2.088,4.361c0.694,0,1.039-0.71,1.204-1.796c0.163,1.079,0.508,1.796,1.199,1.796c1.146,0,2.09-1.95,2.09-4.361c0-0.542-0.052-1.06-0.139-1.538c0.492,0.472,0.966,0.667,1.418,0.407C29.671,21.305,29.541,19.146,28.374,17.043zM6.906,14.914c1.939,0,3.512-1.573,3.512-3.513c0-1.939-1.573-3.513-3.512-3.513c-1.94,0-3.514,1.573-3.514,3.513C3.392,13.341,4.966,14.914,6.906,14.914zM9.441,21.536c-1.593-0.885-1.739-3.524-0.457-6.354c-0.619,0.346-1.322,0.553-2.078,0.553c-0.956,0-1.832-0.321-2.549-0.846c-0.616,0.513-1.229,1.247-1.733,2.154c-1.167,2.104-1.295,4.262-0.287,4.821c0.451,0.257,0.925,0.064,1.414-0.407c-0.086,0.479-0.136,0.996-0.136,1.538c0,2.412,0.935,4.361,2.088,4.361c0.694,0,1.039-0.71,1.204-1.796c0.165,1.079,0.509,1.796,1.201,1.796c1.146,0,2.089-1.95,2.089-4.361c0-0.432-0.04-0.841-0.097-1.233C9.874,21.721,9.651,21.656,9.441,21.536z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Phone.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Phone.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Phone();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Phone = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Phone.prototype */
{

  NAME: "draw2d.shape.icon.Phone",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.065,18.53c-0.467-0.29-1.167-0.21-1.556,0.179l-3.093,3.092c-0.389,0.389-1.025,0.389-1.414,0L9.05,14.848c-0.389-0.389-0.389-1.025,0-1.414l2.913-2.912c0.389-0.389,0.447-1.075,0.131-1.524L6.792,1.485C6.476,1.036,5.863,0.948,5.433,1.29c0,0-4.134,3.281-4.134,6.295c0,12.335,10,22.334,22.334,22.334c3.015,0,5.948-5.533,5.948-5.533c0.258-0.486,0.087-1.122-0.38-1.412L22.065,18.53z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Photo.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Photo.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Photo();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Photo = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Photo.prototype */
{

  NAME: "draw2d.shape.icon.Photo",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.25,10.25H20.5v-1.5h-9.375v1.5h-3.75c-1.104,0-2,0.896-2,2v10.375c0,1.104,0.896,2,2,2H24.25c1.104,0,2-0.896,2-2V12.25C26.25,11.146,25.354,10.25,24.25,10.25zM15.812,23.499c-3.342,0-6.06-2.719-6.06-6.061c0-3.342,2.718-6.062,6.06-6.062s6.062,2.72,6.062,6.062C21.874,20.78,19.153,23.499,15.812,23.499zM15.812,13.375c-2.244,0-4.062,1.819-4.062,4.062c0,2.244,1.819,4.062,4.062,4.062c2.244,0,4.062-1.818,4.062-4.062C19.875,15.194,18.057,13.375,15.812,13.375z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Picker.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Picker.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Picker();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Picker = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Picker.prototype */
{

  NAME: "draw2d.shape.icon.Picker",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.221,10.853c-0.111-0.414-0.261-0.412,0.221-1.539l1.66-3.519c0.021-0.051,0.2-0.412,0.192-0.946c0.015-0.529-0.313-1.289-1.119-1.642c-1.172-0.555-1.17-0.557-2.344-1.107c-0.784-0.396-1.581-0.171-1.979,0.179c-0.42,0.333-0.584,0.7-0.609,0.75L16.58,6.545c-0.564,1.084-0.655,0.97-1.048,1.147c-0.469,0.129-1.244,0.558-1.785,1.815c-1.108,2.346-1.108,2.346-1.108,2.346l-0.276,0.586l1.17,0.553l-3.599,7.623c-0.38,0.828-0.166,1.436-0.166,2.032c0.01,0.627-0.077,1.509-0.876,3.21l-0.276,0.586l3.517,1.661l0.276-0.585c0.808-1.699,1.431-2.326,1.922-2.717c0.46-0.381,1.066-0.6,1.465-1.42l3.599-7.618l1.172,0.554l0.279-0.589c0,0,0,0,1.105-2.345C22.578,12.166,22.419,11.301,22.221,10.853zM14.623,22.83c-0.156,0.353-0.413,0.439-1.091,0.955c-0.577,0.448-1.264,1.172-2.009,2.6l-1.191-0.562c0.628-1.48,0.75-2.474,0.73-3.203c-0.031-0.851-0.128-1.104,0.045-1.449l3.599-7.621l3.517,1.662L14.623,22.83z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Picture.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Picture.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Picture();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Picture = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Picture.prototype */
{

  NAME: "draw2d.shape.icon.Picture",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M2.5,4.833v22.334h27V4.833H2.5zM25.25,25.25H6.75V6.75h18.5V25.25zM11.25,14c1.426,0,2.583-1.157,2.583-2.583c0-1.427-1.157-2.583-2.583-2.583c-1.427,0-2.583,1.157-2.583,2.583C8.667,12.843,9.823,14,11.25,14zM24.251,16.25l-4.917-4.917l-6.917,6.917L10.5,16.333l-2.752,2.752v5.165h16.503V16.25z");
  }
});

/***/ }),

/***/ "./src/shape/icon/PieChart.js":
/*!************************************!*\
  !*** ./src/shape/icon/PieChart.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.PieChart();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.PieChart = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.PieChart.prototype */
{

  NAME: "draw2d.shape.icon.PieChart",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.583,15.917l1.648-10.779C16.692,5.056,16.145,5,15.583,5C9.554,5,4.666,9.888,4.666,15.917c0,6.029,4.888,10.917,10.917,10.917S26.5,21.946,26.5,15.917c0-0.256-0.021-0.507-0.038-0.759L15.583,15.917zM19.437,3.127l-1.648,10.779l10.879-0.759C28.313,8.026,24.436,3.886,19.437,3.127z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Plane.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Plane.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Plane();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Plane = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Plane.prototype */
{

  NAME: "draw2d.shape.icon.Plane",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M19.671,8.11l-2.777,2.777l-3.837-0.861c0.362-0.505,0.916-1.683,0.464-2.135c-0.518-0.517-1.979,0.278-2.305,0.604l-0.913,0.913L7.614,8.804l-2.021,2.021l2.232,1.061l-0.082,0.082l1.701,1.701l0.688-0.687l3.164,1.504L9.571,18.21H6.413l-1.137,1.138l3.6,0.948l1.83,1.83l0.947,3.598l1.137-1.137V21.43l3.725-3.725l1.504,3.164l-0.687,0.687l1.702,1.701l0.081-0.081l1.062,2.231l2.02-2.02l-0.604-2.689l0.912-0.912c0.326-0.326,1.121-1.789,0.604-2.306c-0.452-0.452-1.63,0.101-2.135,0.464l-0.861-3.838l2.777-2.777c0.947-0.947,3.599-4.862,2.62-5.839C24.533,4.512,20.618,7.163,19.671,8.11z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Plugin.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Plugin.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Plugin();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Plugin = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Plugin.prototype */
{

  NAME: "draw2d.shape.icon.Plugin",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M26.33,15.836l-3.893-1.545l3.136-7.9c0.28-0.705-0.064-1.505-0.771-1.785c-0.707-0.28-1.506,0.065-1.785,0.771l-3.136,7.9l-4.88-1.937l3.135-7.9c0.281-0.706-0.064-1.506-0.77-1.786c-0.706-0.279-1.506,0.065-1.785,0.771l-3.136,7.9L8.554,8.781l-1.614,4.066l2.15,0.854l-2.537,6.391c-0.61,1.54,0.143,3.283,1.683,3.895l1.626,0.646L8.985,26.84c-0.407,1.025,0.095,2.188,1.122,2.596l0.93,0.369c1.026,0.408,2.188-0.095,2.596-1.121l0.877-2.207l1.858,0.737c1.54,0.611,3.284-0.142,3.896-1.682l2.535-6.391l1.918,0.761L26.33,15.836z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Plus.js":
/*!********************************!*\
  !*** ./src/shape/icon/Plus.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Plus();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Plus = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Plus.prototype */
{

  NAME: "draw2d.shape.icon.Plus",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.979,12.896 19.312,12.896 19.312,6.229 12.647,6.229 12.647,12.896 5.979,12.896 5.979,19.562 12.647,19.562 12.647,26.229 19.312,26.229 19.312,19.562 25.979,19.562z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Power.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Power.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Power();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Power = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Power.prototype */
{

  NAME: "draw2d.shape.icon.Power",

  /**
   * Creates a new icon element which are not assigned to any canvas.
   *
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.542,8.354c-1.47-1.766-2.896-2.617-3.025-2.695c-0.954-0.565-2.181-0.241-2.739,0.724c-0.556,0.961-0.24,2.194,0.705,2.763c0,0,0.001,0,0.002,0.001c0.001,0,0.002,0.001,0.003,0.002c0.001,0,0.003,0.001,0.004,0.001c0.102,0.062,1.124,0.729,2.08,1.925c1.003,1.261,1.933,3.017,1.937,5.438c-0.001,2.519-1.005,4.783-2.64,6.438c-1.637,1.652-3.877,2.668-6.368,2.669c-2.491-0.001-4.731-1.017-6.369-2.669c-1.635-1.654-2.639-3.919-2.64-6.438c0.005-2.499,0.995-4.292,2.035-5.558c0.517-0.625,1.043-1.098,1.425-1.401c0.191-0.152,0.346-0.263,0.445-0.329c0.049-0.034,0.085-0.058,0.104-0.069c0.005-0.004,0.009-0.006,0.012-0.008s0.004-0.002,0.004-0.002l0,0c0.946-0.567,1.262-1.802,0.705-2.763c-0.559-0.965-1.785-1.288-2.739-0.724c-0.128,0.079-1.555,0.93-3.024,2.696c-1.462,1.751-2.974,4.511-2.97,8.157C2.49,23.775,8.315,29.664,15.5,29.667c7.186-0.003,13.01-5.892,13.012-13.155C28.516,12.864,27.005,10.105,25.542,8.354zM15.5,17.523c1.105,0,2.002-0.907,2.002-2.023h-0.001V3.357c0-1.118-0.896-2.024-2.001-2.024s-2.002,0.906-2.002,2.024V15.5C13.498,16.616,14.395,17.523,15.5,17.523z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Ppt.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Ppt.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Ppt();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Ppt = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Ppt.prototype */
{

  NAME: "draw2d.shape.icon.Ppt",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16.604,1.914c0-0.575-0.466-1.041-1.041-1.041s-1.041,0.466-1.041,1.041v1.04h2.082V1.914zM16.604,22.717h-2.082v3.207c0,0.574-4.225,4.031-4.225,4.031l2.468-0.003l2.807-2.673l3.013,2.693l2.272-0.039l-4.254-4.011V22.717L16.604,22.717zM28.566,7.113c0.86,0,1.56-0.698,1.56-1.56c0-0.861-0.698-1.56-1.56-1.56H2.561c-0.861,0-1.56,0.699-1.56,1.56c0,0.862,0.699,1.56,1.56,1.56h1.583v12.505l-0.932-0.022c-0.861,0-1.213,0.467-1.213,1.04c0,0.576,0.352,1.041,1.213,1.041h24.597c0.86,0,1.299-0.465,1.299-1.041c0-1.094-1.299-1.04-1.299-1.04l-0.804,0.109V7.113H28.566zM11.435,17.516c-3.771,0-4.194-4.191-4.194-4.191c0-4.096,4.162-4.161,4.162-4.161v4.161h4.193C15.596,17.516,11.435,17.516,11.435,17.516zM18.716,13.388h-1.071v-1.073h1.071V13.388zM18.716,10.267h-1.071V9.194h1.071V10.267zM23.314,13.388H20.26c-0.296,0-0.535-0.24-0.535-0.536c0-0.297,0.239-0.537,0.535-0.537h3.057c0.297,0,0.535,0.24,0.535,0.537C23.852,13.147,23.611,13.388,23.314,13.388zM23.314,10.267H20.26c-0.296,0-0.535-0.239-0.535-0.535c0-0.297,0.239-0.537,0.535-0.537h3.057c0.297,0,0.535,0.24,0.535,0.537C23.852,10.027,23.611,10.267,23.314,10.267z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Printer.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Printer.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Printer();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Printer = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Printer.prototype */
{

  NAME: "draw2d.shape.icon.Printer",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.569,12.125h-2.12c-0.207-1.34-1.247-2.759-2.444-3.967c-1.277-1.24-2.654-2.234-3.784-2.37c-0.062-0.008-0.124-0.014-0.198-0.015H8.594c-0.119,0-0.235,0.047-0.319,0.132c-0.083,0.083-0.132,0.2-0.132,0.32v5.9H6.069c-1.104,0-2,0.896-2,2V23h4.074v2.079c0,0.118,0.046,0.23,0.132,0.318c0.086,0.085,0.199,0.131,0.319,0.131h13.445c0.118,0,0.232-0.046,0.318-0.131s0.138-0.199,0.138-0.318V23h4.074v-8.875C26.569,13.021,25.674,12.125,24.569,12.125zM21.589,24.626H9.043V21.5h12.546V24.626zM21.589,13.921c0-0.03,0-0.063-0.003-0.096c-0.015-0.068-0.062-0.135-0.124-0.2H9.043v-6.95h6.987v0.001c0.305-0.019,0.567,0.282,0.769,0.971c0.183,0.655,0.229,1.509,0.229,2.102c0.001,0.433-0.019,0.725-0.019,0.725l-0.037,0.478l0.48,0.005c0.002,0,1.109,0.014,2.196,0.26c1.044,0.226,1.86,0.675,1.938,1.184c0.003,0.045,0.003,0.091,0.003,0.133V13.921z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Quote.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Quote.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Quote();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Quote = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Quote.prototype */
{

  NAME: "draw2d.shape.icon.Quote",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.505,5.873c-3.937,2.52-5.904,5.556-5.904,9.108c0,1.104,0.192,1.656,0.576,1.656l0.396-0.107c0.312-0.12,0.563-0.18,0.756-0.18c1.128,0,2.07,0.411,2.826,1.229c0.756,0.82,1.134,1.832,1.134,3.037c0,1.157-0.408,2.14-1.224,2.947c-0.816,0.807-1.801,1.211-2.952,1.211c-1.608,0-2.935-0.661-3.979-1.984c-1.044-1.321-1.565-2.98-1.565-4.977c0-2.259,0.443-4.327,1.332-6.203c0.888-1.875,2.243-3.57,4.067-5.085c1.824-1.514,2.988-2.272,3.492-2.272c0.336,0,0.612,0.162,0.828,0.486c0.216,0.324,0.324,0.606,0.324,0.846L14.505,5.873zM27.465,5.873c-3.937,2.52-5.904,5.556-5.904,9.108c0,1.104,0.192,1.656,0.576,1.656l0.396-0.107c0.312-0.12,0.563-0.18,0.756-0.18c1.104,0,2.04,0.411,2.808,1.229c0.769,0.82,1.152,1.832,1.152,3.037c0,1.157-0.408,2.14-1.224,2.947c-0.816,0.807-1.801,1.211-2.952,1.211c-1.608,0-2.935-0.661-3.979-1.984c-1.044-1.321-1.565-2.98-1.565-4.977c0-2.284,0.449-4.369,1.35-6.256c0.9-1.887,2.256-3.577,4.068-5.067c1.812-1.49,2.97-2.236,3.474-2.236c0.336,0,0.612,0.162,0.828,0.486c0.216,0.324,0.324,0.606,0.324,0.846L27.465,5.873z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Rain.js":
/*!********************************!*\
  !*** ./src/shape/icon/Rain.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Rain();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Rain = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Rain.prototype */
{

  NAME: "draw2d.shape.icon.Rain",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.371,7.306c-0.092-3.924-3.301-7.077-7.248-7.079c-2.638,0.001-4.942,1.412-6.208,3.517c-0.595-0.327-1.28-0.517-2.01-0.517C7.626,3.229,5.772,5.033,5.689,7.293c-2.393,0.786-4.125,3.025-4.127,5.686c0,3.312,2.687,6,6,6v-0.002h15.874c3.312,0,6-2.688,6-6C29.434,10.34,27.732,8.11,25.371,7.306zM23.436,16.979H7.561c-2.209-0.006-3.997-1.792-4.001-4.001c-0.002-1.982,1.45-3.618,3.35-3.931c0.265-0.043,0.502-0.191,0.657-0.414C7.722,8.41,7.779,8.136,7.73,7.87C7.702,7.722,7.685,7.582,7.685,7.446C7.689,6.221,8.68,5.23,9.905,5.228c0.647,0,1.217,0.278,1.633,0.731c0.233,0.257,0.587,0.375,0.927,0.309c0.342-0.066,0.626-0.307,0.748-0.63c0.749-1.992,2.662-3.412,4.911-3.41c2.899,0.004,5.244,2.35,5.251,5.249c0,0.161-0.009,0.326-0.027,0.497c-0.049,0.517,0.305,0.984,0.815,1.079c1.86,0.344,3.274,1.966,3.271,3.923C27.43,15.186,25.645,16.973,23.436,16.979zM9.029,26.682c0-1.115,0.021-5.425,0.021-5.432c0.002-0.409-0.247-0.779-0.628-0.932c-0.38-0.152-0.815-0.059-1.099,0.24c-0.006,0.008-1.037,1.098-2.081,2.342c-0.523,0.627-1.048,1.287-1.463,1.896c-0.399,0.648-0.753,1.066-0.811,1.885C2.971,28.355,4.324,29.711,6,29.714C7.672,29.71,9.029,28.354,9.029,26.682zM4.971,26.727c0.091-0.349,1.081-1.719,1.993-2.764c0.025-0.029,0.051-0.061,0.076-0.089c-0.005,1.124-0.01,2.294-0.01,2.808c0,0.567-0.461,1.028-1.029,1.03C5.447,27.71,4.997,27.273,4.971,26.727zM16.425,26.682c0-1.115,0.021-5.424,0.021-5.43c0.002-0.41-0.247-0.779-0.628-0.934c-0.381-0.152-0.814-0.058-1.1,0.242c-0.006,0.008-1.035,1.094-2.08,2.342c-0.522,0.623-1.047,1.285-1.463,1.894c-0.399,0.649-0.753,1.068-0.809,1.888c0,1.672,1.354,3.028,3.029,3.028C15.068,29.711,16.425,28.354,16.425,26.682zM12.365,26.729c0.092-0.349,1.081-1.72,1.993-2.765c0.025-0.03,0.05-0.06,0.075-0.089c-0.005,1.123-0.011,2.294-0.011,2.807c-0.002,0.568-0.461,1.027-1.028,1.029C12.84,27.709,12.392,27.273,12.365,26.729zM23.271,20.317c-0.38-0.153-0.816-0.06-1.099,0.24c-0.009,0.008-1.037,1.097-2.08,2.342c-0.523,0.625-1.049,1.285-1.462,1.896c-0.402,0.649-0.754,1.067-0.812,1.886c0,1.672,1.354,3.029,3.03,3.029c1.673,0,3.027-1.357,3.027-3.029c0-1.115,0.022-5.425,0.022-5.431C23.9,20.84,23.651,20.47,23.271,20.317zM21.879,26.681c-0.004,0.568-0.463,1.027-1.031,1.029c-0.553-0.002-1.002-0.438-1.028-0.982c0.092-0.349,1.081-1.72,1.993-2.765c0.025-0.028,0.05-0.059,0.074-0.088C21.883,24.998,21.879,26.167,21.879,26.681z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Raphael.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Raphael.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Raphael();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Raphael = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Raphael.prototype */
{

  NAME: "draw2d.shape.icon.Raphael",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.777,18.941c0.584-0.881,0.896-1.914,0.896-2.998c0-1.457-0.567-2.826-1.598-3.854l-6.91-6.911l-0.003,0.002c-0.985-0.988-2.35-1.6-3.851-1.6c-1.502,0-2.864,0.612-3.85,1.6H12.46l-6.911,6.911c-1.031,1.029-1.598,2.398-1.598,3.854c0,1.457,0.567,2.826,1.598,3.854l6.231,6.229c0.25,0.281,0.512,0.544,0.789,0.785c1.016,0.961,2.338,1.49,3.743,1.49c1.456,0,2.825-0.565,3.854-1.598l6.723-6.725c0.021-0.019,0.034-0.032,0.051-0.051l0.14-0.138c0.26-0.26,0.487-0.54,0.688-0.838c0.004-0.008,0.01-0.015,0.014-0.021L27.777,18.941zM26.658,15.946c0,0.678-0.197,1.326-0.561,1.879c-0.222,0.298-0.447,0.559-0.684,0.784L25.4,18.625c-1.105,1.052-2.354,1.35-3.414,1.35c-0.584,0-1.109-0.09-1.523-0.195c-2.422-0.608-5.056-2.692-6.261-5.732c0.649,0.274,1.362,0.426,2.11,0.426c2.811,0,5.129-2.141,5.415-4.877l3.924,3.925C26.301,14.167,26.658,15.029,26.658,15.946zM16.312,5.6c1.89,0,3.426,1.538,3.426,3.427c0,1.89-1.536,3.427-3.426,3.427c-1.889,0-3.426-1.537-3.426-3.427C12.886,7.138,14.423,5.6,16.312,5.6zM6.974,18.375c-0.649-0.648-1.007-1.512-1.007-2.429c0-0.917,0.357-1.78,1.007-2.428l2.655-2.656c-0.693,2.359-0.991,4.842-0.831,7.221c0.057,0.854,0.175,1.677,0.345,2.46L6.974,18.375zM11.514,11.592c0.583,4.562,4.195,9.066,8.455,10.143c0.693,0.179,1.375,0.265,2.033,0.265c0.01,0,0.02,0,0.027,0l-3.289,3.289c-0.648,0.646-1.512,1.006-2.428,1.006c-0.638,0-1.248-0.177-1.779-0.5l0.001-0.002c-0.209-0.142-0.408-0.295-0.603-0.461c-0.015-0.019-0.031-0.026-0.046-0.043l-0.665-0.664c-1.367-1.567-2.227-3.903-2.412-6.671C10.669,15.856,10.921,13.673,11.514,11.592");
  }
});

/***/ }),

/***/ "./src/shape/icon/ReflectH.js":
/*!************************************!*\
  !*** ./src/shape/icon/ReflectH.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ReflectH();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ReflectH = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ReflectH.prototype */
{

  NAME: "draw2d.shape.icon.ReflectH",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.57,20.273h0.854v-1.705H15.57V20.273zM15.57,23.686h0.854V21.98H15.57V23.686zM15.57,27.096h0.854v-1.705H15.57V27.096zM15.57,29.689h0.854V28.8H15.57V29.689zM15.57,16.865h0.854V15.16H15.57V16.865zM15.57,3.225h0.854V1.52H15.57V3.225zM15.57,6.635h0.854V4.93H15.57V6.635zM15.57,10.045h0.854V8.34H15.57V10.045zM15.57,13.455h0.854V11.75H15.57V13.455zM18.41,3.327V25.46h12.015L18.41,3.327zM19.264,6.68l9.729,17.93h-9.729V6.68zM13.535,25.46V3.327L1.521,25.46H13.535z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ReflectV.js":
/*!************************************!*\
  !*** ./src/shape/icon/ReflectV.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ReflectV();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ReflectV = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ReflectV.prototype */
{

  NAME: "draw2d.shape.icon.ReflectV",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.643,16.008v-0.854h-1.705v0.854H20.643zM24.053,16.008v-0.854h-1.705v0.854H24.053zM27.463,16.008v-0.854h-1.705v0.854H27.463zM30.059,16.008v-0.854h-0.891v0.854H30.059zM17.232,16.008v-0.854h-1.709v0.854H17.232zM3.593,16.008v-0.854H1.888v0.854H3.593zM7.003,16.008v-0.854H5.298v0.854H7.003zM10.414,16.008v-0.854H8.709v0.854H10.414zM13.824,16.008v-0.854h-1.705v0.854H13.824zM3.694,13.167h22.134V1.152L3.694,13.167zM7.048,12.314l17.929-9.729v9.729H7.048zM25.828,18.042H3.694l22.134,12.015V18.042z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Refresh.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Refresh.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Refresh();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Refresh = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Refresh.prototype */
{

  NAME: "draw2d.shape.icon.Refresh",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.083,15.5c-0.009,4.739-3.844,8.574-8.583,8.583c-4.741-0.009-8.577-3.844-8.585-8.583c0.008-4.741,3.844-8.577,8.585-8.585c1.913,0,3.665,0.629,5.09,1.686l-1.782,1.783l8.429,2.256l-2.26-8.427l-1.89,1.89c-2.072-1.677-4.717-2.688-7.587-2.688C8.826,3.418,3.418,8.826,3.416,15.5C3.418,22.175,8.826,27.583,15.5,27.583S27.583,22.175,27.583,15.5H24.083z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Resize2.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Resize2.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Resize2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Resize2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Resize2.prototype */
{

  NAME: "draw2d.shape.icon.Resize2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M1.999,2.332v26.499H28.5V2.332H1.999zM26.499,26.832H4V12.5h8.167V4.332h14.332V26.832zM15.631,17.649l5.468,5.469l-1.208,1.206l5.482,1.469l-1.47-5.481l-1.195,1.195l-5.467-5.466l1.209-1.208l-5.482-1.469l1.468,5.48L15.631,17.649z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Rotate.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Rotate.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Rotate();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Rotate = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Rotate.prototype */
{

  NAME: "draw2d.shape.icon.Rotate",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.5,5.27c1.914,0,3.666,0.629,5.089,1.686l-1.781,1.783l8.428,2.256l-2.26-8.427l-1.889,1.89C21.016,2.781,18.371,1.77,15.5,1.77C8.827,1.773,3.418,7.181,3.417,13.855c0.001,4.063,2.012,7.647,5.084,9.838v-4.887c-0.993-1.4-1.583-3.105-1.585-4.952C6.923,9.114,10.759,5.278,15.5,5.27zM9.5,29.23h12V12.355h-12V29.23z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Ruler.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Ruler.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Ruler();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Ruler = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Ruler.prototype */
{

  NAME: "draw2d.shape.icon.Ruler",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M6.63,21.796l-5.122,5.121h25.743V1.175L6.63,21.796zM18.702,10.48c0.186-0.183,0.48-0.183,0.664,0l1.16,1.159c0.184,0.183,0.186,0.48,0.002,0.663c-0.092,0.091-0.213,0.137-0.332,0.137c-0.121,0-0.24-0.046-0.33-0.137l-1.164-1.159C18.519,10.96,18.519,10.664,18.702,10.48zM17.101,12.084c0.184-0.183,0.48-0.183,0.662,0l2.156,2.154c0.184,0.183,0.184,0.48,0.002,0.661c-0.092,0.092-0.213,0.139-0.334,0.139s-0.24-0.046-0.33-0.137l-2.156-2.154C16.917,12.564,16.917,12.267,17.101,12.084zM15.497,13.685c0.184-0.183,0.48-0.183,0.664,0l1.16,1.161c0.184,0.183,0.182,0.48-0.002,0.663c-0.092,0.092-0.211,0.138-0.33,0.138c-0.121,0-0.24-0.046-0.332-0.138l-1.16-1.16C15.314,14.166,15.314,13.868,15.497,13.685zM13.896,15.288c0.184-0.183,0.48-0.181,0.664,0.002l1.158,1.159c0.183,0.184,0.183,0.48,0,0.663c-0.092,0.092-0.212,0.138-0.332,0.138c-0.119,0-0.24-0.046-0.332-0.138l-1.158-1.161C13.713,15.767,13.713,15.471,13.896,15.288zM12.293,16.892c0.183-0.184,0.479-0.184,0.663,0l2.154,2.153c0.184,0.184,0.184,0.481,0,0.665c-0.092,0.092-0.211,0.138-0.33,0.138c-0.121,0-0.242-0.046-0.334-0.138l-2.153-2.155C12.11,17.371,12.11,17.075,12.293,16.892zM10.302,24.515c-0.091,0.093-0.212,0.139-0.332,0.139c-0.119,0-0.238-0.045-0.33-0.137l-2.154-2.153c-0.184-0.183-0.184-0.479,0-0.663s0.479-0.184,0.662,0l2.154,2.153C10.485,24.036,10.485,24.332,10.302,24.515zM10.912,21.918c-0.093,0.093-0.214,0.139-0.333,0.139c-0.12,0-0.24-0.045-0.33-0.137l-1.162-1.161c-0.184-0.183-0.184-0.479,0-0.66c0.184-0.185,0.48-0.187,0.664-0.003l1.161,1.162C11.095,21.438,11.095,21.735,10.912,21.918zM12.513,20.316c-0.092,0.092-0.211,0.138-0.332,0.138c-0.119,0-0.239-0.046-0.331-0.138l-1.159-1.16c-0.184-0.184-0.184-0.48,0-0.664s0.48-0.182,0.663,0.002l1.159,1.161C12.696,19.838,12.696,20.135,12.513,20.316zM22.25,21.917h-8.67l8.67-8.67V21.917zM22.13,10.7c-0.09,0.092-0.211,0.138-0.33,0.138c-0.121,0-0.242-0.046-0.334-0.138l-1.16-1.159c-0.184-0.183-0.184-0.479,0-0.663c0.182-0.183,0.479-0.183,0.662,0l1.16,1.159C22.312,10.221,22.313,10.517,22.13,10.7zM24.726,10.092c-0.092,0.092-0.213,0.137-0.332,0.137s-0.24-0.045-0.33-0.137l-2.154-2.154c-0.184-0.183-0.184-0.481,0-0.664s0.482-0.181,0.664,0.002l2.154,2.154C24.911,9.613,24.909,9.91,24.726,10.092z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Run.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Run.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Run();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Run = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Run.prototype */
{

  NAME: "draw2d.shape.icon.Run",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M17.41,20.395l-0.778-2.723c0.228-0.2,0.442-0.414,0.644-0.643l2.721,0.778c0.287-0.418,0.534-0.862,0.755-1.323l-2.025-1.96c0.097-0.288,0.181-0.581,0.241-0.883l2.729-0.684c0.02-0.252,0.039-0.505,0.039-0.763s-0.02-0.51-0.039-0.762l-2.729-0.684c-0.061-0.302-0.145-0.595-0.241-0.883l2.026-1.96c-0.222-0.46-0.469-0.905-0.756-1.323l-2.721,0.777c-0.201-0.228-0.416-0.442-0.644-0.643l0.778-2.722c-0.418-0.286-0.863-0.534-1.324-0.755l-1.96,2.026c-0.287-0.097-0.581-0.18-0.883-0.241l-0.683-2.73c-0.253-0.019-0.505-0.039-0.763-0.039s-0.51,0.02-0.762,0.039l-0.684,2.73c-0.302,0.061-0.595,0.144-0.883,0.241l-1.96-2.026C7.048,3.463,6.604,3.71,6.186,3.997l0.778,2.722C6.736,6.919,6.521,7.134,6.321,7.361L3.599,6.583C3.312,7.001,3.065,7.446,2.844,7.907l2.026,1.96c-0.096,0.288-0.18,0.581-0.241,0.883l-2.73,0.684c-0.019,0.252-0.039,0.505-0.039,0.762s0.02,0.51,0.039,0.763l2.73,0.684c0.061,0.302,0.145,0.595,0.241,0.883l-2.026,1.96c0.221,0.46,0.468,0.905,0.755,1.323l2.722-0.778c0.2,0.229,0.415,0.442,0.643,0.643l-0.778,2.723c0.418,0.286,0.863,0.533,1.323,0.755l1.96-2.026c0.288,0.097,0.581,0.181,0.883,0.241l0.684,2.729c0.252,0.02,0.505,0.039,0.763,0.039s0.51-0.02,0.763-0.039l0.683-2.729c0.302-0.061,0.596-0.145,0.883-0.241l1.96,2.026C16.547,20.928,16.992,20.681,17.41,20.395zM11.798,15.594c-1.877,0-3.399-1.522-3.399-3.399s1.522-3.398,3.399-3.398s3.398,1.521,3.398,3.398S13.675,15.594,11.798,15.594zM27.29,22.699c0.019-0.547-0.06-1.104-0.23-1.654l1.244-1.773c-0.188-0.35-0.4-0.682-0.641-0.984l-2.122,0.445c-0.428-0.364-0.915-0.648-1.436-0.851l-0.611-2.079c-0.386-0.068-0.777-0.105-1.173-0.106l-0.974,1.936c-0.279,0.054-0.558,0.128-0.832,0.233c-0.257,0.098-0.497,0.22-0.727,0.353L17.782,17.4c-0.297,0.262-0.568,0.545-0.813,0.852l0.907,1.968c-0.259,0.495-0.437,1.028-0.519,1.585l-1.891,1.06c0.019,0.388,0.076,0.776,0.164,1.165l2.104,0.519c0.231,0.524,0.541,0.993,0.916,1.393l-0.352,2.138c0.32,0.23,0.66,0.428,1.013,0.6l1.715-1.32c0.536,0.141,1.097,0.195,1.662,0.15l1.452,1.607c0.2-0.057,0.399-0.118,0.596-0.193c0.175-0.066,0.34-0.144,0.505-0.223l0.037-2.165c0.455-0.339,0.843-0.747,1.152-1.206l2.161-0.134c0.152-0.359,0.279-0.732,0.368-1.115L27.29,22.699zM23.127,24.706c-1.201,0.458-2.545-0.144-3.004-1.345s0.143-2.546,1.344-3.005c1.201-0.458,2.547,0.144,3.006,1.345C24.931,22.902,24.328,24.247,23.127,24.706z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Rw.js":
/*!******************************!*\
  !*** ./src/shape/icon/Rw.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Rw();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Rw = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Rw.prototype */
{

  NAME: "draw2d.shape.icon.Rw",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M5.5,15.499,15.8,21.447,15.8,15.846,25.5,21.447,25.5,9.552,15.8,15.152,15.8,9.552z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Safari.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Safari.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Safari();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Safari = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Safari.prototype */
{

  NAME: "draw2d.shape.icon.Safari",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16.154,5.135c-0.504,0-1,0.031-1.488,0.089l-0.036-0.18c-0.021-0.104-0.06-0.198-0.112-0.283c0.381-0.308,0.625-0.778,0.625-1.306c0-0.927-0.751-1.678-1.678-1.678s-1.678,0.751-1.678,1.678c0,0.745,0.485,1.376,1.157,1.595c-0.021,0.105-0.021,0.216,0,0.328l0.033,0.167C7.645,6.95,3.712,11.804,3.712,17.578c0,6.871,5.571,12.441,12.442,12.441c6.871,0,12.441-5.57,12.441-12.441C28.596,10.706,23.025,5.135,16.154,5.135zM16.369,8.1c4.455,0,8.183,3.116,9.123,7.287l-0.576,0.234c-0.148-0.681-0.755-1.191-1.48-1.191c-0.837,0-1.516,0.679-1.516,1.516c0,0.075,0.008,0.148,0.018,0.221l-2.771-0.028c-0.054-0.115-0.114-0.226-0.182-0.333l3.399-5.11l0.055-0.083l-4.766,4.059c-0.352-0.157-0.74-0.248-1.148-0.256l0.086-0.018l-1.177-2.585c0.64-0.177,1.111-0.763,1.111-1.459c0-0.837-0.678-1.515-1.516-1.515c-0.075,0-0.147,0.007-0.219,0.018l0.058-0.634C15.357,8.141,15.858,8.1,16.369,8.1zM12.146,3.455c0-0.727,0.591-1.318,1.318-1.318c0.727,0,1.318,0.591,1.318,1.318c0,0.425-0.203,0.802-0.516,1.043c-0.183-0.123-0.413-0.176-0.647-0.13c-0.226,0.045-0.413,0.174-0.535,0.349C12.542,4.553,12.146,4.049,12.146,3.455zM7.017,17.452c0-4.443,3.098-8.163,7.252-9.116l0.297,0.573c-0.61,0.196-1.051,0.768-1.051,1.442c0,0.837,0.678,1.516,1.515,1.516c0.068,0,0.135-0.006,0.2-0.015l-0.058,2.845l0.052-0.011c-0.442,0.204-0.824,0.513-1.116,0.895l0.093-0.147l-1.574-0.603l1.172,1.239l0.026-0.042c-0.19,0.371-0.306,0.788-0.324,1.229l-0.003-0.016l-2.623,1.209c-0.199-0.604-0.767-1.041-1.438-1.041c-0.837,0-1.516,0.678-1.516,1.516c0,0.064,0.005,0.128,0.013,0.191l-0.783-0.076C7.063,18.524,7.017,17.994,7.017,17.452zM16.369,26.805c-4.429,0-8.138-3.078-9.106-7.211l0.691-0.353c0.146,0.686,0.753,1.2,1.482,1.2c0.837,0,1.515-0.679,1.515-1.516c0-0.105-0.011-0.207-0.031-0.307l2.858,0.03c0.045,0.095,0.096,0.187,0.15,0.276l-3.45,5.277l0.227-0.195l4.529-3.92c0.336,0.153,0.705,0.248,1.094,0.266l-0.019,0.004l1.226,2.627c-0.655,0.166-1.142,0.76-1.142,1.468c0,0.837,0.678,1.515,1.516,1.515c0.076,0,0.151-0.007,0.225-0.018l0.004,0.688C17.566,26.746,16.975,26.805,16.369,26.805zM18.662,26.521l-0.389-0.6c0.661-0.164,1.152-0.759,1.152-1.47c0-0.837-0.68-1.516-1.516-1.516c-0.066,0-0.13,0.005-0.193,0.014v-2.86l-0.025,0.004c0.409-0.185,0.77-0.459,1.055-0.798l1.516,0.659l-1.104-1.304c0.158-0.335,0.256-0.704,0.278-1.095l2.552-1.164c0.19,0.618,0.766,1.068,1.447,1.068c0.838,0,1.516-0.679,1.516-1.516c0-0.069-0.006-0.137-0.016-0.204l0.65,0.12c0.089,0.517,0.136,1.049,0.136,1.591C25.722,21.826,22.719,25.499,18.662,26.521z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ScrewDriver.js":
/*!***************************************!*\
  !*** ./src/shape/icon/ScrewDriver.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ScrewDriver();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ScrewDriver = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ScrewDriver.prototype */
{

  NAME: "draw2d.shape.icon.ScrewDriver",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M19.387,14.373c2.119-2.619,5.322-6.77,5.149-7.75c-0.128-0.729-0.882-1.547-1.763-2.171c-0.883-0.625-1.916-1.044-2.645-0.915c-0.98,0.173-3.786,4.603-5.521,7.49c-0.208,0.344,0.328,1.177,0.156,1.468c-0.172,0.292-1.052,0.042-1.18,0.261c-0.263,0.451-0.417,0.722-0.417,0.722s-0.553,0.823,1.163,2.163l-5.233,7.473c-0.267,0.381-1.456,0.459-1.456,0.459l-1.184,3.312l0.859,0.602l2.708-2.246c0,0-0.334-1.143-0.068-1.523l5.242-7.489c1.719,1,2.377,0.336,2.377,0.336s0.201-0.238,0.536-0.639c0.161-0.194-0.374-0.936-0.159-1.197C18.169,14.467,19.133,14.685,19.387,14.373z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Search.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Search.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Search();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Search = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Search.prototype */
{

  NAME: "draw2d.shape.icon.Search",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M29.772,26.433l-7.126-7.126c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127L29.772,26.433zM7.203,13.885c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486c-0.007,3.58-2.905,6.476-6.484,6.484C10.106,20.361,7.209,17.465,7.203,13.885z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Sencha.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Sencha.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Sencha();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Sencha = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Sencha.prototype */
{

  NAME: "draw2d.shape.icon.Sencha",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M18.265,22.734c1.365,0.662,2.309,2.062,2.309,3.682c0,1.566-0.881,2.928-2.176,3.615l1.922-0.98c3.16-1.58,5.332-4.846,5.332-8.617c0-3.719-2.109-6.945-5.195-8.547l-6.272-3.144c-1.366-0.662-2.308-2.062-2.308-3.682c0-1.567,0.881-2.928,2.175-3.614L12.13,2.428c-3.161,1.578-5.332,4.843-5.332,8.616c0,3.718,2.108,6.944,5.195,8.546L18.265,22.734z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Settings.js":
/*!************************************!*\
  !*** ./src/shape/icon/Settings.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Settings();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Settings = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Settings.prototype */
{

  NAME: "draw2d.shape.icon.Settings",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16.015,12.03c-2.156,0-3.903,1.747-3.903,3.903c0,2.155,1.747,3.903,3.903,3.903c0.494,0,0.962-0.102,1.397-0.27l0.836,1.285l1.359-0.885l-0.831-1.276c0.705-0.706,1.142-1.681,1.142-2.757C19.918,13.777,18.171,12.03,16.015,12.03zM16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM26.174,20.809c-0.241,0.504-0.513,0.99-0.826,1.45L22.19,21.58c-0.481,0.526-1.029,0.994-1.634,1.385l0.119,3.202c-0.507,0.23-1.028,0.421-1.569,0.57l-1.955-2.514c-0.372,0.051-0.75,0.086-1.136,0.086c-0.356,0-0.706-0.029-1.051-0.074l-1.945,2.5c-0.541-0.151-1.065-0.342-1.57-0.569l0.117-3.146c-0.634-0.398-1.208-0.88-1.712-1.427L6.78,22.251c-0.313-0.456-0.583-0.944-0.826-1.448l2.088-2.309c-0.226-0.703-0.354-1.451-0.385-2.223l-2.768-1.464c0.055-0.563,0.165-1.107,0.301-1.643l3.084-0.427c0.29-0.702,0.675-1.352,1.135-1.942L8.227,7.894c0.399-0.389,0.83-0.744,1.283-1.07l2.663,1.672c0.65-0.337,1.349-0.593,2.085-0.75l0.968-3.001c0.278-0.021,0.555-0.042,0.837-0.042c0.282,0,0.56,0.022,0.837,0.042l0.976,3.028c0.72,0.163,1.401,0.416,2.036,0.75l2.704-1.697c0.455,0.326,0.887,0.681,1.285,1.07l-1.216,2.986c0.428,0.564,0.793,1.181,1.068,1.845l3.185,0.441c0.135,0.535,0.247,1.081,0.302,1.643l-2.867,1.516c-0.034,0.726-0.15,1.43-0.355,2.1L26.174,20.809z");
  }
});

/***/ }),

/***/ "./src/shape/icon/SettingsAlt.js":
/*!***************************************!*\
  !*** ./src/shape/icon/SettingsAlt.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.SettingsAlt();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.SettingsAlt = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.SettingsAlt.prototype */
{

  NAME: "draw2d.shape.icon.SettingsAlt",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM24.386,14.968c-1.451,1.669-3.706,2.221-5.685,1.586l-7.188,8.266c-0.766,0.88-2.099,0.97-2.979,0.205s-0.973-2.099-0.208-2.979l7.198-8.275c-0.893-1.865-0.657-4.164,0.787-5.824c1.367-1.575,3.453-2.151,5.348-1.674l-2.754,3.212l0.901,2.621l2.722,0.529l2.761-3.22C26.037,11.229,25.762,13.387,24.386,14.968z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Shuffle.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Shuffle.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Shuffle();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Shuffle = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Shuffle.prototype */
{

  NAME: "draw2d.shape.icon.Shuffle",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.786,20.654c-0.618-0.195-1.407-0.703-2.291-1.587c-0.757-0.742-1.539-1.698-2.34-2.741c-0.191,0.256-0.382,0.51-0.574,0.77c-0.524,0.709-1.059,1.424-1.604,2.127c1.904,2.31,3.88,4.578,6.809,4.952v2.701l7.556-4.362l-7.556-4.362V20.654zM9.192,11.933c0.756,0.741,1.538,1.697,2.339,2.739c0.195-0.262,0.39-0.521,0.587-0.788c0.52-0.703,1.051-1.412,1.592-2.11c-2.032-2.463-4.133-4.907-7.396-5.025h-3.5v3.5h3.5C6.969,10.223,7.996,10.735,9.192,11.933zM21.786,10.341v2.535l7.556-4.363l-7.556-4.363v2.647c-1.904,0.219-3.425,1.348-4.751,2.644c-2.196,2.183-4.116,5.167-6.011,7.538c-1.867,2.438-3.741,3.888-4.712,3.771h-3.5v3.5h3.5c2.185-0.029,3.879-1.266,5.34-2.693c2.194-2.184,4.116-5.167,6.009-7.538C19.205,12.003,20.746,10.679,21.786,10.341z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Skull.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Skull.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Skull();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Skull = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Skull.prototype */
{

  NAME: "draw2d.shape.icon.Skull",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.947,11.14c0-5.174-3.979-9.406-10.613-9.406c-6.633,0-10.282,4.232-10.282,9.406c0,5.174,1.459,4.511,1.459,7.43c0,1.095-1.061,0.564-1.061,2.919c0,2.587,3.615,2.223,4.677,3.283c1.061,1.062,0.961,3.019,0.961,3.019s0.199,0.796,0.564,0.563c0,0,0.232,0.564,0.498,0.232c0,0,0.265,0.563,0.531,0.1c0,0,0.265,0.631,0.696,0.166c0,0,0.431,0.63,0.929,0.133c0,0,0.564,0.53,1.194,0.133c0.63,0.397,1.194-0.133,1.194-0.133c0.497,0.497,0.929-0.133,0.929-0.133c0.432,0.465,0.695-0.166,0.695-0.166c0.268,0.464,0.531-0.1,0.531-0.1c0.266,0.332,0.498-0.232,0.498-0.232c0.365,0.232,0.564-0.563,0.564-0.563s-0.1-1.957,0.961-3.019c1.062-1.061,4.676-0.696,4.676-3.283c0-2.354-1.061-1.824-1.061-2.919C24.488,15.651,25.947,16.314,25.947,11.14zM10.333,20.992c-1.783,0.285-2.59-0.215-2.785-1.492c-0.508-3.328,2.555-3.866,4.079-3.683c0.731,0.088,1.99,0.862,1.99,1.825C13.617,20.229,11.992,20.727,10.333,20.992zM16.461,25.303c-0.331,0-0.862-0.431-0.895-1.227c-0.033,0.796-0.63,1.227-0.961,1.227c-0.332,0-0.83-0.331-0.863-1.127c-0.033-0.796,1.028-4.013,1.792-4.013c0.762,0,1.824,3.217,1.791,4.013S16.794,25.303,16.461,25.303zM23.361,19.5c-0.195,1.277-1.004,1.777-2.787,1.492c-1.658-0.266-3.283-0.763-3.283-3.35c0-0.963,1.258-1.737,1.99-1.825C20.805,15.634,23.869,16.172,23.361,19.5z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Skype.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Skype.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Skype();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Skype = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Skype.prototype */
{

  NAME: "draw2d.shape.icon.Skype",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.777,18.438c0.209-0.948,0.318-1.934,0.318-2.944c0-7.578-6.144-13.722-13.724-13.722c-0.799,0-1.584,0.069-2.346,0.2C11.801,1.199,10.35,0.75,8.793,0.75c-4.395,0-7.958,3.562-7.958,7.958c0,1.47,0.399,2.845,1.094,4.024c-0.183,0.893-0.277,1.814-0.277,2.76c0,7.58,6.144,13.723,13.722,13.723c0.859,0,1.699-0.078,2.515-0.23c1.119,0.604,2.399,0.945,3.762,0.945c4.395,0,7.957-3.562,7.957-7.959C29.605,20.701,29.309,19.502,28.777,18.438zM22.412,22.051c-0.635,0.898-1.573,1.609-2.789,2.115c-1.203,0.5-2.646,0.754-4.287,0.754c-1.971,0-3.624-0.346-4.914-1.031C9.5,23.391,8.74,22.717,8.163,21.885c-0.583-0.842-0.879-1.676-0.879-2.479c0-0.503,0.192-0.939,0.573-1.296c0.375-0.354,0.857-0.532,1.432-0.532c0.471,0,0.878,0.141,1.209,0.422c0.315,0.269,0.586,0.662,0.805,1.174c0.242,0.558,0.508,1.027,0.788,1.397c0.269,0.355,0.656,0.656,1.151,0.89c0.497,0.235,1.168,0.354,1.992,0.354c1.135,0,2.064-0.241,2.764-0.721c0.684-0.465,1.016-1.025,1.016-1.711c0-0.543-0.173-0.969-0.529-1.303c-0.373-0.348-0.865-0.621-1.465-0.807c-0.623-0.195-1.47-0.404-2.518-0.623c-1.424-0.306-2.634-0.668-3.596-1.076c-0.984-0.419-1.777-1-2.357-1.727c-0.59-0.736-0.889-1.662-0.889-2.75c0-1.036,0.314-1.971,0.933-2.776c0.613-0.8,1.51-1.423,2.663-1.849c1.139-0.422,2.494-0.635,4.027-0.635c1.225,0,2.303,0.141,3.201,0.421c0.904,0.282,1.668,0.662,2.267,1.13c0.604,0.472,1.054,0.977,1.335,1.5c0.284,0.529,0.43,1.057,0.43,1.565c0,0.49-0.189,0.937-0.563,1.324c-0.375,0.391-0.851,0.589-1.408,0.589c-0.509,0-0.905-0.124-1.183-0.369c-0.258-0.227-0.523-0.58-0.819-1.09c-0.342-0.65-0.756-1.162-1.229-1.523c-0.463-0.351-1.232-0.529-2.292-0.529c-0.984,0-1.784,0.197-2.379,0.588c-0.572,0.375-0.85,0.805-0.85,1.314c0,0.312,0.09,0.574,0.273,0.799c0.195,0.238,0.471,0.447,0.818,0.621c0.36,0.182,0.732,0.326,1.104,0.429c0.382,0.106,1.021,0.263,1.899,0.466c1.11,0.238,2.131,0.506,3.034,0.793c0.913,0.293,1.703,0.654,2.348,1.072c0.656,0.429,1.178,0.979,1.547,1.635c0.369,0.658,0.558,1.471,0.558,2.416C23.371,20.119,23.049,21.148,22.412,22.051z");
  }
});

/***/ }),

/***/ "./src/shape/icon/SlideShare.js":
/*!**************************************!*\
  !*** ./src/shape/icon/SlideShare.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.SlideShare();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.SlideShare = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.SlideShare.prototype */
{

  NAME: "draw2d.shape.icon.SlideShare",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.952,12.795c-0.956,1.062-5.073,2.409-5.604,2.409h-4.513c-0.749,0-1.877,0.147-2.408,0.484c0.061,0.054,0.122,0.108,0.181,0.163c0.408,0.379,1.362,0.913,2.206,0.913c0.397,0,0.723-0.115,1-0.354c1.178-1.007,1.79-1.125,2.145-1.125c0.421,0,0.783,0.193,0.996,0.531c0.4,0.626,0.106,1.445-0.194,2.087c-0.718,1.524-3.058,3.171-5.595,3.171c-0.002,0-0.002,0-0.004,0c-0.354,0-0.701-0.033-1.033-0.099v3.251c0,0.742,1.033,2.533,4.167,2.533s3.955-3.701,3.955-4.338v-4.512c2.23-1.169,4.512-1.805,5.604-3.895C30.882,12.05,29.907,11.733,28.952,12.795zM21.942,17.521c0.796-1.699-0.053-1.699-1.54-0.425s-3.665,0.105-4.408-0.585c-0.743-0.689-1.486-1.22-2.814-1.167c-1.328,0.053-4.46-0.161-6.267-0.585c-1.805-0.425-4.895-3-5.15-2.335c-0.266,0.69,0.211,1.168,1.168,2.335c0.955,1.169,5.075,2.778,5.075,2.778s0,3.453,0,4.886c0,1.435,2.973,3.61,4.512,3.61s2.708-1.062,2.708-1.806v-4.512C17.775,21.045,21.146,19.221,21.942,17.521zM20.342,13.73c1.744,0,3.159-1.414,3.159-3.158c0-1.745-1.415-3.159-3.159-3.159s-3.158,1.414-3.158,3.159C17.184,12.316,18.598,13.73,20.342,13.73zM12.019,13.73c1.744,0,3.158-1.414,3.158-3.158c0-1.745-1.414-3.159-3.158-3.159c-1.745,0-3.159,1.414-3.159,3.159C8.86,12.316,10.273,13.73,12.019,13.73z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Smile.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Smile.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Smile();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Smile = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Smile.prototype */
{

  NAME: "draw2d.shape.icon.Smile",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM20.729,7.375c0.934,0,1.688,1.483,1.688,3.312S21.661,14,20.729,14c-0.932,0-1.688-1.483-1.688-3.312S19.798,7.375,20.729,7.375zM11.104,7.375c0.932,0,1.688,1.483,1.688,3.312S12.037,14,11.104,14s-1.688-1.483-1.688-3.312S10.172,7.375,11.104,7.375zM16.021,26c-2.873,0-5.563-1.757-7.879-4.811c2.397,1.564,5.021,2.436,7.774,2.436c2.923,0,5.701-0.98,8.215-2.734C21.766,24.132,18.99,26,16.021,26z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Smile2.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Smile2.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Smile2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Smile2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Smile2.prototype */
{

  NAME: "draw2d.shape.icon.Smile2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM16,29.534C8.539,29.534,2.466,23.462,2.466,16C2.466,8.539,8.539,2.466,16,2.466c7.462,0,13.535,6.072,13.535,13.533C29.534,23.462,23.462,29.534,16,29.534zM11.104,14c0.932,0,1.688-1.483,1.688-3.312s-0.755-3.312-1.688-3.312s-1.688,1.483-1.688,3.312S10.172,14,11.104,14zM20.729,14c0.934,0,1.688-1.483,1.688-3.312s-0.756-3.312-1.688-3.312c-0.932,0-1.688,1.483-1.688,3.312S19.798,14,20.729,14zM8.143,21.189C10.458,24.243,13.148,26,16.021,26c2.969,0,5.745-1.868,8.11-5.109c-2.515,1.754-5.292,2.734-8.215,2.734C13.164,23.625,10.54,22.756,8.143,21.189z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Snow.js":
/*!********************************!*\
  !*** ./src/shape/icon/Snow.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Snow();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Snow = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Snow.prototype */
{

  NAME: "draw2d.shape.icon.Snow",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.372,6.912c-0.093-3.925-3.302-7.078-7.248-7.08c-2.638,0.002-4.942,1.412-6.208,3.518c-0.595-0.327-1.28-0.518-2.01-0.518C7.627,2.834,5.773,4.639,5.69,6.898c-2.393,0.786-4.125,3.025-4.127,5.686c0,3.312,2.687,6,6,6v-0.002h15.875c3.312,0,6-2.688,6-6C29.434,9.944,27.732,7.715,25.372,6.912zM23.436,16.584H7.562c-2.209-0.006-3.997-1.793-4.001-4c-0.002-1.983,1.45-3.619,3.35-3.933c0.265-0.043,0.502-0.19,0.657-0.414C7.723,8.015,7.78,7.74,7.731,7.475C7.703,7.326,7.686,7.187,7.686,7.051c0.004-1.225,0.995-2.217,2.22-2.219c0.647,0,1.217,0.278,1.633,0.731c0.233,0.257,0.587,0.375,0.927,0.31c0.342-0.066,0.626-0.308,0.748-0.631c0.749-1.992,2.662-3.412,4.911-3.41c2.898,0.004,5.244,2.351,5.251,5.25c0,0.16-0.009,0.325-0.026,0.496c-0.05,0.518,0.305,0.984,0.814,1.079c1.859,0.345,3.273,1.966,3.271,3.923C27.43,14.791,25.645,16.578,23.436,16.584zM16.667,24.09l1.119-1.119c0.389-0.391,0.389-1.025,0-1.416c-0.392-0.391-1.025-0.391-1.415,0l-1.119,1.119l-1.119-1.119c-0.391-0.391-1.025-0.391-1.415,0c-0.391,0.391-0.391,1.025,0,1.416l1.118,1.117l-1.12,1.121c-0.389,0.393-0.389,1.021,0,1.414c0.195,0.188,0.451,0.293,0.707,0.293c0.256,0,0.512-0.104,0.708-0.293l1.12-1.119l1.12,1.119c0.195,0.188,0.451,0.293,0.708,0.293c0.256,0,0.512-0.104,0.707-0.293c0.391-0.396,0.391-1.021,0-1.414L16.667,24.09zM25.119,21.817c-0.393-0.392-1.025-0.392-1.415,0l-1.12,1.121l-1.12-1.121c-0.391-0.392-1.022-0.392-1.414,0c-0.39,0.392-0.39,1.022,0,1.416l1.119,1.119l-1.119,1.119c-0.39,0.391-0.39,1.022,0,1.413c0.195,0.195,0.451,0.294,0.707,0.294c0.257,0,0.513-0.099,0.707-0.294l1.12-1.118l1.12,1.118c0.194,0.195,0.45,0.294,0.707,0.294c0.256,0,0.513-0.099,0.708-0.294c0.389-0.391,0.389-1.022,0-1.413l-1.12-1.119l1.12-1.119C25.507,22.842,25.507,22.209,25.119,21.817zM9.334,23.953l1.119-1.119c0.389-0.394,0.389-1.021,0-1.414c-0.391-0.394-1.025-0.394-1.415,0l-1.119,1.119l-1.12-1.121c-0.391-0.39-1.023-0.39-1.415,0c-0.391,0.396-0.391,1.024,0,1.418l1.119,1.117l-1.12,1.118c-0.391,0.394-0.391,1.025,0,1.414c0.196,0.195,0.452,0.293,0.708,0.293c0.256,0,0.511-0.098,0.707-0.293l1.12-1.119l1.121,1.121c0.195,0.195,0.451,0.293,0.707,0.293s0.513-0.098,0.708-0.293c0.389-0.391,0.389-1.022,0-1.416L9.334,23.953z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Split.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Split.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Split();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Split = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Split.prototype */
{

  NAME: "draw2d.shape.icon.Split",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.786,20.698c-1.792-0.237-2.912-1.331-4.358-2.886c-0.697-0.751-1.428-1.577-2.324-2.319c1.396-1.165,2.411-2.519,3.483-3.503c1.01-0.92,1.901-1.519,3.199-1.688v2.574l7.556-4.363L21.786,4.15v2.652c-3.34,0.266-5.45,2.378-6.934,4.013c-0.819,0.896-1.537,1.692-2.212,2.192c-0.685,0.501-1.227,0.731-2.013,0.742c-0.001,0-0.002,0-0.003,0H2.812v3.5h0.001v0.001c0,0,0.046-0.001,0.136-0.001h7.677c0.786,0.011,1.33,0.241,2.017,0.743c1.021,0.743,2.095,2.181,3.552,3.568c1.312,1.258,3.162,2.46,5.592,2.649v2.664l7.556-4.36l-7.556-4.361V20.698z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Star.js":
/*!********************************!*\
  !*** ./src/shape/icon/Star.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Star();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Star = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Star.prototype */
{

  NAME: "draw2d.shape.icon.Star",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,22.375L7.116,28.83l3.396-10.438l-8.883-6.458l10.979,0.002L16.002,1.5l3.391,10.434h10.981l-8.886,6.457l3.396,10.439L16,22.375L16,22.375z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Star2.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Star2.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Star2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Star2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Star2.prototype */
{

  NAME: "draw2d.shape.icon.Star2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.615,4.928c0.487-0.986,1.284-0.986,1.771,0l2.249,4.554c0.486,0.986,1.775,1.923,2.864,2.081l5.024,0.73c1.089,0.158,1.335,0.916,0.547,1.684l-3.636,3.544c-0.788,0.769-1.28,2.283-1.095,3.368l0.859,5.004c0.186,1.085-0.459,1.553-1.433,1.041l-4.495-2.363c-0.974-0.512-2.567-0.512-3.541,0l-4.495,2.363c-0.974,0.512-1.618,0.044-1.432-1.041l0.858-5.004c0.186-1.085-0.307-2.6-1.094-3.368L3.93,13.977c-0.788-0.768-0.542-1.525,0.547-1.684l5.026-0.73c1.088-0.158,2.377-1.095,2.864-2.081L14.615,4.928z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Star2Off.js":
/*!************************************!*\
  !*** ./src/shape/icon/Star2Off.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Star2Off();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Star2Off = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Star2Off.prototype */
{

  NAME: "draw2d.shape.icon.Star2Off",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M26.522,12.293l-5.024-0.73c-1.089-0.158-2.378-1.095-2.864-2.081l-2.249-4.554c-0.487-0.986-1.284-0.986-1.771,0l-2.247,4.554c-0.487,0.986-1.776,1.923-2.864,2.081l-5.026,0.73c-1.088,0.158-1.334,0.916-0.547,1.684l3.637,3.544c0.788,0.769,1.28,2.283,1.094,3.368l-0.858,5.004c-0.186,1.085,0.458,1.553,1.432,1.041l4.495-2.363c0.974-0.512,2.566-0.512,3.541,0l4.495,2.363c0.974,0.512,1.618,0.044,1.433-1.041l-0.859-5.004c-0.186-1.085,0.307-2.6,1.095-3.368l3.636-3.544C27.857,13.209,27.611,12.452,26.522,12.293zM22.037,16.089c-1.266,1.232-1.966,3.394-1.67,5.137l0.514,2.984l-2.679-1.409c-0.757-0.396-1.715-0.612-2.702-0.612s-1.945,0.216-2.7,0.61l-2.679,1.409l0.511-2.982c0.297-1.743-0.404-3.905-1.671-5.137l-2.166-2.112l2.995-0.435c1.754-0.255,3.592-1.591,4.373-3.175L15.5,7.652l1.342,2.716c0.781,1.583,2.617,2.92,4.369,3.173l2.992,0.435L22.037,16.089z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Star3.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Star3.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Star3();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Star3 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Star3.prototype */
{

  NAME: "draw2d.shape.icon.Star3",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.441,28.181c-0.419,0-0.835-0.132-1.189-0.392l-5.751-4.247L9.75,27.789c-0.354,0.26-0.771,0.392-1.189,0.392c-0.412,0-0.824-0.128-1.175-0.384c-0.707-0.511-1-1.422-0.723-2.25l2.26-6.783l-5.815-4.158c-0.71-0.509-1.009-1.416-0.74-2.246c0.268-0.826,1.037-1.382,1.904-1.382c0.004,0,0.01,0,0.014,0l7.15,0.056l2.157-6.816c0.262-0.831,1.035-1.397,1.906-1.397s1.645,0.566,1.906,1.397l2.155,6.816l7.15-0.056c0.004,0,0.01,0,0.015,0c0.867,0,1.636,0.556,1.903,1.382c0.271,0.831-0.028,1.737-0.739,2.246l-5.815,4.158l2.263,6.783c0.276,0.826-0.017,1.737-0.721,2.25C23.268,28.053,22.854,28.181,22.441,28.181L22.441,28.181z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Star3Off.js":
/*!************************************!*\
  !*** ./src/shape/icon/Star3Off.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Star3Off();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Star3Off = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Star3Off.prototype */
{

  NAME: "draw2d.shape.icon.Star3Off",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M28.631,12.359c-0.268-0.826-1.036-1.382-1.903-1.382h-0.015l-7.15,0.056l-2.155-6.816c-0.262-0.831-1.035-1.397-1.906-1.397s-1.645,0.566-1.906,1.397l-2.157,6.816l-7.15-0.056H4.273c-0.868,0-1.636,0.556-1.904,1.382c-0.27,0.831,0.029,1.737,0.74,2.246l5.815,4.158l-2.26,6.783c-0.276,0.828,0.017,1.739,0.723,2.25c0.351,0.256,0.763,0.384,1.175,0.384c0.418,0,0.834-0.132,1.189-0.392l5.751-4.247l5.751,4.247c0.354,0.26,0.771,0.392,1.189,0.392c0.412,0,0.826-0.128,1.177-0.384c0.704-0.513,0.997-1.424,0.721-2.25l-2.263-6.783l5.815-4.158C28.603,14.097,28.901,13.19,28.631,12.359zM19.712,17.996l2.729,8.184l-6.94-5.125L8.56,26.18l2.729-8.184l-7.019-5.018l8.627,0.066L15.5,4.82l2.603,8.225l8.627-0.066L19.712,17.996z");
  }
});

/***/ }),

/***/ "./src/shape/icon/StarOff.js":
/*!***********************************!*\
  !*** ./src/shape/icon/StarOff.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.StarOff();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.StarOff = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.StarOff.prototype */
{

  NAME: "draw2d.shape.icon.StarOff",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,22.375L7.116,28.83l3.396-10.438l-8.883-6.458l10.979,0.002L16.002,1.5l3.391,10.434h10.981l-8.886,6.457l3.396,10.439L16,22.375L16,22.375zM22.979,26.209l-2.664-8.205l6.979-5.062h-8.627L16,4.729l-2.666,8.206H4.708l6.979,5.07l-2.666,8.203L16,21.146L22.979,26.209L22.979,26.209z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Start.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Start.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Start();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Start = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Start.prototype */
{

  NAME: "draw2d.shape.icon.Start",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.316,5.318,9.833,13.682,9.833,5.5,5.5,5.5,5.5,25.5,9.833,25.5,9.833,17.318,24.316,25.682z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Sticker.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Sticker.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Sticker();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Sticker = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Sticker.prototype */
{

  NAME: "draw2d.shape.icon.Sticker",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.5,1.999c-1.042,0-1.916,0.377-2.57,1.088L2.895,13.138C2.302,13.784,1.999,14.58,1.999,15.5C1.999,22.943,8.057,29,15.5,29S29,22.943,29,15.5S22.943,1.999,15.5,1.999zM15.5,28C8.596,28,3,22.404,3,15.5c0-3.452,5.239-2.737,7.501-4.999C12.762,8.239,12.048,3,15.5,3C22.404,3,28,8.597,28,15.5S22.404,28,15.5,28z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Stop.js":
/*!********************************!*\
  !*** ./src/shape/icon/Stop.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Stop();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Stop = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Stop.prototype */
{

  NAME: "draw2d.shape.icon.Stop",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M5.5,5.5h20v20h-20z");
  }
});

/***/ }),

/***/ "./src/shape/icon/StopWatch.js":
/*!*************************************!*\
  !*** ./src/shape/icon/StopWatch.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.StopWatch();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.StopWatch = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.StopWatch.prototype */
{

  NAME: "draw2d.shape.icon.StopWatch",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.216,18.533c0-3.636-1.655-6.883-4.253-9.032l0.733-0.998l0.482,0.354c0.198,0.146,0.481,0.104,0.628-0.097l0.442-0.604c0.146-0.198,0.103-0.482-0.097-0.628l-2.052-1.506c-0.199-0.146-0.481-0.103-0.628,0.097L22.03,6.724c-0.146,0.199-0.104,0.482,0.096,0.628l0.483,0.354l-0.736,1.003c-1.28-0.834-2.734-1.419-4.296-1.699c0.847-0.635,1.402-1.638,1.403-2.778h-0.002c0-1.922-1.557-3.48-3.479-3.48c-1.925,0-3.48,1.559-3.48,3.48c0,1.141,0.556,2.144,1.401,2.778c-1.549,0.277-2.99,0.857-4.265,1.68L8.424,7.684l0.484-0.353c0.198-0.145,0.245-0.428,0.098-0.628l-0.44-0.604C8.42,5.899,8.136,5.855,7.937,6.001L5.881,7.5c-0.2,0.146-0.243,0.428-0.099,0.628l0.442,0.604c0.145,0.2,0.428,0.244,0.627,0.099l0.483-0.354l0.729,0.999c-2.615,2.149-4.282,5.407-4.282,9.057c0,6.471,5.245,11.716,11.718,11.716c6.47,0,11.716-5.243,11.718-11.716H27.216zM12.918,4.231c0.002-1.425,1.155-2.58,2.582-2.582c1.426,0.002,2.579,1.157,2.581,2.582c-0.002,1.192-0.812,2.184-1.908,2.482v-1.77h0.6c0.246,0,0.449-0.203,0.449-0.449V3.746c0-0.247-0.203-0.449-0.449-0.449h-2.545c-0.247,0-0.449,0.202-0.449,0.449v0.749c0,0.246,0.202,0.449,0.449,0.449h0.599v1.77C13.729,6.415,12.919,5.424,12.918,4.231zM15.5,27.554c-4.983-0.008-9.015-4.038-9.022-9.021c0.008-4.982,4.039-9.013,9.022-9.022c4.981,0.01,9.013,4.04,9.021,9.022C24.513,23.514,20.481,27.546,15.5,27.554zM15.5,12.138c0.476,0,0.861-0.385,0.861-0.86s-0.386-0.861-0.861-0.861s-0.861,0.386-0.861,0.861S15.024,12.138,15.5,12.138zM15.5,24.927c-0.476,0-0.861,0.386-0.861,0.861s0.386,0.861,0.861,0.861s0.861-0.386,0.861-0.861S15.976,24.927,15.5,24.927zM12.618,11.818c-0.237-0.412-0.764-0.553-1.176-0.315c-0.412,0.238-0.554,0.765-0.315,1.177l2.867,6.722c0.481,0.831,1.543,1.116,2.375,0.637c0.829-0.479,1.114-1.543,0.635-2.374L12.618,11.818zM18.698,24.07c-0.412,0.237-0.555,0.765-0.316,1.176c0.237,0.412,0.764,0.554,1.176,0.315c0.413-0.238,0.553-0.765,0.316-1.176C19.635,23.974,19.108,23.832,18.698,24.07zM8.787,15.65c0.412,0.238,0.938,0.097,1.176-0.315c0.237-0.413,0.097-0.938-0.314-1.176c-0.412-0.239-0.938-0.098-1.177,0.313C8.234,14.886,8.375,15.412,8.787,15.65zM22.215,21.413c-0.412-0.236-0.938-0.096-1.176,0.316c-0.238,0.412-0.099,0.938,0.314,1.176c0.41,0.238,0.937,0.098,1.176-0.314C22.768,22.178,22.625,21.652,22.215,21.413zM9.107,18.531c-0.002-0.476-0.387-0.86-0.861-0.86c-0.477,0-0.862,0.385-0.862,0.86c0.001,0.476,0.386,0.86,0.861,0.861C8.722,19.393,9.106,19.008,9.107,18.531zM21.896,18.531c0,0.477,0.384,0.862,0.859,0.86c0.476,0.002,0.862-0.382,0.862-0.859s-0.387-0.86-0.862-0.862C22.279,17.671,21.896,18.056,21.896,18.531zM8.787,21.413c-0.412,0.238-0.554,0.765-0.316,1.176c0.239,0.412,0.765,0.553,1.177,0.316c0.413-0.239,0.553-0.765,0.315-1.178C9.725,21.317,9.198,21.176,8.787,21.413zM21.352,14.157c-0.411,0.238-0.551,0.764-0.312,1.176c0.237,0.413,0.764,0.555,1.174,0.315c0.412-0.236,0.555-0.762,0.316-1.176C22.29,14.06,21.766,13.921,21.352,14.157zM12.304,24.067c-0.413-0.235-0.939-0.096-1.176,0.315c-0.238,0.413-0.098,0.939,0.312,1.178c0.413,0.236,0.939,0.096,1.178-0.315C12.857,24.832,12.715,24.308,12.304,24.067zM18.698,12.992c0.41,0.238,0.938,0.099,1.174-0.313c0.238-0.411,0.1-0.938-0.314-1.177c-0.414-0.238-0.937-0.097-1.177,0.315C18.144,12.229,18.286,12.755,18.698,12.992z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Sun.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Sun.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Sun();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Sun = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Sun.prototype */
{

  NAME: "draw2d.shape.icon.Sun",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.502,7.504c-4.35,0-7.873,3.523-7.873,7.873c0,4.347,3.523,7.872,7.873,7.872c4.346,0,7.871-3.525,7.871-7.872C23.374,11.027,19.85,7.504,15.502,7.504zM15.502,21.25c-3.244-0.008-5.866-2.63-5.874-5.872c0.007-3.243,2.63-5.866,5.874-5.874c3.242,0.008,5.864,2.631,5.871,5.874C21.366,18.62,18.744,21.242,15.502,21.25zM15.502,6.977c0.553,0,1-0.448,1-1.001V1.125c-0.002-0.553-0.448-1-1-1c-0.553,0-1.001,0.449-1,1.002v4.85C14.502,6.528,14.949,6.977,15.502,6.977zM18.715,7.615c0.125,0.053,0.255,0.076,0.382,0.077c0.394,0,0.765-0.233,0.925-0.618l1.856-4.483c0.21-0.511-0.031-1.095-0.541-1.306c-0.511-0.211-1.096,0.031-1.308,0.541L18.174,6.31C17.963,6.82,18.205,7.405,18.715,7.615zM21.44,9.436c0.195,0.194,0.451,0.293,0.707,0.293s0.512-0.098,0.707-0.293l3.43-3.433c0.391-0.39,0.39-1.023,0-1.415c-0.392-0.39-1.025-0.39-1.415,0.002L21.44,8.021C21.049,8.412,21.049,9.045,21.44,9.436zM23.263,12.16c0.158,0.385,0.531,0.617,0.923,0.617c0.127,0,0.257-0.025,0.383-0.078l4.48-1.857c0.511-0.211,0.753-0.797,0.541-1.307s-0.796-0.752-1.307-0.54l-4.481,1.857C23.292,11.064,23.051,11.65,23.263,12.16zM29.752,14.371l-4.851,0.001c-0.552,0-1,0.448-0.998,1.001c0,0.553,0.447,0.999,0.998,0.999l4.852-0.002c0.553,0,0.999-0.449,0.999-1C30.752,14.817,30.304,14.369,29.752,14.371zM29.054,19.899l-4.482-1.854c-0.512-0.212-1.097,0.03-1.307,0.541c-0.211,0.511,0.031,1.096,0.541,1.308l4.482,1.854c0.126,0.051,0.256,0.075,0.383,0.075c0.393,0,0.765-0.232,0.925-0.617C29.806,20.695,29.563,20.109,29.054,19.899zM22.86,21.312c-0.391-0.391-1.023-0.391-1.414,0.001c-0.391,0.39-0.39,1.022,0,1.413l3.434,3.429c0.195,0.195,0.45,0.293,0.706,0.293s0.513-0.098,0.708-0.293c0.391-0.392,0.389-1.025,0-1.415L22.86,21.312zM20.029,23.675c-0.211-0.511-0.796-0.752-1.307-0.541c-0.51,0.212-0.752,0.797-0.54,1.308l1.86,4.48c0.159,0.385,0.531,0.617,0.925,0.617c0.128,0,0.258-0.024,0.383-0.076c0.511-0.211,0.752-0.797,0.54-1.309L20.029,23.675zM15.512,23.778c-0.553,0-1,0.448-1,1l0.004,4.851c0,0.553,0.449,0.999,1,0.999c0.553,0,1-0.448,0.998-1l-0.003-4.852C16.511,24.226,16.062,23.777,15.512,23.778zM12.296,23.142c-0.51-0.21-1.094,0.031-1.306,0.543l-1.852,4.483c-0.21,0.511,0.033,1.096,0.543,1.307c0.125,0.052,0.254,0.076,0.382,0.076c0.392,0,0.765-0.234,0.924-0.619l1.853-4.485C13.051,23.937,12.807,23.353,12.296,23.142zM9.57,21.325c-0.392-0.391-1.025-0.389-1.415,0.002L4.729,24.76c-0.391,0.392-0.389,1.023,0.002,1.415c0.195,0.194,0.45,0.292,0.706,0.292c0.257,0,0.513-0.098,0.708-0.293l3.427-3.434C9.961,22.349,9.961,21.716,9.57,21.325zM7.746,18.604c-0.213-0.509-0.797-0.751-1.307-0.54L1.96,19.925c-0.511,0.212-0.752,0.798-0.54,1.308c0.16,0.385,0.531,0.616,0.924,0.616c0.127,0,0.258-0.024,0.383-0.076l4.479-1.861C7.715,19.698,7.957,19.113,7.746,18.604zM7.1,15.392c0-0.553-0.447-0.999-1-0.999l-4.851,0.006c-0.553,0-1.001,0.448-0.999,1.001c0.001,0.551,0.449,1,1,0.998l4.852-0.006C6.654,16.392,7.102,15.942,7.1,15.392zM1.944,10.869l4.485,1.85c0.125,0.053,0.254,0.076,0.381,0.076c0.393,0,0.766-0.232,0.925-0.618c0.212-0.511-0.032-1.097-0.544-1.306L2.708,9.021c-0.511-0.21-1.095,0.032-1.306,0.542C1.19,10.074,1.435,10.657,1.944,10.869zM8.137,9.451c0.195,0.193,0.449,0.291,0.705,0.291s0.513-0.098,0.709-0.295c0.391-0.389,0.389-1.023-0.004-1.414L6.113,4.609C5.723,4.219,5.088,4.221,4.699,4.612c-0.391,0.39-0.389,1.024,0.002,1.414L8.137,9.451zM10.964,7.084c0.16,0.384,0.532,0.615,0.923,0.615c0.128,0,0.258-0.025,0.384-0.077c0.51-0.212,0.753-0.798,0.54-1.307l-1.864-4.479c-0.212-0.51-0.798-0.751-1.308-0.539C9.129,1.51,8.888,2.096,9.1,2.605L10.964,7.084z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Svg.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Svg.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Svg();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Svg = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Svg.prototype */
{

  NAME: "draw2d.shape.icon.Svg",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M31.274,15.989c0-2.473-2.005-4.478-4.478-4.478l0,0c0.81-0.811,1.312-1.93,1.312-3.167c0-2.474-2.005-4.479-4.479-4.479c-1.236,0-2.356,0.501-3.167,1.312c0-2.473-2.005-4.478-4.478-4.478c-2.474,0-4.479,2.005-4.479,4.478c-0.811-0.81-1.93-1.312-3.167-1.312c-2.474,0-4.479,2.005-4.479,4.479c0,1.236,0.501,2.356,1.312,3.166c-2.474,0-4.479,2.005-4.479,4.479c0,2.474,2.005,4.479,4.479,4.479c-0.811,0.81-1.312,1.93-1.312,3.167c0,2.473,2.005,4.478,4.479,4.478c1.236,0,2.356-0.501,3.167-1.312c0,2.473,2.005,4.479,4.479,4.479c2.473,0,4.478-2.006,4.478-4.479l0,0c0.811,0.811,1.931,1.312,3.167,1.312c2.474,0,4.478-2.005,4.478-4.478c0-1.237-0.501-2.357-1.312-3.168c0.001,0,0.001,0,0.001,0C29.27,20.467,31.274,18.463,31.274,15.989zM23.583,21.211c0.016,0,0.031-0.001,0.047-0.001c1.339,0,2.424,1.085,2.424,2.425c0,1.338-1.085,2.424-2.424,2.424s-2.424-1.086-2.424-2.424c0-0.017,0.001-0.031,0.001-0.047l-3.541-3.542v5.009c0.457,0.44,0.743,1.06,0.743,1.746c0,1.339-1.086,2.424-2.424,2.424c-1.339,0-2.425-1.085-2.425-2.424c0-0.687,0.286-1.306,0.743-1.746v-5.009l-3.541,3.542c0,0.016,0.001,0.031,0.001,0.047c0,1.338-1.085,2.424-2.424,2.424s-2.424-1.086-2.424-2.424c0-1.34,1.085-2.425,2.424-2.425c0.015,0,0.031,0.001,0.046,0.001l3.542-3.541H6.919c-0.44,0.458-1.06,0.743-1.746,0.743c-1.339,0-2.424-1.085-2.424-2.424s1.085-2.424,2.424-2.424c0.686,0,1.305,0.285,1.746,0.744h5.008l-3.542-3.542c-0.015,0-0.031,0.001-0.046,0.001c-1.339,0-2.424-1.085-2.424-2.424S7.001,5.92,8.34,5.92s2.424,1.085,2.424,2.424c0,0.015-0.001,0.031-0.001,0.046l3.541,3.542V6.924c-0.457-0.441-0.743-1.06-0.743-1.746c0-1.339,1.086-2.425,2.425-2.425c1.338,0,2.424,1.085,2.424,2.425c0,0.686-0.286,1.305-0.743,1.746v5.008l3.541-3.542c0-0.015-0.001-0.031-0.001-0.046c0-1.339,1.085-2.424,2.424-2.424s2.424,1.085,2.424,2.424c0,1.339-1.085,2.424-2.424,2.424c-0.016,0-0.031-0.001-0.047-0.001l-3.541,3.542h5.008c0.441-0.458,1.061-0.744,1.747-0.744c1.338,0,2.423,1.085,2.423,2.424s-1.085,2.424-2.423,2.424c-0.687,0-1.306-0.285-1.747-0.743h-5.008L23.583,21.211z");
  }
});

/***/ }),

/***/ "./src/shape/icon/TShirt.js":
/*!**********************************!*\
  !*** ./src/shape/icon/TShirt.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.TShirt();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.TShirt = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.TShirt.prototype */
{

  NAME: "draw2d.shape.icon.TShirt",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.1,4.039c-0.681,1.677-2.32,2.862-4.24,2.862c-1.921,0-3.56-1.185-4.24-2.862L1.238,8.442l2.921,6.884l3.208-1.361V28h17.099V14.015l3.093,1.312l2.922-6.884L20.1,4.039z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Tag.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Tag.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Tag();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Tag = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Tag.prototype */
{

  NAME: "draw2d.shape.icon.Tag",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.263,2.826H7.904L2.702,8.028v6.359L18.405,30.09l11.561-11.562L14.263,2.826zM6.495,8.859c-0.619-0.619-0.619-1.622,0-2.24C7.114,6,8.117,6,8.736,6.619c0.62,0.62,0.619,1.621,0,2.241C8.117,9.479,7.114,9.479,6.495,8.859z");
  }
});

/***/ }),

/***/ "./src/shape/icon/TakeOff.js":
/*!***********************************!*\
  !*** ./src/shape/icon/TakeOff.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.TakeOff();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.TakeOff = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.TakeOff.prototype */
{

  NAME: "draw2d.shape.icon.TakeOff",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M10.27,19.267c0,0,9.375-1.981,16.074-8.681c0,0,1.395-1.339-1.338-1.339c-2.305,0-5.6,2.438-5.6,2.438l-9.137-1.42l-1.769,1.769l4.983,2.411l-3.001,2.035l-2.571-1.285L6.09,16.052C6.09,16.052,8.02,18.062,10.27,19.267zM3.251,23.106v1.998h24.498v-1.998H3.251z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Talke.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Talke.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Talke();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Talke = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Talke.prototype */
{

  NAME: "draw2d.shape.icon.Talke",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,4.938c-7.732,0-14,4.701-14,10.5c0,1.981,0.741,3.833,2.016,5.414L2,25.272l5.613-1.44c2.339,1.316,5.237,2.106,8.387,2.106c7.732,0,14-4.701,14-10.5S23.732,4.938,16,4.938zM16.982,21.375h-1.969v-1.889h1.969V21.375zM16.982,17.469v0.625h-1.969v-0.769c0-2.321,2.641-2.689,2.641-4.337c0-0.752-0.672-1.329-1.553-1.329c-0.912,0-1.713,0.672-1.713,0.672l-1.12-1.393c0,0,1.104-1.153,3.009-1.153c1.81,0,3.49,1.121,3.49,3.009C19.768,15.437,16.982,15.741,16.982,17.469z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Talkq.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Talkq.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Talkq();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Talkq = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Talkq.prototype */
{

  NAME: "draw2d.shape.icon.Talkq",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,4.938c-7.732,0-14,4.701-14,10.5c0,1.981,0.741,3.833,2.016,5.414L2,25.272l5.613-1.44c2.339,1.316,5.237,2.106,8.387,2.106c7.732,0,14-4.701,14-10.5S23.732,4.938,16,4.938zM16.868,21.375h-1.969v-1.889h1.969V21.375zM16.772,18.094h-1.777l-0.176-8.083h2.113L16.772,18.094z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Thunder.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Thunder.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Thunder();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Thunder = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Thunder.prototype */
{

  NAME: "draw2d.shape.icon.Thunder",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.371,7.306c-0.092-3.924-3.301-7.077-7.248-7.079c-2.638,0.001-4.942,1.412-6.208,3.517c-0.595-0.327-1.28-0.517-2.01-0.517C7.626,3.229,5.772,5.033,5.689,7.293c-2.393,0.786-4.125,3.025-4.127,5.686c0,3.312,2.687,6,6,6v-0.002h5.271l-2.166,3.398l1.977-0.411L10,30.875l9.138-10.102L17,21l2.167-2.023h4.269c3.312,0,6-2.688,6-6C29.434,10.34,27.732,8.11,25.371,7.306zM23.436,16.979H7.561c-2.209-0.006-3.997-1.792-4.001-4.001c-0.002-1.982,1.45-3.618,3.35-3.931c0.265-0.043,0.502-0.191,0.657-0.414C7.722,8.41,7.779,8.136,7.73,7.87C7.702,7.722,7.685,7.582,7.685,7.446C7.689,6.221,8.68,5.23,9.905,5.228c0.647,0,1.217,0.278,1.633,0.731c0.233,0.257,0.587,0.375,0.927,0.309c0.342-0.066,0.626-0.307,0.748-0.63c0.749-1.992,2.662-3.412,4.911-3.41c2.899,0.004,5.244,2.35,5.251,5.249c0,0.161-0.009,0.326-0.027,0.497c-0.049,0.517,0.305,0.984,0.815,1.079c1.86,0.344,3.274,1.966,3.271,3.923C27.43,15.186,25.645,16.973,23.436,16.979z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Trash.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Trash.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Trash();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Trash = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Trash.prototype */
{

  NAME: "draw2d.shape.icon.Trash",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.826,5.75l0.396,1.188c1.54,0.575,2.589,1.44,2.589,2.626c0,2.405-4.308,3.498-8.312,3.498c-4.003,0-8.311-1.093-8.311-3.498c0-1.272,1.21-2.174,2.938-2.746l0.388-1.165c-2.443,0.648-4.327,1.876-4.327,3.91v2.264c0,1.224,0.685,2.155,1.759,2.845l0.396,9.265c0,1.381,3.274,2.5,7.312,2.5c4.038,0,7.313-1.119,7.313-2.5l0.405-9.493c0.885-0.664,1.438-1.521,1.438-2.617V9.562C24.812,7.625,23.101,6.42,20.826,5.75zM11.093,24.127c-0.476-0.286-1.022-0.846-1.166-1.237c-1.007-2.76-0.73-4.921-0.529-7.509c0.747,0.28,1.58,0.491,2.45,0.642c-0.216,2.658-0.43,4.923,0.003,7.828C11.916,24.278,11.567,24.411,11.093,24.127zM17.219,24.329c-0.019,0.445-0.691,0.856-1.517,0.856c-0.828,0-1.498-0.413-1.517-0.858c-0.126-2.996-0.032-5.322,0.068-8.039c0.418,0.022,0.835,0.037,1.246,0.037c0.543,0,1.097-0.02,1.651-0.059C17.251,18.994,17.346,21.325,17.219,24.329zM21.476,22.892c-0.143,0.392-0.69,0.95-1.165,1.235c-0.474,0.284-0.817,0.151-0.754-0.276c0.437-2.93,0.214-5.209-0.005-7.897c0.881-0.174,1.708-0.417,2.44-0.731C22.194,17.883,22.503,20.076,21.476,22.892zM11.338,9.512c0.525,0.173,1.092-0.109,1.268-0.633h-0.002l0.771-2.316h4.56l0.771,2.316c0.14,0.419,0.53,0.685,0.949,0.685c0.104,0,0.211-0.017,0.316-0.052c0.524-0.175,0.808-0.742,0.633-1.265l-1.002-3.001c-0.136-0.407-0.518-0.683-0.945-0.683h-6.002c-0.428,0-0.812,0.275-0.948,0.683l-1,2.999C10.532,8.77,10.815,9.337,11.338,9.512z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Twitter.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Twitter.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Twitter();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Twitter = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Twitter.prototype */
{

  NAME: "draw2d.shape.icon.Twitter",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M23.295,22.567h-7.213c-2.125,0-4.103-2.215-4.103-4.736v-1.829h11.232c1.817,0,3.291-1.469,3.291-3.281c0-1.813-1.474-3.282-3.291-3.282H11.979V6.198c0-1.835-1.375-3.323-3.192-3.323c-1.816,0-3.29,1.488-3.29,3.323v11.633c0,6.23,4.685,11.274,10.476,11.274h7.211c1.818,0,3.318-1.463,3.318-3.298S25.112,22.567,23.295,22.567z");
  }
});

/***/ }),

/***/ "./src/shape/icon/TwitterBird.js":
/*!***************************************!*\
  !*** ./src/shape/icon/TwitterBird.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.TwitterBird();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.TwitterBird = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.TwitterBird.prototype */
{

  NAME: "draw2d.shape.icon.TwitterBird",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.605,13.11c0.913-2.851,2.029-4.698,3.313-6.038c0.959-1,1.453-1.316,0.891-0.216c0.25-0.199,0.606-0.464,0.885-0.605c1.555-0.733,1.442-0.119,0.373,0.54c2.923-1.045,2.82,0.286-0.271,0.949c2.527,0.047,5.214,1.656,5.987,5.077c0.105,0.474-0.021,0.428,0.464,0.514c1.047,0.186,2.03,0.174,2.991-0.13c-0.104,0.708-1.039,1.167-2.497,1.471c-0.541,0.112-0.651,0.083-0.005,0.229c0.799,0.179,1.69,0.226,2.634,0.182c-0.734,0.846-1.905,1.278-3.354,1.296c-0.904,3.309-2.976,5.678-5.596,7.164c-6.152,3.492-15.108,2.984-19.599-3.359c2.947,2.312,7.312,2.821,10.555-0.401c-2.125,0-2.674-1.591-0.99-2.449c-1.595-0.017-2.608-0.521-3.203-1.434c-0.226-0.347-0.229-0.374,0.14-0.64c0.405-0.293,0.958-0.423,1.528-0.467c-1.651-0.473-2.66-1.335-3.009-2.491c-0.116-0.382-0.134-0.363,0.256-0.462c0.38-0.097,0.87-0.148,1.309-0.17C6.11,10.88,5.336,9.917,5.139,8.852c-0.186-1.006,0.005-0.748,0.758-0.46C9.263,9.68,12.619,11.062,14.605,13.11L14.605,13.11z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Umbrella.js":
/*!************************************!*\
  !*** ./src/shape/icon/Umbrella.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Umbrella();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Umbrella = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Umbrella.prototype */
{

  NAME: "draw2d.shape.icon.Umbrella",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M14.784,26.991c0,1.238-1.329,1.696-1.835,1.696c-0.504,0-1.536-0.413-1.65-1.812c0-0.354-0.288-0.642-0.644-0.642c-0.354,0-0.641,0.287-0.641,0.642c0.045,1.056,0.756,3.052,2.935,3.052c2.432,0,3.166-1.882,3.166-3.144v-8.176l-1.328-0.024C14.787,18.584,14.784,25.889,14.784,26.991zM15.584,9.804c-6.807,0-11.084,4.859-11.587,8.326c0.636-0.913,1.694-1.51,2.89-1.51c1.197,0,2.22,0.582,2.855,1.495c0.638-0.904,1.69-1.495,2.88-1.495c1.2,0,2.26,0.6,2.896,1.517c0.635-0.917,1.83-1.517,3.03-1.517c1.19,0,2.241,0.591,2.879,1.495c0.636-0.913,1.659-1.495,2.855-1.495c1.197,0,2.254,0.597,2.89,1.51C26.669,14.663,22.393,9.804,15.584,9.804zM14.733,7.125v2.081h1.323V7.125c0-0.365-0.296-0.661-0.661-0.661C15.029,6.464,14.733,6.76,14.733,7.125z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Undo.js":
/*!********************************!*\
  !*** ./src/shape/icon/Undo.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Undo();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Undo = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Undo.prototype */
{

  NAME: "draw2d.shape.icon.Undo",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M12.981,9.073V6.817l-12.106,6.99l12.106,6.99v-2.422c3.285-0.002,9.052,0.28,9.052,2.269c0,2.78-6.023,4.263-6.023,4.263v2.132c0,0,13.53,0.463,13.53-9.823C29.54,9.134,17.952,8.831,12.981,9.073z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Unlock.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Unlock.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Unlock();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Unlock = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Unlock.prototype */
{

  NAME: "draw2d.shape.icon.Unlock",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.375,12.833h-2.209V10c0,0,0,0,0-0.001c0-2.389,1.945-4.333,4.334-4.333c2.391,0,4.335,1.944,4.335,4.333c0,0,0,0,0,0v2.834h2V9.999h-0.001c-0.001-3.498-2.836-6.333-6.334-6.333S16.166,6.502,16.166,10v2.833H3.125V25h17.25V12.833z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Usb.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Usb.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Usb();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Usb = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Usb.prototype */
{

  NAME: "draw2d.shape.icon.Usb",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M15.5,1.667L13.745,4.74h1.252v15.709L11.8,17.391c-0.205-0.26-0.351-0.601-0.358-0.952c0-1.417-0.001-2.258-0.001-2.568c0.592-0.21,1.02-0.774,1.02-1.444c0-0.849-0.682-1.538-1.521-1.538c-0.84,0-1.521,0.689-1.521,1.538c0,0.67,0.427,1.234,1.019,1.444l-0.001,2.539c0,0.688,0.373,1.409,0.812,1.868c-0.013-0.013-0.027-0.025,0,0c0.011,0.01,3.392,3.245,3.392,3.245c0.205,0.26,0.35,0.6,0.357,0.951v1.776c-1.161,0.236-2.036,1.272-2.036,2.517c0,1.418,1.137,2.566,2.539,2.566c1.403,0,2.54-1.148,2.54-2.566c0-1.244-0.875-2.28-2.038-2.517v-1.746c0-0.005,0-0.009,0-0.014v-3.861c0.008-0.35,0.152-0.689,0.358-0.949c0,0,3.38-3.234,3.392-3.245c0.027-0.026,0.012-0.013,0,0c0.438-0.459,0.811-1.181,0.811-1.869V10.12h1.02V7.046h-3.041v3.075h1.018c0,0-0.002,0.644-0.002,2.476c-0.008,0.351-0.152,0.692-0.357,0.952l-3.198,3.06V4.74h1.254L15.5,1.667z");
  }
});

/***/ }),

/***/ "./src/shape/icon/User.js":
/*!********************************!*\
  !*** ./src/shape/icon/User.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.User();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.User = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.User.prototype */
{

  NAME: "draw2d.shape.icon.User",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.771,12.364c0,0,0.849-3.51,0-4.699c-0.85-1.189-1.189-1.981-3.058-2.548s-1.188-0.454-2.547-0.396c-1.359,0.057-2.492,0.792-2.492,1.188c0,0-0.849,0.057-1.188,0.397c-0.34,0.34-0.906,1.924-0.906,2.321s0.283,3.058,0.566,3.624l-0.337,0.113c-0.283,3.283,1.132,3.68,1.132,3.68c0.509,3.058,1.019,1.756,1.019,2.548s-0.51,0.51-0.51,0.51s-0.452,1.245-1.584,1.698c-1.132,0.452-7.416,2.886-7.927,3.396c-0.511,0.511-0.453,2.888-0.453,2.888h26.947c0,0,0.059-2.377-0.452-2.888c-0.512-0.511-6.796-2.944-7.928-3.396c-1.132-0.453-1.584-1.698-1.584-1.698s-0.51,0.282-0.51-0.51s0.51,0.51,1.02-2.548c0,0,1.414-0.397,1.132-3.68H20.771z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Users.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Users.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Users();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Users = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Users.prototype */
{

  NAME: "draw2d.shape.icon.Users",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.053,20.8c-1.132-0.453-1.584-1.698-1.584-1.698s-0.51,0.282-0.51-0.51s0.51,0.51,1.02-2.548c0,0,1.414-0.397,1.132-3.68h-0.34c0,0,0.849-3.51,0-4.699c-0.85-1.189-1.189-1.981-3.058-2.548s-1.188-0.454-2.547-0.396c-1.359,0.057-2.492,0.792-2.492,1.188c0,0-0.849,0.057-1.188,0.397c-0.34,0.34-0.906,1.924-0.906,2.321s0.283,3.058,0.566,3.624l-0.337,0.113c-0.283,3.283,1.132,3.68,1.132,3.68c0.509,3.058,1.019,1.756,1.019,2.548s-0.51,0.51-0.51,0.51s-0.452,1.245-1.584,1.698c-1.132,0.452-7.416,2.886-7.927,3.396c-0.511,0.511-0.453,2.888-0.453,2.888h26.947c0,0,0.059-2.377-0.452-2.888C28.469,23.686,22.185,21.252,21.053,20.8zM8.583,20.628c-0.099-0.18-0.148-0.31-0.148-0.31s-0.432,0.239-0.432-0.432s0.432,0.432,0.864-2.159c0,0,1.199-0.336,0.959-3.119H9.538c0,0,0.143-0.591,0.237-1.334c-0.004-0.308,0.006-0.636,0.037-0.996l0.038-0.426c-0.021-0.492-0.107-0.939-0.312-1.226C8.818,9.619,8.53,8.947,6.947,8.467c-1.583-0.48-1.008-0.385-2.159-0.336C3.636,8.179,2.676,8.802,2.676,9.139c0,0-0.72,0.048-1.008,0.336c-0.271,0.271-0.705,1.462-0.757,1.885v0.281c0.047,0.653,0.258,2.449,0.469,2.872l-0.286,0.096c-0.239,2.783,0.959,3.119,0.959,3.119c0.432,2.591,0.864,1.488,0.864,2.159s-0.432,0.432-0.432,0.432s-0.383,1.057-1.343,1.439c-0.061,0.024-0.139,0.056-0.232,0.092v5.234h0.575c-0.029-1.278,0.077-2.927,0.746-3.594C2.587,23.135,3.754,22.551,8.583,20.628zM30.913,11.572c-0.04-0.378-0.127-0.715-0.292-0.946c-0.719-1.008-1.008-1.679-2.59-2.159c-1.584-0.48-1.008-0.385-2.16-0.336C24.72,8.179,23.76,8.802,23.76,9.139c0,0-0.719,0.048-1.008,0.336c-0.271,0.272-0.709,1.472-0.758,1.891h0.033l0.08,0.913c0.02,0.231,0.022,0.436,0.027,0.645c0.09,0.666,0.21,1.35,0.33,1.589l-0.286,0.096c-0.239,2.783,0.96,3.119,0.96,3.119c0.432,2.591,0.863,1.488,0.863,2.159s-0.432,0.432-0.432,0.432s-0.053,0.142-0.163,0.338c4.77,1.9,5.927,2.48,6.279,2.834c0.67,0.667,0.775,2.315,0.746,3.594h0.48v-5.306c-0.016-0.006-0.038-0.015-0.052-0.021c-0.959-0.383-1.343-1.439-1.343-1.439s-0.433,0.239-0.433-0.432s0.433,0.432,0.864-2.159c0,0,0.804-0.229,0.963-1.841v-1.227c-0.001-0.018-0.001-0.033-0.003-0.051h-0.289c0,0,0.215-0.89,0.292-1.861V11.572z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Video.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Video.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Video();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Video = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Video.prototype */
{

  NAME: "draw2d.shape.icon.Video",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.188,4.875v1.094h-4.5V4.875H8.062v1.094h-4.5V4.875h-1v21.25h1v-1.094h4.5v1.094h14.625v-1.094h4.5v1.094h1.25V4.875H27.188zM8.062,23.719h-4.5v-3.125h4.5V23.719zM8.062,19.281h-4.5v-3.125h4.5V19.281zM8.062,14.844h-4.5v-3.125h4.5V14.844zM8.062,10.406h-4.5V7.281h4.5V10.406zM11.247,20.59V9.754l9.382,5.418L11.247,20.59zM27.188,23.719h-4.5v-3.125h4.5V23.719zM27.188,19.281h-4.5v-3.125h4.5V19.281zM27.188,14.844h-4.5v-3.125h4.5V14.844zM27.188,10.406h-4.5V7.281h4.5V10.406z");
  }
});

/***/ }),

/***/ "./src/shape/icon/View.js":
/*!********************************!*\
  !*** ./src/shape/icon/View.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.View();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.View = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.View.prototype */
{

  NAME: "draw2d.shape.icon.View",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M16,8.286C8.454,8.286,2.5,16,2.5,16s5.954,7.715,13.5,7.715c5.771,0,13.5-7.715,13.5-7.715S21.771,8.286,16,8.286zM16,20.807c-2.649,0-4.807-2.157-4.807-4.807s2.158-4.807,4.807-4.807s4.807,2.158,4.807,4.807S18.649,20.807,16,20.807zM16,13.194c-1.549,0-2.806,1.256-2.806,2.806c0,1.55,1.256,2.806,2.806,2.806c1.55,0,2.806-1.256,2.806-2.806C18.806,14.451,17.55,13.194,16,13.194z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Vim.js":
/*!*******************************!*\
  !*** ./src/shape/icon/Vim.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Vim();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Vim = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Vim.prototype */
{

  NAME: "draw2d.shape.icon.Vim",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M25.012,10.44l4.571-4.645c0.11-0.113,0.173-0.264,0.173-0.423V3.134c0-0.159-0.064-0.314-0.177-0.427l-0.604-0.602c-0.111-0.112-0.261-0.176-0.42-0.177l-9.646-0.086C18.71,1.84,18.523,1.935,18.41,2.099L17.807,2.96c-0.033,0.047-0.059,0.099-0.076,0.154l-2.144-2.156l0,0l-1.646,1.666l-0.447-0.497c-0.112-0.125-0.27-0.197-0.438-0.199L3.324,1.756c-0.163-0.003-0.322,0.06-0.437,0.176L2.284,2.535C2.171,2.647,2.107,2.803,2.107,2.962v2.325c0,0.164,0.066,0.32,0.183,0.434l0.657,0.635C3.056,6.461,3.2,6.521,3.352,6.525l0.285,0.007l0.007,6.512l-2.527,2.557l2.533,2.533l0.008,8.084c0,0.159,0.065,0.314,0.177,0.427l0.861,0.861c0.112,0.111,0.268,0.176,0.427,0.176h2.67c0.161,0,0.317-0.064,0.43-0.181l2.378-2.417l4.9,4.9l14.47-14.558L25.012,10.44zM9.747,24.232l-2.208,2.242H5.372l-0.509-0.509L4.856,19.34l-0.008-7.515L4.842,5.943c0-0.328-0.261-0.594-0.588-0.603L3.617,5.326L3.313,5.031v-1.82l0.245-0.245l9.215,0.163l0.319,0.354l0.126,0.141v1.419l-0.352,0.362H12.26c-0.331,0-0.6,0.266-0.603,0.597l-0.076,7.203c-0.002,0.244,0.141,0.463,0.365,0.56c0.224,0.096,0.482,0.049,0.657-0.12l7.495-7.235c0.174-0.171,0.23-0.432,0.139-0.66c-0.09-0.228-0.312-0.377-0.56-0.377h-0.479l-0.296-0.379V3.496l0.312-0.445l9.083,0.081l0.252,0.252v1.743l-4.388,4.458L9.747,24.232z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Volume0.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Volume0.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Volume0();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Volume0 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Volume0.prototype */
{

  NAME: "draw2d.shape.icon.Volume0",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.998,12.127v7.896h4.495l6.729,5.526l0.004-18.948l-6.73,5.526H4.998z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Volume1.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Volume1.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Volume1();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Volume1 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Volume1.prototype */
{

  NAME: "draw2d.shape.icon.Volume1",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.998,12.127v7.896h4.495l6.729,5.526l0.004-18.948l-6.73,5.526H4.998z M18.806,11.219c-0.393-0.389-1.024-0.389-1.415,0.002c-0.39,0.391-0.39,1.024,0.002,1.416v-0.002c0.863,0.864,1.395,2.049,1.395,3.366c0,1.316-0.531,2.497-1.393,3.361c-0.394,0.389-0.394,1.022-0.002,1.415c0.195,0.195,0.451,0.293,0.707,0.293c0.257,0,0.513-0.098,0.708-0.293c1.222-1.22,1.98-2.915,1.979-4.776C20.788,14.136,20.027,12.439,18.806,11.219z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Volume2.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Volume2.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Volume2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Volume2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Volume2.prototype */
{

  NAME: "draw2d.shape.icon.Volume2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.998,12.127v7.896h4.495l6.729,5.526l0.004-18.948l-6.73,5.526H4.998z M18.806,11.219c-0.393-0.389-1.024-0.389-1.415,0.002c-0.39,0.391-0.39,1.024,0.002,1.416v-0.002c0.863,0.864,1.395,2.049,1.395,3.366c0,1.316-0.531,2.497-1.393,3.361c-0.394,0.389-0.394,1.022-0.002,1.415c0.195,0.195,0.451,0.293,0.707,0.293c0.257,0,0.513-0.098,0.708-0.293c1.222-1.22,1.98-2.915,1.979-4.776C20.788,14.136,20.027,12.439,18.806,11.219z M21.101,8.925c-0.393-0.391-1.024-0.391-1.413,0c-0.392,0.391-0.392,1.025,0,1.414c1.45,1.451,2.344,3.447,2.344,5.661c0,2.212-0.894,4.207-2.342,5.659c-0.392,0.39-0.392,1.023,0,1.414c0.195,0.195,0.451,0.293,0.708,0.293c0.256,0,0.512-0.098,0.707-0.293c1.808-1.809,2.929-4.315,2.927-7.073C24.033,13.24,22.912,10.732,21.101,8.925z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Volume3.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Volume3.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Volume3();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Volume3 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Volume3.prototype */
{

  NAME: "draw2d.shape.icon.Volume3",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M4.998,12.127v7.896h4.495l6.729,5.526l0.004-18.948l-6.73,5.526H4.998z M18.806,11.219c-0.393-0.389-1.024-0.389-1.415,0.002c-0.39,0.391-0.39,1.024,0.002,1.416v-0.002c0.863,0.864,1.395,2.049,1.395,3.366c0,1.316-0.531,2.497-1.393,3.361c-0.394,0.389-0.394,1.022-0.002,1.415c0.195,0.195,0.451,0.293,0.707,0.293c0.257,0,0.513-0.098,0.708-0.293c1.222-1.22,1.98-2.915,1.979-4.776C20.788,14.136,20.027,12.439,18.806,11.219z M21.101,8.925c-0.393-0.391-1.024-0.391-1.413,0c-0.392,0.391-0.392,1.025,0,1.414c1.45,1.451,2.344,3.447,2.344,5.661c0,2.212-0.894,4.207-2.342,5.659c-0.392,0.39-0.392,1.023,0,1.414c0.195,0.195,0.451,0.293,0.708,0.293c0.256,0,0.512-0.098,0.707-0.293c1.808-1.809,2.929-4.315,2.927-7.073C24.033,13.24,22.912,10.732,21.101,8.925z M23.28,6.746c-0.393-0.391-1.025-0.389-1.414,0.002c-0.391,0.389-0.391,1.023,0.002,1.413h-0.002c2.009,2.009,3.248,4.773,3.248,7.839c0,3.063-1.239,5.828-3.246,7.838c-0.391,0.39-0.391,1.023,0.002,1.415c0.194,0.194,0.45,0.291,0.706,0.291s0.513-0.098,0.708-0.293c2.363-2.366,3.831-5.643,3.829-9.251C27.115,12.389,25.647,9.111,23.28,6.746z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Warning.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Warning.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Warning();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Warning = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Warning.prototype */
{

  NAME: "draw2d.shape.icon.Warning",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M29.225,23.567l-3.778-6.542c-1.139-1.972-3.002-5.2-4.141-7.172l-3.778-6.542c-1.14-1.973-3.003-1.973-4.142,0L9.609,9.853c-1.139,1.972-3.003,5.201-4.142,7.172L1.69,23.567c-1.139,1.974-0.207,3.587,2.071,3.587h23.391C29.432,27.154,30.363,25.541,29.225,23.567zM16.536,24.58h-2.241v-2.151h2.241V24.58zM16.428,20.844h-2.023l-0.201-9.204h2.407L16.428,20.844z");
  }
});

/***/ }),

/***/ "./src/shape/icon/WheelChair.js":
/*!**************************************!*\
  !*** ./src/shape/icon/WheelChair.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.WheelChair();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.WheelChair = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.WheelChair.prototype */
{

  NAME: "draw2d.shape.icon.WheelChair",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.373,19.85c0,4.079-3.318,7.397-7.398,7.397c-4.079,0-7.398-3.318-7.398-7.397c0-2.466,1.213-4.652,3.073-5.997l-0.251-2.21c-2.875,1.609-4.825,4.684-4.825,8.207c0,5.184,4.217,9.4,9.401,9.4c4.395,0,8.093-3.031,9.117-7.111L20.37,19.73C20.37,19.771,20.373,19.81,20.373,19.85zM11.768,6.534c1.321,0,2.392-1.071,2.392-2.392c0-1.321-1.071-2.392-2.392-2.392c-1.321,0-2.392,1.071-2.392,2.392C9.375,5.463,10.446,6.534,11.768,6.534zM27.188,22.677l-5.367-7.505c-0.28-0.393-0.749-0.579-1.226-0.538c-0.035-0.003-0.071-0.006-0.106-0.006h-6.132l-0.152-1.335h4.557c0.53,0,0.96-0.429,0.96-0.959c0-0.53-0.43-0.959-0.96-0.959h-4.776l-0.25-2.192c-0.146-1.282-1.303-2.203-2.585-2.057C9.869,7.271,8.948,8.428,9.094,9.71l0.705,6.19c0.136,1.197,1.154,2.078,2.332,2.071c0.004,0,0.007,0.001,0.012,0.001h8.023l4.603,6.436c0.439,0.615,1.338,0.727,2.007,0.248C27.442,24.178,27.628,23.292,27.188,22.677z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Windows.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Windows.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Windows();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Windows = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Windows.prototype */
{

  NAME: "draw2d.shape.icon.Windows",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M20.023,17.484c-1.732-0.205-3.022-0.908-4.212-1.701l0,0l-0.559,0.279l-2.578,8.924l0,0c1.217,0.805,2.905,1.707,4.682,1.914c2.686,0.312,5.56-0.744,6.391-1.195l2.617-9.061l-0.559-0.279C25.805,16.365,23.193,17.857,20.023,17.484zM14.424,14.825c-1.267-0.87-2.578-1.652-4.375-1.816c-0.318-0.029-0.627-0.042-0.925-0.042c-3.011,0-4.948,1.347-4.948,1.347l-2.565,8.877l0,0l0.526,0.281c0.981-0.476,2.78-1.145,5.09-0.984c1.665,0.113,2.92,0.781,4.117,1.531l0.507-0.26l0,0L14.424,14.825zM10.201,12.094c1.664,0.114,2.921,0.78,4.117,1.533l0.509-0.26l0,0L17.4,4.431c-1.27-0.87-2.579-1.653-4.377-1.816c-0.318-0.029-0.626-0.042-0.924-0.042C9.088,2.573,7.15,3.92,7.15,3.92l-2.566,8.878L5.11,13.08C6.092,12.604,7.891,11.936,10.201,12.094zM28.779,5.971L28.779,5.971c0,0.001-2.609,1.492-5.779,1.119c-1.734-0.204-3.023-0.907-4.213-1.701L18.227,5.67l-2.576,8.923l0,0c1.215,0.803,2.906,1.709,4.68,1.915c2.687,0.312,5.558-0.745,6.392-1.197l2.615-9.059L28.779,5.971z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Woman.js":
/*!*********************************!*\
  !*** ./src/shape/icon/Woman.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Woman();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Woman = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Woman.prototype */
{

  NAME: "draw2d.shape.icon.Woman",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M21.022,16.349c-0.611-1.104-1.359-1.998-2.109-2.623c-0.875,0.641-1.941,1.031-3.104,1.031c-1.164,0-2.231-0.391-3.105-1.031c-0.75,0.625-1.498,1.519-2.111,2.623c-1.422,2.563-1.579,5.192-0.351,5.874c0.55,0.307,1.127,0.078,1.723-0.496c-0.105,0.582-0.167,1.213-0.167,1.873c0,2.932,1.139,5.307,2.543,5.307c0.846,0,1.265-0.865,1.466-2.189c0.201,1.324,0.62,2.189,1.464,2.189c1.406,0,2.545-2.375,2.545-5.307c0-0.66-0.061-1.291-0.168-1.873c0.598,0.574,1.174,0.803,1.725,0.496C22.603,21.541,22.444,18.912,21.022,16.349zM15.808,13.757c2.363,0,4.279-1.916,4.279-4.279s-1.916-4.279-4.279-4.279c-2.363,0-4.28,1.916-4.28,4.279S13.445,13.757,15.808,13.757zM18.731,4.974c1.235,0.455,0.492-0.725,0.492-1.531s0.762-1.792-0.492-1.391c-1.316,0.422-2.383,0.654-2.383,1.461S17.415,4.489,18.731,4.974zM15.816,4.4c0.782,0,0.345-0.396,0.345-0.884c0-0.488,0.438-0.883-0.345-0.883s-0.374,0.396-0.374,0.883C15.442,4.005,15.034,4.4,15.816,4.4zM12.884,4.974c1.316-0.484,2.383-0.654,2.383-1.461S14.2,2.474,12.884,2.052c-1.254-0.402-0.492,0.584-0.492,1.391S11.648,5.428,12.884,4.974z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Wrench.js":
/*!**********************************!*\
  !*** ./src/shape/icon/Wrench.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Wrench();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Wrench = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Wrench.prototype */
{

  NAME: "draw2d.shape.icon.Wrench",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M26.834,14.693c1.816-2.088,2.181-4.938,1.193-7.334l-3.646,4.252l-3.594-0.699L19.596,7.45l3.637-4.242c-2.502-0.63-5.258,0.13-7.066,2.21c-1.907,2.193-2.219,5.229-1.039,7.693L5.624,24.04c-1.011,1.162-0.888,2.924,0.274,3.935c1.162,1.01,2.924,0.888,3.935-0.274l9.493-10.918C21.939,17.625,24.918,16.896,26.834,14.693z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Wrench2.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Wrench2.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Wrench2();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Wrench2 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Wrench2.prototype */
{

  NAME: "draw2d.shape.icon.Wrench2",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M24.946,9.721l-2.872-0.768l-0.771-2.874l3.188-3.231c-1.992-0.653-4.268-0.192-5.848,1.391c-1.668,1.668-2.095,4.111-1.279,6.172l-3.476,3.478l-3.478,3.478c-2.062-0.816-4.504-0.391-6.173,1.277c-1.583,1.581-2.043,3.856-1.39,5.849l3.231-3.188l2.874,0.77l0.769,2.872l-3.239,3.197c1.998,0.665,4.288,0.207,5.876-1.384c1.678-1.678,2.1-4.133,1.271-6.202l3.463-3.464l3.464-3.463c2.069,0.828,4.523,0.406,6.202-1.272c1.592-1.589,2.049-3.878,1.384-5.876L24.946,9.721z");
  }
});

/***/ }),

/***/ "./src/shape/icon/Wrench3.js":
/*!***********************************!*\
  !*** ./src/shape/icon/Wrench3.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.Wrench3();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.Wrench3 = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.Wrench3.prototype */
{

  NAME: "draw2d.shape.icon.Wrench3",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   *
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M27.839,6.775l-3.197,3.239L21.77,9.246l-0.771-2.874l3.188-3.231c-1.992-0.653-4.268-0.192-5.848,1.391c-1.668,1.668-2.095,4.111-1.279,6.172L7.42,20.344c-0.204-0.032-0.408-0.062-0.621-0.062c-2.173,0-3.933,1.759-3.933,3.933c0,2.173,1.76,3.933,3.933,3.933c2.171,0,3.931-1.76,3.933-3.933c0-0.24-0.03-0.473-0.071-0.7l9.592-9.59c2.069,0.828,4.523,0.406,6.202-1.272C28.047,11.062,28.504,8.772,27.839,6.775zM6.799,25.146c-0.517,0-0.933-0.418-0.935-0.933c0.002-0.515,0.418-0.933,0.935-0.933c0.514,0,0.932,0.418,0.932,0.933S7.313,25.146,6.799,25.146z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ZoomIn.js":
/*!**********************************!*\
  !*** ./src/shape/icon/ZoomIn.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ZoomIn();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ZoomIn = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ZoomIn.prototype */
{

  NAME: "draw2d.shape.icon.ZoomIn",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.646,19.307c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127l3.535-3.537L22.646,19.307zM13.688,20.369c-3.582-0.008-6.478-2.904-6.484-6.484c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486C20.165,17.465,17.267,20.361,13.688,20.369zM15.687,9.051h-4v2.833H8.854v4.001h2.833v2.833h4v-2.834h2.832v-3.999h-2.833V9.051z");
  }
});

/***/ }),

/***/ "./src/shape/icon/ZoomOut.js":
/*!***********************************!*\
  !*** ./src/shape/icon/ZoomOut.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class

 *
 * @example
 *
 *    let icon =  new draw2d.shape.icon.ZoomOut();
 *
 *    canvas.add(icon,50,10);
 *
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.shape.icon.Icon
 */
_packages2.default.shape.icon.ZoomOut = _packages2.default.shape.icon.Icon.extend(
/** @lends draw2d.shape.icon.ZoomOut.prototype */
{

  NAME: "draw2d.shape.icon.ZoomOut",

  /**
   *
   * Creates a new icon element which are not assigned to any canvas.
   * 
   * @param {Object} attr the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 50, height: 50 }, attr), setter, getter);
  },

  /**
   * @private
   * @returns {Object} the raphaelJS path object
   */
  createSet: function createSet() {
    return this.canvas.paper.path("M22.646,19.307c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127l3.535-3.537L22.646,19.307zM13.688,20.369c-3.582-0.008-6.478-2.904-6.484-6.484c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486C20.165,17.465,17.267,20.361,13.688,20.369zM8.854,11.884v4.001l9.665-0.001v-3.999L8.854,11.884z");
  }
});

/***/ }),

/***/ "./src/shape/layout/FlexGridLayout.js":
/*!********************************************!*\
  !*** ./src/shape/layout/FlexGridLayout.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * FlexGridLayout is a powerful, flexible and precise layout manager that aligns components vertically and
 * horizontally in a dynamic rectangular grid of cells, with each component occupying in one or more cell.
 * To define a form layout you specify the form's columns, rows. Everyhing that applies to columns applies
 * to rows too - just with a different orientation. FlexGridLayout uses the same API, algorithms and implementation
 * for column and rows.
 *
 * FlexGridLayout focuses on form-oriented panels much like the 'Segment' panel. Nevertheless, it is a general purpose
 * layout system that can be used for the vast majority of rectangular layouts.
 *
 * Define your layout with:
 * <ul>
 *  <li>[number]px</li>
 *  <li>grow</li>
 *  <li>pref</li>
 * </ul>
 *
 * e.g. we want build a shape with a border on the left and right and a label in the
 * center. We allow the center to grow, the shape is resizeable.
 *
 * <pre>
 *    10px       grow         10px
 *
 *    -----+------------------+-----
 *    |    |  [LABEL]         |    |
 *    |    |                  |    |
 *    |    |                  |    |    grow
 *    |    |                  |    |
 *    |    |                  |    |
 *    -----+------------------+-----
 * </pre>
 *
 * The number forces the exact width or height of the cell. <b>grow</b> respect the minimum width of the
 * element and allows to resize the shape. The row/col with the <b>grow</b> declaration will be resized.
 * The <b>pref</b> declaration forces the cell to the minimum width/height of the embedded figure.
 *
 * Example Implementation of a shape:
 *
 * @example
 *    let PredefinedProcess = draw2d.shape.layout.FlexGridLayout.extend({
 *
 *
 *         //     10px       grow         10px
 *         //
 *         //    -----+------------------+-----
 *         //    |    |  [LABEL]         |    |
 *         //    |    |                  |    |
 *         //    |    |                  |    |    grow
 *         //    |    |                  |    |
 *         //    |    |                  |    |
 *         //    -----+------------------+-----
 *         //
 *         // @param attr
 *         //
 *        init: function(attr, setter, getter)
 *        {
 *           this._super(extend({
 *                columns:"10px, grow, 10px",
 *                rows:   "grow",
 *                bgColor:"#FFFFFF",
 *                stroke:2
 *            },attr),
 *           setter,
 *            getter);
 *
 *
 *            this.label = new draw2d.shape.basic.Label({text:"Process Name", resizeable:true, stroke:2});
 *            this.label.installEditor(new draw2d.ui.LabelInplaceEditor());
 *            this.add(this.label, {row:0, col:1});
 *
 *            this.setDimension(120,80);
 *        }
 *    });
 *    let shape = new PredefinedProcess();
 *    canvas.add(shape,10,10);
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.layout.Layout
 * @since 2.5.1
 */
_packages2.default.shape.layout.FlexGridLayout = _packages2.default.shape.layout.Layout.extend(
/** @lends draw2d.shape.layout.FlexGridLayout.prototype */
{

  NAME: "draw2d.shape.layout.FlexGridLayout",

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    var _this = this;
    this.cellLocator = {
      relocate: function relocate(index, figure) {
        if (_this.gridDef.layoutRequired === true) {
          _this._layout();
        }
        var cell = figure.__cellConstraint;
        var x = cell.x;
        var y = cell.y;

        // stretch the figure to fill the complete cell
        //
        if (figure.isResizeable()) {
          figure.setDimension(Math.max(figure.getMinWidth(), cell.width), Math.max(figure.getMinHeight(), cell.height));
        }
        // else apply the valign and align property
        //
        else {
            // apply vertical alignment
            //
            switch (cell.valign) {
              case "middle":
                y = y + (cell.height - figure.getHeight()) / 2;
                break;
              case "bottom":
                y = y + (cell.height - figure.getHeight());
                break;
            }

            // apply horizontal alignment
            //
            switch (cell.align) {
              case "center":
                x = x + (cell.width - figure.getWidth()) / 2;
                break;
              case "right":
                x = x + (cell.width - figure.getWidth());
                break;
            }
          }
        figure.setPosition(x, y);
      },
      bind: function bind() {},
      unbind: function unbind() {},
      translate: function translate(figure, diff) {
        figure.setPosition(figure.x + diff.x, figure.y + diff.y);
      }
    };

    this.debug = false;
    this.gridDef = {
      debugLines: [],
      def_cols: [],
      def_rows: [],
      min_height: [],
      min_width: [],
      minGridWidth: 10,
      minGridHeight: 10,
      hResizeable: false,
      vResizeable: false,
      layoutRequired: true
    };

    this._super((0, _extend2.default)({ stroke: 2 }, attr), (0, _extend2.default)({}, setter), (0, _extend2.default)({}, getter));

    this.resizeListener = function (figure) {
      _this.gridDef.layoutRequired = true;
      // propagate the event to the parent or other listener if existing
      //
      if (_this.getParent() instanceof _packages2.default.shape.layout.Layout) {
        _this.fireEvent("resize");
      }
      // or we are the parent and must consume it self
      else {
          _this.setDimension(_this.gridDef.hResizeable === true ? _this.getWidth() : 1, _this.gridDef.vResizeable === true ? _this.getHeight() : 1);
        }
    };

    var rows = attr.rows.split(",");
    var columns = attr.columns.split(",");
    for (var i = 0; i < columns.length; i++) {
      this.gridDef.def_cols[i] = this.cellWidthFromDef(columns[i]);
    }

    for (var _i = 0; _i < rows.length; _i++) {
      this.gridDef.def_rows[_i] = this.cellWidthFromDef(rows[_i]);
    }

    this.installEditPolicy(new _packages2.default.policy.figure.RectangleSelectionFeedbackPolicy());
  },

  add: function add(figure, cellConstraint) {

    figure.__cellConstraint = (0, _extend2.default)({}, {
      row: 0,
      col: 0,
      rowspan: 1,
      colspan: 1,
      align: "left",
      valign: "top",
      width: 1,
      height: 1
    }, cellConstraint);
    this.gridDef.layoutRequired = true;
    this._super(figure, this.cellLocator);
    this._layout();
  },

  /**
   * @inheritdoc
   */
  getMinWidth: function getMinWidth() {
    return this.gridDef.minGridWidth;
  },

  /**
   * @inheritdoc
   */
  getMinHeight: function getMinHeight() {
    return this.gridDef.minGridHeight;
  },

  /**
   * @inheritdoc
   */
  setCanvas: function setCanvas(canvas) {
    // layout must be recalculated if the shape will be assigned
    // to a canvas. "Text" elements can now calculate correct with the right font settings.
    //
    this.gridDef.layoutRequired = true;
    this._super(canvas);

    return this;
  },

  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return this;
    }
    this._super(attributes);
    if (this.debug) {
      this.paintDebugGrid();
    }

    return this;
  },

  setDimension: function setDimension(w, h) {
    // we need the calculated layout to determine the min width/height of the figure
    //
    if (this.gridDef.layoutRequired === true) {
      this._layout();
    }
    // set the new dimension
    this._super(w, h);

    // after setting the new dimension a recalculation of the layout is required. May the shape
    // has grown up
    this.gridDef.layoutRequired = true;
    this.repaint();

    return this;
  },

  _layout: function _layout() {
    this.gridDef.layoutRequired = false;

    var figures = this.getChildren();

    // copy the initial requested width/heights
    //
    this.gridDef.min_height = this.gridDef.def_rows.slice(0);
    this.gridDef.min_width = this.gridDef.def_cols.slice(0);

    // Calculate the basic width/height of the elements without considering the "span" and "grow"
    //
    for (var i = 0; i < figures.getSize(); i++) {
      var figure = figures.get(i);
      var cell = figure.__cellConstraint;
      // ermitteln der derzeitig zur verfgung stehenden weite
      this.gridDef.min_width[cell.col] = Math.max(this.gridDef.min_width[cell.col], figure.getMinWidth());

      // Falls das Elemente eine y_span hat, dann versuchen ob es auf die ganze
      // hhe rein passt. Wenn nicht wird der Teil der 'grow' angegeben hat verndert.
      // Wenn kein Element 'grow' angegeben hat, dann wird das letzte Element verndert
      if (cell.rowspan > 1) {
        var eHeight = figure.getMinHeight();
        var cHeight = this.cellHeight(cell.row, cell.row + cell.rowspan);
        if (cHeight < eHeight) {
          var diff = eHeight - cHeight;
          this.gridDef.min_height[cell.row + cell.rowspan - 1] = this.gridDef.min_height[cell.row + cell.rowspan - 1] + diff;
        }
      } else {
        this.gridDef.min_height[cell.row] = Math.max(this.gridDef.min_height[cell.row], figure.getMinHeight());
      }
    }
    this.gridDef.minGridWidth = this._getGridWidth();
    this.gridDef.minGridHeight = this._getGridHeight();

    // Resize the grid height if at least one row supports "grow"
    //
    var gridHeight = this._getGridHeight();
    for (var _i2 = 0; _i2 < this.gridDef.def_rows.length; _i2++) {
      // row found which can grow
      if (this.gridDef.def_rows[_i2] === -1) {
        this.gridDef.min_height[_i2] = this.gridDef.min_height[_i2] + Math.max(0, this.getHeight() - gridHeight);
        this.gridDef.vResizeable = true;
        break;
      }
    }

    // Resize the grid if at least one column supports "grow"
    //
    var gridWidth = this._getGridWidth();
    for (var _i3 = 0; _i3 < this.gridDef.def_cols.length; _i3++) {
      // column found which can grow
      if (this.gridDef.def_cols[_i3] === -1) {
        this.gridDef.min_width[_i3] = this.gridDef.min_width[_i3] + Math.max(0, this.getWidth() - gridWidth);
        this.gridDef.hResizeable = true;
        break;
      }
    }

    // apply the cell constraints to the elements
    //
    for (var _i4 = 0; _i4 < figures.getSize(); _i4++) {
      var _cell = figures.get(_i4).__cellConstraint;
      _cell.width = this.cellWidth(_cell.col, _cell.col + _cell.colspan);
      _cell.height = this.cellHeight(_cell.row, _cell.row + _cell.rowspan);
      _cell.x = this.cellX(_cell.col);
      _cell.y = this.cellY(_cell.row);
    }

    return this;
  },

  cellX: function cellX(col) {
    var r = 0;
    for (var i = 0; i < col; i++) {
      r = r + this.gridDef.min_width[i];
    }

    return r;
  },

  cellY: function cellY(row) {
    var r = 0;
    for (var i = 0; i < row; i++) {
      r = r + this.gridDef.min_height[i];
    }

    return r;
  },

  cellWidth: function cellWidth(from, to) {
    var r = 0;
    for (var i = from; i < to; i++) {
      r = r + this.gridDef.min_width[i];
    }

    return r;
  },

  cellHeight: function cellHeight(from, to) {
    var r = 0;
    for (var i = from; i < to; i++) {
      r = r + this.gridDef.min_height[i];
    }

    return r;
  },

  paintDebugGrid: function paintDebugGrid() {
    // alte Linien erstmal entfernen bevor man neue zeichnet
    //
    for (var i = 0; i < this.gridDef.debugLines.length; i++) {
      this.gridDef.debugLines[i].remove();
    }this.gridDef.debugLines = [];

    var gridHeight = this._getGridHeight();
    var gridWidth = this._getGridWidth();
    var posX = this.getAbsoluteX();
    var posY = this.getAbsoluteY();

    // draw the cols first
    var x = posX;
    for (var _i5 = 0; _i5 <= this.gridDef.min_width.length; _i5++) {
      var newLine = this.canvas.paper.path("M " + x + " " + posY + " l 0 " + gridHeight).attr({
        "stroke": "#FF0000",
        "stroke-width": 1
      });
      this.gridDef.debugLines.push(newLine);
      if (_i5 < this.gridDef.min_width.length) x = x + this.gridDef.min_width[_i5];
    }

    var y = posY;
    for (var _i6 = 0; _i6 <= this.gridDef.min_height.length; _i6++) {
      var _newLine = this.canvas.paper.path("M " + posX + " " + y + " l " + gridWidth + " 0").attr({
        "stroke": "#FF0000",
        "stroke-width": 1
      });
      this.gridDef.debugLines.push(_newLine);
      if (_i6 < this.gridDef.min_height.length) y = y + this.gridDef.min_height[_i6];
    }
  },

  _getGridWidth: function _getGridWidth() {
    var gridWidth = 0;
    for (var i = 0; i < this.gridDef.min_width.length; i++) {
      gridWidth = gridWidth + this.gridDef.min_width[i];
    }

    return gridWidth;
  },

  _getGridHeight: function _getGridHeight() {
    var gridHeight = 0;
    for (var i = 0; i < this.gridDef.min_height.length; i++) {
      gridHeight = gridHeight + this.gridDef.min_height[i];
    }

    return gridHeight;
  },

  cellWidthFromDef: function cellWidthFromDef(def) {
    var pattern = new RegExp("(\\d+)(?:px)?");
    var match = def.match(pattern);

    if (match != null) {
      return parseInt(match[1]);
    }

    pattern = new RegExp("p(?:ref)?");
    match = def.match(pattern);
    if (match != null) {
      return 0;
    }

    pattern = new RegExp("g(?:row)?");
    match = def.match(pattern);
    if (match != null) {
      this.autoResize = false;
      return -1;
    }

    return 0;
  }

});

/***/ }),

/***/ "./src/shape/layout/HorizontalLayout.js":
/*!**********************************************!*\
  !*** ./src/shape/layout/HorizontalLayout.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * The HorizontalLayout class arranges the layout elements in a horizontal sequence,
 * left to right, with optional gaps between the elements.
 *
 * During the execution of the setDimension() method, the minimum width of the container is calculated
 * by accumulating the minimum sizes of the elements, including stroke, gaps and padding.
 *
 *
 * See the example below with and without gap and border settings
 *
 *
 * @example
 *
 *    // first container without any gap and a border of the parent
 *    // container
 *    let label1 =  new draw2d.shape.basic.Label({text:"Label 1"});
 *    let label2 =  new draw2d.shape.basic.Label({text:"Label 2"});
 *    let label3 =  new draw2d.shape.basic.Label({text:"Label 3"});
 *
 *    let container1 = new draw2d.shape.layout.HorizontalLayout();
 *
 *    container1.add(label1);
 *    container1.add(label2);
 *    container1.add(label3);
 *    container1.setGap(10);
 *    container1.setStroke(2);
 *    canvas.add(container1,50,10);
 *
 *    // second container without any gab or border
 *    //
 *    let label11 =  new draw2d.shape.basic.Label({text:"Label 1"});
 *    let label12 =  new draw2d.shape.basic.Label({text:"Label 2"});
 *    let label13 =  new draw2d.shape.basic.Label({text:"Label 3"});
 *
 *    let container2 = new draw2d.shape.layout.HorizontalLayout();
 *
 *    container2.add(label11);
 *    container2.add(label12);
 *    container2.add(label13);
 *
 *    canvas.add(container2,50,90);
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.layout.Layout
 * @since 2.5.1
 */
_packages2.default.shape.layout.HorizontalLayout = _packages2.default.shape.layout.Layout.extend(
/** @lends draw2d.shape.layout.HorizontalLayout.prototype */
{

  NAME: "draw2d.shape.layout.HorizontalLayout",

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.gap = 0;
    var _this = this;
    this.locator = {
      translate: function translate(figure, diff) {
        figure.setPosition(figure.x + diff.x, figure.y + diff.y);
      },
      bind: function bind() {},
      unbind: function unbind() {},
      relocate: function relocate(index, target) {
        var stroke = _this.getStroke();
        var yPos = stroke + _this.padding.top;
        var xPos = stroke + _this.padding.left; // respect the border and padding of the parent
        for (var i = 0; i < index; i++) {
          var child = _this.children.get(i).figure;
          if (child.isVisible()) {
            xPos += child.getWidth() + _this.gap;
          }
        }

        target.setPosition(xPos, yPos);
      }
    };

    this._super((0, _extend2.default)({ width: 1, height: 1, gap: 0 }, attr), (0, _extend2.default)({
      // @attr {Number} gap the gap between the children shapes */
      gap: this.setGap
    }, setter), (0, _extend2.default)({
      gap: this.getGap
    }, getter));
  },

  /**
   * @inheritdoc
   */
  add: function add(child, locator, index) {
    this._super(child, this.locator, index);

    this.setDimension(1, 1);

    return this;
  },

  /**
   *
   * Set the gap width between child components within this layout.
   * This will only affect the space between components, not the space around all the components in the layout.
   *
   * @param {Number} gap The space, in pixels, between items.
   * @since 2.5.1
   */
  setGap: function setGap(gap) {
    this.gap = gap;
    // this forces a relayout of the element
    this.setDimension(1, 1);

    return this;
  },

  /**
   *
   * Return the gap between the children shapes
   *
   * @since 5.0.0
   *
   */
  getGap: function getGap() {
    return this.gap;
  },

  /**
   * @inheritdoc
   */
  getMinWidth: function getMinWidth() {
    var _this = this;
    var width = this.stroke * 2 + this.padding.left + this.padding.right;
    var gap = 0;

    this.children.each(function (i, e) {
      if (e.figure.isVisible()) {
        width += e.figure.isResizeable() ? e.figure.getMinWidth() : e.figure.getWidth() + gap;
        gap = _this.gap;
      }
    });

    return width;
  },

  /**
   * @inheritdoc
   */
  getMinHeight: function getMinHeight() {
    var markup = this.stroke * 2 + this.padding.top + this.padding.bottom;
    var height = 0;

    this.children.each(function (i, e) {
      height = Math.max(height, e.figure.isResizeable() ? e.figure.getMinHeight() : e.figure.getHeight());
    });

    return height + markup;
  },

  /**
   * @inheritdoc
   */
  setDimension: function setDimension(w, h) {
    this._super(w, h);

    var diff = this.width - this.getMinWidth();
    if (diff > 0) {
      diff = diff / this.children.getSize() | 0;
      this.children.each(function (i, e) {
        if (e.figure.isResizeable() === true) {
          e.figure.setDimension(e.figure.getMinWidth() + diff, e.figure.getHeight());
        }
      });
    } else {
      var minHeight = this.getMinHeight();
      this.children.each(function (i, e) {
        // The layout respect the "resizeable" flag because a layout is a kind of layouter and
        // any kind of autolayouter must respect this flag
        if (e.figure.isResizeable() === true) {
          // reset the shape to the minimum width/height. see setMinWidth/setMinHeight
          e.figure.setDimension(1, minHeight);
        }
      });
    }

    return this;
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.gap = this.gap;

    return memento;
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.gap === "number") {
      this.gap = memento.gap;
    }

    return this;
  }

});

/***/ }),

/***/ "./src/shape/layout/Layout.js":
/*!************************************!*\
  !*** ./src/shape/layout/Layout.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A base class for positioning child figures and determining the ideal size for
 * a figure with children.
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Rectangle
 */
_packages2.default.shape.layout.Layout = _packages2.default.shape.basic.Rectangle.extend(
/** @lends draw2d.shape.layout.Layout.prototype */
{

  NAME: "draw2d.shape.layout.Layout",

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    var _this = this;

    // @since 4.3.3
    this.padding = { top: 0, right: 0, bottom: 0, left: 0 };

    this._super((0, _extend2.default)({ bgColor: null, radius: 0, stroke: 0 }, attr), (0, _extend2.default)({
      // @attr {Number} padding the padding in pixel around the text */
      padding: this.setPadding
    }, setter), (0, _extend2.default)({
      padding: this.getPadding
    }, getter));

    this.resizeListener = function (figure) {
      // propagate the event to the parent or other listener if existing
      //
      if (_this.getParent() instanceof _packages2.default.shape.layout.Layout) {
        _this.fireEvent("resize");
      }
      // or we are the parent and must consume it self
      else {
          _this.setDimension(1, 1);
          _this.fireEvent("resize");
        }
    };

    this.installEditPolicy(new _packages2.default.policy.figure.AntSelectionFeedbackPolicy());
  },

  /**
   * @inheritdoc
   */
  add: function add(child, locator, index) {
    this._super(child, locator, index);

    child.on("resize", this.resizeListener);
    child.on("change:visibility", this.resizeListener);

    // don't use the getter/setter. This considers the canvas assignment and
    // the child is always invisible. BIG BUG. The example shape_db will break if you change this.
    //       child.setVisible(this.isVisible());
    // respect the "visible" flag of the child as well
    child.visible = child.visible && this.visible;

    return this;
  },

  /**
   * @inheritdoc
   */
  remove: function remove(child) {
    var r = this._super(child);
    child.off(this.resizeListener);
    this.setDimension(1, 1);

    return r;
  },

  /**
   * 
   * Set the padding of the element
   *
   *     // Alternatively you can use the attr method:
   *     //
   *     // set the padding for top,left,bottom,right in one call
   *     figure.attr({
   *       padding: 3
   *     });
   *
   *     // update the padding left and top
   *     figure.attr({
   *       padding: {left:3, top:30}
   *     });
   *
   * @param {Number|Object} padding The new padding
   * @since 4.3.3
   **/
  setPadding: function setPadding(padding) {
    if (typeof padding === "number") {
      this.padding = { top: padding, right: padding, bottom: padding, left: padding };
    } else {
      this.padding = (0, _extend2.default)(this.padding, padding);
    }
    this.fireEvent("change:padding", { value: this.padding });

    // force a relayout of the figure
    this.setDimension(1, 1);

    return this;
  },

  /**
   * 
   * Get the padding of the element.
   *
   * @since 4.3.3
   * @returns {this}
   **/
  getPadding: function getPadding() {
    return this.padding;
  },

  /**
   * @inheritdoc
   * @returns {this}
   */
  setVisible: function setVisible(flag) {
    // propagate the visibility to all children too.
    //
    this.children.each(function (i, e) {
      e.figure.setVisible(flag);
    });

    this._super(flag);

    // force a relayout of the shape because the dimension has been changed
    // by enable/disable of child shapes
    this.setDimension(1, 1);

    return this;
  },

  /**
   * 
   * Returns the Command to perform the specified Request or null.
   *
   * @param {draw2d.command.CommandType} request describes the Command being requested
   * @returns {draw2d.command.Command} null or a Command
   * @private
   **/
  createCommand: function createCommand(request) {
    // it is not possible to rate a layout object
    // ..at the moment
    if (request.getPolicy() === _packages2.default.command.CommandType.ROTATE) {
      return null;
    }

    return this._super(request);
  }
});

/***/ }),

/***/ "./src/shape/layout/StackLayout.js":
/*!*****************************************!*\
  !*** ./src/shape/layout/StackLayout.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Using the StackLayout as their layout shape have their children placed on top of one another.
 * Order of placement is determined by the order in which the children were added, first child
 * added placed on the bottom. Only one child is visible at once.
 *
 * @author Andreas Herz
 * @extends draw2d.shape.layout.Layout
 */
_packages2.default.shape.layout.StackLayout = _packages2.default.shape.layout.Layout.extend(
/** @lends draw2d.shape.layout.StackLayout.prototype */
{

  NAME: "draw2d.shape.layout.StackLayout",

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.visibleLayer = 0;
    this.locator = new _packages2.default.layout.locator.XYAbsPortLocator(0, 0);

    this._super((0, _extend2.default)({ resizeable: true, width: 10, height: 10 }, attr), (0, _extend2.default)({}, setter), (0, _extend2.default)({}, getter));

    this.resizeListener = function (figure) {};
    // install default selection handler. Can be overridden or replaced
    this.installEditPolicy(new _packages2.default.policy.figure.RectangleSelectionFeedbackPolicy());
  },

  /**
   *
   * Set the current visible layer of the stack layout
   *
   * @param {Number} visibleLayer
   */
  setVisibleLayer: function setVisibleLayer(visibleLayer, duration) {
    this.getChildren().get(this.visibleLayer).setVisible(false, duration);
    this.visibleLayer = Math.min(this.getChildren().getSize() - 1, Math.max(0, visibleLayer));

    this.getChildren().get(this.visibleLayer).setVisible(true, duration);
    return this;
  },

  /**
   *
   * Returns the current visible layer
   *
   * @returns {Number}
   */
  getVisibleLayer: function getVisibleLayer() {
    return this.visibleLayer;
  },

  /**
   * @inheritdoc
   */
  add: function add(child, locator, index) {
    // the child didn'T care about events...at the moment
    //
    child.hitTest = function () {
      return false;
    };

    // make all existing shapes invisible
    //
    this.getChildren().each(function (i, c) {
      c.setVisible(false);
    });
    this.visibleLayer = this.getChildren().getSize();

    // ignore the parameter "locator" and use the locator for the stack layout instead
    return this._super(child, this.locator, index);
  },

  /**
   * @inheritdoc
   */
  setVisible: function setVisible(flag) {
    _packages2.default.shape.basic.Rectangle.prototype.setVisible.call(this, flag);

    return this;
  },

  /**
   * @inheritdoc
   */
  getMinWidth: function getMinWidth() {
    var markup = this.stroke * 2 + this.padding.left + this.padding.right;
    var width = 10;
    this.children.each(function (i, e) {
      width = Math.max(width, e.figure.isResizeable() ? e.figure.getMinWidth() : e.figure.getWidth());
    });
    return width + markup;
  },

  /**
   * @inheritdoc
   */
  getMinHeight: function getMinHeight() {
    var markup = this.stroke * 2 + this.padding.top + this.padding.bottom;
    var height = 10;
    this.children.each(function (i, e) {
      height = Math.max(height, e.figure.isResizeable() ? e.figure.getMinHeight() : e.figure.getHeight());
    });
    return height + markup;
  },

  /**
   * @inheritdoc
   */
  setDimension: function setDimension(w, h) {
    this._super(w, h);

    var width = this.width - this.padding.left - this.padding.right;
    var height = this.height - this.padding.top - this.padding.bottom;
    if (width === this._recursiveWidth && height === this._recursiveHeight) {
      return this;
    }
    this._recursiveHeight = height;
    this._recursiveWidth = width;

    this.children.each(function (i, e) {
      if (e.figure.isResizeable()) {
        e.figure.setDimension(width, height);
      }
    });

    delete this._recursiveHeight;
    delete this._recursiveWidth;

    return this;
  }

});

/***/ }),

/***/ "./src/shape/layout/TableLayout.js":
/*!*****************************************!*\
  !*** ./src/shape/layout/TableLayout.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * The TableLayout class arranges the children in a row/column order. Each cell can be styled
 * with valign, align and padding.
 *
 *
 * See the example below with and without padding or alignment settings
 *
 *
 * @example
 *
 *        let label1 =  new draw2d.shape.basic.Label({text:"[0,1] with long long long long label", fontColor:"#00AF00"});
 *        let label2 =  new draw2d.shape.basic.Label({text:"[1,1] padding:10", fontColor:"#00AF00"});
 *        let label3 =  new draw2d.shape.basic.Label({text:"[2,1] align:right", fontColor:"#00AF00"});
 *        let label4 =  new draw2d.shape.basic.Label({text:"[3,1] resize:true",resizeable:true, fontColor:"#00AF00"});
 *
 *        let container = new draw2d.shape.layout.TableLayout();
 *
 *        container.addRow("[0,0]", label1 ,"[0,2] align:center");
 *        container.addRow("[1,0] valign:bottom", label2,"[1,2] long long long label");
 *        container.addRow("[2,0]", label3,"[2,2]");
 *        container.addRow("[3,0]", label4,"[3,2]");
 *
 *        container.setPadding(0);
 *        container.setCellPadding(1,1, 10);
 *
 *        container.setCellAlign(0,2, "center");
 *        container.setCellAlign(2,1, "right");
 *
 *        container.setCellVerticalAlign(1, 0, "bottom");
 *        canvas.add(container,10,10);
 *
 *
 * @author Andreas Herz
 * @extends draw2d.shape.layout.Layout
 * @since 5.3.0
 */
_packages2.default.shape.layout.TableLayout = _packages2.default.shape.layout.Layout.extend(
/** @lends draw2d.shape.layout.TableLayout.prototype */
{

  NAME: "draw2d.shape.layout.TableLayout",

  DUMMY_CELL: {
    getMinHeight: function getMinHeight() {
      return 1;
    },
    getMinWidth: function getMinWidth() {
      return 1;
    },
    off: function off() {}
  },
  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    var _this = this;
    this.cellLocator = {
      relocate: function relocate(index, figure) {
        if (_this.repaintBlocked === true) {
          return;
        }
        var cell = figure.__cell;
        var layout = _this.getCellLayout(cell.row, cell.column);
        var outerWidth = _this.getWidth();
        var minWidth = _this.getMinWidth();
        var widthOffset = 0;
        if (outerWidth != minWidth) {
          widthOffset = (outerWidth - minWidth) / _this.layoutInfos[0].length * cell.column;
        }

        var width = figure.getWidth();
        var height = figure.getHeight();
        var x = layout.x + _this.padding.left + layout.padding.left + widthOffset;
        var y = layout.y + _this.padding.top + layout.padding.top;

        // stretch the figure to fill the complete cell
        //
        if (figure.isResizeable()) {
          var w = Math.max(figure.getMinWidth(), layout.w - (layout.padding.left + layout.padding.right) + widthOffset);
          var h = Math.max(figure.getMinHeight(), layout.h - (layout.padding.top + layout.padding.bottom));
          figure.setDimension(w, h);
        }
        // else apply the valign and align property
        //
        else {
            // apply vertical alignment
            //
            switch (layout.valign) {
              case "middle":
                y = y + (layout.h - (height + layout.padding.top + layout.padding.bottom)) / 2;
                break;
              case "bottom":
                y = y + (layout.h - (height + layout.padding.top + layout.padding.bottom));
                break;
            }

            // apply horizontal alignment
            //
            switch (layout.align) {
              case "center":
                x = x + (layout.w - (width + layout.padding.left + layout.padding.right)) / 2 + widthOffset / 2;
                break;
              case "right":
                x = x + (layout.w - (width + layout.padding.left + layout.padding.right)) + widthOffset;
                break;
            }
          }
        figure.setPosition(x, y);
      },
      bind: function bind() {},
      unbind: function unbind() {},
      translate: function translate(figure, diff) {
        figure.setPosition(figure.x + diff.x, figure.y + diff.y);
      }
    };

    this.padding = { top: 4, right: 4, bottom: 4, left: 4 };

    this.grid = [];
    this.layoutInfos = [];
    this.layoutInfos[0] = [];
    this.layoutInfos[0][0] = { x: 0, y: 0, w: 1, h: 1, valign: "top", align: "left" };

    this._super(extend({ stroke: 1, resizeable: false }, attr), extend({
      // @attr {Number} padding the padding in pixel around the text */
      padding: this.setPadding
    }, setter), extend({
      padding: this.getPadding
    }, getter));
  },

  /**
   * 
   * Set the padding of the given cell.
   *
   *
   * @param {Number|Object} padding The new padding
   **/
  setCellPadding: function setCellPadding(row, column, padding) {
    var layout = this.getCellLayout(row, column);
    if (layout === null) {
      return this;
    }

    if (typeof padding === "number") {
      layout.padding = { top: padding, right: padding, bottom: padding, left: padding };
    } else {
      extend(layout.padding, padding);
    }

    this.calculateLayout();
    this.setDimension(1, 1);

    return this;
  },

  /**
   * 
   * Get the padding of the outer grid.
   *
   **/
  getCellPadding: function getCellPadding(row, column) {

    var layout = this.getCellLayout(row, column);
    if (layout === null || typeof layout.padding === "undefined") {
      return { top: 0, right: 0, bottom: 0, left: 0 };
    }
    return layout.padding;
  },

  /**
   * 
   * Set the padding of the outer grid.
   *
   *     // Alternatively you can use the attr method:
   *     //
   *     // set the padding for top,left,bottom,right in one call
   *     figure.attr({
   *       padding: 3
   *     });
   *
   *     // update the padding left and top
   *     figure.attr({
   *       padding: {left:3, top:30}
   *     });
   *
   * @param {Number|Object} padding The new padding
   **/
  setPadding: function setPadding(padding) {
    if (typeof padding === "number") {
      this.padding = { top: padding, right: padding, bottom: padding, left: padding };
    } else {
      this.padding = extend(this.padding, padding);
    }
    this.calculateLayout();
    this.setDimension(1, 1);
    this.fireEvent("change:padding", { value: this.padding });

    return this;
  },

  /**
   * 
   * Get the padding of the outer grid.
   *
   **/
  getPadding: function getPadding() {
    return this.padding;
  },

  setCanvas: function setCanvas(canvas) {
    this._super(canvas);
    this.calculateLayout();
    this.setDimension(2, 2);

    return this;
  },

  /**
   * @inheritdoc
   */
  add: function add(child, locator, index) {
    this._super(child, locator, index);

    this.setDimension(1, 1);

    return this;
  },

  /**
   *
   * 
   * Removes the row from the TableLayout
   *
   * @returns the removed row
   */
  removeRow: function removeRow(index) {
    var _this = this;
    var removedRow = this.grid.splice(index, 1);
    removedRow[0].forEach(function (figure) {
      _this.remove(figure);
    });

    this.calculateLayout();
    this.setDimension(2, 2);

    return removedRow;
  },

  /**
   * 
   * Add a row to the table grid.
   * This method has a variable argument list. All arguments are added in one row.
   *
   * @param {Array} figures variable count of figures to add as one row
   */
  addRow: function addRow() {
    var figuresToAdd = [];
    var _this = this;
    var args = Array.prototype.slice.call(arguments); // sometimes js is stupid...

    var rowCount = this.grid.length + 1;
    var columnCount = this.grid.length > 0 ? Math.max(this.grid[0].length, args.length) : args.length;

    var row = [];

    args.forEach(function (figure, index) {
      if (typeof figure === "string") {
        figure = new _packages2.default.shape.basic.Label({ text: figure });
      }
      row.push(figure);
      figuresToAdd.push(figure);
    });
    this.grid.push(row);

    // adjust the columns. All rows must have the same column count. Add empty cells
    // if required.
    //
    this.grid.forEach(function (row, index) {
      var missingColumns = columnCount - row.length;
      for (var i = 0; i < missingColumns; i++) {
        row.push(_this.DUMMY_CELL);
      }
    });

    var orig = this.repaintBlocked;
    this.repaintBlocked = true;
    figuresToAdd.forEach(function (figure) {
      _this.add(figure, _this.cellLocator);
    });
    this.repaintBlocked = orig;

    this.calculateLayout();
    this.setDimension(1, 1);

    return this;
  },

  getMinWidth: function getMinWidth() {
    // return some good default if we are not part of the canvas.
    // A real width/height calculation isn'T possible if the canvas not set
    if (this.canvas === null || this.layoutInfos.length === 0) {
      return 10;
    }

    var bottom = this.layoutInfos[this.layoutInfos.length - 1];
    var layout = bottom[bottom.length - 1];

    return layout.w + layout.x + this.padding.left + this.padding.right;
  },

  getMinHeight: function getMinHeight() {
    // return some good default if we are not part of the canvas.
    // A real width/height calculation isn'T possible if the canvas not set
    if (this.canvas === null || this.layoutInfos.length === 0) {
      return 10;
    }

    var bottom = this.layoutInfos[this.layoutInfos.length - 1];
    var layout = bottom[bottom.length - 1];

    return layout.h + layout.y + this.padding.top + this.padding.bottom;
  },

  /**
   * 
   * Set the vertical alignment of a cell. Possible values are
   * <ul>
   * <li>top</li>
   * <li>middle</li>
   * <li>bottom</li>
   * </ul>
   *
   * @param {Number} row  The row index of the cell. Starting by 0
   * @param {Number} column The column index of the cell. Starting by 0
   * @param {String} align The vertical alignment of the cell
   */
  setCellVerticalAlign: function setCellVerticalAlign(row, column, valign) {
    var layout = this.getCellLayout(row, column);
    if (layout === null) {
      return; // silently
    }

    switch (valign) {
      case "top":
      case "middle":
      case "bottom":
        layout.valign = valign;
        this.calculateLayout();
        this.setDimension(1, 1);
    }

    return this;
  },

  /**
   * 
   * Get the vertical alignment of a cell. Possible values are
   * <ul>
   * <li>top</li>
   * <li>middle</li>
   * <li>bottom</li>
   * </ul>
   *
   * @param {Number} row  The row index of the cell. Starting by 0
   * @param {Number} column The column index of the cell. Starting by 0
   * @returns {String} The vertical alignment of the cell
   */
  getCellVerticalAlign: function getCellVerticalAlign(row, column) {
    var layout = this.getCellLayout(row, column);
    if (layout === null) {
      return "top";
    }

    return layout.valign;
  },

  /**
   * 
   * Set the alignment of a cell. Possible values are
   * <ul>
   * <li>left</li>
   * <li>center</li>
   * <li>right</li>
   * </ul>
   *
   *
   * @param {Number} row  The row index of the cell. Starting by 0
   * @param {Number} column The column index of the cell. Starting by 0
   * @param {String} align The horizontal alignment of the cell
   */
  setCellAlign: function setCellAlign(row, column, align) {

    var layout = this.getCellLayout(row, column);
    if (layout === null) {
      return; // silently
    }

    switch (align) {
      case "left":
      case "center":
      case "right":
        layout.align = align;
        this.calculateLayout();
        this.setDimension(1, 1);
    }

    return this;
  },

  /**
   * 
   * Return the alignment of a cell. Possible values are
   * <ul>
   * <li>left</li>
   * <li>center</li>
   * <li>right</li>
   * </ul>
   *
   *
   * @param {Number} row  The row index of the cell. Starting by 0
   * @param {Number} column The column index of the cell. Starting by 0
   * return {String} The horizontal alignment of the cell
   */
  getCellAlign: function getCellAlign(row, column) {

    var layout = this.getCellLayout(row, column);
    if (layout === null) {
      return "left";
    }
    return layout.align;
  },

  /**
   * 
   * Return the layout information for the given row/column or <b>null</b>
   * if the row/column index is out of range.
   *
   * @private
   */
  getCellLayout: function getCellLayout(row, column) {
    if (row < 0 || column < 0) {
      return null; // silently
    }

    if (row >= this.layoutInfos.length) {
      return null; // silently
    }

    var layouts = this.layoutInfos[row];
    if (column >= layouts.length) {
      return null; // silently
    }

    return layouts[column];
  },

  /**
   * 
   * Recalculate the layout of the table
   *
   * @private
   */
  calculateLayout: function calculateLayout() {
    var _this = this;
    var rowCount = this.grid.length;
    var columnCount = this.grid.length > 0 ? this.grid[0].length : 0;

    var newLayoutInfos = [];
    for (var row = 0; row < rowCount; row++) {
      newLayoutInfos[row] = [];
      for (var column = 0; column < columnCount; column++) {
        newLayoutInfos[row][column] = {
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          valign: this.getCellVerticalAlign(row, column),
          align: this.getCellAlign(row, column),
          padding: this.getCellPadding(row, column)
        };
      }
    }

    // determine the heights/widths of the grid
    //
    var layoutWidths = new Array(columnCount + 1).join('0').split('').map(parseFloat);
    var layoutHeights = new Array(rowCount + 1).join('0').split('').map(parseFloat);
    this.grid.forEach(function (figures, row) {
      for (var _column = 0; _column < columnCount; _column++) {
        var layout = newLayoutInfos[row][_column];
        var figure = figures[_column];
        figure.__cell = { row: row, column: _column };
        layoutHeights[row] = Math.max(layoutHeights[row], figure.getMinHeight() + layout.padding.top + layout.padding.bottom);
        layoutWidths[_column] = Math.max(layoutWidths[_column], figure.getMinWidth() + layout.padding.left + layout.padding.right);
      }
    });

    var x = 0,
        y = 0;
    for (var _row = 0; _row < rowCount; _row++) {
      for (var _column2 = 0; _column2 < columnCount; _column2++) {
        var layout = newLayoutInfos[_row][_column2];
        layout.w = layoutWidths[_column2];
        layout.h = layoutHeights[_row];
        layout.x = x;
        layout.y = y;
        x = x + layout.w;
      }
      y = y + layoutHeights[_row];
      x = 0;
    }

    this.layoutInfos = newLayoutInfos;

    return this;
  }
});

/***/ }),

/***/ "./src/shape/layout/VerticalLayout.js":
/*!********************************************!*\
  !*** ./src/shape/layout/VerticalLayout.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * The VerticalLayout class arranges the layout elements in a vertical sequence,
 * left to right, with optional gaps between the elements.
 *
 * During the execution of the setDimension() method, the minimum height of the container is calculated
 * by accumulating the minimum sizes of the elements, including stroke, gaps and padding.
 *
 * See the example below with and without gap and border settings
 *
 *
 * @example
 *
 *    // first container without any gap and a border of the parent
 *    // container
 *    let label1 =  new draw2d.shape.basic.Label({text:"Label 1"});
 *    let label2 =  new draw2d.shape.basic.Label({text:"Label 2"});
 *    let label3 =  new draw2d.shape.basic.Label({text:"Label 3"});
 *
 *    let container1 = new draw2d.shape.layout.VerticalLayout();
 *
 *    container1.add(label1);
 *    container1.add(label2);
 *    container1.add(label3);
 *    container1.setGap(10);
 *    container1.setStroke(2);
 *    canvas.add(container1,50,10);
 *
 *    // second container without any gab or border
 *    //
 *    let label11 =  new draw2d.shape.basic.Label({text:"Label 1"});
 *    let label12 =  new draw2d.shape.basic.Label({text:"Label 2"});
 *    let label13 =  new draw2d.shape.basic.Label({text:"Label 3"});
 *
 *    let container2 = new draw2d.shape.layout.VerticalLayout();
 *
 *    container2.add(label11);
 *    container2.add(label12);
 *    container2.add(label13);
 *
 *    canvas.add(container2,150,10);
 *
 * @author Andreas Herz
 * @extends draw2d.shape.layout.Layout
 */
_packages2.default.shape.layout.VerticalLayout = _packages2.default.shape.layout.Layout.extend(
/** @lends draw2d.shape.layout.VerticalLayout.prototype */
{

  NAME: "draw2d.shape.layout.VerticalLayout",

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    // some layout parameter
    //
    this.gap = 0;

    // "this" shortcut to avoid $.proxy
    var _this = this;

    this.locator = {
      translate: function translate(figure, diff) {
        figure.setPosition(figure.x + diff.x, figure.y + diff.y);
      },
      bind: function bind() {},
      unbind: function unbind() {},
      relocate: function relocate(index, target) {
        var stroke = _this.getStroke();
        var yPos = stroke + _this.padding.top; // respect the border and padding of the shape
        var xPos = _this.padding.left;

        for (var i = 0; i < index; i++) {
          var child = _this.children.get(i).figure;
          if (child.isVisible()) {
            yPos += child.getHeight() + _this.gap;
          }
        }

        target.setPosition(xPos, yPos);
      }
    };

    this._super(extend({ width: 10, height: 10 }, attr), extend({
      // @attr {Number} gap the gap between the children shapes */
      gap: this.setGap
    }, setter), extend({
      gap: this.getGap
    }, getter));
  },

  /**
   * @inheritdoc
   */
  add: function add(child, locator, index) {
    this._super(child, this.locator, index);

    this.setDimension(1, 1);

    return this;
  },

  /**
   * 
   * Set the gap width between child components within this layout.
   * This will only affect the space between components, not the space around all the components in the layout.
   *
   * @param {Number} gap The space, in pixels, between items.
   */
  setGap: function setGap(gap) {
    this.gap = gap;
    // this forces a relayout of the element
    this.setDimension(1, 1);
  },

  /**
   * @inheritdoc
   */
  getMinWidth: function getMinWidth() {
    var markup = this.stroke * 2 + this.padding.left + this.padding.right;
    var width = 10;
    this.children.each(function (i, e) {
      if (e.figure.isVisible()) width = Math.max(width, e.figure.isResizeable() ? e.figure.getMinWidth() : e.figure.getWidth());
    });
    return width + markup;
  },

  /**
   * @inheritdoc
   */
  getMinHeight: function getMinHeight() {
    var _this = this;
    var gap = 0;
    var markup = this.stroke * 2 + this.padding.top + this.padding.bottom;
    var height = 0;

    this.children.each(function (i, e) {
      if (e.figure.isVisible()) {
        height += (e.figure.isResizeable() ? e.figure.getMinHeight() : e.figure.getHeight()) + gap;
        // first element is iterated. Now we must add the gap to all next elements
        gap = _this.gap;
      }
    });

    return height + markup;
  },

  /**
   * @inheritdoc
   */
  setDimension: function setDimension(w, h) {
    this._super(w, h);

    var width = this.width - this.padding.left - this.padding.right;
    if (width === this._recursiveWidth) {
      return this;
    }
    this._recursiveWidth = width;

    this.children.each(function (i, e) {
      if (e.figure.isResizeable() && e.figure.isVisible()) {
        e.figure.setDimension(width, e.figure.getMinHeight());
      }
    });

    delete this._recursiveWidth;

    return this;
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.gap = this.gap;

    return memento;
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.gap === "number") {
      this.gap = memento.gap;
    }

    return this;
  }

});

/***/ }),

/***/ "./src/shape/node/Between.js":
/*!***********************************!*\
  !*** ./src/shape/node/Between.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A simple Node which has a  InputPort and OutputPort. Mainly used for demo and examples.
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.node.Between({color: "#3d3d3d"});
 *
 *    canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.basic.Rectangle
 */
_packages2.default.shape.node.Between = _packages2.default.shape.basic.Rectangle.extend(
/** @lends draw2d.shape.node.Between.prototype */
{

  NAME: "draw2d.shape.node.Between",

  DEFAULT_COLOR: new _packages2.default.util.Color("#4D90FE"),

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({
      bgColor: this.DEFAULT_COLOR,
      color: this.DEFAULT_COLOR.darker(),
      width: 50,
      height: 50
    }, attr), setter, getter);

    this.createPort("output");
    this.createPort("input");
  }
});

/***/ }),

/***/ "./src/shape/node/End.js":
/*!*******************************!*\
  !*** ./src/shape/node/End.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * A simple Node which has a InputPort. Mainly used for demo and examples.
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.node.End({color: "#3d3d3d"});
 *
 *    canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.basic.Rectangle
 */
_packages2.default.shape.node.End = _packages2.default.shape.basic.Rectangle.extend(
/** @lends draw2d.shape.node.End.prototype */
{

  NAME: "draw2d.shape.node.End",

  DEFAULT_COLOR: new _packages2.default.util.Color("#4D90FE"),

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({
      bgColor: this.DEFAULT_COLOR,
      color: this.DEFAULT_COLOR.darker(),
      width: 50,
      height: 50
    }, attr), setter, getter);

    this.createPort("input");
  }

});

/***/ }),

/***/ "./src/shape/node/Fulcrum.js":
/*!***********************************!*\
  !*** ./src/shape/node/Fulcrum.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _JSONUtil = __webpack_require__(/*! ../../util/JSONUtil */ "./src/util/JSONUtil.js");

var _JSONUtil2 = _interopRequireDefault(_JSONUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A horizontal bus shape with a special kind of port handling. The hole figure is a hybrid port.
 *
 *
 * @example
 *
 *    canvas.add( new draw2d.shape.node.Fulcrum(),50,10);
 *    canvas.add( new draw2d.shape.node.Fulcrum(),80,100);
 *    canvas.add( new draw2d.shape.node.Fulcrum(),150,50);
 *
 * @extends draw2d.shape.node.Hub
 */
_packages2.default.shape.node.Fulcrum = _packages2.default.shape.node.Hub.extend(
/** @lends draw2d.shape.node.Fulcrum.prototype */
{

  NAME: "draw2d.shape.node.Fulcrum",

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({ width: 40, height: 40 }, attr), setter, getter);

    this.port.setConnectionAnchor(new _packages2.default.layout.anchor.ConnectionAnchor(this.port));
    this.port.setVisible(true);
    this.port.hitTest = this.port._orig_hitTest;

    this.setConnectionDirStrategy(0);
    this.setColor(null);
    this.setRadius(10);
    this.setBackgroundColor(null);
    this.setStroke(0);
    this.installEditPolicy(new _packages2.default.policy.figure.AntSelectionFeedbackPolicy());
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return this;
    }

    attributes = attributes || {};

    // set some good defaults if the parent didn't
    _JSONUtil2.default.ensureDefault(attributes, "fill", this.bgColor.rgba());

    return this._super(attributes);
  }

});

/***/ }),

/***/ "./src/shape/node/HorizontalBus.js":
/*!*****************************************!*\
  !*** ./src/shape/node/HorizontalBus.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A horizontal bus shape with a special kind of port handling. The hole figure is a hybrid port.
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.node.HorizontalBus({width:300, height:20, text:"Horizontal Bus"});
 *
 *    canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.node.Hub
 */
_packages2.default.shape.node.HorizontalBus = _packages2.default.shape.node.Hub.extend(
/** @lends draw2d.shape.node.HorizontalBus.prototype */
{

  NAME: "draw2d.shape.node.HorizontalBus",

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.setConnectionDirStrategy(1);

    this.installEditPolicy(new _packages2.default.policy.figure.HBusSelectionFeedbackPolicy());
  }

});

/***/ }),

/***/ "./src/shape/node/Hub.js":
/*!*******************************!*\
  !*** ./src/shape/node/Hub.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _Color = __webpack_require__(/*! ../../util/Color */ "./src/util/Color.js");

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A hub is a shape with a special kind of port handling. The hole figure is a hybrid port. You can drag&drop a Port directly on
 * the figure.
 *
 *
 * @example
 *
 *
 *    canvas.add(new draw2d.shape.node.Start({x:50, y:50}));
 *    canvas.add(new draw2d.shape.node.Hub({x:150, y:50}));
 *
 * @extends draw2d.shape.basic.Rectangle
 */
_packages2.default.shape.node.Hub = _packages2.default.shape.basic.Rectangle.extend(
/** @lends draw2d.shape.node.Hub.prototype */
{

  NAME: "draw2d.shape.node.Hub",

  DEFAULT_COLOR: new _Color2.default("#4DF0FE"),
  BACKGROUND_COLOR: new _Color2.default("#29AA77"),

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.label = null;

    this._super(extend({ color: this.DEFAULT_COLOR.darker(), bgColor: this.BACKGROUND_COLOR }, attr), extend({
      // deprecated
      label: this.setLabel,
      // @attr {String} text the text to display in the center of the hub */
      text: this.setLabel
    }, setter), extend({
      label: this.getLabel,
      text: this.getLabel
    }, getter));

    var _port = this.port = this.createPort("hybrid", new _packages2.default.layout.locator.CenterLocator());

    var r = _packages2.default.geo.Rectangle;
    this.CONNECTION_DIR_STRATEGY = [function (peerPort) {
      return _port.getParent().getBoundingBox().getDirection(peerPort.getAbsolutePosition());
    }, function (peerPort) {
      return _port.getAbsoluteY() > peerPort.getAbsoluteY() ? r.DIRECTION_UP : r.DIRECTION_DOWN;
    }, function (peerPort) {
      return _port.getAbsoluteX() > peerPort.getAbsoluteX() ? r.DIRECTION_LEFT : r.DIRECTION_RIGHT;
    }];

    // redirect the glow effect and the hitTest for the port to the parent node
    //
    this.port.setGlow = this.setGlow.bind(this);
    this.port._orig_hitTest = this.port.hitTest;
    this.port.hitTest = this.hitTest.bind(this);

    // provide a special connection anchor for this port. We use the bounding box of the
    // parent as connection border
    //
    this.port.setConnectionAnchor(new _packages2.default.layout.anchor.ShortesPathConnectionAnchor(this.port));
    this.port.setVisible(false);
    this.port.setVisible = function () {};

    this.setConnectionDirStrategy(0);
  },

  /**
   * 
   * Called by the framework during drag&drop operations if the user drag a figure over this figure
   *
   * @param {draw2d.Figure} draggedFigure The figure which is currently dragging
   *
   * @returns {draw2d.Figure} the figure which should receive the drop event or null if the element didn't want a drop event
   **/
  delegateTarget: function delegateTarget(draggedFigure) {
    // redirect the dragEnter handling to the hybrid port
    //
    return this.getHybridPort(0).delegateTarget(draggedFigure);
  },

  /**
   * 
   * This value is relevant for the interactive resize of the figure.
   *
   * @returns {Number} Returns the min. width of this object.
   */
  getMinWidth: function getMinWidth() {
    if (this.label !== null) {
      return Math.max(this.label.getMinWidth(), this._super());
    }
    return this._super();
  },

  /**
   * @inheritdoc
   *
   * @private
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    // set some good defaults if the parent didn't
    if (typeof attributes.fill === "undefined") {
      if (this.bgColor !== null) {
        attributes.fill = "90-" + this.bgColor.hash() + ":5-" + this.bgColor.lighter(0.3).hash() + ":95";
      } else {
        attributes.fill = "none";
      }
    }

    this._super(attributes);
  },

  /**
   * 
   * Set the label for the Hub
   *
   *     // Alternatively you can use the attr method:
   *     figure.attr({
   *       text: label
   *     });
   *
   *
   * @param {String} label
   * @since 3.0.4
   */
  setLabel: function setLabel(label) {
    // Create any Draw2D figure as decoration for the connection
    //
    if (this.label === null) {
      var _this = this;

      this.label = new _packages2.default.shape.basic.Label({ text: label, color: "#0d0d0d", fontColor: "#0d0d0d", stroke: 0 });
      // add the new decoration to the connection with a position locator.
      //
      this.add(this.label, new _packages2.default.layout.locator.CenterLocator());
      this.label.setSelectionAdapter(function () {
        return _this;
      });
      this.label.delegateTarget = function () {
        return _this.port;
      };
    } else {
      this.label.setText(label);
    }
  },

  /**
   * 
   * Set the strategy for the connection direction calculation.<br>
   * <br>
   *
   * <ul>
   * <li>0 - Use the best/shortest direction (UP/RIGHT/DOWN/LEFT) for the connection routing (default)</li>
   * <li>1 - Use UP/DOWN for the connection direction</li>
   * <li>2 - Use LEFT/RIGHT</li>
   * </ul>
   * @param {Number} strategy the connection routing strategy to use
   * @since 2.4.3
   */
  setConnectionDirStrategy: function setConnectionDirStrategy(strategy) {
    switch (strategy) {
      case 0:
      case 1:
      case 2:
        this.port.getConnectionDirection = this.CONNECTION_DIR_STRATEGY[strategy];
        break;
    }
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    memento.dirStrategy = this.CONNECTION_DIR_STRATEGY.indexOf(this.port.getConnectionDirection);
    if (this.label !== null) {
      memento.label = this.label.getText();
    }

    return memento;
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.dirStrategy === "number") {
      this.setConnectionDirStrategy(memento.dirStrategy);
    }

    if (typeof memento.label !== "undefined") {
      this.setLabel(memento.label);
    }
  }

});

/***/ }),

/***/ "./src/shape/node/Node.js":
/*!********************************!*\
  !*** ./src/shape/node/Node.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _extend = __webpack_require__(/*! ../../util/extend */ "./src/util/extend.js");

var _extend2 = _interopRequireDefault(_extend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A Node is the base class for all figures which can have {@link draw2d.Port}s. A {@link draw2d.Port} is the
 * anchor for a {@link draw2d.Connection} line.<br><br>A {@link draw2d.Port} is a green dot which can
 * be dragged and dropped over another port.<br>
 * @inheritable
 * @author Andreas Herz
 * @extends draw2d.Figure
 */
_packages2.default.shape.node.Node = _packages2.default.Figure.extend(
/** @lends draw2d.shape.node.Node.prototype */
{

  NAME: "draw2d.shape.node.Node",

  /**
   * Creates a new Node element which are not assigned to any canvas.
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this.inputPorts = new _packages2.default.util.ArrayList();
    this.outputPorts = new _packages2.default.util.ArrayList();
    this.hybridPorts = new _packages2.default.util.ArrayList();

    // flag which indicates if the figure should read/write ports to
    // JSON
    this.persistPorts = true;

    // Flags just for performance reasons
    //
    this.portRelayoutRequired = true;

    // just for performance reasons
    //
    this.cachedPorts = null;

    this._super((0, _extend2.default)({ width: 50, height: 50 }, attr), (0, _extend2.default)({
      // @attr {Number} indicate whenever you want persists the ports too */
      persistPorts: this.setPersistPorts
    }, setter), (0, _extend2.default)({
      persistPorts: this.getPersistPorts
    }, getter));
  },

  /**
   *
   * Indicates if the node should read/write the ports via the draw2d.Figure.getPersistenAttributes
   * to the JSON object
   *
   * @param {Boolean} flag
   * @since 5.0.4
   */
  setPersistPorts: function setPersistPorts(flag) {
    this.persistPorts = flag;
    this.fireEvent("change:persistPorts", { value: this.persistPorts });

    return this;
  },

  /**
   *
   * Indicates if the figure writes the ports to the JSON structore too.
   * Default is "false"
   *
   * @returns {Boolean}
   */
  getPersistPorts: function getPersistPorts() {
    return this.persistPorts;
  },

  /**
   * @inheritdoc
   */
  toFront: function toFront(figure) {
    var _this = this;

    this._super(figure);

    this.getPorts().each(function (i, port) {
      port.getConnections().each(function (i, connection) {
        return connection.toFront(figure);
      });
      port.toFront(_this);
    });

    return this;
  },

  /**
   * @inheritdoc
   */
  toBack: function toBack(figure) {

    this.getPorts().each(function (i, port) {
      port.getConnections().each(function (i, connection) {
        return connection.toBack(figure);
      });
      port.toBack(figure);
    });

    this._super(figure);

    return this;
  },

  /**
   * @inheritdoc
   */
  setVisible: function setVisible(flag, duration) {
    // adjust the visibility of the ports to the parent state
    //
    if (!flag) {
      this.getPorts().each(function (i, port) {
        port.__initialVisibilityState = port.isVisible();
        port.setVisible(false, duration);
      });
    } else {
      this.getPorts().each(function (i, port) {
        if (typeof port.__initialVisibilityState !== "undefined") {
          port.setVisible(port.__initialVisibilityState, duration);
        } else {
          port.setVisible(true, duration);
        }
        delete port.__initialVisibilityState;
      });
    }
    this._super(flag, duration);
  },

  /**
   *
   * Return all ports of the node. The results contains
   * all ports of the children too per default. Set <b>recursive</b>
   * to false to retrieve direct assigned ports only.
   *
   * @param {Boolean} [recursive] indicates if the method should return children ports too. Default is <b>true</b>
   * @returns  {draw2d.util.ArrayList}
   **/
  getPorts: function getPorts(recursive) {
    var _this2 = this;

    if (typeof recursive === "boolean" && recursive === false) {
      var ports = new _packages2.default.util.ArrayList();
      ports.addAll(this.inputPorts);
      ports.addAll(this.outputPorts);
      ports.addAll(this.hybridPorts);
      return ports;
    }

    if (this.cachedPorts === null) {
      this.cachedPorts = new _packages2.default.util.ArrayList();
      this.cachedPorts.addAll(this.inputPorts);
      this.cachedPorts.addAll(this.outputPorts);
      this.cachedPorts.addAll(this.hybridPorts);

      this.children.each(function (i, e) {
        _this2.cachedPorts.addAll(e.figure.getPorts());
      });
    }
    return this.cachedPorts;
  },

  /**
   *
   * Return all input ports of the node.
   *
   * @returns {draw2d.util.ArrayList}
   **/
  getInputPorts: function getInputPorts() {
    return this.inputPorts.clone().addAll(this.hybridPorts);
  },

  /**
   *
   * Return all output ports of the node.
   *
   * @returns {draw2d.util.ArrayList}
   **/
  getOutputPorts: function getOutputPorts() {
    return this.outputPorts.clone().addAll(this.hybridPorts);
  },

  /**
   *
   * Clone the figure. <br>
   * You must override and implement the methods <b>getPersistentAttributes</b> and <b>setPersistentAttributes</b> for your custom
   * figures if the have special attributes.
   *
   * The clone() method performs a deep copy of the object, meaning that it copies the children, ports and decorations
   * per default. You can control the clone procedure with the 'cloneMetaData'.
   *
   *
   * @param {Object} [cloneMetaData] controls the clone procedure
   * @param {Boolean} [cloneMetaData.excludeChildren] set it to true if you want exclude the children.
   * @param {Boolean} [cloneMetaData.excludePorts] set it to true if you want exclude the ports of the node.
   *
   * @since 4.1.0
   * @experimental
   */
  clone: function clone(cloneMetaData) {
    cloneMetaData = (0, _extend2.default)({ excludePorts: false }, cloneMetaData);

    var clone = this._super(cloneMetaData);

    // remove all ports of the clone. the "init" method can have create some. but this must
    // removed because we want a clone of an existing figure
    //
    if (cloneMetaData.excludePorts === false) {
      clone.resetPorts();
      var ports = this.getPorts(false);

      ports.each(function (i, port) {
        var clonePort = port.clone();
        var locator = port.getLocator().clone();
        clone.addPort(clonePort, locator);
      });
    }

    return clone;
  },

  /**
   *
   * Return the port with the corresponding name.
   *
   *
   * @param {String} portName The name of the port to return.
   * @returns {draw2d.Port} Returns the port with the hands over name or null.
   **/
  getPort: function getPort(portName) {
    return this.getPorts().find(function (e) {
      return e.getName() === portName;
    });
  },

  /**
   *
   * Return the input port with the corresponding name.
   *
   *
   * @param {String/Number} portNameOrIndex The name or numeric index of the port to return.
   * @returns {draw2d.InputPort} Returns the port with the hands over name or null.
   **/
  getInputPort: function getInputPort(portNameOrIndex) {
    if (typeof portNameOrIndex === "number") {
      return this.inputPorts.get(portNameOrIndex);
    }

    for (var i = 0; i < this.inputPorts.getSize(); i++) {
      var port = this.inputPorts.get(i);
      if (port.getName() === portNameOrIndex) {
        return port;
      }
    }

    return null;
  },

  /**
   *
   * Return the output port with the corresponding name.
   *
   * @param {String/Number} portNameOrIndex The name or the numeric index of the port to return.
   * @returns {draw2d.OutputPort} Returns the port with the hands over name or null.
   **/
  getOutputPort: function getOutputPort(portNameOrIndex) {
    if (typeof portNameOrIndex === "number") {
      return this.outputPorts.get(portNameOrIndex);
    }

    for (var i = 0; i < this.outputPorts.getSize(); i++) {
      var port = this.outputPorts.get(i);
      if (port.getName() === portNameOrIndex) {
        return port;
      }
    }

    return null;
  },

  /**
   *
   * Return the input port with the corresponding name.
   *
   *
   * @param {String/Number} portNameOrIndex The name or numeric index of the port to return.
   * @returns {draw2d.InputPort} Returns the port with the hands over name or null.
   **/
  getHybridPort: function getHybridPort(portNameOrIndex) {
    if (typeof portNameOrIndex === "number") {
      return this.hybridPorts.get(portNameOrIndex);
    }

    for (var i = 0; i < this.hybridPorts.getSize(); i++) {
      var port = this.hybridPorts.get(i);
      if (port.getName() === portNameOrIndex) {
        return port;
      }
    }

    return null;
  },

  /**
   *
   * Add a port to this node at the given position.<br>
   *
   * @param {draw2d.Port} port The new port to add.
   * @param {draw2d.layout.locator.Locator} locator The layout for the port.
   **/
  addPort: function addPort(port, locator) {
    if (!(port instanceof _packages2.default.Port)) {
      throw "Argument is not typeof 'draw2d.Port'. \nFunction: draw2d.shape.node.Node#addPort";
    }

    // add to the internal cache if already build
    if (this.cachedPorts !== null) {
      this.cachedPorts.add(port);
    }

    this.portRelayoutRequired = true;

    if (port instanceof _packages2.default.InputPort) {
      this.inputPorts.add(port);
    } else if (port instanceof _packages2.default.OutputPort) {
      this.outputPorts.add(port);
    } else if (port instanceof _packages2.default.HybridPort) {
      this.hybridPorts.add(port);
    }

    if (typeof locator !== "undefined" && locator instanceof _packages2.default.layout.locator.Locator) {
      port.setLocator(locator);
    }

    port.setParent(this);
    port.setCanvas(this.canvas);

    // You can't delete a port with the [DEL] key if a port is a child of a node
    port.setDeleteable(false);

    if (this.canvas !== null) {
      port.getShapeElement();
      this.canvas.registerPort(port);
    }

    return port;
  },

  /**
   *
   * Remove all ports of this node
   *
   * @since 5.0.0
   * @returns {this}
   */
  resetPorts: function resetPorts() {
    var _this3 = this;

    this.getPorts().each(function (i, port) {
      return _this3.removePort(port);
    });
    return this;
  },

  /**
   *
   * Removes a port and all related connections from this node.<br>
   *
   * @param {draw2d.Port} port The port to remove.
   * @returns {this}
   **/
  removePort: function removePort(port) {
    this.portRelayoutRequired = true;

    this.cachedPorts = null;
    this.inputPorts.remove(port);
    this.outputPorts.remove(port);
    this.hybridPorts.remove(port);

    if (port.getCanvas() !== null) {
      port.getCanvas().unregisterPort(port);
      // remove the related connections of the port too.
      var connections = port.getConnections();
      for (var i = 0; i < connections.getSize(); ++i) {
        port.getCanvas().remove(connections.get(i));
      }
    }

    port.setCanvas(null);

    return this;
  },

  /**
   *
   * Create a standard Port for this element. Inherited class can override this
   * method to create its own type of ports.
   *
   * @param {String} type the type of the requested port. possible ["input", "output"]
   * @param {draw2d.layout.locator.Locator} [locator] the layouter to use for this port
   * @template
   */
  createPort: function createPort(type, locator) {
    var newPort = null;
    var count = 0;

    switch (type) {
      case "input":
        newPort = _packages2.default.Configuration.factory.createInputPort(this);
        count = this.inputPorts.getSize();
        break;
      case "output":
        newPort = _packages2.default.Configuration.factory.createOutputPort(this);
        count = this.outputPorts.getSize();
        break;
      case "hybrid":
        newPort = _packages2.default.Configuration.factory.createHybridPort(this);
        count = this.hybridPorts.getSize();
        break;
      default:
        throw "Unknown type [" + type + "] of port requested";
    }

    newPort.setName(type + count);

    this.addPort(newPort, locator);
    // relayout the ports
    this.setDimension(this.width, this.height);

    return newPort;
  },

  /**
   *
   * Return all connections related to this node.
   *
   * @returns {draw2d.util.ArrayList}
   */
  getConnections: function getConnections() {
    var connections = new _packages2.default.util.ArrayList();
    var ports = this.getPorts();
    for (var i = 0; i < ports.getSize(); i++) {
      var port = ports.get(i);
      // Do NOT add twice the same connection if it is linking ports from the same node
      for (var c = 0, c_size = port.getConnections().getSize(); c < c_size; c++) {
        if (!connections.contains(port.getConnections().get(c))) {
          connections.add(port.getConnections().get(c));
        }
      }
    }
    return connections;
  },

  /**
   * @returns {this}
   */
  setCanvas: function setCanvas(canvas) {
    var oldCanvas = this.canvas;
    this._super(canvas);

    var ports = this.getPorts();
    if (oldCanvas !== null) {
      ports.each(function (i, port) {
        return oldCanvas.unregisterPort(port);
      });
    }

    if (canvas !== null) {
      ports.each(function (i, port) {
        port.setCanvas(canvas);
        canvas.registerPort(port);
      });
      // relayout the ports
      this.setDimension(this.width, this.height);
    } else {
      ports.each(function (i, port) {
        return port.setCanvas(null);
      });
    }
    return this;
  },

  /**
   * @returns {this}
   */
  setRotationAngle: function setRotationAngle(angle) {
    this.portRelayoutRequired = true;
    this._super(angle);

    this.layoutPorts();

    return this;
  },

  /**
   * @returns {this}
   */
  setDimension: function setDimension(w, h) {
    this.portRelayoutRequired = true;
    this._super(w, h);

    return this;
  },

  /**
   *
   * Called if the value of any port has been changed
   *
   * @param {draw2d.Port} relatedPort
   * @template
   */
  onPortValueChanged: function onPortValueChanged(relatedPort) {},

  /**
   * @private
   * @return {this}
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return this;
    }

    this._super(attributes);
    this.layoutPorts();

    return this;
  },

  /**
   *
   *
   * @private
   * @returns {this}
   */
  layoutPorts: function layoutPorts() {
    if (this.portRelayoutRequired === false) {
      return this; //silently
    }
    this.portRelayoutRequired = false;

    // layout the ports
    //
    this.outputPorts.each(function (i, port) {
      return port.locator.relocate(i, port);
    });
    this.inputPorts.each(function (i, port) {
      return port.locator.relocate(i, port);
    });
    this.hybridPorts.each(function (i, port) {
      return port.locator.relocate(i, port);
    });

    return this;
  },

  /**
   *
   * Returns the Command to perform the specified Request or null.
   *
   * @param {draw2d.command.CommandType} request describes the Command being requested
   * @returns {draw2d.command.Command} null or a Command
   * @private
   **/
  createCommand: function createCommand(request) {
    if (request === null) {
      return null;
    }

    if (request.getPolicy() === _packages2.default.command.CommandType.ROTATE) {
      return new _packages2.default.command.CommandRotate(this, (this.getRotationAngle() + 90) % 360);
    }

    return this._super(request);
  },

  /**
   *
   * Return an objects with all important attributes for XML or JSON serialization
   *
   * @returns {Object}
   */
  getPersistentAttributes: function getPersistentAttributes() {
    var memento = this._super();

    // write all ports to the JSON
    //
    if (this.persistPorts === true) {
      memento.ports = [];
      this.getPorts().each(function (i, port) {
        console.log(port.getLocator());
        console.log(port.getLocator().attr());
        memento.ports.push((0, _extend2.default)(port.getPersistentAttributes(), {
          name: port.getName(),
          port: port.NAME,
          locator: port.getLocator().NAME,
          locatorAttr: port.getLocator().attr()
        }));
      });
    }

    return memento;
  },

  /**
   *
   * Read all attributes from the serialized properties and transfer them into the shape.
   *
   * @param {Object} memento
   * @returns {this}
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    var _this4 = this;

    this._super(memento);

    if (typeof memento.ports !== "undefined") {
      // we read the ports from the JSON and now we save it to the JSON too.
      this.persistPorts = true;

      // remove all ports created in the init method
      //
      this.resetPorts();

      // and restore all ports of the JSON document instead.
      //
      memento.ports.forEach(function (e) {
        var locator = eval("new " + e.locator + "()");
        if (e.locatorAttr) {
          locator.attr(e.locatorAttr);
        }

        var port = eval("new " + e.port + "()");
        port.setPersistentAttributes(e);
        _this4.addPort(port, locator);
      });
    }

    return this;
  }

});

/***/ }),

/***/ "./src/shape/node/Start.js":
/*!*********************************!*\
  !*** ./src/shape/node/Start.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A generic Node which has an OutputPort. Mainly used for demos and examples.
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.node.Start({color: "#3d3d3d"});
 *
 *    canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.basic.Rectangle
 */
_packages2.default.shape.node.Start = _packages2.default.shape.basic.Rectangle.extend(
/** @lends draw2d.shape.node.Start.prototype */
{

  NAME: "draw2d.shape.node.Start",
  DEFAULT_COLOR: new _packages2.default.util.Color("#4D90FE"),

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(extend({
      bgColor: this.DEFAULT_COLOR,
      color: this.DEFAULT_COLOR.darker(),
      width: 50,
      height: 50
    }, attr), setter, getter);
    this.createPort("output");
  }

});

/***/ }),

/***/ "./src/shape/node/VerticalBus.js":
/*!***************************************!*\
  !*** ./src/shape/node/VerticalBus.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A horizontal bus shape with a special kind of port handling. The hole figure is a hybrid port.
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.node.VerticalBus({width:40, height:300, text:"Vertical Bus"});
 *
 *    canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.node.Hub
 */
_packages2.default.shape.node.VerticalBus = _packages2.default.shape.node.Hub.extend(
/** @lends draw2d.shape.node.VerticalBus.prototype */
{

  NAME: "draw2d.shape.node.VerticalBus",

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.setConnectionDirStrategy(2);
    this.installEditPolicy(new _packages2.default.policy.figure.VBusSelectionFeedbackPolicy());
  },

  /**
   * 
   * set the label for the Hub
   *
   * @param {String} labelString
   * @since 3.0.4
   */
  setLabel: function setLabel(labelString) {
    var mustAdjustTheAngel = this.label === null;

    this._super(labelString);

    if (mustAdjustTheAngel === true && this.label !== null) {
      this.label.setRotationAngle(90);
    }
  },

  /**
   * @inheritdoc
   */
  getMinHeight: function getMinHeight() {
    if (this.shape === null && this.label === null) {
      return 0;
    }

    if (this.label !== null) {
      return this.label.getMinWidth();
    }

    return this._super();
  },

  /**
   * @inheritdoc
   */
  getMinWidth: function getMinWidth() {
    if (this.shape === null && this.label === null) {
      return 0;
    }

    if (this.label !== null) {
      return this.label.getMinHeight();
    }

    return this._super();
  }

});

/***/ }),

/***/ "./src/shape/note/PostIt.js":
/*!**********************************!*\
  !*** ./src/shape/note/PostIt.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Simple Post-it like figure with text. Can be used for annotations or documentation.
 *
 *
 * @example
 *
 *    let shape =  new draw2d.shape.note.PostIt({
 *       text:"This is a simple sticky note",
 *       color:"#000000",
 *       padding:20
 *    });
 *
 *    canvas.add(shape,40,10);
 *
 * @author Andreas Herz
 * @extends draw2d.shape.basic.Label
 */
_packages2.default.shape.note.PostIt = _packages2.default.shape.basic.Label.extend(
/** @lends draw2d.shape.note.PostIt.prototype */
{

  NAME: "draw2d.shape.note.PostIt",

  /**
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.setStroke(1);
    this.setBackgroundColor("#5b5b5b");
    this.setColor("#FFFFFF");
    this.setFontColor("#ffffff");
    this.setFontSize(14);
    this.setPadding(5);
    this.setRadius(5);
  }
});

/***/ }),

/***/ "./src/shape/pert/Activity.js":
/*!************************************!*\
  !*** ./src/shape/pert/Activity.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * NOT FOR PRODUCTIVE
 *
 * Checkout [Wikipedia PERT][1] for more information.
 *
 * Double click on the Task name or the top middle number to change the value.
 *
 *
 * @example
 *
 *    canvas.add( new draw2d.shape.pert.Start(),10,10);
 *    canvas.add( new draw2d.shape.pert.Activity(),80,130);
 *    canvas.add( new draw2d.shape.pert.Activity(),180,50);
 *
 * [1] http://en.wikipedia.org/wiki/Program_Evaluation_and_Review_Technique
 *
 * @extends draw2d.shape.layout.VerticalLayout
 */
_packages2.default.shape.pert.Activity = _packages2.default.shape.layout.VerticalLayout.extend(
/** @lends draw2d.shape.pert.Activity.prototype */
{

  NAME: "draw2d.shape.pert.Activity",

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    // shortcut for some callback methods to avoid $.proxy wrapper
    var _this = this;

    // persistence values for the activity
    // will be stored/read in the JSON
    this.mementoValues = {
      duration: null

      // just some color attributes for the rendering/gradient
    };this.bgColor = new _packages2.default.util.Color("#f3f3f3");
    this.lighterBgColor = this.bgColor.lighter(0.2).rgba();
    this.darkerBgColor = this.bgColor.darker(0.2).rgba();

    this._super(extend({ bgColor: this.bgColor, stroke: 2, radius: 2, color: this.darkerBgColor }, attr), setter, getter);

    // Compose the top row of the shape
    //
    var top = new _packages2.default.shape.layout.HorizontalLayout({ stroke: 0 });

    this.earlyStartLabel = this.createLabel("Early Start").setStroke(0);

    this.durationLabel = new _packages2.default.shape.basic.Label({
      text: "Duration",
      stroke: 1,
      color: this.darkerBgColor,
      radius: 0,
      bgColor: null,
      padding: 5
    });
    // duration label has a inplaceEditor for the value
    this.durationLabel.installEditor(new _packages2.default.ui.LabelEditor({
      onCommit: function onCommit(value) {
        _this.setDuration(parseFloat(value));
      }
    }));

    this.earlyEndLabel = this.createLabel({ text: "Early End", stroke: 0 });

    top.add(this.earlyStartLabel);
    top.add(this.durationLabel);
    top.add(this.earlyEndLabel);

    // the middle part of the shape
    // This part contains the ports for the connection
    //
    this.activityLabel = new _packages2.default.shape.basic.Label({
      text: "Activity Name",
      radius: 0,
      padding: 10,
      color: this.darkerBgColor,
      bgColor: null
    });
    // direct editor for the label
    this.activityLabel.installEditor(new _packages2.default.ui.LabelInplaceEditor());

    this.inputPort = this.activityLabel.createPort("input");
    this.inputPort.getActivity = function () {
      return _this;
    };
    this.inputPort.onConnect = function () {
      _this.setDuration(_this.mementoValues.duration);
    };
    this.inputPort.onDisconnect = function () {
      _this.setDuration(_this.mementoValues.duration);
    };
    this.inputPort.setValue = function (anyValue) {
      _this.setDuration(_this.mementoValues.duration);
    };

    this.outputPort = this.activityLabel.createPort("output");
    this.outputPort.getActivity = function () {
      return _this;
    };
    this.outputPort.onConnect = function () {
      _this.setDuration(_this.mementoValues.duration);
    };
    this.outputPort.onDisconnect = function () {
      _this.setDuration(_this.mementoValues.duration);
    };

    // the bottom of the activity shape
    //
    var bottom = new _packages2.default.shape.layout.HorizontalLayout({ stroke: 0 });

    this.lateStartLabel = this.createLabel("Late Start").setStroke(0);
    this.stackLabel = this.createLabel("Stack");
    this.lateEndLabel = this.createLabel("Late End").setStroke(0);

    bottom.add(this.lateStartLabel);
    bottom.add(this.stackLabel);
    bottom.add(this.lateEndLabel);

    // finally compose the shape with top/middle/bottom in VerticalLayout
    //
    this.add(top);
    this.add(this.activityLabel);
    this.add(bottom);

    // set some good default value for the activity
    //
    this.setDuration(1);
  },

  /**
   * 
   * Set the duration for the activity. This triggers a complete recalculation of the complete
   * diagram. No further calls are required
   *
   * @param {Number} duration the new Duration for the activity
   */
  setDuration: function setDuration(duration) {

    if (this.mementoValues.duration !== duration) {
      // store the new value
      this.mementoValues.duration = duration;

      // update the labels for duration
      this.durationLabel.setText(this.mementoValues.duration);
    }

    // calculate the earlyStart and latestEnd and set the labels
    //
    var start = this.getEarlyStart();

    this.earlyStartLabel.setText(start);
    this.earlyEndLabel.setText(start + this.mementoValues.duration);

    // notify all children that a parent value has been changed
    // Just knock on the inputPort...
    //
    var connections = this.outputPort.getConnections();
    connections.each(function (i, conn) {
      var targetPort = conn.getTarget();
      targetPort.setValue();
    });

    // propagate the lateFinish up to all parent nodes if we are a leaf
    //
    if (connections.getSize() === 0) {
      var lateFinish = parseFloat(this.earlyEndLabel.getText());
      this.setLateFinish(lateFinish);
    }
  },

  getEarlyEnd: function getEarlyEnd() {
    return this.getEarlyStart() + this.mementoValues.duration;
  },

  getEarlyStart: function getEarlyStart() {
    var latestEarlyEnd = 0;

    // retrieve the greatest "earlyStart" from all parent activities
    this.inputPort.getConnections().each(function (i, conn) {
      var parentActivity = conn.getSource().getActivity();
      latestEarlyEnd = Math.max(latestEarlyEnd, parentActivity.getEarlyEnd());
    });

    return latestEarlyEnd;
  },

  setLateFinish: function setLateFinish(value) {
    var lateStart = value - this.mementoValues.duration;

    this.lateEndLabel.setText(value);
    this.lateStartLabel.setText(lateStart);
    this.stackLabel.setText(lateStart - parseFloat(this.earlyStartLabel.getText()));

    var connections = this.inputPort.getConnections();
    connections.each(function (i, conn) {
      var sourcePort = conn.getSource();
      sourcePort.getActivity().setLateFinish(lateStart);
    });
  },

  /**
   * 
   * help method to create some labels
   *
   * @param {String} txt the label to display
   * @returns {draw2d.shape.basic.Label}
   */
  createLabel: function createLabel(txt) {
    var label = new _packages2.default.shape.basic.Label({ text: txt });
    label.setStroke(1);
    label.setColor(this.darkerBgColor);
    label.setRadius(0);
    label.setBackgroundColor(null);
    label.setPadding(5);
    label.setColor(this.bgColor.darker(0.2));
    label.onDoubleClick = function (angle) {/* ignore them for the layout elements*/
    };

    return label;
  },

  /**
   * @inheritdoc
   */
  setBackgroundColor: function setBackgroundColor(color) {
    this._super(color);

    // calculate the new lighter and darker colors for the gradient
    //
    this.lighterBgColor = this.bgColor.lighter(0.2).rgba();
    this.darkerBgColor = this.bgColor.darker(0.2).rgba();
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {

    // repaint can be blocked during deserialization and if the shape
    // not part of any canvas.
    //
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    if (this.getAlpha() < 0.9) {
      attributes.fill = this.bgColor.rgba();
    } else {
      attributes.fill = ["90", this.bgColor.hash(), this.lighterBgColor].join("-");
    }

    this._super(attributes);
  }
});

/***/ }),

/***/ "./src/shape/pert/Start.js":
/*!*********************************!*\
  !*** ./src/shape/pert/Start.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * NOT FOR PRODUCTIVE
 *
 * Checkout [Wikipedia PERT][1] for more information.
 *
 * Double click on the Task name or the top middle number to change the value.
 *
 *
 * @example
 *
 *    canvas.add( new draw2d.shape.pert.Start(),10,10);
 *    canvas.add( new draw2d.shape.pert.Activity(),80,130);
 *    canvas.add( new draw2d.shape.pert.Activity(),180,50);
 *
 * [1] http://en.wikipedia.org/wiki/Program_Evaluation_and_Review_Technique
 *
 * @extends draw2d.shape.layout.VerticalLayout
 */
_packages2.default.shape.pert.Start = _packages2.default.shape.layout.VerticalLayout.extend(
/** @lends draw2d.shape.pert.Start.prototype */
{

  NAME: "draw2d.shape.pert.Start",

  /**
   * Create a new instance
   *
   * @param {Object} [attr] the configuration of the shape
   */
  init: function init(attr, setter, getter) {
    // shortcut for some callback methods to avoid $.proxy wrapper
    var _this = this;

    // persistence values for the activity
    // will be stored/read in the JSON
    this.mementoValues = {
      duration: null

      // just some color attributes for the rendering/gradient
    };this.bgColor = new _packages2.default.util.Color("#f3f3f3");
    this.lighterBgColor = this.bgColor.lighter(0.2).rgba();
    this.darkerBgColor = this.bgColor.darker(0.2).rgba();

    this._super(extend({ bgColor: this.bgColor, stroke: 2, radius: 2, color: this.darkerBgColor }, attr), setter, getter);

    // Compose the top row of the shape
    //
    var top = new _packages2.default.shape.layout.HorizontalLayout({ stroke: 0 });

    this.durationLabel = new _packages2.default.shape.basic.Label({
      text: "Duration",
      stroke: 1,
      color: this.darkerBgColor,
      radius: 0,
      bgColor: null,
      padding: 5
    });
    // duration label has a inplaceEditor for the value
    this.durationLabel.installEditor(new _packages2.default.ui.LabelEditor({
      text: "Enter new duration",
      onCommit: function onCommit(value) {
        _this.setDuration(parseFloat(value));
      }
    }));

    this.earlyEndLabel = this.createLabel({ text: "Early End", stroke: 0 });

    top.add(this.durationLabel);
    top.add(this.earlyEndLabel);

    // the middle part of the shape
    // This part contains the ports for the connection
    //
    this.activityLabel = new _packages2.default.shape.basic.Label({
      text: "Start",
      radius: 0,
      padding: 10,
      color: this.darkerBgColor,
      bgColor: null
    });
    // direct editor for the label
    this.activityLabel.installEditor(new _packages2.default.ui.LabelInplaceEditor());

    this.outputPort = this.activityLabel.createPort("output");
    this.outputPort.getActivity = function () {
      return _this;
    };
    this.outputPort.onConnect = function () {
      _this.setDuration(_this.mementoValues.duration);
    };
    this.outputPort.onDisconnect = function () {
      _this.setDuration(_this.mementoValues.duration);
    };

    // the bottom of the activity shape
    //
    var bottom = this.createLabel(" ");
    bottom.setPadding(10);
    bottom.setStroke(0);
    this.lateEndLabel = bottom;

    // finally compose the shape with top/middle/bottom in VerticalLayout
    //
    this.add(top);
    this.add(this.activityLabel);
    this.add(bottom);

    // set some good default value for the activity
    //
    this.setDuration(1);
  },

  /**
   * 
   * Set the duration for the activity. This triggers a complete recalculation of the complete
   * diagram. No further calls are required
   *
   * @param {Number} duration the new Duration for the activity
   */
  setDuration: function setDuration(duration) {

    if (this.mementoValues.duration !== duration) {
      // store the new value
      this.mementoValues.duration = duration;

      // update the labels for duration
      this.durationLabel.setText(this.mementoValues.duration);
    }

    this.earlyEndLabel.setText(this.mementoValues.duration);

    // notify all children that a parent value has been changed
    // Just knock on the inputPort...
    //
    var connections = this.outputPort.getConnections();
    connections.each(function (i, conn) {
      var targetPort = conn.getTarget();
      targetPort.setValue();
    });

    // propagate the lateFinish up to all parent nodes if we are a leaf
    //
    if (connections.getSize() === 0) {
      var lateFinish = parseFloat(this.earlyEndLabel.getText());
      this.setLateFinish(lateFinish);
    }
  },

  getEarlyEnd: function getEarlyEnd() {
    return this.mementoValues.duration;
  },

  setLateFinish: function setLateFinish(value) {
    var lateStart = value - this.mementoValues.duration;

    this.lateEndLabel.setText(value);
  },

  /**
   * 
   * help method to create some labels
   *
   * @param {String} txt the label to display
   * @returns {draw2d.shape.basic.Label}
   */
  createLabel: function createLabel(txt) {
    var label = new _packages2.default.shape.basic.Label({ text: txt });
    label.setStroke(1);
    label.setColor(this.darkerBgColor);
    label.setRadius(0);
    label.setBackgroundColor(null);
    label.setPadding(5);
    label.setColor(this.bgColor.darker(0.2));
    label.onDoubleClick = function (angle) {/* ignore them for the layout elements*/
    };

    return label;
  },

  /**
   * @inheritdoc
   */
  setBackgroundColor: function setBackgroundColor(color) {
    this._super(color);

    // calculate the new lighter and darker colors for the gradient
    //
    this.lighterBgColor = this.bgColor.lighter(0.2).rgba();
    this.darkerBgColor = this.bgColor.darker(0.2).rgba();
  },

  /**
   * @inheritdoc
   */
  repaint: function repaint(attributes) {

    // repaint can be blocked during deserialization and if the shape
    // not part of any canvas.
    //
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    if (this.getAlpha() < 0.9) {
      attributes.fill = this.bgColor.rgba();
    } else {
      attributes.fill = ["90", this.bgColor.hash(), this.lighterBgColor].join("-");
    }

    this._super(attributes);
  }
});

/***/ }),

/***/ "./src/shape/state/Connection.js":
/*!***************************************!*\
  !*** ./src/shape/state/Connection.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Connection designed for a state diagram with arrow decoration at the
 * target of the connection and a label
 *
 *
 * @example
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let start = new draw2d.shape.state.Start();
 *    let end   = new draw2d.shape.state.End();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( end, 230,180);
 *
 *    // Create a Connection and connect the Start and End node
 *    //
 *    let c = new draw2d.shape.state.Connection({
 *    	 source : start.getOutputPort(0),
 *      target : end.getInputPort(0)
 *    });
 *
 *    // and finally add the connection to the canvas
 *    canvas.add(c);
 *
 *
 * @extends draw2d.Connection
 */
_packages2.default.shape.state.Connection = _packages2.default.Connection.extend(
/** @lends draw2d.shape.state.Connection.prototype */
{
  NAME: "draw2d.shape.state.Connection",

  DEFAULT_COLOR: new _packages2.default.util.Color("#4D90FE"),

  init: function init(attr, setter, getter) {
    this._super(extend({ router: null, stroke: 2 }, attr), setter, getter);

    this.setTargetDecorator(new _packages2.default.decoration.connection.ArrowDecorator(17, 8));

    this.label = new _packages2.default.shape.basic.Label({ text: "label" });
    this.label.setStroke(1);
    this.label.setPadding(2);
    this.label.setBackgroundColor("#f0f0f0");
    this.add(this.label, new _packages2.default.layout.locator.ParallelMidpointLocator());
  },
  /**
   * 
   * Set the text to show if the state shape
   *
   * @param {String} text
   */
  setLabel: function setLabel(text) {
    this.label.setText(text);

    // hide the label if no text available
    this.label.setVisible(!(text === null || text === ""));
    this.fireEvent("change:label", { value: text });

    return this;
  },

  /**
   * 
   * Return the label of the shape
   *
   */
  getLabel: function getLabel() {
    return this.label.getText();
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    return extend(this._super(), {
      label: this.getLabel()
    });
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.label !== "undefined") {
      this.setLabel(memento.label);
    }
  }

});

/***/ }),

/***/ "./src/shape/state/End.js":
/*!********************************!*\
  !*** ./src/shape/state/End.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * The end node for a state diagram
 *
 *
 * @example
 *    let end   = new draw2d.shape.state.End();

 *    // ...add it to the canvas
 *    canvas.add( end, 230,80);
 *
 * @extends draw2d.shape.basic.Circle
 */
_packages2.default.shape.state.End = _packages2.default.shape.basic.Circle.extend(
/** @lends draw2d.shape.state.End.prototype */
{

  NAME: "draw2d.shape.state.End",

  DEFAULT_COLOR: new _packages2.default.util.Color("#4D90FE"),

  init: function init(attr, setter, getter) {
    this.innerCircle = new _packages2.default.shape.basic.Circle(20);

    this._super(attr, setter, getter);

    this.port = this.createPort("input", new _packages2.default.layout.locator.TopLocator());
    this.port.setConnectionAnchor(new _packages2.default.layout.anchor.ShortesPathConnectionAnchor(this.port));

    this.setDimension(50, 50);
    this.setBackgroundColor(this.DEFAULT_COLOR);
    this.installEditPolicy(new _packages2.default.policy.figure.AntSelectionFeedbackPolicy());

    this.innerCircle.setStroke(2);
    this.innerCircle.setBackgroundColor(null);
    this.add(this.innerCircle, new _packages2.default.layout.locator.CenterLocator());

    this.setStroke(0);
    //this.setColor(this.DEFAULT_COLOR.darker());
  },

  /**
   * @inheritdoc
   */
  setDimension: function setDimension(w, h) {
    this._super(w, h);
    this.innerCircle.setDimension(this.getWidth() - 10, this.getHeight() - 10);
  }
});

/***/ }),

/***/ "./src/shape/state/Start.js":
/*!**********************************!*\
  !*** ./src/shape/state/Start.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * The start node for a state diagram
 *
 *
 * @example
 *
 *    let figure =  new draw2d.shape.state.Start({color:"#3d3d3d"});
 *
 *    canvas.add(figure,50,10);
 *
 * @extends draw2d.shape.basic.Rectangle
 */
_packages2.default.shape.state.Start = _packages2.default.shape.basic.Circle.extend(
/** @lends draw2d.shape.state.Start.prototype */
{

  NAME: "draw2d.shape.state.Start",

  DEFAULT_COLOR: new _packages2.default.util.Color("#3369E8"),

  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.port = this.createPort("output", new _packages2.default.layout.locator.BottomLocator());
    this.port.setConnectionAnchor(new _packages2.default.layout.anchor.ShortesPathConnectionAnchor(this.port));

    this.setDimension(50, 50);
    this.setBackgroundColor(this.DEFAULT_COLOR);
    this.installEditPolicy(new _packages2.default.policy.figure.AntSelectionFeedbackPolicy());

    this.setStroke(0);
    //this.setColor(this.DEFAULT_COLOR.darker());

    var label = new _packages2.default.shape.basic.Label({ text: "START" });
    label.setStroke(0);
    label.setFontColor("#ffffff");
    label.setFontFamily('"Open Sans",sans-serif');
    this.add(label, new _packages2.default.layout.locator.CenterLocator());
  }
});

/***/ }),

/***/ "./src/shape/state/State.js":
/*!**********************************!*\
  !*** ./src/shape/state/State.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * a state shape for a state diagram
 *
 * @example
 *
 *    // create and add two nodes which contains Ports (In and OUT)
 *    //
 *    let start = new draw2d.shape.state.Start();
 *    let state   = new draw2d.shape.state.State();

 *    // ...add it to the canvas
 *    canvas.add( start, 50,50);
 *    canvas.add( state, 230,180);
 *
 *    // Create a Connection and connect the Start and End node
 *    //
 *    let c = new draw2d.shape.state.Connection({
 *    		source : start.getOutputPort(0),
 *         target : state.getInputPort(0)
 *    });
 *
 *
 *    // and finally add the connection to the canvas
 *    canvas.add(c);
 *
 * @extends draw2d.shape.layout.VerticalLayout
 */
_packages2.default.shape.state.State = _packages2.default.shape.layout.VerticalLayout.extend(
/** @lends draw2d.shape.state.State.prototype */
{

  NAME: "draw2d.shape.state.State",

  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);

    this.port = this.createPort("hybrid", new _packages2.default.layout.locator.BottomLocator());
    this.port.setConnectionAnchor(new _packages2.default.layout.anchor.ChopboxConnectionAnchor(this.port));

    this.setBackgroundColor("#f3f3f3");

    // UI representation
    this.setStroke(1);
    this.setColor("#e0e0e0");
    this.setRadius(5);

    // Compose the top row of the shape
    //
    var top = this.createLabel("State").setStroke(0);
    this.label = top;

    // the middle part of the shape
    // This part contains the ports for the connection
    //
    var center = new _packages2.default.shape.basic.Rectangle();
    center.getHeight = function () {
      return 1;
    };
    center.setMinWidth(90);
    center.setColor("#e0e0e0");

    // the bottom of the activity shape
    //
    var bottom = new _packages2.default.shape.basic.Rectangle();
    bottom.setMinHeight(30);
    bottom.setStroke(0);
    bottom.setBackgroundColor(null);

    // finally compose the shape with top/middle/bottom in VerticalLayout
    //
    this.add(top);
    this.add(center);
    this.add(bottom);
  },

  /**
   *
   * Set the text to show if the state shape
   *
   * @param {String} text
   */
  setLabel: function setLabel(text) {
    this.label.setText(text);
    this.fireEvent("change:label", { value: text });

    return this;
  },

  /**
   *
   * Return the label of the shape
   *
   */
  getLabel: function getLabel() {
    return this.label.getText();
  },

  /**
   *
   * helper method to create some labels
   *
   * @param {String} txt the label to display
   * @returns {draw2d.shape.basic.Label}
   * @private
   */
  createLabel: function createLabel(txt) {
    var label = new _packages2.default.shape.basic.Label(txt);
    label.setStroke(1);
    label.setColor(this.darkerBgColor);
    label.setRadius(0);
    label.setBackgroundColor(null);
    label.setPadding(5);
    label.setColor(this.bgColor.darker(0.2));
    label.onDoubleClick = function (angle) {/* ignore them for the layout elements*/
    };

    return label;
  },

  /**
   * @inheritdoc
   */
  getPersistentAttributes: function getPersistentAttributes() {
    return extend(this._super(), {
      label: this.getLabel()
    });
  },

  /**
   * @inheritdoc
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this._super(memento);

    if (typeof memento.label !== "undefined") {
      this.setLabel(memento.label);
    }
  }
});

/***/ }),

/***/ "./src/shape/widget/Slider.js":
/*!************************************!*\
  !*** ./src/shape/widget/Slider.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _shifty = __webpack_require__(/*! shifty */ "./node_modules/shifty/dist/shifty.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * @example
 *
 *    let slider = new draw2d.shape.widget.Slider({width:120, height:20});
 *    canvas.add( slider,100,60);
 *
 * @extends draw2d.shape.widget.Widget
 */
_packages2.default.shape.widget.Slider = _packages2.default.shape.widget.Widget.extend(
/** @lends draw2d.shape.widget.Slider.prototype */
{

  NAME: "draw2d.shape.widget.Slider",

  DEFAULT_COLOR_THUMB: new _packages2.default.util.Color("#bddf69"),
  DEFAULT_COLOR_BG: new _packages2.default.util.Color("#d3d3d3"),

  init: function init(attr, setter, getter) {
    this.currentValue = 0; // [0..100]
    this.slideBoundingBox = new _packages2.default.geo.Rectangle(0, 0, 10, 20);
    this.padding = { top: 4, right: 4, bottom: 4, left: 4 };
    this.panning = false;
    this.thumbGrow = 0;

    this._super(extend({
      width: 150,
      height: 15,
      stroke: 1,
      radius: 4,
      resizeable: true,
      color: this.DEFAULT_COLOR_THUMB,
      bgColor: this.DEFAULT_COLOR_BG,
      value: 50
    }, attr), extend({
      // @attr {Number} padding the padding in pixel around the text */
      padding: this.setPadding,
      // @attr {Number} value the new value of the slider. values must be in range of [0..100] */
      value: this.setValue
    }, setter), extend({
      padding: this.getPadding,
      value: this.getValue
    }, getter));

    this.setMinHeight(15);
    this.setMinWidth(80);
  },

  /**
   * 
   * Create the additional elements for the figure
   *
   */
  createSet: function createSet() {
    var result = this.canvas.paper.set();
    var thumb = this.canvas.paper.rect(0, 0, 10, 20);
    thumb.node.style.cursor = "col-resize";
    result.push(thumb);

    return result;
  },

  /**
   * @inheritdoc
   */
  setDimension: function setDimension(w, h) {
    this._super(w, h);
    this.slideBoundingBox.setBoundary(this.padding.left, 0, this.getWidth() - this.padding.right, this.getHeight());
    this.slideBoundingBox.setHeight(this.getHeight() + 1);

    // TODO: and repaint again.....two repaints for one "setDimension"....BAD
    //
    this.repaint();
  },

  /**
   * 
   * Set the padding of the element
   *
   *     // Alternatively you can use the attr method:
   *     //
   *     // set the padding for top,left,bottom,right in one call
   *     figure.attr({
   *       padding: 3
   *     });
   *
   *     // update the padding left and top
   *     figure.attr({
   *       padding: {left:3, top:30}
   *     });
   *
   * @param {Number|Object} padding The new padding
   * @since 5.6.0
   **/
  setPadding: function setPadding(padding) {
    this.clearCache();
    if (typeof padding === "number") {
      this.padding = { top: padding, right: padding, bottom: padding, left: padding };
    } else {
      this.padding = extend(this.padding, padding);
    }
    this.repaint();
    this.fireEvent("change:padding", { value: this.padding });

    return this;
  },

  /**
   * 
   * Get the padding of the element.
   *
   * @since 5.6.0
   **/
  getPadding: function getPadding() {
    return this.padding;
  },

  /**
   * 
   * Called if the value of the slider has been changed.
   *
   * @param {Number} value The new value of the slider in percentage [0..100]
   * @template
   */
  onValueChange: function onValueChange(value) {},

  /**
   * 
   * Will be called if the drag and drop action begins. You can return [false] if you
   * want avoid that the figure can be move.
   *
   * @param {Number} x the x-coordinate of the mouse up event
   * @param {Number} y the y-coordinate of the mouse up event
   * @param {Boolean} shiftKey true if the shift key has been pressed during this event
   * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
   *
   * @returns {Boolean} true if the figure accepts dragging
   **/
  onDragStart: function onDragStart(x, y, shiftKey, ctrlKey) {
    // check if the use has been clicked on the thumb.
    // Return "false" to prevent drag&drop operation.
    //
    if (this.slideBoundingBox.hitTest(x, y)) {

      this.panningX = x;
      this.panningY = y;
      this.panning = true;
      var tweenable = new _shifty.Tweenable();
      tweenable.tween({
        from: { grow: this.thumbGrow },
        to: { grow: 10 },
        duration: 500,
        easing: 'easeOutQuart',
        step: function (state) {
          this.thumbGrow = state.grow;
          this.repaint();
        }.bind(this),
        finish: function finish() {
          tweenable.dispose();
        }
      });
      return false;
    }

    return this._super(x, y, shiftKey, ctrlKey);
  },

  /**
   * 
   * Called by the framework if the figure returns false for the drag operation. In this
   * case we send a "panning" event - mouseDown + mouseMove. This is very useful for
   * UI-Widget like slider, spinner,...
   *
   * @param {Number} dx the x difference between the mouse down operation and now
   * @param {Number} dy the y difference between the mouse down operation and now
   * @param {Number} dx2 The x diff since the last call of this dragging operation
   * @param {Number} dy2 The y diff since the last call of this dragging operation
   */
  onPanning: function onPanning(dx, dy, dx2, dy2) {
    // calculate the current position of the mouse pos
    //
    var thumbW2 = this.slideBoundingBox.w / 2;
    var width = this.getWidth();
    var sliderWidth = width - this.padding.left - this.padding.right;

    var figurePos = Math.min(width, Math.max(0, this.panningX + dx));
    var sliderPos = Math.min(width - this.padding.left - this.padding.right, figurePos - this.padding.left) - thumbW2;

    this.setValue(100 / sliderWidth * sliderPos);
  },

  /**
   * @inheritdoc
   */
  onPanningEnd: function onPanningEnd() {
    this.panning = false;

    var tweenable = new _shifty.Tweenable();
    tweenable.tween({
      from: { grow: this.thumbGrow },
      to: { grow: 0 },
      duration: 300,
      easing: 'easeOutQuart',
      step: function (state) {
        this.thumbGrow = state.grow;
        this.repaint();
      }.bind(this),
      finish: function finish() {
        tweenable.dispose();
      }
    });
    this.thumbGrow = 0;
    this.repaint();
  },

  /**
   * 
   * Set the current value of the slider. Valid values are [0..100]
   *
   * @param {Number} value values between [0..100]
   */
  setValue: function setValue(value) {
    this.currentValue = Math.min(Math.max(0, value | 0), 100);
    this.repaint();
    this.onValueChange(this.currentValue);
    this.fireEvent("change:value", { value: this.currentValue });

    return this;
  },

  /**
   * 
   * Returns the current value of the slider
   *
   * @since 5.6.0
   *
   * @returns {Number}
   */
  getValue: function getValue() {
    return this.currentValue;
  },

  /**
   *
   * @param attributes
   */
  repaint: function repaint(attributes) {
    if (this.repaintBlocked === true || this.shape === null) {
      return;
    }

    attributes = attributes || {};

    // adjust the slider to the current value and the new dimension of the widget
    //
    var thumbX = (this.getWidth() - this.padding.left - this.padding.right) / 100 * this.currentValue + this.padding.left | 0;
    this.slideBoundingBox.setX(thumbX);

    // update slider
    //
    if (this.svgNodes !== null) {
      var attr = this.slideBoundingBox.toJSON();
      attr.y -= this.thumbGrow / 2;
      attr.height += this.thumbGrow;
      attr.fill = this.getColor().rgba();
      attr.stroke = this.getColor().darker(0.2).rgba();
      attr.r = 4;
      this.svgNodes.attr(attr);
    }

    attributes.fill = "90-" + this.bgColor.hash() + ":5-" + this.bgColor.lighter(0.3).hash() + ":95";
    attributes.stroke = this.bgColor.darker(0.1).rgba();

    this._super(attributes);
  },

  applyTransformation: function applyTransformation() {
    this.svgNodes.transform("T" + this.getAbsoluteX() + "," + this.getAbsoluteY());

    return this;
  }

});

/***/ }),

/***/ "./src/shape/widget/Widget.js":
/*!************************************!*\
  !*** ./src/shape/widget/Widget.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Base class for all diagrams.
 *
 * @extends draw2d.SetFigure
 */
_packages2.default.shape.widget.Widget = _packages2.default.SetFigure.extend({

  init: function init(attr, setter, getter) {
    this._super(attr, setter, getter);
  }
});

/***/ }),

/***/ "./src/ui/LabelEditor.js":
/*!*******************************!*\
  !*** ./src/ui/LabelEditor.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Base class for all draw2d.shape.basic.Label editors. The default implementation is to open
 * a simple javascript prompt dialog.<br>
 * Use LabelInplaceEditor or your own implementation if you need more comfort.
 *
 * @example
 *
 *    let label =  new draw2d.shape.basic.Label({text:"Double Click on me"});
 *
 *    label.installEditor(new draw2d.ui.LabelEditor({
 *       // called after the value has been set to the LabelFigure
 *       onCommit: $.proxy(function(value){
 *           alert("new value set to:"+value);
 *       },this),
 *       // called if the user abort the operation
 *       onCancel: function(){
 *       }
 *    }));
 *
 *    canvas.add(label,50,10);
 *
 *
 * @author Andreas Herz
 */
_packages2.default.ui.LabelEditor = Class.extend(
/** @lends draw2d.ui.LabelEditor.prototype */
{
  NAME: "draw2d.ui.LabelEditor",

  /**
   *
   * @param {Object} attr callback handler and configuration. **{ onCommit:function(){}}, onCancel: function(){}, onStart: function(){}, text:'My Dialog Title' }**
   */
  init: function init(attr) {
    // register some default listener and override this with the handover one
    this.configuration = extend({
      onCommit: function onCommit() {},
      onCancel: function onCancel() {},
      onStart: function onStart() {},
      text: "Value"
    }, attr);
  },

  /**
   *
   * Trigger the edit of the label text.
   *
   * @param {draw2d.shape.basic.Label} label the label to edit
   */
  start: function start(label) {
    this.configuration.onStart();
    var newText = prompt(this.configuration.text, label.getText());
    if (newText) {
      var cmd = new _packages2.default.command.CommandAttr(label, { text: newText });
      label.getCanvas().getCommandStack().execute(cmd);

      this.configuration.onCommit(label.getText());
    } else {
      this.configuration.onCancel();
    }
  }
});

/***/ }),

/***/ "./src/ui/LabelInplaceEditor.js":
/*!**************************************!*\
  !*** ./src/ui/LabelInplaceEditor.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

var _jquery = __webpack_require__(/*! lib/jquery.autoresize */ "./src/lib/jquery.autoresize.js");

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * Inplace editor for draw2d.shape.base.Label
 *
 * @example
 *
 *    var label =  new draw2d.shape.basic.Label({text:"Double Click on me"});
 *
 *    label.installEditor(new draw2d.ui.LabelInplaceEditor({
 *       // called after the value has been set to the LabelFigure
 *       onCommit: $.proxy(function(value){
 *           alert("new value set to:"+value);
 *       },this),
 *       // called if the user abort the operation
 *       onCancel: function(){
 *       }
 *    }));
 *
 *    canvas.add(label,50,10);
 *
 * @author Andreas Herz
 * @extends draw2d.ui.LabelEditor
 */
_packages2.default.ui.LabelInplaceEditor = _packages2.default.ui.LabelEditor.extend(
/** @lends draw2d.ui.LabelInplaceEditor.prototype */
{

  NAME: "draw2d.ui.LabelInplaceEditor",

  init: function init(listener) {
    this._super();

    // register some default listener and override this with the handover one
    this.listener = extend({
      onCommit: function onCommit() {},
      onCancel: function onCancel() {},
      onStart: function onStart() {}
    }, listener);
  },

  /**
   *
   * Trigger the edit of the label text.
   *
   * @param {draw2d.shape.basic.Label} label the label to edit
   */
  start: function start(label) {
    var _this = this;

    this.label = label;

    this.commitCallback = this.commit.bind(this);

    // commit the editor if the user clicks anywhere in the document
    //
    $("body").bind("click", this.commitCallback);

    // append the input field to the document and register
    // the ENTER and ESC key to commit /cancel the operation
    //
    this.html = $('<input id="inplaceeditor">');
    this.html.val(label.getText());
    this.html.hide();

    $("body").append(this.html);

    this.html.autoResize();

    this.html.bind("keyup", function (e) {
      switch (e.which) {
        case 13:
          this.commit();
          break;
        case 27:
          this.cancel();
          break;
      }
    }.bind(this));

    this.html.bind("blur", this.commitCallback);

    // avoid commit of the operation if we click inside the editor
    //
    this.html.bind("click", function (e) {
      e.stopPropagation();
      e.preventDefault();
    });

    // Position the INPUT and init the autoresize of the element
    //
    var canvas = this.label.getCanvas();
    var bb = this.label.getBoundingBox();

    bb.setPosition(canvas.fromCanvasToDocumentCoordinate(bb.x, bb.y));

    // remove the scroll from the body if we add the canvas directly into the body
    var scrollDiv = canvas.getScrollArea();
    if (scrollDiv.is($("body"))) {
      bb.translate(canvas.getScrollLeft(), canvas.getScrollTop());
    }

    bb.translate(-1, -1);
    bb.resize(2, 2);

    this.html.css({
      position: "absolute",
      "top": bb.y,
      "left": bb.x,
      "min-width": bb.w * (1 / canvas.getZoom()),
      "height": Math.max(25, bb.h * (1 / canvas.getZoom()))
    });
    this.html.fadeIn(function () {
      _this.html.focus();
      _this.listener.onStart();
    });
  },

  /**
   *
   * Transfer the data from the editor into the label.<br>
   * Remove the editor.<br>
   *
   * @private
   */
  commit: function commit() {
    var _this2 = this;

    this.html.unbind("blur", this.commitCallback);
    $("body").unbind("click", this.commitCallback);
    var label = this.html.val();
    var cmd = new _packages2.default.command.CommandAttr(this.label, { text: label });
    this.label.getCanvas().getCommandStack().execute(cmd);
    this.html.fadeOut(function () {
      _this2.html.remove();
      _this2.html = null;
      _this2.listener.onCommit(_this2.label.getText());
    });
  },

  /**
   *
   * Transfer the data from the editor into the label.<br>
   * Remove the editor.<br>
   * @private
   */
  cancel: function cancel() {
    var _this3 = this;

    this.html.unbind("blur", this.commitCallback);
    $("body").unbind("click", this.commitCallback);
    this.html.fadeOut(function () {
      _this3.html.remove();
      _this3.html = null;
      _this3.listener.onCancel();
    });
  }
});

/***/ }),

/***/ "./src/util/ArrayList.js":
/*!*******************************!*\
  !*** ./src/util/ArrayList.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * <Disclaimer> Writing my own class for arrays was one of my worst ideas...
 *
 * An ArrayList stores a variable number of objects. This is similar to making an array of
 * objects, but with an ArrayList, items can be easily added and removed from the ArrayList
 * and it is resized dynamically. This can be very convenient, but it's slower than making
 * an array of objects when using many elements.
 */
_packages2.default.util.ArrayList = Class.extend(
/** @lends draw2d.util.ArrayList */
{

  init: function init(a) {
    if (Array.isArray(a)) {
      this.data = a;
    } else {
      this.data = [];
    }
  },

  /**
   *
   * Clears the array
   *
   * @since 6.1.0
   * @returns {this}
   */
  clear: function clear() {
    this.data = [];

    return this;
  },

  /**
   *
   * Reverses the order of the elements in the ArrayList. The array will be modified!
   *
   * @returns {this}
   */
  reverse: function reverse() {
    this.data.reverse();

    return this;
  },

  /**
   *
   * The size/count of the stored objects.
   *
   * @returns {Number}
   */
  getSize: function getSize() {
    return this.data.length;
  },

  /**
   *
   * checks to see if the Vector has any elements.
   *
   * @returns {Boolean} true if the list is empty
   **/
  isEmpty: function isEmpty() {
    return this.getSize() === 0;
  },

  /**
   *
   * return the last element.
   *
   * @returns {Object}
   */
  last: function last() {
    return this.data[this.data.length - 1];
  },

  /**
   *
   * Return a reference to the internal javascript native array.
   *
   * @returns {Array}
   */
  asArray: function asArray() {
    return this.data;
  },

  /**
   *
   * returns the first element
   *
   * @returns {Object}
   */
  first: function first() {
    if (this.data.length > 0) {
      return this.data[0];
    }
    return null;
  },

  /**
   *
   * returns an element at a specified index
   *
   * @param {Number} i
   * @returns {Object}
   */
  get: function get(i) {
    return this.data[i];
  },

  /**
   *
   * Adds a element at the end of the Vector.
   *
   * @param {Object} obj the object to add
   * @returns {this}
   */
  add: function add() {
    var _data;

    (_data = this.data).push.apply(_data, arguments);

    return this;
  },

  /**
   *
   *
   * The method removes items from an array as necessary so that all remaining items pass a
   * provided test. The test is a function that is passed an array item and the index of the
   * item within the array. Only if the test returns true will the item stay in the array.
   *
   * @param {Function} func the filter function(element,index)
   * @param {Object} func.value value of the element in iteration.
   * @since 2.0.0
   * @returns {this}
   */
  grep: function grep(func) {
    this.data = this.data.filter(func);

    return this;
  },

  /**
   *
   *
   * Return ONE element which matches by the given function or <b>null</b>
   * if no element is found.
   *
   *    var r1= figures.find(function(figure){
   *                  return figure.id===123456
   *            });
   *
   * @param {Function} func the filter function
   * @param {Object} func.value value of the element in iteration.
   * @param {Object} func.index index of the element in collection.
   * @since 2.0.0
   */
  find: function find(func) {
    var result = this.data.filter(func);
    if (result.length === 0) {
      return null;
    }
    return result[0];
  },

  /**
   *
   * Translate all items in the array into new items. The array list is modified after this call.
   * You must clone the array before if you want avoid this.
   *
   *    var labels = this.commands.clone().map(function(e){
   *         return e.getLabel();
   *    });
   *
   * @param {Function} func The function to process each item against. The first argument to the function is the value; the second argument is the index or key of the array or object property.
   * @param {Object} func.value value of the element in iteration.
   * @param {Number} func.i index of the element in iteration
   *
   * @since 4.0.0
   * @returns {this}
   */
  map: function map(func) {
    this.data = this.data.map(func);

    return this;
  },

  /**
   *
   * Removes any duplicate elements from the array. The array is modified after this call. You
   * must clone the array before if you want avoid this
   *
   * @since 4.0.0
   * @returns {this}
   */
  unique: function unique() {
    this.data = this.data.filter(function (value, index, self) {
      return self.indexOf(value) === index;
    });

    return this;
  },

  /**
   *
   * Add all elements into this array.
   *
   * @param {draw2d.util.ArrayList} list
   * @param {Boolean} [avoidDuplicates] checks whenever the new elements exists before insert if the parameter is to [true]
   * @returns {this}
   */
  addAll: function addAll(list, avoidDuplicates) {
    if (!(list instanceof _packages2.default.util.ArrayList)) {
      throw "Unable to handle unknown object type in ArrayList.addAll";
    }

    this.data = this.data.concat(list.data);
    if (avoidDuplicates) {
      this.unique();
    }
    return this;
  },

  /**
   *
   * You can use the Array list as Stack as well. this is the pop method to remove one element
   * at the end of the stack.
   *
   * @returns {Object} the remove object
   */
  pop: function pop() {
    return this.removeElementAt(this.data.length - 1);
  },

  /**
   * Push one element at the top of the stack/array
   *
   * @param {Object} value The object to add
   * @returns {this}
   */
  push: function push(value) {
    this.add(value);
  },

  /**
   *
   * Remove the element from the list
   *
   * @param {Object} obj the object to remove
   *
   * @returns {Object} the removed object or null
   */
  remove: function remove(obj) {
    var index = this.indexOf(obj);
    if (index >= 0) {
      return this.removeElementAt(index);
    }

    return null;
  },

  /**
   *
   * Inserts an element at a given position. Existing elements will be shifted
   * to the right.
   *
   * @param {Object} obj the object to insert.
   * @param {Number} index the insert position.
   * @returns {this}
   */
  insertElementAt: function insertElementAt(obj, index) {
    this.data.splice(index, 0, obj);

    return this;
  },

  /**
   *
   * Removes an element at a specific index.
   *
   * @param {Number} index the index of the element to remove
   * @returns {Object} the removed object
   */
  removeElementAt: function removeElementAt(index) {
    var element = this.data[index];

    this.data.splice(index, 1);

    return element;
  },

  /**
   *
   * removes all given elements in the ArrayList
   *
   * @param {draw2d.util.ArrayList} elements The elements to remove
   * @returns {this}
   */
  removeAll: function removeAll(elements) {
    var _this = this;

    if (elements instanceof _packages2.default.util.ArrayList) {
      elements = elements.data;
    }

    if (Array.isArray(elements)) {
      elements.forEach(function (e) {
        _this.remove(e);
      });
    }

    return this;
  },

  /**
   *
   * Return the zero based index of the given element or -1 if the element
   * not in the list.
   *
   * @param {Object} obj the element to check
   *
   * @returns {Number} the index of the element or -1
   */
  indexOf: function indexOf(obj) {
    return this.data.indexOf(obj);
  },

  /**
   *
   * returns true if the element is in the Vector, otherwise false.
   *
   * @param {Object} obj the object to check
   *
   * @returns {Boolean}
   */
  contains: function contains(obj) {
    return this.indexOf(obj) !== -1;
  },

  /**
   *
   * Sorts the collection based on a field name or sort a function. See on http://www.w3schools.com/jsref/jsref_sort.asp
   * if you use a sort function.
   *
   * @param {String|Function} f the field name for the sorting or a sort function
   *
   * @returns {this}
   *
   */
  sort: function sort(f) {
    if (typeof f === "function") {
      this.data.sort(f);
    } else {
      this.data.sort(function (a, b) {
        if (a[f] < b[f]) return -1;
        if (a[f] > b[f]) return 1;
        return 0;
      });
    }
    return this;
  },

  /**
   *
   * Copies the contents of a Vector to another Vector returning the new Vector.
   *
   * @param {Boolean} [deep] call "clone" of each elements and add the clone to the new ArrayList
   *
   * @returns {draw2d.util.ArrayList} the new ArrayList
   */
  clone: function clone(deep) {
    var newVector = new _packages2.default.util.ArrayList();

    if (deep) {
      for (var i = 0; i < this.data.length; i++) {
        newVector.data.push(this.data[i].clone());
      }
    } else {
      newVector.data = this.data.slice(0);
    }

    return newVector;
  },

  /**
   *
   * Iterates over the list of elements, yielding each in turn to an iterator
   * function.
   * Each invocation of iterator is called with two arguments: (index, element).
   *
   * @param {Function} func the callback function to call for each element
   * @param {Number} func.i index of the element in iteration
   * @param {Object} func.value value of the element in iteration.
   * @param {Boolean} [reverse] optional parameter. Iterate the collection reverse if it set to <b>true</b>
   * @returns {this}
   */
  each: function each(func, reverse) {
    if (typeof reverse !== "undefined" && reverse === true) {
      for (var i = this.data.length - 1; i >= 0; i--) {
        if (func(i, this.data[i]) === false) break;
      }
    } else {
      for (var _i = 0; _i < this.data.length; _i++) {
        if (func(_i, this.data[_i]) === false) break;
      }
    }

    return this;
  },

  /**
   * overwrites the element with an object at the specific index.
   *
   * @param {Object} obj The object to add
   * @param {Number} index the index where the object should places.
   *
   * @returns {this}
   */
  overwriteElementAt: function overwriteElementAt(obj, index) {
    this.data[index] = obj;

    return this;
  },

  /**
   *
   * @returns {Object} the attributes which are required for persistence
   */
  getPersistentAttributes: function getPersistentAttributes() {
    return { data: this.data };
  },

  /**
   *
   * Read all attributes from the serialized properties and transfer them into the shape.
   *
   * @param {Object} memento
   * @returns {this}
   */
  setPersistentAttributes: function setPersistentAttributes(memento) {
    this.data = memento.data;

    return this;
  }

});

_packages2.default.util.ArrayList.EMPTY_LIST = new _packages2.default.util.ArrayList();

/***/ }),

/***/ "./src/util/Base64.js":
/*!****************************!*\
  !*** ./src/util/Base64.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.util.Base64 = {

  /**
   * Maps bytes to characters.
   * @type {Object}
   * @private
   */
  byteToCharMap_: null,

  /**
   * Maps characters to bytes.
   * @type {Object}
   * @private
   */
  charToByteMap_: null,

  /**
   * Maps bytes to websafe characters.
   * @type {Object}
   * @private
   */
  byteToCharMapWebSafe_: null,

  /**
   * Maps websafe characters to bytes.
   * @type {Object}
   * @private
   */
  charToByteMapWebSafe_: null,

  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   * @type {string}
   */
  ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',

  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   * @type {string}
   */
  ENCODED_VALS: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + '+/=',

  /**
   * Our websafe alphabet.
   * @type {string}
   */
  ENCODED_VALS_WEBSAFE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + '-_.',

  encodeByteArray: function encodeByteArray(input, opt_webSafe) {
    _packages2.default.util.Base64.init();

    var byteToCharMap = opt_webSafe ? _packages2.default.util.Base64.byteToCharMapWebSafe_ : _packages2.default.util.Base64.byteToCharMap_;

    var output = [];

    for (var i = 0; i < input.length; i += 3) {
      var byte1 = input[i];
      var haveByte2 = i + 1 < input.length;
      var byte2 = haveByte2 ? input[i + 1] : 0;
      var haveByte3 = i + 2 < input.length;
      var byte3 = haveByte3 ? input[i + 2] : 0;

      var outByte1 = byte1 >> 2;
      var outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;
      var outByte3 = (byte2 & 0x0F) << 2 | byte3 >> 6;
      var outByte4 = byte3 & 0x3F;

      if (!haveByte3) {
        outByte4 = 64;

        if (!haveByte2) {
          outByte3 = 64;
        }
      }

      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }

    return output.join('');
  },

  /**
   * 
   * Base64-encode a string.
   *
   * @param {string} input A string to encode.
   * @param {boolean=} opt_webSafe If true, we should use the alternative alphabet.
   * @returns {string} The base64 encoded string.
   */
  encode: function encode(input, opt_webSafe) {
    return _packages2.default.util.Base64.encodeByteArray(_packages2.default.util.Base64.stringToByteArray(input), opt_webSafe);
  },

  /**
   * 
   * Base64-decode a string.
   *
   * @param {String} input to decode (length not required to be a multiple of 4).
   * @param {boolean=} opt_webSafe True if we should use the
   *    alternative alphabet.
   * @returns {Array} bytes representing the decoded value.
   */
  decode: function decode(input, opt_webSafe) {
    _packages2.default.util.Base64.init();

    var charToByteMap = opt_webSafe ? _packages2.default.util.Base64.charToByteMapWebSafe_ : _packages2.default.util.Base64.charToByteMap_;

    var output = [];

    for (var i = 0; i < input.length;) {
      var byte1 = charToByteMap[input.charAt(i++)];

      var haveByte2 = i < input.length;
      var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
      ++i;

      var haveByte3 = i < input.length;
      var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 0;
      ++i;

      var haveByte4 = i < input.length;
      var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 0;
      ++i;

      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw Error();
      }

      var outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);

      if (byte3 != 64) {
        var outByte2 = byte2 << 4 & 0xF0 | byte3 >> 2;
        output.push(outByte2);

        if (byte4 != 64) {
          var outByte3 = byte3 << 6 & 0xC0 | byte4;
          output.push(outByte3);
        }
      }
    }

    return output;
  },

  /**
   * Turns a string into an array of bytes; a "byte" being a JS number in the
   * range 0-255.
   * @param {string} str String value to arrify.
   * @returns {!Array.<number>} Array of numbers corresponding to the
   *    UCS character codes of each character in str.
   */
  stringToByteArray: function stringToByteArray(str) {
    var output = [],
        p = 0;
    for (var i = 0; i < str.length; i++) {
      var c = str.charCodeAt(i);
      while (c > 0xff) {
        output[p++] = c & 0xff;
        c >>= 8;
      }
      output[p++] = c;
    }
    return output;
  },

  init: function init() {
    if (!_packages2.default.util.Base64.byteToCharMap_) {
      _packages2.default.util.Base64.byteToCharMap_ = {};
      _packages2.default.util.Base64.charToByteMap_ = {};
      _packages2.default.util.Base64.byteToCharMapWebSafe_ = {};
      _packages2.default.util.Base64.charToByteMapWebSafe_ = {};

      // We want quick mappings back and forth, so we precompute two maps.
      for (var i = 0; i < _packages2.default.util.Base64.ENCODED_VALS.length; i++) {
        _packages2.default.util.Base64.byteToCharMap_[i] = _packages2.default.util.Base64.ENCODED_VALS.charAt(i);
        _packages2.default.util.Base64.charToByteMap_[_packages2.default.util.Base64.byteToCharMap_[i]] = i;
        _packages2.default.util.Base64.byteToCharMapWebSafe_[i] = _packages2.default.util.Base64.ENCODED_VALS_WEBSAFE.charAt(i);
        _packages2.default.util.Base64.charToByteMapWebSafe_[_packages2.default.util.Base64.byteToCharMapWebSafe_[i]] = i;
      }
    }
  }
};

/***/ }),

/***/ "./src/util/Color.js":
/*!***************************!*\
  !*** ./src/util/Color.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Util class to handle colors in the draw2d enviroment.
 *
 * @example
 *     // Create a new Color with RGB values
 *     var color = new draw2d.util.Color(127,0,0);
 *
 *     // of from a hex string
 *     var color2 = new draw2d.util.Color("#f00000");
 *
 *     // Create a little bit darker color
 *     var darkerColor = color.darker(0.2); // 20% darker
 *
 *     // create a optimal text color if 'color' the background color
 *     // (best in meaning of contrast and readability)
 *     var fontColor = color.getIdealTextColor();
 *
 * @param {Number|String|draw2d.util.Color|Array} red
 * @param {Number} green
 * @param {Number} blue
 * @param {Number} [alpha]
 */
_packages2.default.util.Color = Class.extend(
/** @lends draw2d.util.Color */
{

  init: function init(red, green, blue, alpha) {

    this.hashString = null;

    if (typeof red === "undefined" || red === null) {
      this.hashString = "none";
    } else if (red instanceof _packages2.default.util.Color) {
      if (red.hashString === "none") {
        this.hashString = "none";
      } else {
        this.red = red.red;
        this.green = red.green;
        this.blue = red.blue;
        this.alpha = red.alpha;
      }
    } else if (typeof red === "string") {
      if (red === "none") {
        this.hashString = "none";
      } else {
        var rgba = this.hex2rgb(red);
        this.red = rgba[0];
        this.green = rgba[1];
        this.blue = rgba[2];
        this.alpha = rgba[3];
      }
    }
    // JSON struct of {red:###, green:###, blue:### }
    else if ((typeof red === "undefined" ? "undefined" : _typeof(red)) === "object" && typeof red.red === "number") {
        this.red = red.red;
        this.green = red.green;
        this.blue = red.blue;
        this.alpha = red.alpha;
      }
      // array detection 1
      else if (red instanceof Array && red.length === 3) {
          this.red = red[0];
          this.green = red[1];
          this.blue = red[2];
          this.alpha = red[3];
        }
        // array detection 2
        else if ((typeof red === "undefined" ? "undefined" : _typeof(red)) === "object" && typeof red.length === "number" && red.length === 3) {
            this.red = red[0];
            this.green = red[1];
            this.blue = red[2];
            this.alpha = red[3];
          } else {
            this.red = parseInt(red);
            this.green = parseInt(green);
            this.blue = parseInt(blue);
            this.alpha = typeof alpha === 'undefined' ? 1 : parseFloat(alpha);
          }
  },

  /**
   * 
   * Convert the color object into a HTML CSS representation
   * @returns {String} the color in rgb(##,##,##) representation
   **/
  getHTMLStyle: function getHTMLStyle() {
    if (typeof this.red === "undefined") return "rgba(0,0,0,0)";

    return "rgba(" + this.red + "," + this.green + "," + this.blue + "," + this.alpha + ")";
  },

  /**
   * 
   * The red part of the color.
   *
   * @returns {Number} the [red] part of the color.
   **/
  getRed: function getRed() {
    return this.red;
  },

  /**
   * 
   * The green part of the color.
   *
   * @returns {Number} the [green] part of the color.
   **/
  getGreen: function getGreen() {
    return this.green;
  },

  /**
   * 
   * The blue part of the color
   *
   * @returns {Number} the [blue] part of the color.
   **/
  getBlue: function getBlue() {
    return this.blue;
  },

  /**
   * 
   * The alpha part of the color
   *
   * @returns {Number} the [alpha] part of the color.
   **/
  getAlpha: function getAlpha() {
    return this.alpha;
  },

  /**
   * 
   * Returns the ideal Text Color. Useful for font color selection by a given background color.
   *
   * @returns {draw2d.util.Color} The <i>ideal</i> inverse color.
   **/
  getIdealTextColor: function getIdealTextColor() {
    var nThreshold = 105;
    var bgDelta = this.red * 0.299 + this.green * 0.587 + this.blue * 0.114;
    return 255 - bgDelta < nThreshold ? new _packages2.default.util.Color(0, 0, 0) : new _packages2.default.util.Color(255, 255, 255);
  },

  /**
   * return array of [r,g,b,a] from any valid color. if failed returns [0,0,0,1]
   *
   * @param hexcolor
   * @returns {*}
   */
  hex2rgb: function hex2rgb(color) {
    if (!color) {
      return [0, 0, 0, 1];
    }

    if (color.toLowerCase() === 'transparent') {
      return [0, 0, 0, 0];
    }

    if (color[0] === '#') {
      if (color.length < 7) {
        // convert #RGB and #RGBA to #RRGGBB and #RRGGBBAA
        color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3] + (color.length > 4 ? color[4] + color[4] : '');
      }
      return [parseInt(color.substr(1, 2), 16), parseInt(color.substr(3, 2), 16), parseInt(color.substr(5, 2), 16), color.length > 7 ? parseInt(color.substr(7, 2), 16) / 255 : 1];
    }

    if (color.indexOf('rgb') === -1) {
      // convert named colors
      var temp_elem = document.body.appendChild(document.createElement('fictum')); // intentionally use unknown tag to lower chances of css rule override with !important
      var flag = 'rgb(1, 2, 3)'; // this flag tested on chrome 59, ff 53, ie9, ie10, ie11, edge 14
      temp_elem.style.color = flag;
      if (temp_elem.style.color !== flag) {
        return [0, 0, 0, 1]; // color set failed - some monstrous css rule is probably taking over the color of our object
      }
      temp_elem.style.color = color;

      if (temp_elem.style.color === flag || temp_elem.style.color === '') {
        return [0, 0, 0, 1]; // color parse failed
      }
      color = getComputedStyle(temp_elem).color;
      document.body.removeChild(temp_elem);
    }

    if (color.indexOf('rgb') === 0) {
      if (color.indexOf('rgba') === -1) {
        color += ',1'; // convert 'rgb(R,G,B)' to 'rgb(R,G,B)A' which looks awful but will pass the regxep below
      }
      return color.match(/[\.\d]+/g).map(function (a) {
        return +a;
      });
    }
  },

  /**
   *
   **/
  hex: function hex() {
    return this.int2hex(this.red) + this.int2hex(this.green) + this.int2hex(this.blue)
    // breaks raphaelJS...so don'T use it right now
    //(this.alpha * 255).toString(16).substring(0,2).toUpperCase()
    ;
  },

  /**
   * 
   * Convert the color object into a HTML CSS representation
   * @returns {String} the color in rgb(##,##,##) representation
   **/
  rgba: function rgba() {
    return this.getHTMLStyle();
  },

  /**
   * 
   * Convert the color object into a HTML CSS representation
   * @returns {String} the color in #RRGGBB representation
   **/
  hash: function hash() {
    if (this.hashString === null) {
      this.hashString = "#" + this.hex();
    }
    return this.hashString;
  },

  /**
   * @private
   */
  int2hex: function int2hex(v) {
    v = Math.round(Math.min(Math.max(0, v), 255));
    return "0123456789ABCDEF".charAt((v - v % 16) / 16) + "0123456789ABCDEF".charAt(v % 16);
  },

  /**
   * 
   * Returns a darker color of the given one. The original color is unchanged.
   *
   * @param {Number} fraction  Darkness fraction between [0..1].
   * @return{draw2d.util.Color}        Darker color.
   */
  darker: function darker(fraction) {
    // we can't "darker" a undefined color. In this case we return the undefnied color itself
    //
    if (this.hashString === "none") return this;

    fraction = typeof fraction === 'undefined' ? 0.1 : fraction;

    var red = parseInt(Math.round(this.getRed() * (1.0 - fraction)));
    var green = parseInt(Math.round(this.getGreen() * (1.0 - fraction)));
    var blue = parseInt(Math.round(this.getBlue() * (1.0 - fraction)));

    if (red < 0) red = 0;else if (red > 255) red = 255;
    if (green < 0) green = 0;else if (green > 255) green = 255;
    if (blue < 0) blue = 0;else if (blue > 255) blue = 255;

    return new _packages2.default.util.Color(red, green, blue, this.alpha);
  },

  /**
   * 
   * Make a color lighter. The original color is unchanged.
   *
   * @param {Number} fraction  lighter fraction between [0..1].
   * @returns {draw2d.util.Color} Lighter color.
   */
  lighter: function lighter(fraction) {
    // we can't "lighter" a undefined color. In this case we return the undefined color itself
    //
    if (this.hashString === "none") return this;

    fraction = typeof fraction === 'undefined' ? 0.1 : fraction;

    var red = parseInt(Math.round(this.getRed() * (1.0 + fraction)));
    var green = parseInt(Math.round(this.getGreen() * (1.0 + fraction)));
    var blue = parseInt(Math.round(this.getBlue() * (1.0 + fraction)));

    if (red < 0) red = 0;else if (red > 255) red = 255;
    if (green < 0) green = 0;else if (green > 255) green = 255;
    if (blue < 0) blue = 0;else if (blue > 255) blue = 255;

    return new _packages2.default.util.Color(red, green, blue, this.alpha);
  },

  /**
   * 
   * Return a new color wich is faded to the given color.
   * @param {draw2d.util.Color} color
   * @param {Number} pc the fade percentage in [0..1]
   * @returns {draw2d.util.Color}
   *
   * @since 2.1.0
   */
  fadeTo: function fadeTo(color, pc) {

    var r = Math.floor(this.red + pc * (color.red - this.red) + .5);
    var g = Math.floor(this.green + pc * (color.green - this.green) + .5);
    var b = Math.floor(this.blue + pc * (color.blue - this.blue) + .5);
    var a = Math.floor(this.alpha + pc * (color.alpha - this.alpha) + .5);

    return new _packages2.default.util.Color(r, g, b, a);
  },

  /**
   * 
   * Compares two color objects
   *
   * @param {draw2d.util.Color} o
   * @returns {Boolean}
   **/
  equals: function equals(o) {
    if (!(o instanceof _packages2.default.util.Color)) {
      return false;
    }
    return this.rgba() === o.rgba();
  }

});

module.exports = _packages2.default.util.Color;

/***/ }),

/***/ "./src/util/Debug.js":
/*!***************************!*\
  !*** ./src/util/Debug.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * JavaScript Debug - v0.4 - 6/22/2010
 * http://benalman.com/projects/javascript-debug-console-log/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 *
 * With lots of help from Paul Irish!
 * http://paulirish.com/
 */
// Script: JavaScript Debug: A simple wrapper for console.log
//
// *Version: 0.4, Last Updated: 6/22/2010*
//
// Tested with Internet Explorer 6-8, Firefox 3-3.6, Safari 3-4, Chrome 3-5, Opera 9.6-10.5
//
// Home       - http://benalman.com/projects/javascript-debug-console-log/
// GitHub     - http://github.com/cowboy/javascript-debug/
// Source     - http://github.com/cowboy/javascript-debug/raw/master/ba-debug.js
// (Minified) - http://github.com/cowboy/javascript-debug/raw/master/ba-debug.min.js (1.1kb)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Support and Testing
//
// Information about what browsers this code has been tested in.
//
// Browsers Tested - Internet Explorer 6-8, Firefox 3-3.6, Safari 3-4, Chrome
// 3-5, Opera 9.6-10.5
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// Examples - http://benalman.com/code/projects/javascript-debug/examples/debug/
//
// About: Revision History
//
// 0.4 - (6/22/2010) Added missing passthrough methods: exception,
//       groupCollapsed, table
// 0.3 - (6/8/2009) Initial release
//
// Topic: Pass-through console methods
//
// assert, clear, count, dir, dirxml, exception, group, groupCollapsed,
// groupEnd, profile, profileEnd, table, time, timeEnd, trace
//
// These console methods are passed through (but only if both the console and
// the method exists), so use them without fear of reprisal. Note that these
// methods will not be passed through if the logging level is set to 0 via
// <debug.setLevel>.

window.debug = function () {
  var window = this,


  // Some convenient shortcuts.
  aps = Array.prototype.slice,
      con = console,


  // Public object to be returned.
  that = {},
      callback_func,
      callback_force,


  // Default logging level, show everything.
  log_level = 9,


  // Logging methods, in "priority order". Not all console implementations
  // will utilize these, but they will be used in the callback passed to
  // setCallback.
  log_methods = ['error', 'warn', 'info', 'debug', 'log'],


  // Pass these methods through to the console if they exist, otherwise just
  // fail gracefully. These methods are provided for convenience.
  pass_methods = 'assert clear count dir dirxml exception group groupCollapsed groupEnd profile profileEnd table time timeEnd trace'.split(' '),
      idx = pass_methods.length,


  // Logs are stored here so that they can be recalled as necessary.
  logs = [];

  while (--idx >= 0) {
    (function (method) {

      // Generate pass-through methods. These methods will be called, if they
      // exist, as long as the logging level is non-zero.
      that[method] = function () {
        log_level !== 0 && con && con[method] && con[method].apply(con, arguments);
      };
    })(pass_methods[idx]);
  }

  idx = log_methods.length;
  while (--idx >= 0) {
    (function (idx, level) {

      // Method: debug.log
      //
      // Call the console.log method if available. Adds an entry into the logs
      // array for a callback specified via <debug.setCallback>.
      //
      // Usage:
      //
      //  debug.log( object [, object, ...] );                               - -
      //
      // Arguments:
      //
      //  object - (Object) Any valid JavaScript object.

      // Method: debug.debug
      //
      // Call the console.debug method if available, otherwise call console.log.
      // Adds an entry into the logs array for a callback specified via
      // <debug.setCallback>.
      //
      // Usage:
      //
      //  debug.debug( object [, object, ...] );                             - -
      //
      // Arguments:
      //
      //  object - (Object) Any valid JavaScript object.

      // Method: debug.info
      //
      // Call the console.info method if available, otherwise call console.log.
      // Adds an entry into the logs array for a callback specified via
      // <debug.setCallback>.
      //
      // Usage:
      //
      //  debug.info( object [, object, ...] );                              - -
      //
      // Arguments:
      //
      //  object - (Object) Any valid JavaScript object.

      // Method: debug.warn
      //
      // Call the console.warn method if available, otherwise call console.log.
      // Adds an entry into the logs array for a callback specified via
      // <debug.setCallback>.
      //
      // Usage:
      //
      //  debug.warn( object [, object, ...] );                              - -
      //
      // Arguments:
      //
      //  object - (Object) Any valid JavaScript object.

      // Method: debug.error
      //
      // Call the console.error method if available, otherwise call console.log.
      // Adds an entry into the logs array for a callback specified via
      // <debug.setCallback>.
      //
      // Usage:
      //
      //  debug.error( object [, object, ...] );                             - -
      //
      // Arguments:
      //
      //  object - (Object) Any valid JavaScript object.

      that[level] = function () {
        var args = aps.call(arguments),
            log_arr = [level].concat(args);

        logs.push(log_arr);
        exec_callback(log_arr);

        if (!con || !is_level(idx)) {
          return;
        }

        con.firebug ? con[level].apply(window, args) : con[level] ? con[level](args) : con.log(args);
      };
    })(idx, log_methods[idx]);
  }

  // Execute the callback function if set.
  function exec_callback(args) {
    if (callback_func && (callback_force || !con || !con.log)) {
      callback_func.apply(window, args);
    }
  };

  // Method: debug.setLevel
  //
  // Set a minimum or maximum logging level for the console. Doesn't affect
  // the <debug.setCallback> callback function, but if set to 0 to disable
  // logging, <Pass-through console methods> will be disabled as well.
  //
  // Usage:
  //
  //  debug.setLevel( [ level ] )                                            - -
  //
  // Arguments:
  //
  //  level - (Number) If 0, disables logging. If negative, shows N lowest
  //    priority levels of log messages. If positive, shows N highest priority
  //    levels of log messages.
  //
  // Priority levels:
  //
  //   log (1) < debug (2) < info (3) < warn (4) < error (5)

  that.setLevel = function (level) {
    log_level = typeof level === 'number' ? level : 9;
  };

  // Determine if the level is visible given the current log_level.
  function is_level(level) {
    return log_level > 0 ? log_level > level : log_methods.length + log_level <= level;
  };

  // Method: debug.setCallback
  //
  // Set a callback to be used if logging isn't possible due to console.log
  // not existing. If unlogged logs exist when callback is set, they will all
  // be logged immediately unless a limit is specified.
  //
  // Usage:
  //
  //  debug.setCallback( callback [, force ] [, limit ] )
  //
  // Arguments:
  //
  //  callback - (Function) The aforementioned callback function. The first
  //    argument is the logging level, and all subsequent arguments are those
  //    passed to the initial debug logging method.
  //  force - (Boolean) If false, log to console.log if available, otherwise
  //    callback. If true, log to both console.log and callback.
  //  limit - (Number) If specified, number of lines to limit initial scrollback
  //    to.

  that.setCallback = function () {
    var args = aps.call(arguments),
        max = logs.length,
        i = max;

    callback_func = args.shift() || null;
    callback_force = typeof args[0] === 'boolean' ? args.shift() : false;

    i -= typeof args[0] === 'number' ? args.shift() : max;

    while (i < max) {
      exec_callback(logs[i++]);
    }
  };

  return that;
}();

/***/ }),

/***/ "./src/util/JSONUtil.js":
/*!******************************!*\
  !*** ./src/util/JSONUtil.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.util.JSON = {

  /**
   * 
   * Given a dot deliminated string set will create an object
   * based on the structure of the string with the desired value
   *
   * @param {Object} data   the json object to modify
   * @param {String} path   path indicating where value should be placed
   * @param {Object} value  the value desired to be set at the location determined by path
   */
  set: function set(data, path, value) {
    if (!path || path === '') {
      return;
    }

    var re = /[\w-]+|\[\]|([^\[[\w]\]]|["'](.*?)['"])/g;
    // parse path on dots, and brackets
    var pathList = path.match(re);
    var parent = data;
    var parentKey = void 0;
    var grandParent = null;
    var grandParentKey = null;

    var addObj = function addObj(obj, key, data) {
      if (key === '[]') {
        obj.push(data);
      } else {
        obj[key] = data;
      }
    };

    while (pathList.length > 0) {
      parentKey = pathList.shift().replace(/["']/g, '');

      // Number, treat it as an array
      if (!isNaN(+parentKey) || parentKey === "[]") {
        if (parent.constructor !== Array) {
          parent = [];
          addObj(grandParent, grandParentKey, parent);
        }
        // String, treat it as a key
      } else if (typeof parentKey === "string") {
        if (!$.isPlainObject(parent)) {
          parent = {};
          addObj(grandParent, grandParentKey, parent);
        }
      }
      // Next
      grandParent = parent;
      grandParentKey = parentKey;
      parent = parent[parentKey];
    }

    addObj(grandParent, grandParentKey, value);
  },

  /**
   * 
   * Returns the value defined by the path passed in
   *
   * @param  {Object} data the JSON data object
   * @param  {String} path string leading to a desired value
   */
  get: function get(data, path) {
    var regex = /[\w-]+|\[\]|([^\[[\w]\]]|["'](.*?)['"])/g;
    //check if path is truthy
    if (!path) {
      return undefined;
    }
    //parse path on dots and brackets
    var paths = path.match(regex);
    //step through data object until all keys in path have been processed
    while (data !== null && paths.length > 0) {
      if (data.propertyIsEnumerable(paths[0].replace(/"/g, ''))) {
        data = data[paths.shift().replace(/"/g, '')];
      } else {
        return undefined;
      }
    }
    return data;
  },

  /**
   * 
   * calculates the diff between the given json objects
   *
   */
  diff: function diff(obj1, obj2) {
    var result = {};
    for (var key in obj1) {
      var v1 = obj1[key];
      var v2 = obj2[key];
      if (v1 !== v2) {
        if (v1.equals) {
          if (!v1.equals(v2)) {
            result[key] = obj1[key];
          }
        } else {
          result[key] = obj1[key];
        }
      }
    }
    return result;
  },

  flatDiff: function flatDiff(obj1, obj2) {
    var result = {};
    for (var key in obj1) {
      if (obj1[key] !== obj2[key]) {
        result[key] = obj1[key];
      }
    }
    return result;
  },

  ensureDefault: function ensureDefault(json, attribute, value) {
    if (!json.hasOwnProperty(attribute)) {
      json[attribute] = value;
    }
  }
};

module.exports = _packages2.default.util.JSON;

/***/ }),

/***/ "./src/util/Polyfill.js":
/*!******************************!*\
  !*** ./src/util/Polyfill.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// avoid iPad bounce effect during DragDrop//
document.ontouchmove = function (e) {
  e.preventDefault();
};

/***/ }),

/***/ "./src/util/SVGUtil.js":
/*!*****************************!*\
  !*** ./src/util/SVGUtil.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// extending raphael with a polygon function
Raphael.fn.polygon = function (pointString) {
  var poly = ['M'];
  var point = pointString.split(' ');

  for (var i = 0; i < point.length; i++) {
    var c = point[i].split(',');
    for (var j = 0; j < c.length; j++) {
      var d = parseFloat(c[j]);
      if (!isNaN(d)) poly.push(d);
    };
    if (i == 0) poly.push('L');
  }
  poly.push('Z');

  return this.path(poly);
};

/***/ }),

/***/ "./src/util/UUID.js":
/*!**************************!*\
  !*** ./src/util/UUID.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 * Generates a (pseudo) UUID's
 *
 * @example
 *     // a UUID in the format
 *     // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)
 *     var id = draw2d.util.UUID.create();
 *
 * @author Andreas Herz
 */
_packages2.default.util.UUID = {
  /**
   *
   * Generates a unique id.<br>
   * But just for the correctness: <strong>this is no Global Unique Identifier</strong>, it is just a random generator
   * with the output that looks like a GUID. <br>
   * But may be also useful.
   *
   * @returns {String} the  UUID in the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)
   **/
  create: function create() {
    var segment = function segment() {
      return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
    };
    return segment() + segment() + "-" + segment() + "-" + segment() + "-" + segment() + "-" + segment() + segment() + segment();
  }
};

module.exports = _packages2.default.util.UUID;

/***/ }),

/***/ "./src/util/extend.js":
/*!****************************!*\
  !*** ./src/util/extend.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// Pass in the objects to merge as arguments.// For a deep extend, set the first argument to `true`.
var fn = function fn() {

  // Variables
  var extended = {};
  var deep = false;
  var i = 0;
  var length = arguments.length;

  // Check if a deep merge
  if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
    deep = arguments[0];
    i++;
  }

  // Merge the object into the extended object
  /**
   *
   * @param obj
   */
  var merge = function merge(obj) {
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        // If deep merge and property is an object, merge properties
        if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
          extended[prop] = extend(true, extended[prop], obj[prop]);
        } else {
          extended[prop] = obj[prop];
        }
      }
    }
  };

  // Loop through each object and conduct a merge
  for (; i < length; i++) {
    var obj = arguments[i];
    merge(obj);
  }

  return extended;
};
module.exports = fn;
global.extend = fn;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/util/raphael_ext.js":
/*!*********************************!*\
  !*** ./src/util/raphael_ext.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// hacking RaphaelJS to support groups of elements
//
(function () {
    Raphael.fn.group = function (f, g) {
        var enabled = document.getElementsByTagName("svg").length > 0;
        if (!enabled) {
            // return a stub for VML compatibility
            return {
                add: function add() {
                    // intentionally left blank
                }
            };
        }
        var i;
        this.svg = "http://www.w3.org/2000/svg";
        this.defs = document.getElementsByTagName("defs")[f];
        this.svgcanv = document.getElementsByTagName("svg")[f];
        this.group = document.createElementNS(this.svg, "g");
        for (i = 0; i < g.length; i++) {
            this.group.appendChild(g[i].node);
        }
        this.svgcanv.appendChild(this.group);
        this.group.translate = function (c, a) {
            this.setAttribute("transform", "translate(" + c + "," + a + ") scale(" + this.getAttr("scale").x + "," + this.getAttr("scale").y + ")");
        };
        this.group.rotate = function (c, a, e) {
            this.setAttribute("transform", "translate(" + this.getAttr("translate").x + "," + this.getAttr("translate").y + ") scale(" + this.getAttr("scale").x + "," + this.getAttr("scale").y + ") rotate(" + c + "," + a + "," + e + ")");
        };
        this.group.scale = function (c, a) {
            this.setAttribute("transform", "scale(" + c + "," + a + ") translate(" + this.getAttr("translate").x + "," + this.getAttr("translate").y + ")");
        };
        this.group.push = function (c) {
            this.appendChild(c.node);
        };
        this.group.getAttr = function (c) {
            this.previous = this.getAttribute("transform") ? this.getAttribute("transform") : "";
            var a = [],
                e,
                h,
                j;
            a = this.previous.split(" ");
            for (i = 0; i < a.length; i++) {
                if (a[i].substring(0, 1) == "t") {
                    var d = a[i],
                        b = [];
                    b = d.split("(");
                    d = b[1].substring(0, b[1].length - 1);
                    b = [];
                    b = d.split(",");
                    e = b.length === 0 ? { x: 0, y: 0 } : { x: b[0], y: b[1] };
                } else {
                    if (a[i].substring(0, 1) === "r") {
                        d = a[i];
                        b = d.split("(");
                        d = b[1].substring(0, b[1].length - 1);
                        b = d.split(",");
                        h = b.length === 0 ? { x: 0, y: 0, z: 0 } : { x: b[0], y: b[1], z: b[2] };
                    } else {
                        if (a[i].substring(0, 1) === "s") {
                            d = a[i];
                            b = d.split("(");
                            d = b[1].substring(0, b[1].length - 1);
                            b = d.split(",");
                            j = b.length === 0 ? { x: 1, y: 1 } : { x: b[0], y: b[1] };
                        }
                    }
                }
            }
            if (typeof e === "undefined") {
                e = { x: 0, y: 0 };
            }
            if (typeof h === "undefined") {
                h = { x: 0, y: 0, z: 0 };
            }
            if (typeof j === "undefined") {
                j = { x: 1, y: 1 };
            }

            if (c == "translate") {
                var k = e;
            } else {
                if (c == "rotate") {
                    k = h;
                } else {
                    if (c == "scale") {
                        k = j;
                    }
                }
            }
            return k;
        };
        this.group.copy = function (el) {
            this.copy = el.node.cloneNode(true);
            this.appendChild(this.copy);
        };
        return this.group;
    };
})();

/**
 * adding support method to check if the node is already visible
 **/
(function () {
    Raphael.el.isVisible = function () {
        return this.node.style.display !== "none";
    };
})();

/***/ }),

/***/ "./src/util/spline/BezierSpline.js":
/*!*****************************************!*\
  !*** ./src/util/spline/BezierSpline.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.util.spline.BezierSpline = _packages2.default.util.spline.Spline.extend(

/** @lends draw2d.util.spline.BezierSpline.prototype */
{

  NAME: "draw2d.util.spline.BezierSpline",

  /**
   */
  init: function init() {
    this._super();
  },

  /**
   * Create a spline based on the given control points.
   * The generated curve starts in the first control point and ends
   * in the last control point.
   *
   * @param {Array} controlPoints  Control points of spline (x0,y0,z0,x1,y1,z1,...).
   * @param {Number} parts Number of parts to divide each leg into.
   *
   * @returns {Array} the new generated array with new draw2d.geo.Point
   */
  generate: function generate(controlPoints, parts) {
    var n = controlPoints.getSize();
    var spline = new _packages2.default.util.ArrayList();

    spline.add(this.p(0, 0, controlPoints));

    for (var i = 0; i < n - 3; i += 3) {
      for (var j = 1; j <= parts; j++) {
        spline.add(this.p(i, j / parts, controlPoints));
      }
    }

    //    spline.add(controlPoints.get(controlPoints.getSize()-1));

    return spline;
  },

  p: function p(i, t, cp) {
    var x = 0.0;
    var y = 0.0;

    var k = i;
    for (var j = 0; j <= 3; j++) {
      var b = this.blend(j, t);
      var p = cp.get(k++);
      x += b * p.x;
      y += b * p.y;
    }

    return new _packages2.default.geo.Point(x, y);
  },

  blend: function blend(i, t) {
    if (i == 0) return (1 - t) * (1 - t) * (1 - t);else if (i == 1) return 3 * t * (1 - t) * (1 - t);else if (i == 2) return 3 * t * t * (1 - t);else return t * t * t;
  }
});

/**
 * @class
 *
 * A bezier spline object.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.util.spline.Spline
 */

/***/ }),

/***/ "./src/util/spline/CatmullRomSpline.js":
/*!*********************************************!*\
  !*** ./src/util/spline/CatmullRomSpline.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A catmull-rom spline object.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.util.spline.CubicSpline
 */
_packages2.default.util.spline.CatmullRomSpline = _packages2.default.util.spline.CubicSpline.extend(

/** @lends draw2d.util.spline.CatmullRomSpline.prototype */
{

    NAME: "draw2d.util.spline.CatmullRomSpline",

    /**
     */
    init: function init() {
        this._super();
    },

    blend: function blend(i, t) {
        if (i == -2) return ((-t + 2) * t - 1) * t / 2;else if (i == -1) return ((3 * t - 5) * t * t + 2) / 2;else if (i == 0) return ((-3 * t + 4) * t + 1) * t / 2;else return (t - 1) * t * t / 2;
    }

});

/***/ }),

/***/ "./src/util/spline/CubicSpline.js":
/*!****************************************!*\
  !*** ./src/util/spline/CubicSpline.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class
 *
 * A cubic spline object.
 *
 * @inheritable
 * @author Andreas Herz
 *
 * @extends draw2d.util.spline.Spline
 */
_packages2.default.util.spline.CubicSpline = _packages2.default.util.spline.Spline.extend(

/** @lends draw2d.util.spline.CubicSpline.prototype */
{

  NAME: "draw2d.util.spline.CubicSpline",

  /**
   */
  init: function init() {
    this._super();
  },

  /**
  * Create a spline based on the given control points.
  * The generated curve starts in the first control point and ends
  * in the last control point.
  *
  * @param {Array} controlPoints  Control points of spline (x0,y0,z0,x1,y1,z1,...).
  * @param {Number} parts Number of parts to divide each leg into.
  *
  * @returns {Array} the new generated array with new draw2d.geo.Point
  */
  generate: function generate(controlPoints, parts) {
    // Endpoints are added twice to get them include in the
    // generated array
    var cp = new _packages2.default.util.ArrayList();
    cp.add(controlPoints.get(0));
    cp.addAll(controlPoints);
    cp.add(controlPoints.get(controlPoints.getSize() - 1));

    var n = cp.getSize();
    var spline = new _packages2.default.util.ArrayList();
    spline.add(controlPoints.get(0));
    spline.add(this.p(1, 0, cp));

    for (var i = 1; i < n - 2; i++) {
      for (var j = 1; j <= parts; j++) {
        spline.add(this.p(i, j / parts, cp));
      }
    }
    spline.add(controlPoints.get(controlPoints.getSize() - 1));

    return spline;
  },

  p: function p(i, t, cp) {
    var x = 0.0;
    var y = 0.0;

    var k = i - 1;
    for (var j = -2; j <= 1; j++) {
      var b = this.blend(j, t);
      var p = cp.get(k++);
      x += b * p.x;
      y += b * p.y;
    }

    return new _packages2.default.geo.Point(x, y);
  },

  blend: function blend(i, t) {
    if (i === -2) return (((-t + 3) * t - 3) * t + 1) / 6;else if (i === -1) return ((3 * t - 6) * t * t + 4) / 6;else if (i === 0) return (((-3 * t + 3) * t + 3) * t + 1) / 6;

    return t * t * t / 6;
  }

});

/***/ }),

/***/ "./src/util/spline/Spline.js":
/*!***********************************!*\
  !*** ./src/util/spline/Spline.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _packages = __webpack_require__(/*! ../../packages */ "./src/packages.js");

var _packages2 = _interopRequireDefault(_packages);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_packages2.default.util.spline.Spline = Class.extend(
/** @lends draw2d.util.spline.Spline.prototype */
{

  NAME: "draw2d.util.spline.Spline",

  /**
   */
  init: function init() {},

  /**
   * Create a spline based on the given control points.
   * The generated curve starts in the first control point and ends
   * in the last control point.
   *
   * @param {Array} controlPoints  Control points of spline (x0,y0,z0,x1,y1,z1,...).
   * @param {Number} parts Number of parts to divide each leg into.
   **/
  generate: function generate(controlPoints, parts) {
    throw "inherit classes must implement the method 'draw2d.util.spline.Spline.generate()'";
  }

});
/**
 * @class
 *
 *  An abstract class defining a general spline object.
 */

/***/ })

/******/ });
});
//# sourceMappingURL=draw2d.js.map